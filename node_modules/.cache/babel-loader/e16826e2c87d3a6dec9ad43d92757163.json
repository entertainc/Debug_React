{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getChildHostContext, getRootHostContext } from './ReactFiberHostConfig';\nimport { createCursor, push, pop } from './ReactFiberStack';\nconst contextStackCursor = createCursor(null);\nconst contextFiberStackCursor = createCursor(null);\nconst rootInstanceStackCursor = createCursor(null);\n\nfunction requiredContext(c) {\n  if (__DEV__) {\n    if (c === null) {\n      console.error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n    }\n  }\n\n  return c;\n}\n\nfunction getCurrentRootHostContainer() {\n  return rootInstanceStackCursor.current;\n}\n\nfunction getRootHostContainer() {\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n\n  push(contextStackCursor, null, fiber);\n  const nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n\n  pop(contextStackCursor, fiber);\n  push(contextStackCursor, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  const context = requiredContext(contextStackCursor.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  const context = requiredContext(contextStackCursor.current);\n  const nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.\n\n  if (context === nextContext) {\n    return;\n  } // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nexport { getHostContext, getCurrentRootHostContainer, getRootHostContainer, popHostContainer, popHostContext, pushHostContainer, pushHostContext };","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberHostContext.js"],"names":["getChildHostContext","getRootHostContext","createCursor","push","pop","contextStackCursor","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","c","__DEV__","console","error","getCurrentRootHostContainer","current","getRootHostContainer","rootInstance","pushHostContainer","fiber","nextRootInstance","nextRootContext","popHostContainer","getHostContext","context","pushHostContext","nextContext","type","popHostContext"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA,SAAQA,mBAAR,EAA6BC,kBAA7B,QAAsD,wBAAtD;AACA,SAAQC,YAAR,EAAsBC,IAAtB,EAA4BC,GAA5B,QAAsC,mBAAtC;AAEA,MAAMC,kBAAmD,GAAGH,YAAY,CAAC,IAAD,CAAxE;AACA,MAAMI,uBAAkD,GAAGJ,YAAY,CAAC,IAAD,CAAvE;AACA,MAAMK,uBAAsD,GAAGL,YAAY,CACzE,IADyE,CAA3E;;AAIA,SAASM,eAAT,CAAgCC,CAAhC,EAAwD;AACtD,MAAIC,OAAJ,EAAa;AACX,QAAID,CAAC,KAAK,IAAV,EAAgB;AACdE,MAAAA,OAAO,CAACC,KAAR,CACE,0EACE,iCAFJ;AAID;AACF;;AACD,SAAQH,CAAR;AACD;;AAED,SAASI,2BAAT,GAAyD;AACvD,SAAON,uBAAuB,CAACO,OAA/B;AACD;;AAED,SAASC,oBAAT,GAA2C;AACzC,QAAMC,YAAY,GAAGR,eAAe,CAACD,uBAAuB,CAACO,OAAzB,CAApC;AACA,SAAOE,YAAP;AACD;;AAED,SAASC,iBAAT,CAA2BC,KAA3B,EAAyCC,gBAAzC,EAAsE;AACpE;AACA;AACAhB,EAAAA,IAAI,CAACI,uBAAD,EAA0BY,gBAA1B,EAA4CD,KAA5C,CAAJ,CAHoE,CAIpE;AACA;;AACAf,EAAAA,IAAI,CAACG,uBAAD,EAA0BY,KAA1B,EAAiCA,KAAjC,CAAJ,CANoE,CAQpE;AACA;AACA;AACA;AACA;;AACAf,EAAAA,IAAI,CAACE,kBAAD,EAAqB,IAArB,EAA2Ba,KAA3B,CAAJ;AACA,QAAME,eAAe,GAAGnB,kBAAkB,CAACkB,gBAAD,CAA1C,CAdoE,CAepE;;AACAf,EAAAA,GAAG,CAACC,kBAAD,EAAqBa,KAArB,CAAH;AACAf,EAAAA,IAAI,CAACE,kBAAD,EAAqBe,eAArB,EAAsCF,KAAtC,CAAJ;AACD;;AAED,SAASG,gBAAT,CAA0BH,KAA1B,EAAwC;AACtCd,EAAAA,GAAG,CAACC,kBAAD,EAAqBa,KAArB,CAAH;AACAd,EAAAA,GAAG,CAACE,uBAAD,EAA0BY,KAA1B,CAAH;AACAd,EAAAA,GAAG,CAACG,uBAAD,EAA0BW,KAA1B,CAAH;AACD;;AAED,SAASI,cAAT,GAAuC;AACrC,QAAMC,OAAO,GAAGf,eAAe,CAACH,kBAAkB,CAACS,OAApB,CAA/B;AACA,SAAOS,OAAP;AACD;;AAED,SAASC,eAAT,CAAyBN,KAAzB,EAA6C;AAC3C,QAAMK,OAAoB,GAAGf,eAAe,CAACH,kBAAkB,CAACS,OAApB,CAA5C;AACA,QAAMW,WAAW,GAAGzB,mBAAmB,CAACuB,OAAD,EAAUL,KAAK,CAACQ,IAAhB,CAAvC,CAF2C,CAI3C;;AACA,MAAIH,OAAO,KAAKE,WAAhB,EAA6B;AAC3B;AACD,GAP0C,CAS3C;AACA;;;AACAtB,EAAAA,IAAI,CAACG,uBAAD,EAA0BY,KAA1B,EAAiCA,KAAjC,CAAJ;AACAf,EAAAA,IAAI,CAACE,kBAAD,EAAqBoB,WAArB,EAAkCP,KAAlC,CAAJ;AACD;;AAED,SAASS,cAAT,CAAwBT,KAAxB,EAA4C;AAC1C;AACA;AACA,MAAIZ,uBAAuB,CAACQ,OAAxB,KAAoCI,KAAxC,EAA+C;AAC7C;AACD;;AAEDd,EAAAA,GAAG,CAACC,kBAAD,EAAqBa,KAArB,CAAH;AACAd,EAAAA,GAAG,CAACE,uBAAD,EAA0BY,KAA1B,CAAH;AACD;;AAED,SACEI,cADF,EAEET,2BAFF,EAGEE,oBAHF,EAIEM,gBAJF,EAKEM,cALF,EAMEV,iBANF,EAOEO,eAPF","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\nimport type {StackCursor} from './ReactFiberStack';\nimport type {Container, HostContext} from './ReactFiberHostConfig';\n\nimport {getChildHostContext, getRootHostContext} from './ReactFiberHostConfig';\nimport {createCursor, push, pop} from './ReactFiberStack';\n\nconst contextStackCursor: StackCursor<HostContext | null> = createCursor(null);\nconst contextFiberStackCursor: StackCursor<Fiber | null> = createCursor(null);\nconst rootInstanceStackCursor: StackCursor<Container | null> = createCursor(\n  null,\n);\n\nfunction requiredContext<Value>(c: Value | null): Value {\n  if (__DEV__) {\n    if (c === null) {\n      console.error(\n        'Expected host context to exist. This error is likely caused by a bug ' +\n          'in React. Please file an issue.',\n      );\n    }\n  }\n  return (c: any);\n}\n\nfunction getCurrentRootHostContainer(): null | Container {\n  return rootInstanceStackCursor.current;\n}\n\nfunction getRootHostContainer(): Container {\n  const rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber: Fiber, nextRootInstance: Container) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber);\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n\n  // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n  push(contextStackCursor, null, fiber);\n  const nextRootContext = getRootHostContext(nextRootInstance);\n  // Now that we know this function doesn't throw, replace it.\n  pop(contextStackCursor, fiber);\n  push(contextStackCursor, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber: Fiber) {\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext(): HostContext {\n  const context = requiredContext(contextStackCursor.current);\n  return context;\n}\n\nfunction pushHostContext(fiber: Fiber): void {\n  const context: HostContext = requiredContext(contextStackCursor.current);\n  const nextContext = getChildHostContext(context, fiber.type);\n\n  // Don't push this Fiber's context unless it's unique.\n  if (context === nextContext) {\n    return;\n  }\n\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor, nextContext, fiber);\n}\n\nfunction popHostContext(fiber: Fiber): void {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nexport {\n  getHostContext,\n  getCurrentRootHostContainer,\n  getRootHostContainer,\n  popHostContainer,\n  popHostContext,\n  pushHostContainer,\n  pushHostContext,\n};\n"]},"metadata":{},"sourceType":"module"}