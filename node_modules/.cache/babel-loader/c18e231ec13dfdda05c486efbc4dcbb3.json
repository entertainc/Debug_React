{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getInstanceFromNode, isContainerMarkedAsRoot, markContainerAsRoot, unmarkContainerAsRoot } from 'react-dom-bindings/src/client/ReactDOMComponentTree';\nimport { listenToAllSupportedEvents } from 'react-dom-bindings/src/events/DOMPluginEventSystem';\nimport { isValidContainerLegacy } from './ReactDOMRoot';\nimport { DOCUMENT_NODE, ELEMENT_NODE, COMMENT_NODE } from 'react-dom-bindings/src/shared/HTMLNodeType';\nimport { createContainer, createHydrationContainer, findHostInstanceWithNoPortals, updateContainer, flushSync, getPublicRootInstance, findHostInstance, findHostInstanceWithWarning } from 'react-reconciler/src/ReactFiberReconciler';\nimport { LegacyRoot } from 'react-reconciler/src/ReactRootTags';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { has as hasInstance } from 'shared/ReactInstanceMap';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nlet topLevelUpdateWarnings;\n\nif (__DEV__) {\n  topLevelUpdateWarnings = container => {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      const hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);\n\n      if (hostInstance) {\n        if (hostInstance.parentNode !== container) {\n          console.error('render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');\n        }\n      }\n    }\n\n    const isRootRenderedBySomeReact = !!container._reactRootContainer;\n    const rootEl = getReactRootElementInContainer(container);\n    const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n\n    if (hasNonRootReactChild && !isRootRenderedBySomeReact) {\n      console.error('render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');\n    }\n\n    if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') {\n      console.error('render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');\n    }\n  };\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction noopOnRecoverableError() {// This isn't reachable because onRecoverableError isn't called in the\n  // legacy API.\n}\n\nfunction legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {\n  if (isHydrationContainer) {\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n\n      callback = function () {\n        const instance = getPublicRootInstance(root);\n        originalCallback.call(instance);\n      };\n    }\n\n    const root = createHydrationContainer(initialChildren, callback, container, LegacyRoot, null, // hydrationCallbacks\n    false, // isStrictMode\n    false, // concurrentUpdatesByDefaultOverride,\n    '', // identifierPrefix\n    noopOnRecoverableError, // TODO(luna) Support hydration later\n    null);\n    container._reactRootContainer = root;\n    markContainerAsRoot(root.current, container);\n    const rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container; // $FlowFixMe[incompatible-call]\n\n    listenToAllSupportedEvents(rootContainerElement);\n    flushSync();\n    return root;\n  } else {\n    // First clear any existing content.\n    let rootSibling;\n\n    while (rootSibling = container.lastChild) {\n      container.removeChild(rootSibling);\n    }\n\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n\n      callback = function () {\n        const instance = getPublicRootInstance(root);\n        originalCallback.call(instance);\n      };\n    }\n\n    const root = createContainer(container, LegacyRoot, null, // hydrationCallbacks\n    false, // isStrictMode\n    false, // concurrentUpdatesByDefaultOverride,\n    '', // identifierPrefix\n    noopOnRecoverableError, // onRecoverableError\n    null // transitionCallbacks\n    );\n    container._reactRootContainer = root;\n    markContainerAsRoot(root.current, container);\n    const rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container; // $FlowFixMe[incompatible-call]\n\n    listenToAllSupportedEvents(rootContainerElement); // Initial mount should not be batched.\n\n    flushSync(() => {\n      updateContainer(initialChildren, root, parentComponent, callback);\n    });\n    return root;\n  }\n}\n\nfunction warnOnInvalidCallback(callback, callerName) {\n  if (__DEV__) {\n    if (callback !== null && typeof callback !== 'function') {\n      console.error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  }\n}\n\nfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  if (__DEV__) {\n    topLevelUpdateWarnings(container);\n    warnOnInvalidCallback(callback === undefined ? null : callback, 'render');\n  }\n\n  const maybeRoot = container._reactRootContainer;\n  let root;\n\n  if (!maybeRoot) {\n    // Initial mount\n    root = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);\n  } else {\n    root = maybeRoot;\n\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n\n      callback = function () {\n        const instance = getPublicRootInstance(root);\n        originalCallback.call(instance);\n      };\n    } // Update\n\n\n    updateContainer(children, root, parentComponent, callback);\n  }\n\n  return getPublicRootInstance(root);\n}\n\nexport function findDOMNode(componentOrElement) {\n  if (__DEV__) {\n    const owner = ReactCurrentOwner.current;\n\n    if (owner !== null && owner.stateNode !== null) {\n      const warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n\n      if (!warnedAboutRefsInRender) {\n        console.error('%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromType(owner.type) || 'A component');\n      }\n\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n\n  if (componentOrElement == null) {\n    return null;\n  }\n\n  if (componentOrElement.nodeType === ELEMENT_NODE) {\n    return componentOrElement;\n  }\n\n  if (__DEV__) {\n    return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');\n  }\n\n  return findHostInstance(componentOrElement);\n}\nexport function hydrate(element, container, callback) {\n  if (__DEV__) {\n    console.error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot ' + 'instead. Until you switch to the new API, your app will behave as ' + \"if it's running React 17. Learn \" + 'more: https://reactjs.org/link/switch-to-createroot');\n  }\n\n  if (!isValidContainerLegacy(container)) {\n    throw new Error('Target container is not a DOM element.');\n  }\n\n  if (__DEV__) {\n    const isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n\n    if (isModernRoot) {\n      console.error('You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOMClient.createRoot(). This is not supported. ' + 'Did you mean to call hydrateRoot(container, element)?');\n    }\n  } // TODO: throw or warn if we couldn't hydrate?\n\n\n  return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n}\nexport function render(element, container, callback) {\n  if (__DEV__) {\n    console.error('ReactDOM.render is no longer supported in React 18. Use createRoot ' + 'instead. Until you switch to the new API, your app will behave as ' + \"if it's running React 17. Learn \" + 'more: https://reactjs.org/link/switch-to-createroot');\n  }\n\n  if (!isValidContainerLegacy(container)) {\n    throw new Error('Target container is not a DOM element.');\n  }\n\n  if (__DEV__) {\n    const isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n\n    if (isModernRoot) {\n      console.error('You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOMClient.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?');\n    }\n  }\n\n  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n}\nexport function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\n  if (__DEV__) {\n    console.error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported ' + 'in React 18. Consider using a portal instead. Until you switch to ' + \"the createRoot API, your app will behave as if it's running React \" + '17. Learn more: https://reactjs.org/link/switch-to-createroot');\n  }\n\n  if (!isValidContainerLegacy(containerNode)) {\n    throw new Error('Target container is not a DOM element.');\n  }\n\n  if (parentComponent == null || !hasInstance(parentComponent)) {\n    throw new Error('parentComponent must be a valid React Component');\n  }\n\n  return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n}\nexport function unmountComponentAtNode(container) {\n  if (!isValidContainerLegacy(container)) {\n    throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');\n  }\n\n  if (__DEV__) {\n    const isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n\n    if (isModernRoot) {\n      console.error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');\n    }\n  }\n\n  if (container._reactRootContainer) {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);\n\n      if (renderedByDifferentReact) {\n        console.error(\"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.');\n      }\n    } // Unmount should not be batched.\n\n\n    flushSync(() => {\n      legacyRenderSubtreeIntoContainer(null, null, container, false, () => {\n        // $FlowFixMe This should probably use `delete container._reactRootContainer`\n        container._reactRootContainer = null;\n        unmarkContainerAsRoot(container);\n      });\n    }); // If you call unmountComponentAtNode twice in quick succession, you'll\n    // get `true` twice. That's probably fine?\n\n    return true;\n  } else {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl)); // Check if the container itself is a React root node.\n\n      const isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && // $FlowFixMe[prop-missing]\n      // $FlowFixMe[incompatible-use]\n      !!container.parentNode._reactRootContainer;\n\n      if (hasNonRootReactChild) {\n        console.error(\"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\n      }\n    }\n\n    return false;\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-dom/src/client/ReactDOMLegacy.js"],"names":["getInstanceFromNode","isContainerMarkedAsRoot","markContainerAsRoot","unmarkContainerAsRoot","listenToAllSupportedEvents","isValidContainerLegacy","DOCUMENT_NODE","ELEMENT_NODE","COMMENT_NODE","createContainer","createHydrationContainer","findHostInstanceWithNoPortals","updateContainer","flushSync","getPublicRootInstance","findHostInstance","findHostInstanceWithWarning","LegacyRoot","getComponentNameFromType","ReactSharedInternals","has","hasInstance","ReactCurrentOwner","topLevelUpdateWarnings","__DEV__","container","_reactRootContainer","nodeType","hostInstance","current","parentNode","console","error","isRootRenderedBySomeReact","rootEl","getReactRootElementInContainer","hasNonRootReactChild","tagName","toUpperCase","documentElement","firstChild","noopOnRecoverableError","legacyCreateRootFromDOMContainer","initialChildren","parentComponent","callback","isHydrationContainer","originalCallback","instance","root","call","rootContainerElement","rootSibling","lastChild","removeChild","warnOnInvalidCallback","callerName","legacyRenderSubtreeIntoContainer","children","forceHydrate","undefined","maybeRoot","findDOMNode","componentOrElement","owner","stateNode","warnedAboutRefsInRender","_warnedAboutRefsInRender","type","hydrate","element","Error","isModernRoot","render","unstable_renderSubtreeIntoContainer","containerNode","unmountComponentAtNode","renderedByDifferentReact","isContainerReactRoot"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  Container,\n  PublicInstance,\n} from 'react-dom-bindings/src/client/ReactDOMHostConfig';\nimport type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';\nimport type {ReactNodeList} from 'shared/ReactTypes';\n\nimport {\n  getInstanceFromNode,\n  isContainerMarkedAsRoot,\n  markContainerAsRoot,\n  unmarkContainerAsRoot,\n} from 'react-dom-bindings/src/client/ReactDOMComponentTree';\nimport {listenToAllSupportedEvents} from 'react-dom-bindings/src/events/DOMPluginEventSystem';\nimport {isValidContainerLegacy} from './ReactDOMRoot';\nimport {\n  DOCUMENT_NODE,\n  ELEMENT_NODE,\n  COMMENT_NODE,\n} from 'react-dom-bindings/src/shared/HTMLNodeType';\n\nimport {\n  createContainer,\n  createHydrationContainer,\n  findHostInstanceWithNoPortals,\n  updateContainer,\n  flushSync,\n  getPublicRootInstance,\n  findHostInstance,\n  findHostInstanceWithWarning,\n} from 'react-reconciler/src/ReactFiberReconciler';\nimport {LegacyRoot} from 'react-reconciler/src/ReactRootTags';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {has as hasInstance} from 'shared/ReactInstanceMap';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nlet topLevelUpdateWarnings;\n\nif (__DEV__) {\n  topLevelUpdateWarnings = (container: Container) => {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      const hostInstance = findHostInstanceWithNoPortals(\n        container._reactRootContainer.current,\n      );\n      if (hostInstance) {\n        if (hostInstance.parentNode !== container) {\n          console.error(\n            'render(...): It looks like the React-rendered content of this ' +\n              'container was removed without using React. This is not ' +\n              'supported and will cause errors. Instead, call ' +\n              'ReactDOM.unmountComponentAtNode to empty a container.',\n          );\n        }\n      }\n    }\n\n    const isRootRenderedBySomeReact = !!container._reactRootContainer;\n    const rootEl = getReactRootElementInContainer(container);\n    const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n\n    if (hasNonRootReactChild && !isRootRenderedBySomeReact) {\n      console.error(\n        'render(...): Replacing React-rendered children with a new root ' +\n          'component. If you intended to update the children of this node, ' +\n          'you should instead have the existing children update their state ' +\n          'and render the new components instead of calling ReactDOM.render.',\n      );\n    }\n\n    if (\n      container.nodeType === ELEMENT_NODE &&\n      ((container: any): Element).tagName &&\n      ((container: any): Element).tagName.toUpperCase() === 'BODY'\n    ) {\n      console.error(\n        'render(): Rendering components directly into document.body is ' +\n          'discouraged, since its children are often manipulated by third-party ' +\n          'scripts and browser extensions. This may lead to subtle ' +\n          'reconciliation issues. Try rendering into a container element created ' +\n          'for your app.',\n      );\n    }\n  };\n}\n\nfunction getReactRootElementInContainer(container: any) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction noopOnRecoverableError() {\n  // This isn't reachable because onRecoverableError isn't called in the\n  // legacy API.\n}\n\nfunction legacyCreateRootFromDOMContainer(\n  container: Container,\n  initialChildren: ReactNodeList,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n  isHydrationContainer: boolean,\n): FiberRoot {\n  if (isHydrationContainer) {\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(root);\n        originalCallback.call(instance);\n      };\n    }\n\n    const root = createHydrationContainer(\n      initialChildren,\n      callback,\n      container,\n      LegacyRoot,\n      null, // hydrationCallbacks\n      false, // isStrictMode\n      false, // concurrentUpdatesByDefaultOverride,\n      '', // identifierPrefix\n      noopOnRecoverableError,\n      // TODO(luna) Support hydration later\n      null,\n    );\n    container._reactRootContainer = root;\n    markContainerAsRoot(root.current, container);\n\n    const rootContainerElement =\n      container.nodeType === COMMENT_NODE ? container.parentNode : container;\n    // $FlowFixMe[incompatible-call]\n    listenToAllSupportedEvents(rootContainerElement);\n\n    flushSync();\n    return root;\n  } else {\n    // First clear any existing content.\n    let rootSibling;\n    while ((rootSibling = container.lastChild)) {\n      container.removeChild(rootSibling);\n    }\n\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(root);\n        originalCallback.call(instance);\n      };\n    }\n\n    const root = createContainer(\n      container,\n      LegacyRoot,\n      null, // hydrationCallbacks\n      false, // isStrictMode\n      false, // concurrentUpdatesByDefaultOverride,\n      '', // identifierPrefix\n      noopOnRecoverableError, // onRecoverableError\n      null, // transitionCallbacks\n    );\n    container._reactRootContainer = root;\n    markContainerAsRoot(root.current, container);\n\n    const rootContainerElement =\n      container.nodeType === COMMENT_NODE ? container.parentNode : container;\n    // $FlowFixMe[incompatible-call]\n    listenToAllSupportedEvents(rootContainerElement);\n\n    // Initial mount should not be batched.\n    flushSync(() => {\n      updateContainer(initialChildren, root, parentComponent, callback);\n    });\n\n    return root;\n  }\n}\n\nfunction warnOnInvalidCallback(callback: mixed, callerName: string): void {\n  if (__DEV__) {\n    if (callback !== null && typeof callback !== 'function') {\n      console.error(\n        '%s(...): Expected the last optional `callback` argument to be a ' +\n          'function. Instead received: %s.',\n        callerName,\n        callback,\n      );\n    }\n  }\n}\n\nfunction legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  container: Container,\n  forceHydrate: boolean,\n  callback: ?Function,\n): React$Component<any, any> | PublicInstance | null {\n  if (__DEV__) {\n    topLevelUpdateWarnings(container);\n    warnOnInvalidCallback(callback === undefined ? null : callback, 'render');\n  }\n\n  const maybeRoot = container._reactRootContainer;\n  let root: FiberRoot;\n  if (!maybeRoot) {\n    // Initial mount\n    root = legacyCreateRootFromDOMContainer(\n      container,\n      children,\n      parentComponent,\n      callback,\n      forceHydrate,\n    );\n  } else {\n    root = maybeRoot;\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(root);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    updateContainer(children, root, parentComponent, callback);\n  }\n  return getPublicRootInstance(root);\n}\n\nexport function findDOMNode(\n  componentOrElement: Element | ?React$Component<any, any>,\n): null | Element | Text {\n  if (__DEV__) {\n    const owner = (ReactCurrentOwner.current: any);\n    if (owner !== null && owner.stateNode !== null) {\n      const warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n      if (!warnedAboutRefsInRender) {\n        console.error(\n          '%s is accessing findDOMNode inside its render(). ' +\n            'render() should be a pure function of props and state. It should ' +\n            'never access something that requires stale data from the previous ' +\n            'render, such as refs. Move this logic to componentDidMount and ' +\n            'componentDidUpdate instead.',\n          getComponentNameFromType(owner.type) || 'A component',\n        );\n      }\n      owner.stateNode._warnedAboutRefsInRender = true;\n    }\n  }\n  if (componentOrElement == null) {\n    return null;\n  }\n  if ((componentOrElement: any).nodeType === ELEMENT_NODE) {\n    return (componentOrElement: any);\n  }\n  if (__DEV__) {\n    return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');\n  }\n  return findHostInstance(componentOrElement);\n}\n\nexport function hydrate(\n  element: React$Node,\n  container: Container,\n  callback: ?Function,\n): React$Component<any, any> | PublicInstance | null {\n  if (__DEV__) {\n    console.error(\n      'ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot ' +\n        'instead. Until you switch to the new API, your app will behave as ' +\n        \"if it's running React 17. Learn \" +\n        'more: https://reactjs.org/link/switch-to-createroot',\n    );\n  }\n\n  if (!isValidContainerLegacy(container)) {\n    throw new Error('Target container is not a DOM element.');\n  }\n\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      console.error(\n        'You are calling ReactDOM.hydrate() on a container that was previously ' +\n          'passed to ReactDOMClient.createRoot(). This is not supported. ' +\n          'Did you mean to call hydrateRoot(container, element)?',\n      );\n    }\n  }\n  // TODO: throw or warn if we couldn't hydrate?\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    true,\n    callback,\n  );\n}\n\nexport function render(\n  element: React$Element<any>,\n  container: Container,\n  callback: ?Function,\n): React$Component<any, any> | PublicInstance | null {\n  if (__DEV__) {\n    console.error(\n      'ReactDOM.render is no longer supported in React 18. Use createRoot ' +\n        'instead. Until you switch to the new API, your app will behave as ' +\n        \"if it's running React 17. Learn \" +\n        'more: https://reactjs.org/link/switch-to-createroot',\n    );\n  }\n\n  if (!isValidContainerLegacy(container)) {\n    throw new Error('Target container is not a DOM element.');\n  }\n\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      console.error(\n        'You are calling ReactDOM.render() on a container that was previously ' +\n          'passed to ReactDOMClient.createRoot(). This is not supported. ' +\n          'Did you mean to call root.render(element)?',\n      );\n    }\n  }\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n\nexport function unstable_renderSubtreeIntoContainer(\n  parentComponent: React$Component<any, any>,\n  element: React$Element<any>,\n  containerNode: Container,\n  callback: ?Function,\n): React$Component<any, any> | PublicInstance | null {\n  if (__DEV__) {\n    console.error(\n      'ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported ' +\n        'in React 18. Consider using a portal instead. Until you switch to ' +\n        \"the createRoot API, your app will behave as if it's running React \" +\n        '17. Learn more: https://reactjs.org/link/switch-to-createroot',\n    );\n  }\n\n  if (!isValidContainerLegacy(containerNode)) {\n    throw new Error('Target container is not a DOM element.');\n  }\n\n  if (parentComponent == null || !hasInstance(parentComponent)) {\n    throw new Error('parentComponent must be a valid React Component');\n  }\n\n  return legacyRenderSubtreeIntoContainer(\n    parentComponent,\n    element,\n    containerNode,\n    false,\n    callback,\n  );\n}\n\nexport function unmountComponentAtNode(container: Container): boolean {\n  if (!isValidContainerLegacy(container)) {\n    throw new Error(\n      'unmountComponentAtNode(...): Target container is not a DOM element.',\n    );\n  }\n\n  if (__DEV__) {\n    const isModernRoot =\n      isContainerMarkedAsRoot(container) &&\n      container._reactRootContainer === undefined;\n    if (isModernRoot) {\n      console.error(\n        'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' +\n          'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?',\n      );\n    }\n  }\n\n  if (container._reactRootContainer) {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);\n      if (renderedByDifferentReact) {\n        console.error(\n          \"unmountComponentAtNode(): The node you're attempting to unmount \" +\n            'was rendered by another copy of React.',\n        );\n      }\n    }\n\n    // Unmount should not be batched.\n    flushSync(() => {\n      legacyRenderSubtreeIntoContainer(null, null, container, false, () => {\n        // $FlowFixMe This should probably use `delete container._reactRootContainer`\n        container._reactRootContainer = null;\n        unmarkContainerAsRoot(container);\n      });\n    });\n    // If you call unmountComponentAtNode twice in quick succession, you'll\n    // get `true` twice. That's probably fine?\n    return true;\n  } else {\n    if (__DEV__) {\n      const rootEl = getReactRootElementInContainer(container);\n      const hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n\n      // Check if the container itself is a React root node.\n      const isContainerReactRoot =\n        container.nodeType === ELEMENT_NODE &&\n        isValidContainerLegacy(container.parentNode) &&\n        // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-use]\n        !!container.parentNode._reactRootContainer;\n\n      if (hasNonRootReactChild) {\n        console.error(\n          \"unmountComponentAtNode(): The node you're attempting to unmount \" +\n            'was rendered by React and is not a top-level container. %s',\n          isContainerReactRoot\n            ? 'You may have accidentally passed in a React root node instead ' +\n                'of its container.'\n            : 'Instead, have the parent component update its state and ' +\n                'rerender in order to remove this component.',\n        );\n      }\n    }\n\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}