{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableSuspenseAvoidThisFallback } from 'shared/ReactFeatureFlags';\nimport { createCursor, push, pop } from './ReactFiberStack';\nimport { isCurrentTreeHidden } from './ReactFiberHiddenContext';\nimport { SuspenseComponent, OffscreenComponent } from './ReactWorkTags'; // The Suspense handler is the boundary that should capture if something\n// suspends, i.e. it's the nearest `catch` block on the stack.\n\nconst suspenseHandlerStackCursor = createCursor(null);\n\nfunction shouldAvoidedBoundaryCapture(workInProgress, handlerOnStack, props) {\n  if (enableSuspenseAvoidThisFallback) {\n    // If the parent is already showing content, and we're not inside a hidden\n    // tree, then we should show the avoided fallback.\n    if (handlerOnStack.alternate !== null && !isCurrentTreeHidden()) {\n      return true;\n    } // If the handler on the stack is also an avoided boundary, then we should\n    // favor this inner one.\n\n\n    if (handlerOnStack.tag === SuspenseComponent && handlerOnStack.memoizedProps.unstable_avoidThisFallback === true) {\n      return true;\n    } // If this avoided boundary is dehydrated, then it should capture.\n\n\n    const suspenseState = workInProgress.memoizedState;\n\n    if (suspenseState !== null && suspenseState.dehydrated !== null) {\n      return true;\n    }\n  } // If none of those cases apply, then we should avoid this fallback and show\n  // the outer one instead.\n\n\n  return false;\n}\n\nexport function isBadSuspenseFallback(current, nextProps) {\n  // Check if this is a \"bad\" fallback state or a good one. A bad fallback state\n  // is one that we only show as a last resort; if this is a transition, we'll\n  // block it from displaying, and wait for more data to arrive.\n  if (current !== null) {\n    const prevState = current.memoizedState;\n    const isShowingFallback = prevState !== null;\n\n    if (!isShowingFallback && !isCurrentTreeHidden()) {\n      // It's bad to switch to a fallback if content is already visible\n      return true;\n    }\n  }\n\n  if (enableSuspenseAvoidThisFallback && nextProps.unstable_avoidThisFallback === true) {\n    // Experimental: Some fallbacks are always bad\n    return true;\n  }\n\n  return false;\n}\nexport function pushPrimaryTreeSuspenseHandler(handler) {\n  const props = handler.pendingProps;\n  const handlerOnStack = suspenseHandlerStackCursor.current;\n\n  if (enableSuspenseAvoidThisFallback && props.unstable_avoidThisFallback === true && handlerOnStack !== null && !shouldAvoidedBoundaryCapture(handler, handlerOnStack, props)) {\n    // This boundary should not capture if something suspends. Reuse the\n    // existing handler on the stack.\n    push(suspenseHandlerStackCursor, handlerOnStack, handler);\n  } else {\n    // Push this handler onto the stack.\n    push(suspenseHandlerStackCursor, handler, handler);\n  }\n}\nexport function pushFallbackTreeSuspenseHandler(fiber) {\n  // We're about to render the fallback. If something in the fallback suspends,\n  // it's akin to throwing inside of a `catch` block. This boundary should not\n  // capture. Reuse the existing handler on the stack.\n  reuseSuspenseHandlerOnStack(fiber);\n}\nexport function pushOffscreenSuspenseHandler(fiber) {\n  if (fiber.tag === OffscreenComponent) {\n    push(suspenseHandlerStackCursor, fiber, fiber);\n  } else {\n    // This is a LegacyHidden component.\n    reuseSuspenseHandlerOnStack(fiber);\n  }\n}\nexport function reuseSuspenseHandlerOnStack(fiber) {\n  push(suspenseHandlerStackCursor, getSuspenseHandler(), fiber);\n}\nexport function getSuspenseHandler() {\n  return suspenseHandlerStackCursor.current;\n}\nexport function popSuspenseHandler(fiber) {\n  pop(suspenseHandlerStackCursor, fiber);\n} // SuspenseList context\n// TODO: Move to a separate module? We may change the SuspenseList\n// implementation to hide/show in the commit phase, anyway.\n\nconst DefaultSuspenseContext = 0b00;\nconst SubtreeSuspenseContextMask = 0b01; // ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\n\nexport const ForceSuspenseFallback = 0b10;\nexport const suspenseStackCursor = createCursor(DefaultSuspenseContext);\nexport function hasSuspenseListContext(parentContext, flag) {\n  return (parentContext & flag) !== 0;\n}\nexport function setDefaultShallowSuspenseListContext(parentContext) {\n  return parentContext & SubtreeSuspenseContextMask;\n}\nexport function setShallowSuspenseListContext(parentContext, shallowContext) {\n  return parentContext & SubtreeSuspenseContextMask | shallowContext;\n}\nexport function pushSuspenseListContext(fiber, newContext) {\n  push(suspenseStackCursor, newContext, fiber);\n}\nexport function popSuspenseListContext(fiber) {\n  pop(suspenseStackCursor, fiber);\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberSuspenseContext.js"],"names":["enableSuspenseAvoidThisFallback","createCursor","push","pop","isCurrentTreeHidden","SuspenseComponent","OffscreenComponent","suspenseHandlerStackCursor","shouldAvoidedBoundaryCapture","workInProgress","handlerOnStack","props","alternate","tag","memoizedProps","unstable_avoidThisFallback","suspenseState","memoizedState","dehydrated","isBadSuspenseFallback","current","nextProps","prevState","isShowingFallback","pushPrimaryTreeSuspenseHandler","handler","pendingProps","pushFallbackTreeSuspenseHandler","fiber","reuseSuspenseHandlerOnStack","pushOffscreenSuspenseHandler","getSuspenseHandler","popSuspenseHandler","DefaultSuspenseContext","SubtreeSuspenseContextMask","ForceSuspenseFallback","suspenseStackCursor","hasSuspenseListContext","parentContext","flag","setDefaultShallowSuspenseListContext","setShallowSuspenseListContext","shallowContext","pushSuspenseListContext","newContext","popSuspenseListContext"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\nimport type {StackCursor} from './ReactFiberStack';\nimport type {SuspenseState, SuspenseProps} from './ReactFiberSuspenseComponent';\n\nimport {enableSuspenseAvoidThisFallback} from 'shared/ReactFeatureFlags';\nimport {createCursor, push, pop} from './ReactFiberStack';\nimport {isCurrentTreeHidden} from './ReactFiberHiddenContext';\nimport {SuspenseComponent, OffscreenComponent} from './ReactWorkTags';\n\n// The Suspense handler is the boundary that should capture if something\n// suspends, i.e. it's the nearest `catch` block on the stack.\nconst suspenseHandlerStackCursor: StackCursor<Fiber | null> = createCursor(\n  null,\n);\n\nfunction shouldAvoidedBoundaryCapture(\n  workInProgress: Fiber,\n  handlerOnStack: Fiber,\n  props: any,\n): boolean {\n  if (enableSuspenseAvoidThisFallback) {\n    // If the parent is already showing content, and we're not inside a hidden\n    // tree, then we should show the avoided fallback.\n    if (handlerOnStack.alternate !== null && !isCurrentTreeHidden()) {\n      return true;\n    }\n\n    // If the handler on the stack is also an avoided boundary, then we should\n    // favor this inner one.\n    if (\n      handlerOnStack.tag === SuspenseComponent &&\n      handlerOnStack.memoizedProps.unstable_avoidThisFallback === true\n    ) {\n      return true;\n    }\n\n    // If this avoided boundary is dehydrated, then it should capture.\n    const suspenseState: SuspenseState | null = workInProgress.memoizedState;\n    if (suspenseState !== null && suspenseState.dehydrated !== null) {\n      return true;\n    }\n  }\n\n  // If none of those cases apply, then we should avoid this fallback and show\n  // the outer one instead.\n  return false;\n}\n\nexport function isBadSuspenseFallback(\n  current: Fiber | null,\n  nextProps: SuspenseProps,\n): boolean {\n  // Check if this is a \"bad\" fallback state or a good one. A bad fallback state\n  // is one that we only show as a last resort; if this is a transition, we'll\n  // block it from displaying, and wait for more data to arrive.\n  if (current !== null) {\n    const prevState: SuspenseState = current.memoizedState;\n    const isShowingFallback = prevState !== null;\n    if (!isShowingFallback && !isCurrentTreeHidden()) {\n      // It's bad to switch to a fallback if content is already visible\n      return true;\n    }\n  }\n\n  if (\n    enableSuspenseAvoidThisFallback &&\n    nextProps.unstable_avoidThisFallback === true\n  ) {\n    // Experimental: Some fallbacks are always bad\n    return true;\n  }\n\n  return false;\n}\n\nexport function pushPrimaryTreeSuspenseHandler(handler: Fiber): void {\n  const props = handler.pendingProps;\n  const handlerOnStack = suspenseHandlerStackCursor.current;\n  if (\n    enableSuspenseAvoidThisFallback &&\n    props.unstable_avoidThisFallback === true &&\n    handlerOnStack !== null &&\n    !shouldAvoidedBoundaryCapture(handler, handlerOnStack, props)\n  ) {\n    // This boundary should not capture if something suspends. Reuse the\n    // existing handler on the stack.\n    push(suspenseHandlerStackCursor, handlerOnStack, handler);\n  } else {\n    // Push this handler onto the stack.\n    push(suspenseHandlerStackCursor, handler, handler);\n  }\n}\n\nexport function pushFallbackTreeSuspenseHandler(fiber: Fiber): void {\n  // We're about to render the fallback. If something in the fallback suspends,\n  // it's akin to throwing inside of a `catch` block. This boundary should not\n  // capture. Reuse the existing handler on the stack.\n  reuseSuspenseHandlerOnStack(fiber);\n}\n\nexport function pushOffscreenSuspenseHandler(fiber: Fiber): void {\n  if (fiber.tag === OffscreenComponent) {\n    push(suspenseHandlerStackCursor, fiber, fiber);\n  } else {\n    // This is a LegacyHidden component.\n    reuseSuspenseHandlerOnStack(fiber);\n  }\n}\n\nexport function reuseSuspenseHandlerOnStack(fiber: Fiber) {\n  push(suspenseHandlerStackCursor, getSuspenseHandler(), fiber);\n}\n\nexport function getSuspenseHandler(): Fiber | null {\n  return suspenseHandlerStackCursor.current;\n}\n\nexport function popSuspenseHandler(fiber: Fiber): void {\n  pop(suspenseHandlerStackCursor, fiber);\n}\n\n// SuspenseList context\n// TODO: Move to a separate module? We may change the SuspenseList\n// implementation to hide/show in the commit phase, anyway.\nexport opaque type SuspenseContext = number;\nexport opaque type SubtreeSuspenseContext: SuspenseContext = number;\nexport opaque type ShallowSuspenseContext: SuspenseContext = number;\n\nconst DefaultSuspenseContext: SuspenseContext = 0b00;\n\nconst SubtreeSuspenseContextMask: SuspenseContext = 0b01;\n\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\nexport const ForceSuspenseFallback: ShallowSuspenseContext = 0b10;\n\nexport const suspenseStackCursor: StackCursor<SuspenseContext> = createCursor(\n  DefaultSuspenseContext,\n);\n\nexport function hasSuspenseListContext(\n  parentContext: SuspenseContext,\n  flag: SuspenseContext,\n): boolean {\n  return (parentContext & flag) !== 0;\n}\n\nexport function setDefaultShallowSuspenseListContext(\n  parentContext: SuspenseContext,\n): SuspenseContext {\n  return parentContext & SubtreeSuspenseContextMask;\n}\n\nexport function setShallowSuspenseListContext(\n  parentContext: SuspenseContext,\n  shallowContext: ShallowSuspenseContext,\n): SuspenseContext {\n  return (parentContext & SubtreeSuspenseContextMask) | shallowContext;\n}\n\nexport function pushSuspenseListContext(\n  fiber: Fiber,\n  newContext: SuspenseContext,\n): void {\n  push(suspenseStackCursor, newContext, fiber);\n}\n\nexport function popSuspenseListContext(fiber: Fiber): void {\n  pop(suspenseStackCursor, fiber);\n}\n"]},"metadata":{},"sourceType":"module"}