{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { findCurrentHostFiber, findCurrentHostFiberWithNoPortals } from './ReactFiberTreeReflection';\nimport { get as getInstance } from 'shared/ReactInstanceMap';\nimport { HostComponent, HostSingleton, ClassComponent, HostRoot, SuspenseComponent } from './ReactWorkTags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport isArray from 'shared/isArray';\nimport { enableSchedulingProfiler } from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { getPublicInstance } from './ReactFiberHostConfig';\nimport { findCurrentUnmaskedContext, processChildContext, emptyContextObject, isContextProvider as isLegacyContextProvider } from './ReactFiberContext';\nimport { createFiberRoot } from './ReactFiberRoot';\nimport { isRootDehydrated } from './ReactFiberShellHydration';\nimport { injectInternals, markRenderScheduled, onScheduleRoot } from './ReactFiberDevToolsHook';\nimport { requestEventTime, requestUpdateLane, scheduleUpdateOnFiber, scheduleInitialHydrationOnRoot, flushRoot, batchedUpdates, flushSync, isAlreadyRendering, flushControlled, deferredUpdates, discreteUpdates, flushPassiveEffects } from './ReactFiberWorkLoop';\nimport { enqueueConcurrentRenderForLane } from './ReactFiberConcurrentUpdates';\nimport { createUpdate, enqueueUpdate, entangleTransitions } from './ReactFiberClassUpdateQueue';\nimport { isRendering as ReactCurrentFiberIsRendering, current as ReactCurrentFiberCurrent, resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV } from './ReactCurrentFiber';\nimport { StrictLegacyMode } from './ReactTypeOfMode';\nimport { SyncLane, SelectiveHydrationLane, NoTimestamp, getHighestPriorityPendingLanes, higherPriorityLane } from './ReactFiberLane';\nimport { getCurrentUpdatePriority, runWithPriority } from './ReactEventPriorities';\nimport { scheduleRefresh, scheduleRoot, setRefreshHandler, findHostInstancesForRefresh } from './ReactFiberHotReloading';\nimport ReactVersion from 'shared/ReactVersion';\nexport { registerMutableSourceForHydration } from './ReactMutableSource';\nexport { createPortal } from './ReactPortal';\nexport { createComponentSelector, createHasPseudoClassSelector, createRoleSelector, createTestNameSelector, createTextSelector, getFindAllNodesFailureDescription, findAllNodes, findBoundingRects, focusWithin, observeVisibleRects } from './ReactTestSelectors';\nlet didWarnAboutNestedUpdates;\nlet didWarnAboutFindNodeInStrictMode;\n\nif (__DEV__) {\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  const fiber = getInstance(parentComponent);\n  const parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    const Component = fiber.type;\n\n    if (isLegacyContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component) {\n  const fiber = getInstance(component);\n\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      throw new Error('Unable to find node on an unmounted component.');\n    } else {\n      const keys = Object.keys(component).join(',');\n      throw new Error(`Argument appears to not be a ReactComponent. Keys: ${keys}`);\n    }\n  }\n\n  const hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(component, methodName) {\n  if (__DEV__) {\n    const fiber = getInstance(component);\n\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        throw new Error('Unable to find node on an unmounted component.');\n      } else {\n        const keys = Object.keys(component).join(',');\n        throw new Error(`Argument appears to not be a ReactComponent. Keys: ${keys}`);\n      }\n    }\n\n    const hostFiber = findCurrentHostFiber(fiber);\n\n    if (hostFiber === null) {\n      return null;\n    }\n\n    if (hostFiber.mode & StrictLegacyMode) {\n      const componentName = getComponentNameFromFiber(fiber) || 'Component';\n\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n        const previousFiber = ReactCurrentFiberCurrent;\n\n        try {\n          setCurrentDebugFiberInDEV(hostFiber);\n\n          if (fiber.mode & StrictLegacyMode) {\n            console.error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          } else {\n            console.error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          }\n        } finally {\n          // Ideally this should reset to previous but this shouldn't be called in\n          // render and there's another warning for that anyway.\n          if (previousFiber) {\n            setCurrentDebugFiberInDEV(previousFiber);\n          } else {\n            resetCurrentDebugFiberInDEV();\n          }\n        }\n      }\n    }\n\n    return hostFiber.stateNode;\n  }\n\n  return findHostInstance(component);\n}\n\nexport function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n  const hydrate = false;\n  const initialChildren = null;\n  return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks);\n}\nexport function createHydrationContainer(initialChildren, // TODO: Remove `callback` when we delete legacy mode.\ncallback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n  const hydrate = true;\n  const root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks); // TODO: Move this to FiberRoot constructor\n\n  root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n  // a regular update because the initial render must match was was rendered\n  // on the server.\n  // NOTE: This update intentionally doesn't have a payload. We're only using\n  // the update to schedule work on the root fiber (and, for legacy roots, to\n  // enqueue the callback if one is provided).\n\n  const current = root.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n  const update = createUpdate(eventTime, lane);\n  update.callback = callback !== undefined && callback !== null ? callback : null;\n  enqueueUpdate(current, update, lane);\n  scheduleInitialHydrationOnRoot(root, lane, eventTime);\n  return root;\n}\nexport function updateContainer(element, container, parentComponent, callback) {\n  if (__DEV__) {\n    onScheduleRoot(container, element);\n  }\n\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n\n  if (enableSchedulingProfiler) {\n    markRenderScheduled(lane);\n  }\n\n  const context = getContextForSubtree(parentComponent);\n\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  if (__DEV__) {\n    if (ReactCurrentFiberIsRendering && ReactCurrentFiberCurrent !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n      console.error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(ReactCurrentFiberCurrent) || 'Unknown');\n    }\n  }\n\n  const update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element\n  };\n  callback = callback === undefined ? null : callback;\n\n  if (callback !== null) {\n    if (__DEV__) {\n      if (typeof callback !== 'function') {\n        console.error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    }\n\n    update.callback = callback;\n  }\n\n  const root = enqueueUpdate(current, update, lane);\n\n  if (root !== null) {\n    scheduleUpdateOnFiber(root, current, lane, eventTime);\n    entangleTransitions(root, current, lane);\n  }\n\n  return lane;\n}\nexport { batchedUpdates, deferredUpdates, discreteUpdates, flushControlled, flushSync, isAlreadyRendering, flushPassiveEffects };\nexport function getPublicRootInstance(container) {\n  const containerFiber = container.current;\n\n  if (!containerFiber.child) {\n    return null;\n  }\n\n  switch (containerFiber.child.tag) {\n    case HostSingleton:\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\nexport function attemptSynchronousHydration(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n      {\n        const root = fiber.stateNode;\n\n        if (isRootDehydrated(root)) {\n          // Flush the first scheduled \"update\".\n          const lanes = getHighestPriorityPendingLanes(root);\n          flushRoot(root, lanes);\n        }\n\n        break;\n      }\n\n    case SuspenseComponent:\n      {\n        flushSync(() => {\n          const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n          if (root !== null) {\n            const eventTime = requestEventTime();\n            scheduleUpdateOnFiber(root, fiber, SyncLane, eventTime);\n          }\n        }); // If we're still blocked after this, we need to increase\n        // the priority of any promises resolving within this\n        // boundary so that they next attempt also has higher pri.\n\n        const retryLane = SyncLane;\n        markRetryLaneIfNotHydrated(fiber, retryLane);\n        break;\n      }\n  }\n}\n\nfunction markRetryLaneImpl(fiber, retryLane) {\n  const suspenseState = fiber.memoizedState;\n\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n  }\n} // Increases the priority of thenables when they resolve within this boundary.\n\n\nfunction markRetryLaneIfNotHydrated(fiber, retryLane) {\n  markRetryLaneImpl(fiber, retryLane);\n  const alternate = fiber.alternate;\n\n  if (alternate) {\n    markRetryLaneImpl(alternate, retryLane);\n  }\n}\n\nexport function attemptDiscreteHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  const lane = SyncLane;\n  const root = enqueueConcurrentRenderForLane(fiber, lane);\n\n  if (root !== null) {\n    const eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nexport function attemptContinuousHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  const lane = SelectiveHydrationLane;\n  const root = enqueueConcurrentRenderForLane(fiber, lane);\n\n  if (root !== null) {\n    const eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nexport function attemptHydrationAtCurrentPriority(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n\n  const lane = requestUpdateLane(fiber);\n  const root = enqueueConcurrentRenderForLane(fiber, lane);\n\n  if (root !== null) {\n    const eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nexport { getCurrentUpdatePriority, runWithPriority };\nexport { findHostInstance };\nexport { findHostInstanceWithWarning };\nexport function findHostInstanceWithNoPortals(fiber) {\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nlet shouldErrorImpl = fiber => null;\n\nexport function shouldError(fiber) {\n  return shouldErrorImpl(fiber);\n}\n\nlet shouldSuspendImpl = fiber => false;\n\nexport function shouldSuspend(fiber) {\n  return shouldSuspendImpl(fiber);\n}\nlet overrideHookState = null;\nlet overrideHookStateDeletePath = null;\nlet overrideHookStateRenamePath = null;\nlet overrideProps = null;\nlet overridePropsDeletePath = null;\nlet overridePropsRenamePath = null;\nlet scheduleUpdate = null;\nlet setErrorHandler = null;\nlet setSuspenseHandler = null;\n\nif (__DEV__) {\n  const copyWithDeleteImpl = (obj, path, index) => {\n    const key = path[index];\n    const updated = isArray(obj) ? obj.slice() : { ...obj\n    };\n\n    if (index + 1 === path.length) {\n      if (isArray(updated)) {\n        updated.splice(key, 1);\n      } else {\n        delete updated[key];\n      }\n\n      return updated;\n    } // $FlowFixMe number or string is fine here\n\n\n    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n    return updated;\n  };\n\n  const copyWithDelete = (obj, path) => {\n    return copyWithDeleteImpl(obj, path, 0);\n  };\n\n  const copyWithRenameImpl = (obj, oldPath, newPath, index) => {\n    const oldKey = oldPath[index];\n    const updated = isArray(obj) ? obj.slice() : { ...obj\n    };\n\n    if (index + 1 === oldPath.length) {\n      const newKey = newPath[index]; // $FlowFixMe number or string is fine here\n\n      updated[newKey] = updated[oldKey];\n\n      if (isArray(updated)) {\n        updated.splice(oldKey, 1);\n      } else {\n        delete updated[oldKey];\n      }\n    } else {\n      // $FlowFixMe number or string is fine here\n      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here\n      obj[oldKey], oldPath, newPath, index + 1);\n    }\n\n    return updated;\n  };\n\n  const copyWithRename = (obj, oldPath, newPath) => {\n    if (oldPath.length !== newPath.length) {\n      console.warn('copyWithRename() expects paths of the same length');\n      return;\n    } else {\n      for (let i = 0; i < newPath.length - 1; i++) {\n        if (oldPath[i] !== newPath[i]) {\n          console.warn('copyWithRename() expects paths to be the same except for the deepest key');\n          return;\n        }\n      }\n    }\n\n    return copyWithRenameImpl(obj, oldPath, newPath, 0);\n  };\n\n  const copyWithSetImpl = (obj, path, index, value) => {\n    if (index >= path.length) {\n      return value;\n    }\n\n    const key = path[index];\n    const updated = isArray(obj) ? obj.slice() : { ...obj\n    }; // $FlowFixMe number or string is fine here\n\n    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n    return updated;\n  };\n\n  const copyWithSet = (obj, path, value) => {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  const findHook = (fiber, id) => {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    let currentHook = fiber.memoizedState;\n\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n\n    return currentHook;\n  }; // Support DevTools editable values for useState and useReducer.\n\n\n  overrideHookState = (fiber, id, path, value) => {\n    const hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      const newState = copyWithSet(hook.memoizedState, path, value);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  };\n\n  overrideHookStateDeletePath = (fiber, id, path) => {\n    const hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      const newState = copyWithDelete(hook.memoizedState, path);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  };\n\n  overrideHookStateRenamePath = (fiber, id, oldPath, newPath) => {\n    const hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      const newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = { ...fiber.memoizedProps\n      };\n      const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n\n\n  overrideProps = (fiber, path, value) => {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overridePropsDeletePath = (fiber, path) => {\n    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overridePropsRenamePath = (fiber, oldPath, newPath) => {\n    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  scheduleUpdate = fiber => {\n    const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  setErrorHandler = newShouldErrorImpl => {\n    shouldErrorImpl = newShouldErrorImpl;\n  };\n\n  setSuspenseHandler = newShouldSuspendImpl => {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nfunction findHostInstanceByFiber(fiber) {\n  const hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction emptyFindFiberByHostInstance(instance) {\n  return null;\n}\n\nfunction getCurrentFiberForDevTools() {\n  return ReactCurrentFiberCurrent;\n}\n\nexport function injectIntoDevTools(devToolsConfig) {\n  const {\n    findFiberByHostInstance\n  } = devToolsConfig;\n  const {\n    ReactCurrentDispatcher\n  } = ReactSharedInternals;\n  return injectInternals({\n    bundleType: devToolsConfig.bundleType,\n    version: devToolsConfig.version,\n    rendererPackageName: devToolsConfig.rendererPackageName,\n    rendererConfig: devToolsConfig.rendererConfig,\n    overrideHookState,\n    overrideHookStateDeletePath,\n    overrideHookStateRenamePath,\n    overrideProps,\n    overridePropsDeletePath,\n    overridePropsRenamePath,\n    setErrorHandler,\n    setSuspenseHandler,\n    scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber,\n    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n    // React Refresh\n    findHostInstancesForRefresh: __DEV__ ? findHostInstancesForRefresh : null,\n    scheduleRefresh: __DEV__ ? scheduleRefresh : null,\n    scheduleRoot: __DEV__ ? scheduleRoot : null,\n    setRefreshHandler: __DEV__ ? setRefreshHandler : null,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber: __DEV__ ? getCurrentFiberForDevTools : null,\n    // Enables DevTools to detect reconciler version rather than renderer version\n    // which may not match for third party renderers.\n    reconcilerVersion: ReactVersion\n  });\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberReconciler.js"],"names":["findCurrentHostFiber","findCurrentHostFiberWithNoPortals","get","getInstance","HostComponent","HostSingleton","ClassComponent","HostRoot","SuspenseComponent","getComponentNameFromFiber","isArray","enableSchedulingProfiler","ReactSharedInternals","getPublicInstance","findCurrentUnmaskedContext","processChildContext","emptyContextObject","isContextProvider","isLegacyContextProvider","createFiberRoot","isRootDehydrated","injectInternals","markRenderScheduled","onScheduleRoot","requestEventTime","requestUpdateLane","scheduleUpdateOnFiber","scheduleInitialHydrationOnRoot","flushRoot","batchedUpdates","flushSync","isAlreadyRendering","flushControlled","deferredUpdates","discreteUpdates","flushPassiveEffects","enqueueConcurrentRenderForLane","createUpdate","enqueueUpdate","entangleTransitions","isRendering","ReactCurrentFiberIsRendering","current","ReactCurrentFiberCurrent","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","StrictLegacyMode","SyncLane","SelectiveHydrationLane","NoTimestamp","getHighestPriorityPendingLanes","higherPriorityLane","getCurrentUpdatePriority","runWithPriority","scheduleRefresh","scheduleRoot","setRefreshHandler","findHostInstancesForRefresh","ReactVersion","registerMutableSourceForHydration","createPortal","createComponentSelector","createHasPseudoClassSelector","createRoleSelector","createTestNameSelector","createTextSelector","getFindAllNodesFailureDescription","findAllNodes","findBoundingRects","focusWithin","observeVisibleRects","didWarnAboutNestedUpdates","didWarnAboutFindNodeInStrictMode","__DEV__","getContextForSubtree","parentComponent","fiber","parentContext","tag","Component","type","findHostInstance","component","undefined","render","Error","keys","Object","join","hostFiber","stateNode","findHostInstanceWithWarning","methodName","mode","componentName","previousFiber","console","error","createContainer","containerInfo","hydrationCallbacks","isStrictMode","concurrentUpdatesByDefaultOverride","identifierPrefix","onRecoverableError","transitionCallbacks","hydrate","initialChildren","createHydrationContainer","callback","root","context","eventTime","lane","update","updateContainer","element","container","pendingContext","payload","getPublicRootInstance","containerFiber","child","attemptSynchronousHydration","lanes","retryLane","markRetryLaneIfNotHydrated","markRetryLaneImpl","suspenseState","memoizedState","dehydrated","alternate","attemptDiscreteHydration","attemptContinuousHydration","attemptHydrationAtCurrentPriority","findHostInstanceWithNoPortals","shouldErrorImpl","shouldError","shouldSuspendImpl","shouldSuspend","overrideHookState","overrideHookStateDeletePath","overrideHookStateRenamePath","overrideProps","overridePropsDeletePath","overridePropsRenamePath","scheduleUpdate","setErrorHandler","setSuspenseHandler","copyWithDeleteImpl","obj","path","index","key","updated","slice","length","splice","copyWithDelete","copyWithRenameImpl","oldPath","newPath","oldKey","newKey","copyWithRename","warn","i","copyWithSetImpl","value","copyWithSet","findHook","id","currentHook","next","hook","newState","baseState","memoizedProps","pendingProps","newShouldErrorImpl","newShouldSuspendImpl","findHostInstanceByFiber","emptyFindFiberByHostInstance","instance","getCurrentFiberForDevTools","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","ReactCurrentDispatcher","bundleType","version","rendererPackageName","rendererConfig","currentDispatcherRef","getCurrentFiber","reconcilerVersion"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  Fiber,\n  FiberRoot,\n  SuspenseHydrationCallbacks,\n  TransitionTracingCallbacks,\n} from './ReactInternalTypes';\nimport type {RootTag} from './ReactRootTags';\nimport type {\n  Instance,\n  TextInstance,\n  Container,\n  PublicInstance,\n  RendererInspectionConfig,\n} from './ReactFiberHostConfig';\nimport type {ReactNodeList} from 'shared/ReactTypes';\nimport type {Lane} from './ReactFiberLane';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\n\nimport {\n  findCurrentHostFiber,\n  findCurrentHostFiberWithNoPortals,\n} from './ReactFiberTreeReflection';\nimport {get as getInstance} from 'shared/ReactInstanceMap';\nimport {\n  HostComponent,\n  HostSingleton,\n  ClassComponent,\n  HostRoot,\n  SuspenseComponent,\n} from './ReactWorkTags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport isArray from 'shared/isArray';\nimport {enableSchedulingProfiler} from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {getPublicInstance} from './ReactFiberHostConfig';\nimport {\n  findCurrentUnmaskedContext,\n  processChildContext,\n  emptyContextObject,\n  isContextProvider as isLegacyContextProvider,\n} from './ReactFiberContext';\nimport {createFiberRoot} from './ReactFiberRoot';\nimport {isRootDehydrated} from './ReactFiberShellHydration';\nimport {\n  injectInternals,\n  markRenderScheduled,\n  onScheduleRoot,\n} from './ReactFiberDevToolsHook';\nimport {\n  requestEventTime,\n  requestUpdateLane,\n  scheduleUpdateOnFiber,\n  scheduleInitialHydrationOnRoot,\n  flushRoot,\n  batchedUpdates,\n  flushSync,\n  isAlreadyRendering,\n  flushControlled,\n  deferredUpdates,\n  discreteUpdates,\n  flushPassiveEffects,\n} from './ReactFiberWorkLoop';\nimport {enqueueConcurrentRenderForLane} from './ReactFiberConcurrentUpdates';\nimport {\n  createUpdate,\n  enqueueUpdate,\n  entangleTransitions,\n} from './ReactFiberClassUpdateQueue';\nimport {\n  isRendering as ReactCurrentFiberIsRendering,\n  current as ReactCurrentFiberCurrent,\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\n  setCurrentFiber as setCurrentDebugFiberInDEV,\n} from './ReactCurrentFiber';\nimport {StrictLegacyMode} from './ReactTypeOfMode';\nimport {\n  SyncLane,\n  SelectiveHydrationLane,\n  NoTimestamp,\n  getHighestPriorityPendingLanes,\n  higherPriorityLane,\n} from './ReactFiberLane';\nimport {\n  getCurrentUpdatePriority,\n  runWithPriority,\n} from './ReactEventPriorities';\nimport {\n  scheduleRefresh,\n  scheduleRoot,\n  setRefreshHandler,\n  findHostInstancesForRefresh,\n} from './ReactFiberHotReloading';\nimport ReactVersion from 'shared/ReactVersion';\nexport {registerMutableSourceForHydration} from './ReactMutableSource';\nexport {createPortal} from './ReactPortal';\nexport {\n  createComponentSelector,\n  createHasPseudoClassSelector,\n  createRoleSelector,\n  createTestNameSelector,\n  createTextSelector,\n  getFindAllNodesFailureDescription,\n  findAllNodes,\n  findBoundingRects,\n  focusWithin,\n  observeVisibleRects,\n} from './ReactTestSelectors';\n\ntype OpaqueRoot = FiberRoot;\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\ntype BundleType = 0 | 1;\n\ntype DevToolsConfig = {\n  bundleType: BundleType,\n  version: string,\n  rendererPackageName: string,\n  // Note: this actually *does* depend on Fiber internal fields.\n  // Used by \"inspect clicked DOM element\" in React DevTools.\n  findFiberByHostInstance?: (instance: Instance | TextInstance) => Fiber | null,\n  rendererConfig?: RendererInspectionConfig,\n};\n\nlet didWarnAboutNestedUpdates;\nlet didWarnAboutFindNodeInStrictMode;\n\nif (__DEV__) {\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(\n  parentComponent: ?React$Component<any, any>,\n): Object {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  const fiber = getInstance(parentComponent);\n  const parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    const Component = fiber.type;\n    if (isLegacyContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component: Object): PublicInstance | null {\n  const fiber = getInstance(component);\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      throw new Error('Unable to find node on an unmounted component.');\n    } else {\n      const keys = Object.keys(component).join(',');\n      throw new Error(\n        `Argument appears to not be a ReactComponent. Keys: ${keys}`,\n      );\n    }\n  }\n  const hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(\n  component: Object,\n  methodName: string,\n): PublicInstance | null {\n  if (__DEV__) {\n    const fiber = getInstance(component);\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        throw new Error('Unable to find node on an unmounted component.');\n      } else {\n        const keys = Object.keys(component).join(',');\n        throw new Error(\n          `Argument appears to not be a ReactComponent. Keys: ${keys}`,\n        );\n      }\n    }\n    const hostFiber = findCurrentHostFiber(fiber);\n    if (hostFiber === null) {\n      return null;\n    }\n    if (hostFiber.mode & StrictLegacyMode) {\n      const componentName = getComponentNameFromFiber(fiber) || 'Component';\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n\n        const previousFiber = ReactCurrentFiberCurrent;\n        try {\n          setCurrentDebugFiberInDEV(hostFiber);\n          if (fiber.mode & StrictLegacyMode) {\n            console.error(\n              '%s is deprecated in StrictMode. ' +\n                '%s was passed an instance of %s which is inside StrictMode. ' +\n                'Instead, add a ref directly to the element you want to reference. ' +\n                'Learn more about using refs safely here: ' +\n                'https://reactjs.org/link/strict-mode-find-node',\n              methodName,\n              methodName,\n              componentName,\n            );\n          } else {\n            console.error(\n              '%s is deprecated in StrictMode. ' +\n                '%s was passed an instance of %s which renders StrictMode children. ' +\n                'Instead, add a ref directly to the element you want to reference. ' +\n                'Learn more about using refs safely here: ' +\n                'https://reactjs.org/link/strict-mode-find-node',\n              methodName,\n              methodName,\n              componentName,\n            );\n          }\n        } finally {\n          // Ideally this should reset to previous but this shouldn't be called in\n          // render and there's another warning for that anyway.\n          if (previousFiber) {\n            setCurrentDebugFiberInDEV(previousFiber);\n          } else {\n            resetCurrentDebugFiberInDEV();\n          }\n        }\n      }\n    }\n    return hostFiber.stateNode;\n  }\n  return findHostInstance(component);\n}\n\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  isStrictMode: boolean,\n  concurrentUpdatesByDefaultOverride: null | boolean,\n  identifierPrefix: string,\n  onRecoverableError: (error: mixed) => void,\n  transitionCallbacks: null | TransitionTracingCallbacks,\n): OpaqueRoot {\n  const hydrate = false;\n  const initialChildren = null;\n  return createFiberRoot(\n    containerInfo,\n    tag,\n    hydrate,\n    initialChildren,\n    hydrationCallbacks,\n    isStrictMode,\n    concurrentUpdatesByDefaultOverride,\n    identifierPrefix,\n    onRecoverableError,\n    transitionCallbacks,\n  );\n}\n\nexport function createHydrationContainer(\n  initialChildren: ReactNodeList,\n  // TODO: Remove `callback` when we delete legacy mode.\n  callback: ?Function,\n  containerInfo: Container,\n  tag: RootTag,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  isStrictMode: boolean,\n  concurrentUpdatesByDefaultOverride: null | boolean,\n  identifierPrefix: string,\n  onRecoverableError: (error: mixed) => void,\n  transitionCallbacks: null | TransitionTracingCallbacks,\n): OpaqueRoot {\n  const hydrate = true;\n  const root = createFiberRoot(\n    containerInfo,\n    tag,\n    hydrate,\n    initialChildren,\n    hydrationCallbacks,\n    isStrictMode,\n    concurrentUpdatesByDefaultOverride,\n    identifierPrefix,\n    onRecoverableError,\n    transitionCallbacks,\n  );\n\n  // TODO: Move this to FiberRoot constructor\n  root.context = getContextForSubtree(null);\n\n  // Schedule the initial render. In a hydration root, this is different from\n  // a regular update because the initial render must match was was rendered\n  // on the server.\n  // NOTE: This update intentionally doesn't have a payload. We're only using\n  // the update to schedule work on the root fiber (and, for legacy roots, to\n  // enqueue the callback if one is provided).\n  const current = root.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n  const update = createUpdate(eventTime, lane);\n  update.callback =\n    callback !== undefined && callback !== null ? callback : null;\n  enqueueUpdate(current, update, lane);\n  scheduleInitialHydrationOnRoot(root, lane, eventTime);\n\n  return root;\n}\n\nexport function updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n): Lane {\n  if (__DEV__) {\n    onScheduleRoot(container, element);\n  }\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n\n  if (enableSchedulingProfiler) {\n    markRenderScheduled(lane);\n  }\n\n  const context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  if (__DEV__) {\n    if (\n      ReactCurrentFiberIsRendering &&\n      ReactCurrentFiberCurrent !== null &&\n      !didWarnAboutNestedUpdates\n    ) {\n      didWarnAboutNestedUpdates = true;\n      console.error(\n        'Render methods should be a pure function of props and state; ' +\n          'triggering nested component updates from render is not allowed. ' +\n          'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' +\n          'Check the render method of %s.',\n        getComponentNameFromFiber(ReactCurrentFiberCurrent) || 'Unknown',\n      );\n    }\n  }\n\n  const update = createUpdate(eventTime, lane);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    if (__DEV__) {\n      if (typeof callback !== 'function') {\n        console.error(\n          'render(...): Expected the last optional `callback` argument to be a ' +\n            'function. Instead received: %s.',\n          callback,\n        );\n      }\n    }\n    update.callback = callback;\n  }\n\n  const root = enqueueUpdate(current, update, lane);\n  if (root !== null) {\n    scheduleUpdateOnFiber(root, current, lane, eventTime);\n    entangleTransitions(root, current, lane);\n  }\n\n  return lane;\n}\n\nexport {\n  batchedUpdates,\n  deferredUpdates,\n  discreteUpdates,\n  flushControlled,\n  flushSync,\n  isAlreadyRendering,\n  flushPassiveEffects,\n};\n\nexport function getPublicRootInstance(\n  container: OpaqueRoot,\n): React$Component<any, any> | PublicInstance | null {\n  const containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostSingleton:\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\n\nexport function attemptSynchronousHydration(fiber: Fiber): void {\n  switch (fiber.tag) {\n    case HostRoot: {\n      const root: FiberRoot = fiber.stateNode;\n      if (isRootDehydrated(root)) {\n        // Flush the first scheduled \"update\".\n        const lanes = getHighestPriorityPendingLanes(root);\n        flushRoot(root, lanes);\n      }\n      break;\n    }\n    case SuspenseComponent: {\n      flushSync(() => {\n        const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n        if (root !== null) {\n          const eventTime = requestEventTime();\n          scheduleUpdateOnFiber(root, fiber, SyncLane, eventTime);\n        }\n      });\n      // If we're still blocked after this, we need to increase\n      // the priority of any promises resolving within this\n      // boundary so that they next attempt also has higher pri.\n      const retryLane = SyncLane;\n      markRetryLaneIfNotHydrated(fiber, retryLane);\n      break;\n    }\n  }\n}\n\nfunction markRetryLaneImpl(fiber: Fiber, retryLane: Lane) {\n  const suspenseState: null | SuspenseState = fiber.memoizedState;\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    suspenseState.retryLane = higherPriorityLane(\n      suspenseState.retryLane,\n      retryLane,\n    );\n  }\n}\n\n// Increases the priority of thenables when they resolve within this boundary.\nfunction markRetryLaneIfNotHydrated(fiber: Fiber, retryLane: Lane) {\n  markRetryLaneImpl(fiber, retryLane);\n  const alternate = fiber.alternate;\n  if (alternate) {\n    markRetryLaneImpl(alternate, retryLane);\n  }\n}\n\nexport function attemptDiscreteHydration(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n  const lane = SyncLane;\n  const root = enqueueConcurrentRenderForLane(fiber, lane);\n  if (root !== null) {\n    const eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\n\nexport function attemptContinuousHydration(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n  const lane = SelectiveHydrationLane;\n  const root = enqueueConcurrentRenderForLane(fiber, lane);\n  if (root !== null) {\n    const eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\n\nexport function attemptHydrationAtCurrentPriority(fiber: Fiber): void {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n  const lane = requestUpdateLane(fiber);\n  const root = enqueueConcurrentRenderForLane(fiber, lane);\n  if (root !== null) {\n    const eventTime = requestEventTime();\n    scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n  }\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\n\nexport {getCurrentUpdatePriority, runWithPriority};\n\nexport {findHostInstance};\n\nexport {findHostInstanceWithWarning};\n\nexport function findHostInstanceWithNoPortals(\n  fiber: Fiber,\n): PublicInstance | null {\n  const hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nlet shouldErrorImpl: Fiber => ?boolean = fiber => null;\n\nexport function shouldError(fiber: Fiber): ?boolean {\n  return shouldErrorImpl(fiber);\n}\n\nlet shouldSuspendImpl = fiber => false;\n\nexport function shouldSuspend(fiber: Fiber): boolean {\n  return shouldSuspendImpl(fiber);\n}\n\nlet overrideHookState = null;\nlet overrideHookStateDeletePath = null;\nlet overrideHookStateRenamePath = null;\nlet overrideProps = null;\nlet overridePropsDeletePath = null;\nlet overridePropsRenamePath = null;\nlet scheduleUpdate = null;\nlet setErrorHandler = null;\nlet setSuspenseHandler = null;\n\nif (__DEV__) {\n  const copyWithDeleteImpl = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    index: number,\n  ) => {\n    const key = path[index];\n    const updated = isArray(obj) ? obj.slice() : {...obj};\n    if (index + 1 === path.length) {\n      if (isArray(updated)) {\n        updated.splice(((key: any): number), 1);\n      } else {\n        delete updated[key];\n      }\n      return updated;\n    }\n    // $FlowFixMe number or string is fine here\n    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n    return updated;\n  };\n\n  const copyWithDelete = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n  ): Object | Array<any> => {\n    return copyWithDeleteImpl(obj, path, 0);\n  };\n\n  const copyWithRenameImpl = (\n    obj: Object | Array<any>,\n    oldPath: Array<string | number>,\n    newPath: Array<string | number>,\n    index: number,\n  ) => {\n    const oldKey = oldPath[index];\n    const updated = isArray(obj) ? obj.slice() : {...obj};\n    if (index + 1 === oldPath.length) {\n      const newKey = newPath[index];\n      // $FlowFixMe number or string is fine here\n      updated[newKey] = updated[oldKey];\n      if (isArray(updated)) {\n        updated.splice(((oldKey: any): number), 1);\n      } else {\n        delete updated[oldKey];\n      }\n    } else {\n      // $FlowFixMe number or string is fine here\n      updated[oldKey] = copyWithRenameImpl(\n        // $FlowFixMe number or string is fine here\n        obj[oldKey],\n        oldPath,\n        newPath,\n        index + 1,\n      );\n    }\n    return updated;\n  };\n\n  const copyWithRename = (\n    obj: Object | Array<any>,\n    oldPath: Array<string | number>,\n    newPath: Array<string | number>,\n  ): Object | Array<any> => {\n    if (oldPath.length !== newPath.length) {\n      console.warn('copyWithRename() expects paths of the same length');\n      return;\n    } else {\n      for (let i = 0; i < newPath.length - 1; i++) {\n        if (oldPath[i] !== newPath[i]) {\n          console.warn(\n            'copyWithRename() expects paths to be the same except for the deepest key',\n          );\n          return;\n        }\n      }\n    }\n    return copyWithRenameImpl(obj, oldPath, newPath, 0);\n  };\n\n  const copyWithSetImpl = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    index: number,\n    value: any,\n  ) => {\n    if (index >= path.length) {\n      return value;\n    }\n    const key = path[index];\n    const updated = isArray(obj) ? obj.slice() : {...obj};\n    // $FlowFixMe number or string is fine here\n    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n    return updated;\n  };\n\n  const copyWithSet = (\n    obj: Object | Array<any>,\n    path: Array<string | number>,\n    value: any,\n  ): Object | Array<any> => {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  const findHook = (fiber: Fiber, id: number) => {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    let currentHook = fiber.memoizedState;\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n    return currentHook;\n  };\n\n  // Support DevTools editable values for useState and useReducer.\n  overrideHookState = (\n    fiber: Fiber,\n    id: number,\n    path: Array<string | number>,\n    value: any,\n  ) => {\n    const hook = findHook(fiber, id);\n    if (hook !== null) {\n      const newState = copyWithSet(hook.memoizedState, path, value);\n      hook.memoizedState = newState;\n      hook.baseState = newState;\n\n      // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n      fiber.memoizedProps = {...fiber.memoizedProps};\n\n      const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  };\n  overrideHookStateDeletePath = (\n    fiber: Fiber,\n    id: number,\n    path: Array<string | number>,\n  ) => {\n    const hook = findHook(fiber, id);\n    if (hook !== null) {\n      const newState = copyWithDelete(hook.memoizedState, path);\n      hook.memoizedState = newState;\n      hook.baseState = newState;\n\n      // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n      fiber.memoizedProps = {...fiber.memoizedProps};\n\n      const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  };\n  overrideHookStateRenamePath = (\n    fiber: Fiber,\n    id: number,\n    oldPath: Array<string | number>,\n    newPath: Array<string | number>,\n  ) => {\n    const hook = findHook(fiber, id);\n    if (hook !== null) {\n      const newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n      hook.memoizedState = newState;\n      hook.baseState = newState;\n\n      // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n      fiber.memoizedProps = {...fiber.memoizedProps};\n\n      const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n      if (root !== null) {\n        scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n      }\n    }\n  };\n\n  // Support DevTools props for function components, forwardRef, memo, host components, etc.\n  overrideProps = (fiber: Fiber, path: Array<string | number>, value: any) => {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n    const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n  overridePropsDeletePath = (fiber: Fiber, path: Array<string | number>) => {\n    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n    const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n  overridePropsRenamePath = (\n    fiber: Fiber,\n    oldPath: Array<string | number>,\n    newPath: Array<string | number>,\n  ) => {\n    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n    const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  scheduleUpdate = (fiber: Fiber) => {\n    const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n    if (root !== null) {\n      scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  setErrorHandler = (newShouldErrorImpl: Fiber => ?boolean) => {\n    shouldErrorImpl = newShouldErrorImpl;\n  };\n\n  setSuspenseHandler = (newShouldSuspendImpl: Fiber => boolean) => {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nfunction findHostInstanceByFiber(fiber: Fiber): Instance | TextInstance | null {\n  const hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction emptyFindFiberByHostInstance(\n  instance: Instance | TextInstance,\n): Fiber | null {\n  return null;\n}\n\nfunction getCurrentFiberForDevTools() {\n  return ReactCurrentFiberCurrent;\n}\n\nexport function injectIntoDevTools(devToolsConfig: DevToolsConfig): boolean {\n  const {findFiberByHostInstance} = devToolsConfig;\n  const {ReactCurrentDispatcher} = ReactSharedInternals;\n\n  return injectInternals({\n    bundleType: devToolsConfig.bundleType,\n    version: devToolsConfig.version,\n    rendererPackageName: devToolsConfig.rendererPackageName,\n    rendererConfig: devToolsConfig.rendererConfig,\n    overrideHookState,\n    overrideHookStateDeletePath,\n    overrideHookStateRenamePath,\n    overrideProps,\n    overridePropsDeletePath,\n    overridePropsRenamePath,\n    setErrorHandler,\n    setSuspenseHandler,\n    scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber,\n    findFiberByHostInstance:\n      findFiberByHostInstance || emptyFindFiberByHostInstance,\n    // React Refresh\n    findHostInstancesForRefresh: __DEV__ ? findHostInstancesForRefresh : null,\n    scheduleRefresh: __DEV__ ? scheduleRefresh : null,\n    scheduleRoot: __DEV__ ? scheduleRoot : null,\n    setRefreshHandler: __DEV__ ? setRefreshHandler : null,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber: __DEV__ ? getCurrentFiberForDevTools : null,\n    // Enables DevTools to detect reconciler version rather than renderer version\n    // which may not match for third party renderers.\n    reconcilerVersion: ReactVersion,\n  });\n}\n"]},"metadata":{},"sourceType":"module"}