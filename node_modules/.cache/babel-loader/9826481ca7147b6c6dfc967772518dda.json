{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport { ClassComponent, HostRoot, IncompleteClassComponent, FunctionComponent, ForwardRef, SimpleMemoComponent, SuspenseComponent, OffscreenComponent } from './ReactWorkTags';\nimport { DidCapture, Incomplete, NoFlags, ShouldCapture, LifecycleEffectMask, ForceUpdateForLegacySuspense, ForceClientRender } from './ReactFiberFlags';\nimport { NoMode, ConcurrentMode, DebugTracingMode } from './ReactTypeOfMode';\nimport { enableDebugTracing, enableLazyContextPropagation, enableUpdaterTracking } from 'shared/ReactFeatureFlags';\nimport { createCapturedValueAtFiber } from './ReactCapturedValue';\nimport { enqueueCapturedUpdate, createUpdate, CaptureUpdate, ForceUpdate, enqueueUpdate } from './ReactFiberClassUpdateQueue';\nimport { markFailedErrorBoundaryForHotReloading } from './ReactFiberHotReloading';\nimport { getSuspenseHandler } from './ReactFiberSuspenseContext';\nimport { renderDidError, renderDidSuspendDelayIfPossible, onUncaughtError, markLegacyErrorBoundaryAsFailed, isAlreadyFailedLegacyErrorBoundary, attachPingListener, restorePendingUpdaters } from './ReactFiberWorkLoop';\nimport { propagateParentContextChangesToDeferredTree } from './ReactFiberNewContext';\nimport { logCapturedError } from './ReactFiberErrorLogger';\nimport { logComponentSuspended } from './DebugTracing';\nimport { isDevToolsPresent } from './ReactFiberDevToolsHook';\nimport { SyncLane, NoTimestamp, includesSomeLane, mergeLanes, pickArbitraryLane } from './ReactFiberLane';\nimport { getIsHydrating, markDidThrowWhileHydratingDEV, queueHydrationError } from './ReactFiberHydrationContext';\nimport { ConcurrentRoot } from './ReactRootTags';\n\nfunction createRootErrorUpdate(fiber, errorInfo, lane) {\n  const update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\n\n  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element: null\n  };\n  const error = errorInfo.value;\n\n  update.callback = () => {\n    onUncaughtError(error);\n    logCapturedError(fiber, errorInfo);\n  };\n\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, lane) {\n  const update = createUpdate(NoTimestamp, lane);\n  update.tag = CaptureUpdate;\n  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n\n  if (typeof getDerivedStateFromError === 'function') {\n    const error = errorInfo.value;\n\n    update.payload = () => {\n      return getDerivedStateFromError(error);\n    };\n\n    update.callback = () => {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n    };\n  }\n\n  const inst = fiber.stateNode;\n\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n\n      const error = errorInfo.value;\n      const stack = errorInfo.stack;\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : ''\n      });\n\n      if (__DEV__) {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          if (!includesSomeLane(fiber.lanes, SyncLane)) {\n            console.error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n          }\n        }\n      }\n    };\n  }\n\n  return update;\n}\n\nfunction resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n  if (enableLazyContextPropagation) {\n    const currentSourceFiber = sourceFiber.alternate;\n\n    if (currentSourceFiber !== null) {\n      // Since we never visited the children of the suspended component, we\n      // need to propagate the context change now, to ensure that we visit\n      // them during the retry.\n      //\n      // We don't have to do this for errors because we retry errors without\n      // committing in between. So this is specific to Suspense.\n      propagateParentContextChangesToDeferredTree(currentSourceFiber, sourceFiber, rootRenderLanes);\n    }\n  } // Reset the memoizedState to what it was before we attempted to render it.\n  // A legacy mode Suspense quirk, only relevant to hook components.\n\n\n  const tag = sourceFiber.tag;\n\n  if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n    const currentSource = sourceFiber.alternate;\n\n    if (currentSource) {\n      sourceFiber.updateQueue = currentSource.updateQueue;\n      sourceFiber.memoizedState = currentSource.memoizedState;\n      sourceFiber.lanes = currentSource.lanes;\n    } else {\n      sourceFiber.updateQueue = null;\n      sourceFiber.memoizedState = null;\n    }\n  }\n}\n\nfunction markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n  // This marks a Suspense boundary so that when we're unwinding the stack,\n  // it captures the suspended \"exception\" and does a second (fallback) pass.\n  if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n    // Legacy Mode Suspense\n    //\n    // If the boundary is in legacy mode, we should *not*\n    // suspend the commit. Pretend as if the suspended component rendered\n    // null and keep rendering. When the Suspense boundary completes,\n    // we'll do a second pass to render the fallback.\n    if (suspenseBoundary === returnFiber) {\n      // Special case where we suspended while reconciling the children of\n      // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n      // when a React.lazy component is a direct child of a\n      // Suspense boundary.\n      //\n      // Suspense boundaries are implemented as multiple fibers, but they\n      // are a single conceptual unit. The legacy mode behavior where we\n      // pretend the suspended fiber committed as `null` won't work,\n      // because in this case the \"suspended\" fiber is the inner\n      // Offscreen wrapper.\n      //\n      // Because the contents of the boundary haven't started rendering\n      // yet (i.e. nothing in the tree has partially rendered) we can\n      // switch to the regular, concurrent mode behavior: mark the\n      // boundary with ShouldCapture and enter the unwind phase.\n      suspenseBoundary.flags |= ShouldCapture;\n    } else {\n      suspenseBoundary.flags |= DidCapture;\n      sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\n      // But we shouldn't call any lifecycle methods or callbacks. Remove\n      // all lifecycle effect tags.\n\n      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n\n      if (sourceFiber.tag === ClassComponent) {\n        const currentSourceFiber = sourceFiber.alternate;\n\n        if (currentSourceFiber === null) {\n          // This is a new mount. Change the tag so it's not mistaken for a\n          // completed class component. For example, we should not call\n          // componentWillUnmount if it is deleted.\n          sourceFiber.tag = IncompleteClassComponent;\n        } else {\n          // When we try rendering again, we should not reuse the current fiber,\n          // since it's known to be in an inconsistent state. Use a force update to\n          // prevent a bail out.\n          const update = createUpdate(NoTimestamp, SyncLane);\n          update.tag = ForceUpdate;\n          enqueueUpdate(sourceFiber, update, SyncLane);\n        }\n      } // The source fiber did not complete. Mark it with Sync priority to\n      // indicate that it still has pending work.\n\n\n      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n    }\n\n    return suspenseBoundary;\n  } // Confirmed that the boundary is in a concurrent mode tree. Continue\n  // with the normal suspend path.\n  //\n  // After this we'll use a set of heuristics to determine whether this\n  // render pass will run to completion or restart or \"suspend\" the commit.\n  // The actual logic for this is spread out in different places.\n  //\n  // This first principle is that if we're going to suspend when we complete\n  // a root, then we should also restart if we get an update or ping that\n  // might unsuspend it, and vice versa. The only reason to suspend is\n  // because you think you might want to restart before committing. However,\n  // it doesn't make sense to restart only while in the period we're suspended.\n  //\n  // Restarting too aggressively is also not good because it starves out any\n  // intermediate loading state. So we use heuristics to determine when.\n  // Suspense Heuristics\n  //\n  // If nothing threw a Promise or all the same fallbacks are already showing,\n  // then don't suspend/restart.\n  //\n  // If this is an initial render of a new tree of Suspense boundaries and\n  // those trigger a fallback, then don't suspend/restart. We want to ensure\n  // that we can show the initial loading state as quickly as possible.\n  //\n  // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n  // a fallback, then we should always suspend/restart. Transitions apply\n  // to this case. If none is defined, JND is used instead.\n  //\n  // If we're already showing a fallback and it gets \"retried\", allowing us to show\n  // another level, but there's still an inner boundary that would show a fallback,\n  // then we suspend/restart for 500ms since the last time we showed a fallback\n  // anywhere in the tree. This effectively throttles progressive loading into a\n  // consistent train of commits. This also gives us an opportunity to restart to\n  // get to the completed state slightly earlier.\n  //\n  // If there's ambiguity due to batching it's resolved in preference of:\n  // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n  //\n  // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n  // ensure that new initial loading states can commit as soon as possible.\n\n\n  suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n  // the begin phase to prevent an early bailout.\n\n  suspenseBoundary.lanes = rootRenderLanes;\n  return suspenseBoundary;\n}\n\nfunction throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n  // The source fiber did not complete.\n  sourceFiber.flags |= Incomplete;\n\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      // If we have pending work still, restore the original updaters\n      restorePendingUpdaters(root, rootRenderLanes);\n    }\n  }\n\n  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {\n    // This is a wakeable. The component suspended.\n    const wakeable = value;\n    resetSuspendedComponent(sourceFiber, rootRenderLanes);\n\n    if (__DEV__) {\n      if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n        markDidThrowWhileHydratingDEV();\n      }\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (sourceFiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(sourceFiber) || 'Unknown';\n          logComponentSuspended(name, wakeable);\n        }\n      }\n    } // Schedule the nearest Suspense to re-render the timed out view.\n\n\n    const suspenseBoundary = getSuspenseHandler();\n\n    if (suspenseBoundary !== null) {\n      switch (suspenseBoundary.tag) {\n        case SuspenseComponent:\n          {\n            suspenseBoundary.flags &= ~ForceClientRender;\n            markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Retry listener\n            //\n            // If the fallback does commit, we need to attach a different type of\n            // listener. This one schedules an update on the Suspense boundary to\n            // turn the fallback state off.\n            //\n            // Stash the wakeable on the boundary fiber so we can access it in the\n            // commit phase.\n            //\n            // When the wakeable resolves, we'll attempt to render the boundary\n            // again (\"retry\").\n\n            const wakeables = suspenseBoundary.updateQueue;\n\n            if (wakeables === null) {\n              suspenseBoundary.updateQueue = new Set([wakeable]);\n            } else {\n              wakeables.add(wakeable);\n            }\n\n            break;\n          }\n\n        case OffscreenComponent:\n          {\n            if (suspenseBoundary.mode & ConcurrentMode) {\n              suspenseBoundary.flags |= ShouldCapture;\n              const offscreenQueue = suspenseBoundary.updateQueue;\n\n              if (offscreenQueue === null) {\n                const newOffscreenQueue = {\n                  transitions: null,\n                  markerInstances: null,\n                  wakeables: new Set([wakeable])\n                };\n                suspenseBoundary.updateQueue = newOffscreenQueue;\n              } else {\n                const wakeables = offscreenQueue.wakeables;\n\n                if (wakeables === null) {\n                  offscreenQueue.wakeables = new Set([wakeable]);\n                } else {\n                  wakeables.add(wakeable);\n                }\n              }\n\n              break;\n            }\n          }\n        // eslint-disable-next-line no-fallthrough\n\n        default:\n          {\n            throw new Error(`Unexpected Suspense handler tag (${suspenseBoundary.tag}). This ` + 'is a bug in React.');\n          }\n      } // We only attach ping listeners in concurrent mode. Legacy Suspense always\n      // commits fallbacks synchronously, so there are no pings.\n\n\n      if (suspenseBoundary.mode & ConcurrentMode) {\n        attachPingListener(root, wakeable, rootRenderLanes);\n      }\n\n      return;\n    } else {\n      // No boundary was found. Unless this is a sync update, this is OK.\n      // We can suspend and wait for more data to arrive.\n      if (root.tag === ConcurrentRoot) {\n        // In a concurrent root, suspending without a Suspense boundary is\n        // allowed. It will suspend indefinitely without committing.\n        //\n        // TODO: Should we have different behavior for discrete updates? What\n        // about flushSync? Maybe it should put the tree into an inert state,\n        // and potentially log a warning. Revisit this for a future release.\n        attachPingListener(root, wakeable, rootRenderLanes);\n        renderDidSuspendDelayIfPossible();\n        return;\n      } else {\n        // In a legacy root, suspending without a boundary is always an error.\n        const uncaughtSuspenseError = new Error('A component suspended while responding to synchronous input. This ' + 'will cause the UI to be replaced with a loading indicator. To ' + 'fix, updates that suspend should be wrapped ' + 'with startTransition.');\n        value = uncaughtSuspenseError;\n      }\n    }\n  } else {\n    // This is a regular error, not a Suspense wakeable.\n    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n      markDidThrowWhileHydratingDEV();\n      const suspenseBoundary = getSuspenseHandler(); // If the error was thrown during hydration, we may be able to recover by\n      // discarding the dehydrated content and switching to a client render.\n      // Instead of surfacing the error, find the nearest Suspense boundary\n      // and render it again without hydration.\n\n      if (suspenseBoundary !== null) {\n        if ((suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n          // Set a flag to indicate that we should try rendering the normal\n          // children again, not the fallback.\n          suspenseBoundary.flags |= ForceClientRender;\n        }\n\n        markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n        // still log it so it can be fixed.\n\n        queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));\n        return;\n      }\n    } else {// Otherwise, fall through to the error path.\n    }\n  }\n\n  value = createCapturedValueAtFiber(value, sourceFiber);\n  renderDidError(value); // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n\n  let workInProgress = returnFiber;\n\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot:\n        {\n          const errorInfo = value;\n          workInProgress.flags |= ShouldCapture;\n          const lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n          const update = createRootErrorUpdate(workInProgress, errorInfo, lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n      case ClassComponent:\n        // Capture and retry\n        const errorInfo = value;\n        const ctor = workInProgress.type;\n        const instance = workInProgress.stateNode;\n\n        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n          workInProgress.flags |= ShouldCapture;\n          const lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n\n          const update = createClassErrorUpdate(workInProgress, errorInfo, lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n        break;\n\n      default:\n        break;\n    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n\n\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nexport { throwException, createRootErrorUpdate, createClassErrorUpdate };","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberThrow.js"],"names":["getComponentNameFromFiber","ClassComponent","HostRoot","IncompleteClassComponent","FunctionComponent","ForwardRef","SimpleMemoComponent","SuspenseComponent","OffscreenComponent","DidCapture","Incomplete","NoFlags","ShouldCapture","LifecycleEffectMask","ForceUpdateForLegacySuspense","ForceClientRender","NoMode","ConcurrentMode","DebugTracingMode","enableDebugTracing","enableLazyContextPropagation","enableUpdaterTracking","createCapturedValueAtFiber","enqueueCapturedUpdate","createUpdate","CaptureUpdate","ForceUpdate","enqueueUpdate","markFailedErrorBoundaryForHotReloading","getSuspenseHandler","renderDidError","renderDidSuspendDelayIfPossible","onUncaughtError","markLegacyErrorBoundaryAsFailed","isAlreadyFailedLegacyErrorBoundary","attachPingListener","restorePendingUpdaters","propagateParentContextChangesToDeferredTree","logCapturedError","logComponentSuspended","isDevToolsPresent","SyncLane","NoTimestamp","includesSomeLane","mergeLanes","pickArbitraryLane","getIsHydrating","markDidThrowWhileHydratingDEV","queueHydrationError","ConcurrentRoot","createRootErrorUpdate","fiber","errorInfo","lane","update","tag","payload","element","error","value","callback","createClassErrorUpdate","getDerivedStateFromError","type","__DEV__","inst","stateNode","componentDidCatch","stack","componentStack","lanes","console","resetSuspendedComponent","sourceFiber","rootRenderLanes","currentSourceFiber","alternate","mode","currentSource","updateQueue","memoizedState","markSuspenseBoundaryShouldCapture","suspenseBoundary","returnFiber","root","flags","throwException","then","wakeable","name","wakeables","Set","add","offscreenQueue","newOffscreenQueue","transitions","markerInstances","Error","uncaughtSuspenseError","workInProgress","ctor","instance","return"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Lane, Lanes} from './ReactFiberLane';\nimport type {CapturedValue} from './ReactCapturedValue';\nimport type {Update} from './ReactFiberClassUpdateQueue';\nimport type {Wakeable} from 'shared/ReactTypes';\nimport type {OffscreenQueue} from './ReactFiberOffscreenComponent';\n\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport {\n  ClassComponent,\n  HostRoot,\n  IncompleteClassComponent,\n  FunctionComponent,\n  ForwardRef,\n  SimpleMemoComponent,\n  SuspenseComponent,\n  OffscreenComponent,\n} from './ReactWorkTags';\nimport {\n  DidCapture,\n  Incomplete,\n  NoFlags,\n  ShouldCapture,\n  LifecycleEffectMask,\n  ForceUpdateForLegacySuspense,\n  ForceClientRender,\n} from './ReactFiberFlags';\nimport {NoMode, ConcurrentMode, DebugTracingMode} from './ReactTypeOfMode';\nimport {\n  enableDebugTracing,\n  enableLazyContextPropagation,\n  enableUpdaterTracking,\n} from 'shared/ReactFeatureFlags';\nimport {createCapturedValueAtFiber} from './ReactCapturedValue';\nimport {\n  enqueueCapturedUpdate,\n  createUpdate,\n  CaptureUpdate,\n  ForceUpdate,\n  enqueueUpdate,\n} from './ReactFiberClassUpdateQueue';\nimport {markFailedErrorBoundaryForHotReloading} from './ReactFiberHotReloading';\nimport {getSuspenseHandler} from './ReactFiberSuspenseContext';\nimport {\n  renderDidError,\n  renderDidSuspendDelayIfPossible,\n  onUncaughtError,\n  markLegacyErrorBoundaryAsFailed,\n  isAlreadyFailedLegacyErrorBoundary,\n  attachPingListener,\n  restorePendingUpdaters,\n} from './ReactFiberWorkLoop';\nimport {propagateParentContextChangesToDeferredTree} from './ReactFiberNewContext';\nimport {logCapturedError} from './ReactFiberErrorLogger';\nimport {logComponentSuspended} from './DebugTracing';\nimport {isDevToolsPresent} from './ReactFiberDevToolsHook';\nimport {\n  SyncLane,\n  NoTimestamp,\n  includesSomeLane,\n  mergeLanes,\n  pickArbitraryLane,\n} from './ReactFiberLane';\nimport {\n  getIsHydrating,\n  markDidThrowWhileHydratingDEV,\n  queueHydrationError,\n} from './ReactFiberHydrationContext';\nimport {ConcurrentRoot} from './ReactRootTags';\n\nfunction createRootErrorUpdate(\n  fiber: Fiber,\n  errorInfo: CapturedValue<mixed>,\n  lane: Lane,\n): Update<mixed> {\n  const update = createUpdate(NoTimestamp, lane);\n  // Unmount the root by rendering null.\n  update.tag = CaptureUpdate;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element: null};\n  const error = errorInfo.value;\n  update.callback = () => {\n    onUncaughtError(error);\n    logCapturedError(fiber, errorInfo);\n  };\n  return update;\n}\n\nfunction createClassErrorUpdate(\n  fiber: Fiber,\n  errorInfo: CapturedValue<mixed>,\n  lane: Lane,\n): Update<mixed> {\n  const update = createUpdate(NoTimestamp, lane);\n  update.tag = CaptureUpdate;\n  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n  if (typeof getDerivedStateFromError === 'function') {\n    const error = errorInfo.value;\n    update.payload = () => {\n      return getDerivedStateFromError(error);\n    };\n    update.callback = () => {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n      logCapturedError(fiber, errorInfo);\n    };\n  }\n\n  const inst = fiber.stateNode;\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (__DEV__) {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n      logCapturedError(fiber, errorInfo);\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n      const error = errorInfo.value;\n      const stack = errorInfo.stack;\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : '',\n      });\n      if (__DEV__) {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          if (!includesSomeLane(fiber.lanes, (SyncLane: Lane))) {\n            console.error(\n              '%s: Error boundaries should implement getDerivedStateFromError(). ' +\n                'In that method, return a state update to display an error message or fallback UI.',\n              getComponentNameFromFiber(fiber) || 'Unknown',\n            );\n          }\n        }\n      }\n    };\n  }\n  return update;\n}\n\nfunction resetSuspendedComponent(sourceFiber: Fiber, rootRenderLanes: Lanes) {\n  if (enableLazyContextPropagation) {\n    const currentSourceFiber = sourceFiber.alternate;\n    if (currentSourceFiber !== null) {\n      // Since we never visited the children of the suspended component, we\n      // need to propagate the context change now, to ensure that we visit\n      // them during the retry.\n      //\n      // We don't have to do this for errors because we retry errors without\n      // committing in between. So this is specific to Suspense.\n      propagateParentContextChangesToDeferredTree(\n        currentSourceFiber,\n        sourceFiber,\n        rootRenderLanes,\n      );\n    }\n  }\n\n  // Reset the memoizedState to what it was before we attempted to render it.\n  // A legacy mode Suspense quirk, only relevant to hook components.\n  const tag = sourceFiber.tag;\n  if (\n    (sourceFiber.mode & ConcurrentMode) === NoMode &&\n    (tag === FunctionComponent ||\n      tag === ForwardRef ||\n      tag === SimpleMemoComponent)\n  ) {\n    const currentSource = sourceFiber.alternate;\n    if (currentSource) {\n      sourceFiber.updateQueue = currentSource.updateQueue;\n      sourceFiber.memoizedState = currentSource.memoizedState;\n      sourceFiber.lanes = currentSource.lanes;\n    } else {\n      sourceFiber.updateQueue = null;\n      sourceFiber.memoizedState = null;\n    }\n  }\n}\n\nfunction markSuspenseBoundaryShouldCapture(\n  suspenseBoundary: Fiber,\n  returnFiber: Fiber,\n  sourceFiber: Fiber,\n  root: FiberRoot,\n  rootRenderLanes: Lanes,\n): Fiber | null {\n  // This marks a Suspense boundary so that when we're unwinding the stack,\n  // it captures the suspended \"exception\" and does a second (fallback) pass.\n  if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n    // Legacy Mode Suspense\n    //\n    // If the boundary is in legacy mode, we should *not*\n    // suspend the commit. Pretend as if the suspended component rendered\n    // null and keep rendering. When the Suspense boundary completes,\n    // we'll do a second pass to render the fallback.\n    if (suspenseBoundary === returnFiber) {\n      // Special case where we suspended while reconciling the children of\n      // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n      // when a React.lazy component is a direct child of a\n      // Suspense boundary.\n      //\n      // Suspense boundaries are implemented as multiple fibers, but they\n      // are a single conceptual unit. The legacy mode behavior where we\n      // pretend the suspended fiber committed as `null` won't work,\n      // because in this case the \"suspended\" fiber is the inner\n      // Offscreen wrapper.\n      //\n      // Because the contents of the boundary haven't started rendering\n      // yet (i.e. nothing in the tree has partially rendered) we can\n      // switch to the regular, concurrent mode behavior: mark the\n      // boundary with ShouldCapture and enter the unwind phase.\n      suspenseBoundary.flags |= ShouldCapture;\n    } else {\n      suspenseBoundary.flags |= DidCapture;\n      sourceFiber.flags |= ForceUpdateForLegacySuspense;\n\n      // We're going to commit this fiber even though it didn't complete.\n      // But we shouldn't call any lifecycle methods or callbacks. Remove\n      // all lifecycle effect tags.\n      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n\n      if (sourceFiber.tag === ClassComponent) {\n        const currentSourceFiber = sourceFiber.alternate;\n        if (currentSourceFiber === null) {\n          // This is a new mount. Change the tag so it's not mistaken for a\n          // completed class component. For example, we should not call\n          // componentWillUnmount if it is deleted.\n          sourceFiber.tag = IncompleteClassComponent;\n        } else {\n          // When we try rendering again, we should not reuse the current fiber,\n          // since it's known to be in an inconsistent state. Use a force update to\n          // prevent a bail out.\n          const update = createUpdate(NoTimestamp, SyncLane);\n          update.tag = ForceUpdate;\n          enqueueUpdate(sourceFiber, update, SyncLane);\n        }\n      }\n\n      // The source fiber did not complete. Mark it with Sync priority to\n      // indicate that it still has pending work.\n      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n    }\n    return suspenseBoundary;\n  }\n  // Confirmed that the boundary is in a concurrent mode tree. Continue\n  // with the normal suspend path.\n  //\n  // After this we'll use a set of heuristics to determine whether this\n  // render pass will run to completion or restart or \"suspend\" the commit.\n  // The actual logic for this is spread out in different places.\n  //\n  // This first principle is that if we're going to suspend when we complete\n  // a root, then we should also restart if we get an update or ping that\n  // might unsuspend it, and vice versa. The only reason to suspend is\n  // because you think you might want to restart before committing. However,\n  // it doesn't make sense to restart only while in the period we're suspended.\n  //\n  // Restarting too aggressively is also not good because it starves out any\n  // intermediate loading state. So we use heuristics to determine when.\n\n  // Suspense Heuristics\n  //\n  // If nothing threw a Promise or all the same fallbacks are already showing,\n  // then don't suspend/restart.\n  //\n  // If this is an initial render of a new tree of Suspense boundaries and\n  // those trigger a fallback, then don't suspend/restart. We want to ensure\n  // that we can show the initial loading state as quickly as possible.\n  //\n  // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n  // a fallback, then we should always suspend/restart. Transitions apply\n  // to this case. If none is defined, JND is used instead.\n  //\n  // If we're already showing a fallback and it gets \"retried\", allowing us to show\n  // another level, but there's still an inner boundary that would show a fallback,\n  // then we suspend/restart for 500ms since the last time we showed a fallback\n  // anywhere in the tree. This effectively throttles progressive loading into a\n  // consistent train of commits. This also gives us an opportunity to restart to\n  // get to the completed state slightly earlier.\n  //\n  // If there's ambiguity due to batching it's resolved in preference of:\n  // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n  //\n  // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n  // ensure that new initial loading states can commit as soon as possible.\n  suspenseBoundary.flags |= ShouldCapture;\n  // TODO: I think we can remove this, since we now use `DidCapture` in\n  // the begin phase to prevent an early bailout.\n  suspenseBoundary.lanes = rootRenderLanes;\n  return suspenseBoundary;\n}\n\nfunction throwException(\n  root: FiberRoot,\n  returnFiber: Fiber,\n  sourceFiber: Fiber,\n  value: mixed,\n  rootRenderLanes: Lanes,\n): void {\n  // The source fiber did not complete.\n  sourceFiber.flags |= Incomplete;\n\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      // If we have pending work still, restore the original updaters\n      restorePendingUpdaters(root, rootRenderLanes);\n    }\n  }\n\n  if (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.then === 'function'\n  ) {\n    // This is a wakeable. The component suspended.\n    const wakeable: Wakeable = (value: any);\n    resetSuspendedComponent(sourceFiber, rootRenderLanes);\n\n    if (__DEV__) {\n      if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n        markDidThrowWhileHydratingDEV();\n      }\n    }\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        if (sourceFiber.mode & DebugTracingMode) {\n          const name = getComponentNameFromFiber(sourceFiber) || 'Unknown';\n          logComponentSuspended(name, wakeable);\n        }\n      }\n    }\n\n    // Schedule the nearest Suspense to re-render the timed out view.\n    const suspenseBoundary = getSuspenseHandler();\n    if (suspenseBoundary !== null) {\n      switch (suspenseBoundary.tag) {\n        case SuspenseComponent: {\n          suspenseBoundary.flags &= ~ForceClientRender;\n          markSuspenseBoundaryShouldCapture(\n            suspenseBoundary,\n            returnFiber,\n            sourceFiber,\n            root,\n            rootRenderLanes,\n          );\n          // Retry listener\n          //\n          // If the fallback does commit, we need to attach a different type of\n          // listener. This one schedules an update on the Suspense boundary to\n          // turn the fallback state off.\n          //\n          // Stash the wakeable on the boundary fiber so we can access it in the\n          // commit phase.\n          //\n          // When the wakeable resolves, we'll attempt to render the boundary\n          // again (\"retry\").\n          const wakeables: Set<Wakeable> | null = (suspenseBoundary.updateQueue: any);\n          if (wakeables === null) {\n            suspenseBoundary.updateQueue = new Set([wakeable]);\n          } else {\n            wakeables.add(wakeable);\n          }\n          break;\n        }\n        case OffscreenComponent: {\n          if (suspenseBoundary.mode & ConcurrentMode) {\n            suspenseBoundary.flags |= ShouldCapture;\n            const offscreenQueue: OffscreenQueue | null = (suspenseBoundary.updateQueue: any);\n            if (offscreenQueue === null) {\n              const newOffscreenQueue: OffscreenQueue = {\n                transitions: null,\n                markerInstances: null,\n                wakeables: new Set([wakeable]),\n              };\n              suspenseBoundary.updateQueue = newOffscreenQueue;\n            } else {\n              const wakeables = offscreenQueue.wakeables;\n              if (wakeables === null) {\n                offscreenQueue.wakeables = new Set([wakeable]);\n              } else {\n                wakeables.add(wakeable);\n              }\n            }\n            break;\n          }\n        }\n        // eslint-disable-next-line no-fallthrough\n        default: {\n          throw new Error(\n            `Unexpected Suspense handler tag (${suspenseBoundary.tag}). This ` +\n              'is a bug in React.',\n          );\n        }\n      }\n      // We only attach ping listeners in concurrent mode. Legacy Suspense always\n      // commits fallbacks synchronously, so there are no pings.\n      if (suspenseBoundary.mode & ConcurrentMode) {\n        attachPingListener(root, wakeable, rootRenderLanes);\n      }\n      return;\n    } else {\n      // No boundary was found. Unless this is a sync update, this is OK.\n      // We can suspend and wait for more data to arrive.\n\n      if (root.tag === ConcurrentRoot) {\n        // In a concurrent root, suspending without a Suspense boundary is\n        // allowed. It will suspend indefinitely without committing.\n        //\n        // TODO: Should we have different behavior for discrete updates? What\n        // about flushSync? Maybe it should put the tree into an inert state,\n        // and potentially log a warning. Revisit this for a future release.\n        attachPingListener(root, wakeable, rootRenderLanes);\n        renderDidSuspendDelayIfPossible();\n        return;\n      } else {\n        // In a legacy root, suspending without a boundary is always an error.\n        const uncaughtSuspenseError = new Error(\n          'A component suspended while responding to synchronous input. This ' +\n            'will cause the UI to be replaced with a loading indicator. To ' +\n            'fix, updates that suspend should be wrapped ' +\n            'with startTransition.',\n        );\n        value = uncaughtSuspenseError;\n      }\n    }\n  } else {\n    // This is a regular error, not a Suspense wakeable.\n    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n      markDidThrowWhileHydratingDEV();\n      const suspenseBoundary = getSuspenseHandler();\n      // If the error was thrown during hydration, we may be able to recover by\n      // discarding the dehydrated content and switching to a client render.\n      // Instead of surfacing the error, find the nearest Suspense boundary\n      // and render it again without hydration.\n      if (suspenseBoundary !== null) {\n        if ((suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n          // Set a flag to indicate that we should try rendering the normal\n          // children again, not the fallback.\n          suspenseBoundary.flags |= ForceClientRender;\n        }\n        markSuspenseBoundaryShouldCapture(\n          suspenseBoundary,\n          returnFiber,\n          sourceFiber,\n          root,\n          rootRenderLanes,\n        );\n\n        // Even though the user may not be affected by this error, we should\n        // still log it so it can be fixed.\n        queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));\n        return;\n      }\n    } else {\n      // Otherwise, fall through to the error path.\n    }\n  }\n\n  value = createCapturedValueAtFiber(value, sourceFiber);\n  renderDidError(value);\n\n  // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n  let workInProgress: Fiber = returnFiber;\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot: {\n        const errorInfo = value;\n        workInProgress.flags |= ShouldCapture;\n        const lane = pickArbitraryLane(rootRenderLanes);\n        workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n        const update = createRootErrorUpdate(workInProgress, errorInfo, lane);\n        enqueueCapturedUpdate(workInProgress, update);\n        return;\n      }\n      case ClassComponent:\n        // Capture and retry\n        const errorInfo = value;\n        const ctor = workInProgress.type;\n        const instance = workInProgress.stateNode;\n        if (\n          (workInProgress.flags & DidCapture) === NoFlags &&\n          (typeof ctor.getDerivedStateFromError === 'function' ||\n            (instance !== null &&\n              typeof instance.componentDidCatch === 'function' &&\n              !isAlreadyFailedLegacyErrorBoundary(instance)))\n        ) {\n          workInProgress.flags |= ShouldCapture;\n          const lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n          // Schedule the error boundary to re-render using updated state\n          const update = createClassErrorUpdate(\n            workInProgress,\n            errorInfo,\n            lane,\n          );\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n    // $FlowFixMe[incompatible-type] we bail out when we get a null\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nexport {throwException, createRootErrorUpdate, createClassErrorUpdate};\n"]},"metadata":{},"sourceType":"module"}