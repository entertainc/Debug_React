{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions } from './ReactMutableSource';\nimport { ClassComponent, HostRoot, HostComponent, HostResource, HostSingleton, HostPortal, ContextProvider, SuspenseComponent, SuspenseListComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent, TracingMarkerComponent } from './ReactWorkTags';\nimport { DidCapture, NoFlags, ShouldCapture } from './ReactFiberFlags';\nimport { NoMode, ProfileMode } from './ReactTypeOfMode';\nimport { enableProfilerTimer, enableCache, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { popHostContainer, popHostContext } from './ReactFiberHostContext';\nimport { popSuspenseListContext, popSuspenseHandler } from './ReactFiberSuspenseContext';\nimport { popHiddenContext } from './ReactFiberHiddenContext';\nimport { resetHydrationState } from './ReactFiberHydrationContext';\nimport { isContextProvider as isLegacyContextProvider, popContext as popLegacyContext, popTopLevelContextObject as popTopLevelLegacyContextObject } from './ReactFiberContext';\nimport { popProvider } from './ReactFiberNewContext';\nimport { popCacheProvider } from './ReactFiberCacheComponent';\nimport { transferActualDuration } from './ReactProfilerTimer';\nimport { popTreeContext } from './ReactFiberTreeContext';\nimport { popRootTransition, popTransition } from './ReactFiberTransition';\nimport { popMarkerInstance, popRootMarkerInstance } from './ReactFiberTracingMarkerComponent';\n\nfunction unwindWork(current, workInProgress, renderLanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(workInProgress);\n\n  switch (workInProgress.tag) {\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(workInProgress);\n        }\n\n        const flags = workInProgress.flags;\n\n        if (flags & ShouldCapture) {\n          workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n\n          if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case HostRoot:\n      {\n        const root = workInProgress.stateNode;\n\n        if (enableCache) {\n          const cache = workInProgress.memoizedState.cache;\n          popCacheProvider(workInProgress, cache);\n        }\n\n        if (enableTransitionTracing) {\n          popRootMarkerInstance(workInProgress);\n        }\n\n        popRootTransition(workInProgress, root, renderLanes);\n        popHostContainer(workInProgress);\n        popTopLevelLegacyContextObject(workInProgress);\n        resetMutableSourceWorkInProgressVersions();\n        const flags = workInProgress.flags;\n\n        if ((flags & ShouldCapture) !== NoFlags && (flags & DidCapture) === NoFlags) {\n          // There was an error during render that wasn't captured by a suspense\n          // boundary. Do a second pass on the root to unmount the children.\n          workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        } // We unwound to the root without completing it. Exit.\n\n\n        return null;\n      }\n\n    case HostResource:\n    case HostSingleton:\n    case HostComponent:\n      {\n        // TODO: popHydrationState\n        popHostContext(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseHandler(workInProgress);\n        const suspenseState = workInProgress.memoizedState;\n\n        if (suspenseState !== null && suspenseState.dehydrated !== null) {\n          if (workInProgress.alternate === null) {\n            throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');\n          }\n\n          resetHydrationState();\n        }\n\n        const flags = workInProgress.flags;\n\n        if (flags & ShouldCapture) {\n          workInProgress.flags = flags & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n\n          if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseListContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n        // caught by a nested boundary. If not, it should bubble through.\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n\n    case ContextProvider:\n      const context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      return null;\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        popSuspenseHandler(workInProgress);\n        popHiddenContext(workInProgress);\n        popTransition(workInProgress, current);\n        const flags = workInProgress.flags;\n\n        if (flags & ShouldCapture) {\n          workInProgress.flags = flags & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n\n          if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case CacheComponent:\n      if (enableCache) {\n        const cache = workInProgress.memoizedState.cache;\n        popCacheProvider(workInProgress, cache);\n      }\n\n      return null;\n\n    case TracingMarkerComponent:\n      if (enableTransitionTracing) {\n        if (workInProgress.stateNode !== null) {\n          popMarkerInstance(workInProgress);\n        }\n      }\n\n      return null;\n\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(current, interruptedWork, renderLanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(interruptedWork);\n\n  switch (interruptedWork.tag) {\n    case ClassComponent:\n      {\n        const childContextTypes = interruptedWork.type.childContextTypes;\n\n        if (childContextTypes !== null && childContextTypes !== undefined) {\n          popLegacyContext(interruptedWork);\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n        const root = interruptedWork.stateNode;\n\n        if (enableCache) {\n          const cache = interruptedWork.memoizedState.cache;\n          popCacheProvider(interruptedWork, cache);\n        }\n\n        if (enableTransitionTracing) {\n          popRootMarkerInstance(interruptedWork);\n        }\n\n        popRootTransition(interruptedWork, root, renderLanes);\n        popHostContainer(interruptedWork);\n        popTopLevelLegacyContextObject(interruptedWork);\n        resetMutableSourceWorkInProgressVersions();\n        break;\n      }\n\n    case HostResource:\n    case HostSingleton:\n    case HostComponent:\n      {\n        popHostContext(interruptedWork);\n        break;\n      }\n\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n\n    case SuspenseComponent:\n      popSuspenseHandler(interruptedWork);\n      break;\n\n    case SuspenseListComponent:\n      popSuspenseListContext(interruptedWork);\n      break;\n\n    case ContextProvider:\n      const context = interruptedWork.type._context;\n      popProvider(context, interruptedWork);\n      break;\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popSuspenseHandler(interruptedWork);\n      popHiddenContext(interruptedWork);\n      popTransition(interruptedWork, current);\n      break;\n\n    case CacheComponent:\n      if (enableCache) {\n        const cache = interruptedWork.memoizedState.cache;\n        popCacheProvider(interruptedWork, cache);\n      }\n\n      break;\n\n    case TracingMarkerComponent:\n      if (enableTransitionTracing) {\n        const instance = interruptedWork.stateNode;\n\n        if (instance !== null) {\n          popMarkerInstance(interruptedWork);\n        }\n      }\n\n      break;\n\n    default:\n      break;\n  }\n}\n\nexport { unwindWork, unwindInterruptedWork };","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberUnwindWork.js"],"names":["resetWorkInProgressVersions","resetMutableSourceWorkInProgressVersions","ClassComponent","HostRoot","HostComponent","HostResource","HostSingleton","HostPortal","ContextProvider","SuspenseComponent","SuspenseListComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","TracingMarkerComponent","DidCapture","NoFlags","ShouldCapture","NoMode","ProfileMode","enableProfilerTimer","enableCache","enableTransitionTracing","popHostContainer","popHostContext","popSuspenseListContext","popSuspenseHandler","popHiddenContext","resetHydrationState","isContextProvider","isLegacyContextProvider","popContext","popLegacyContext","popTopLevelContextObject","popTopLevelLegacyContextObject","popProvider","popCacheProvider","transferActualDuration","popTreeContext","popRootTransition","popTransition","popMarkerInstance","popRootMarkerInstance","unwindWork","current","workInProgress","renderLanes","tag","Component","type","flags","mode","root","stateNode","cache","memoizedState","suspenseState","dehydrated","alternate","Error","context","_context","unwindInterruptedWork","interruptedWork","childContextTypes","undefined","instance"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactContext} from 'shared/ReactTypes';\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Lanes} from './ReactFiberLane';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\nimport type {Cache} from './ReactFiberCacheComponent';\nimport type {TracingMarkerInstance} from './ReactFiberTracingMarkerComponent';\n\nimport {resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions} from './ReactMutableSource';\nimport {\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostResource,\n  HostSingleton,\n  HostPortal,\n  ContextProvider,\n  SuspenseComponent,\n  SuspenseListComponent,\n  OffscreenComponent,\n  LegacyHiddenComponent,\n  CacheComponent,\n  TracingMarkerComponent,\n} from './ReactWorkTags';\nimport {DidCapture, NoFlags, ShouldCapture} from './ReactFiberFlags';\nimport {NoMode, ProfileMode} from './ReactTypeOfMode';\nimport {\n  enableProfilerTimer,\n  enableCache,\n  enableTransitionTracing,\n} from 'shared/ReactFeatureFlags';\n\nimport {popHostContainer, popHostContext} from './ReactFiberHostContext';\nimport {\n  popSuspenseListContext,\n  popSuspenseHandler,\n} from './ReactFiberSuspenseContext';\nimport {popHiddenContext} from './ReactFiberHiddenContext';\nimport {resetHydrationState} from './ReactFiberHydrationContext';\nimport {\n  isContextProvider as isLegacyContextProvider,\n  popContext as popLegacyContext,\n  popTopLevelContextObject as popTopLevelLegacyContextObject,\n} from './ReactFiberContext';\nimport {popProvider} from './ReactFiberNewContext';\nimport {popCacheProvider} from './ReactFiberCacheComponent';\nimport {transferActualDuration} from './ReactProfilerTimer';\nimport {popTreeContext} from './ReactFiberTreeContext';\nimport {popRootTransition, popTransition} from './ReactFiberTransition';\nimport {\n  popMarkerInstance,\n  popRootMarkerInstance,\n} from './ReactFiberTracingMarkerComponent';\n\nfunction unwindWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      const flags = workInProgress.flags;\n      if (flags & ShouldCapture) {\n        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;\n        if (\n          enableProfilerTimer &&\n          (workInProgress.mode & ProfileMode) !== NoMode\n        ) {\n          transferActualDuration(workInProgress);\n        }\n        return workInProgress;\n      }\n      return null;\n    }\n    case HostRoot: {\n      const root: FiberRoot = workInProgress.stateNode;\n      if (enableCache) {\n        const cache: Cache = workInProgress.memoizedState.cache;\n        popCacheProvider(workInProgress, cache);\n      }\n\n      if (enableTransitionTracing) {\n        popRootMarkerInstance(workInProgress);\n      }\n\n      popRootTransition(workInProgress, root, renderLanes);\n      popHostContainer(workInProgress);\n      popTopLevelLegacyContextObject(workInProgress);\n      resetMutableSourceWorkInProgressVersions();\n      const flags = workInProgress.flags;\n      if (\n        (flags & ShouldCapture) !== NoFlags &&\n        (flags & DidCapture) === NoFlags\n      ) {\n        // There was an error during render that wasn't captured by a suspense\n        // boundary. Do a second pass on the root to unmount the children.\n        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;\n        return workInProgress;\n      }\n      // We unwound to the root without completing it. Exit.\n      return null;\n    }\n    case HostResource:\n    case HostSingleton:\n    case HostComponent: {\n      // TODO: popHydrationState\n      popHostContext(workInProgress);\n      return null;\n    }\n    case SuspenseComponent: {\n      popSuspenseHandler(workInProgress);\n      const suspenseState: null | SuspenseState = workInProgress.memoizedState;\n      if (suspenseState !== null && suspenseState.dehydrated !== null) {\n        if (workInProgress.alternate === null) {\n          throw new Error(\n            'Threw in newly mounted dehydrated component. This is likely a bug in ' +\n              'React. Please file an issue.',\n          );\n        }\n\n        resetHydrationState();\n      }\n\n      const flags = workInProgress.flags;\n      if (flags & ShouldCapture) {\n        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;\n        // Captured a suspense effect. Re-render the boundary.\n        if (\n          enableProfilerTimer &&\n          (workInProgress.mode & ProfileMode) !== NoMode\n        ) {\n          transferActualDuration(workInProgress);\n        }\n        return workInProgress;\n      }\n      return null;\n    }\n    case SuspenseListComponent: {\n      popSuspenseListContext(workInProgress);\n      // SuspenseList doesn't actually catch anything. It should've been\n      // caught by a nested boundary. If not, it should bubble through.\n      return null;\n    }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      const context: ReactContext<any> = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      return null;\n    case OffscreenComponent:\n    case LegacyHiddenComponent: {\n      popSuspenseHandler(workInProgress);\n      popHiddenContext(workInProgress);\n      popTransition(workInProgress, current);\n      const flags = workInProgress.flags;\n      if (flags & ShouldCapture) {\n        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;\n        // Captured a suspense effect. Re-render the boundary.\n        if (\n          enableProfilerTimer &&\n          (workInProgress.mode & ProfileMode) !== NoMode\n        ) {\n          transferActualDuration(workInProgress);\n        }\n        return workInProgress;\n      }\n      return null;\n    }\n    case CacheComponent:\n      if (enableCache) {\n        const cache: Cache = workInProgress.memoizedState.cache;\n        popCacheProvider(workInProgress, cache);\n      }\n      return null;\n    case TracingMarkerComponent:\n      if (enableTransitionTracing) {\n        if (workInProgress.stateNode !== null) {\n          popMarkerInstance(workInProgress);\n        }\n      }\n      return null;\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(\n  current: Fiber | null,\n  interruptedWork: Fiber,\n  renderLanes: Lanes,\n) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(interruptedWork);\n  switch (interruptedWork.tag) {\n    case ClassComponent: {\n      const childContextTypes = interruptedWork.type.childContextTypes;\n      if (childContextTypes !== null && childContextTypes !== undefined) {\n        popLegacyContext(interruptedWork);\n      }\n      break;\n    }\n    case HostRoot: {\n      const root: FiberRoot = interruptedWork.stateNode;\n      if (enableCache) {\n        const cache: Cache = interruptedWork.memoizedState.cache;\n        popCacheProvider(interruptedWork, cache);\n      }\n\n      if (enableTransitionTracing) {\n        popRootMarkerInstance(interruptedWork);\n      }\n\n      popRootTransition(interruptedWork, root, renderLanes);\n      popHostContainer(interruptedWork);\n      popTopLevelLegacyContextObject(interruptedWork);\n      resetMutableSourceWorkInProgressVersions();\n      break;\n    }\n    case HostResource:\n    case HostSingleton:\n    case HostComponent: {\n      popHostContext(interruptedWork);\n      break;\n    }\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n    case SuspenseComponent:\n      popSuspenseHandler(interruptedWork);\n      break;\n    case SuspenseListComponent:\n      popSuspenseListContext(interruptedWork);\n      break;\n    case ContextProvider:\n      const context: ReactContext<any> = interruptedWork.type._context;\n      popProvider(context, interruptedWork);\n      break;\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popSuspenseHandler(interruptedWork);\n      popHiddenContext(interruptedWork);\n      popTransition(interruptedWork, current);\n      break;\n    case CacheComponent:\n      if (enableCache) {\n        const cache: Cache = interruptedWork.memoizedState.cache;\n        popCacheProvider(interruptedWork, cache);\n      }\n      break;\n    case TracingMarkerComponent:\n      if (enableTransitionTracing) {\n        const instance: TracingMarkerInstance | null =\n          interruptedWork.stateNode;\n        if (instance !== null) {\n          popMarkerInstance(interruptedWork);\n        }\n      }\n      break;\n    default:\n      break;\n  }\n}\n\nexport {unwindWork, unwindInterruptedWork};\n"]},"metadata":{},"sourceType":"module"}