{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactDOMSharedInternals from 'shared/ReactDOMSharedInternals.js';\nconst {\n  Dispatcher\n} = ReactDOMSharedInternals;\nimport { DOCUMENT_NODE } from '../shared/HTMLNodeType';\nimport { warnOnMissingHrefAndRel, validatePreloadResourceDifference, validateURLKeyedUpdatedProps, validateStyleResourceDifference, validateScriptResourceDifference, validateLinkPropsForStyleResource, validateLinkPropsForPreloadResource, validatePreloadArguments, validatePreinitArguments } from '../shared/ReactDOMResourceValidation';\nimport { createElement, setInitialProperties } from './ReactDOMComponent';\nimport { getResourcesFromRoot, markNodeAsResource } from './ReactDOMComponentTree';\nimport { HTML_NAMESPACE, SVG_NAMESPACE } from '../shared/DOMNamespaces';\nimport { getCurrentRootHostContainer } from 'react-reconciler/src/ReactFiberHostContext'; // The resource types we support. currently they match the form for the as argument.\n// In the future this may need to change, especially when modules / scripts are supported\n\n// It is valid to preload even when we aren't actively rendering. For cases where Float functions are\n// called when there is no rendering we track the last used document. It is not safe to insert\n// arbitrary resources into the lastCurrentDocument b/c it may not actually be the document\n// that the resource is meant to apply too (for example stylesheets or scripts). This is only\n// appropriate for resources that don't really have a strict tie to the document itself for example\n// preloads\nlet lastCurrentDocument = null;\nlet previousDispatcher = null;\nexport function prepareToRenderResources(rootContainer) {\n  const rootNode = getRootNode(rootContainer);\n  lastCurrentDocument = getDocumentFromRoot(rootNode);\n  previousDispatcher = Dispatcher.current;\n  Dispatcher.current = ReactDOMClientDispatcher;\n}\nexport function cleanupAfterRenderResources() {\n  Dispatcher.current = previousDispatcher;\n  previousDispatcher = null;\n} // We want this to be the default dispatcher on ReactDOMSharedInternals but we don't want to mutate\n// internals in Module scope. Instead we export it and Internals will import it. There is already a cycle\n// from Internals -> ReactDOM -> FloatClient -> Internals so this doesn't introduce a new one.\n\nexport const ReactDOMClientDispatcher = {\n  preload,\n  preinit\n};\n// global maps of Resources\nconst preloadResources = new Map(); // getRootNode is missing from IE and old jsdom versions\n\nfunction getRootNode(container) {\n  // $FlowFixMe[method-unbinding]\n  return typeof container.getRootNode === 'function' ?\n  /* $FlowFixMe[incompatible-return] Flow types this as returning a `Node`,\n   * but it's either a `Document` or `ShadowRoot`. */\n  container.getRootNode() : container.ownerDocument;\n}\n\nfunction getCurrentResourceRoot() {\n  const currentContainer = getCurrentRootHostContainer(); // $FlowFixMe flow should know currentContainer is a Node and has getRootNode\n\n  return currentContainer ? getRootNode(currentContainer) : null;\n} // This resource type constraint can be loosened. It really is everything except PreloadResource\n// because that is the only one that does not have an optional instance type. Expand as needed.\n\n\nfunction resetInstance(resource) {\n  resource.instance = undefined;\n}\n\nexport function clearRootResources(rootContainer) {\n  const rootNode = getRootNode(rootContainer);\n  const resources = getResourcesFromRoot(rootNode); // We can't actually delete the resource cache because this function is called\n  // during commit after we have rendered. Instead we detatch any instances from\n  // the Resource object if they are going to be cleared\n  // Styles stay put\n  // Scripts get reset\n\n  resources.scripts.forEach(resetInstance); // Head Resources get reset\n\n  resources.head.forEach(resetInstance); // lastStructuredMeta stays put\n} // Preloads are somewhat special. Even if we don't have the Document\n// used by the root that is rendering a component trying to insert a preload\n// we can still seed the file cache by doing the preload on any document we have\n// access to. We prefer the currentDocument if it exists, we also prefer the\n// lastCurrentDocument if that exists. As a fallback we will use the window.document\n// if available.\n\nfunction getDocumentForPreloads() {\n  const root = getCurrentResourceRoot();\n\n  if (root) {\n    return root.ownerDocument || root;\n  } else {\n    try {\n      return lastCurrentDocument || window.document;\n    } catch (error) {\n      return null;\n    }\n  }\n}\n\nfunction getDocumentFromRoot(root) {\n  return root.ownerDocument || root;\n} // --------------------------------------\n//      ReactDOM.Preload\n// --------------------------------------\n\n\nfunction preload(href, options) {\n  if (__DEV__) {\n    validatePreloadArguments(href, options);\n  }\n\n  const ownerDocument = getDocumentForPreloads();\n\n  if (typeof href === 'string' && href && typeof options === 'object' && options !== null && ownerDocument) {\n    const as = options.as;\n    const resource = preloadResources.get(href);\n\n    if (resource) {\n      if (__DEV__) {\n        const originallyImplicit = resource._dev_implicit_construction === true;\n        const latestProps = preloadPropsFromPreloadOptions(href, as, options);\n        validatePreloadResourceDifference(resource.props, originallyImplicit, latestProps, false);\n      }\n    } else {\n      const resourceProps = preloadPropsFromPreloadOptions(href, as, options);\n      createPreloadResource(ownerDocument, href, resourceProps);\n    }\n  }\n}\n\nfunction preloadPropsFromPreloadOptions(href, as, options) {\n  return {\n    href,\n    rel: 'preload',\n    as,\n    crossOrigin: as === 'font' ? '' : options.crossOrigin,\n    integrity: options.integrity\n  };\n} // --------------------------------------\n//      ReactDOM.preinit\n// --------------------------------------\n\n\nfunction preinit(href, options) {\n  if (__DEV__) {\n    validatePreinitArguments(href, options);\n  }\n\n  if (typeof href === 'string' && href && typeof options === 'object' && options !== null) {\n    const resourceRoot = getCurrentResourceRoot();\n    const as = options.as;\n\n    if (!resourceRoot) {\n      // We are going to emit a preload as a best effort fallback since this preinit\n      // was called outside of a render. Given the passive nature of this fallback\n      // we do not warn in dev when props disagree if there happens to already be a\n      // matching preload with this href\n      const preloadDocument = getDocumentForPreloads();\n\n      if (preloadDocument) {\n        const preloadResource = preloadResources.get(href);\n\n        if (!preloadResource) {\n          const preloadProps = preloadPropsFromPreinitOptions(href, as, options);\n          createPreloadResource(preloadDocument, href, preloadProps);\n        }\n      }\n\n      return;\n    }\n\n    switch (as) {\n      case 'style':\n        {\n          const styleResources = getResourcesFromRoot(resourceRoot).styles;\n          const precedence = options.precedence || 'default';\n          let resource = styleResources.get(href);\n\n          if (resource) {\n            if (__DEV__) {\n              const latestProps = stylePropsFromPreinitOptions(href, precedence, options);\n              validateStyleResourceDifference(resource.props, latestProps);\n            }\n          } else {\n            const resourceProps = stylePropsFromPreinitOptions(href, precedence, options);\n            resource = createStyleResource(styleResources, resourceRoot, href, precedence, resourceProps);\n          }\n\n          acquireResource(resource);\n          return;\n        }\n\n      case 'script':\n        {\n          const src = href;\n          const scriptResources = getResourcesFromRoot(resourceRoot).scripts;\n          let resource = scriptResources.get(src);\n\n          if (resource) {\n            if (__DEV__) {\n              const latestProps = scriptPropsFromPreinitOptions(src, options);\n              validateScriptResourceDifference(resource.props, latestProps);\n            }\n          } else {\n            const resourceProps = scriptPropsFromPreinitOptions(src, options);\n            resource = createScriptResource(scriptResources, resourceRoot, src, resourceProps);\n          }\n\n          acquireResource(resource);\n          return;\n        }\n    }\n  }\n}\n\nfunction preloadPropsFromPreinitOptions(href, as, options) {\n  return {\n    href,\n    rel: 'preload',\n    as,\n    crossOrigin: as === 'font' ? '' : options.crossOrigin,\n    integrity: options.integrity\n  };\n}\n\nfunction stylePropsFromPreinitOptions(href, precedence, options) {\n  return {\n    rel: 'stylesheet',\n    href,\n    'data-precedence': precedence,\n    crossOrigin: options.crossOrigin\n  };\n}\n\nfunction scriptPropsFromPreinitOptions(src, options) {\n  return {\n    src,\n    async: true,\n    crossOrigin: options.crossOrigin,\n    integrity: options.integrity\n  };\n} // --------------------------------------\n//      Resources from render\n// --------------------------------------\n\n\nfunction getTitleKey(child) {\n  return 'title:' + child;\n} // This function is called in begin work and we should always have a currentDocument set\n\n\nexport function getResource(type, pendingProps, currentProps) {\n  const resourceRoot = getCurrentResourceRoot();\n\n  if (!resourceRoot) {\n    throw new Error('\"resourceRoot\" was expected to exist. This is a bug in React.');\n  }\n\n  switch (type) {\n    case 'base':\n      {\n        const headRoot = getDocumentFromRoot(resourceRoot);\n        const headResources = getResourcesFromRoot(headRoot).head;\n        const {\n          target,\n          href\n        } = pendingProps;\n        let matcher = 'base';\n        matcher += typeof href === 'string' ? `[href=\"${escapeSelectorAttributeValueInsideDoubleQuotes(href)}\"]` : ':not([href])';\n        matcher += typeof target === 'string' ? `[target=\"${escapeSelectorAttributeValueInsideDoubleQuotes(target)}\"]` : ':not([target])';\n        let resource = headResources.get(matcher);\n\n        if (!resource) {\n          resource = {\n            type: 'base',\n            matcher,\n            props: Object.assign({}, pendingProps),\n            count: 0,\n            instance: null,\n            root: headRoot\n          };\n          headResources.set(matcher, resource);\n        }\n\n        return resource;\n      }\n\n    case 'meta':\n      {\n        let matcher, propertyString, parentResource;\n        const {\n          charSet,\n          content,\n          httpEquiv,\n          name,\n          itemProp,\n          property\n        } = pendingProps;\n        const headRoot = getDocumentFromRoot(resourceRoot);\n        const {\n          head: headResources,\n          lastStructuredMeta\n        } = getResourcesFromRoot(headRoot);\n\n        if (typeof charSet === 'string') {\n          matcher = 'meta[charset]';\n        } else if (typeof content === 'string') {\n          if (typeof httpEquiv === 'string') {\n            matcher = `meta[http-equiv=\"${escapeSelectorAttributeValueInsideDoubleQuotes(httpEquiv)}\"][content=\"${escapeSelectorAttributeValueInsideDoubleQuotes(content)}\"]`;\n          } else if (typeof property === 'string') {\n            propertyString = property;\n            matcher = `meta[property=\"${escapeSelectorAttributeValueInsideDoubleQuotes(property)}\"][content=\"${escapeSelectorAttributeValueInsideDoubleQuotes(content)}\"]`;\n            const parentPropertyPath = property.split(':').slice(0, -1).join(':');\n            parentResource = lastStructuredMeta.get(parentPropertyPath);\n\n            if (parentResource) {\n              // When using parentResource the matcher is not functional for locating\n              // the instance in the DOM but it still serves as a unique key.\n              matcher = parentResource.matcher + matcher;\n            }\n          } else if (typeof name === 'string') {\n            matcher = `meta[name=\"${escapeSelectorAttributeValueInsideDoubleQuotes(name)}\"][content=\"${escapeSelectorAttributeValueInsideDoubleQuotes(content)}\"]`;\n          } else if (typeof itemProp === 'string') {\n            matcher = `meta[itemprop=\"${escapeSelectorAttributeValueInsideDoubleQuotes(itemProp)}\"][content=\"${escapeSelectorAttributeValueInsideDoubleQuotes(content)}\"]`;\n          }\n        }\n\n        if (matcher) {\n          let resource = headResources.get(matcher);\n\n          if (!resource) {\n            resource = {\n              type: 'meta',\n              matcher,\n              property: propertyString,\n              parentResource,\n              props: Object.assign({}, pendingProps),\n              count: 0,\n              instance: null,\n              root: headRoot\n            };\n            headResources.set(matcher, resource);\n          }\n\n          if (typeof resource.property === 'string') {\n            // We cast because flow doesn't know that this resource must be a Meta resource\n            lastStructuredMeta.set(resource.property, resource);\n          }\n\n          return resource;\n        }\n\n        return null;\n      }\n\n    case 'title':\n      {\n        const children = pendingProps.children;\n        let child;\n\n        if (Array.isArray(children)) {\n          child = children.length === 1 ? children[0] : null;\n        } else {\n          child = children;\n        }\n\n        if (typeof child !== 'function' && typeof child !== 'symbol' && child !== null && child !== undefined) {\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          const childString = '' + child;\n          const headRoot = getDocumentFromRoot(resourceRoot);\n          const headResources = getResourcesFromRoot(headRoot).head;\n          const key = getTitleKey(childString);\n          let resource = headResources.get(key);\n\n          if (!resource) {\n            const titleProps = titlePropsFromRawProps(childString, pendingProps);\n            resource = {\n              type: 'title',\n              props: titleProps,\n              count: 0,\n              instance: null,\n              root: headRoot\n            };\n            headResources.set(key, resource);\n          }\n\n          return resource;\n        }\n\n        return null;\n      }\n\n    case 'link':\n      {\n        const {\n          rel\n        } = pendingProps;\n\n        switch (rel) {\n          case 'stylesheet':\n            {\n              const styleResources = getResourcesFromRoot(resourceRoot).styles;\n              let didWarn;\n\n              if (__DEV__) {\n                if (currentProps) {\n                  didWarn = validateURLKeyedUpdatedProps(pendingProps, currentProps, 'style', 'href');\n                }\n\n                if (!didWarn) {\n                  didWarn = validateLinkPropsForStyleResource(pendingProps);\n                }\n              }\n\n              const {\n                precedence,\n                href\n              } = pendingProps;\n\n              if (typeof href === 'string' && typeof precedence === 'string') {\n                // We've asserted all the specific types for StyleQualifyingProps\n                const styleRawProps = pendingProps; // We construct or get an existing resource for the style itself and return it\n\n                let resource = styleResources.get(href);\n\n                if (resource) {\n                  if (__DEV__) {\n                    if (!didWarn) {\n                      const latestProps = stylePropsFromRawProps(styleRawProps);\n\n                      if (resource._dev_preload_props) {\n                        adoptPreloadPropsForStyle(latestProps, resource._dev_preload_props);\n                      }\n\n                      validateStyleResourceDifference(resource.props, latestProps);\n                    }\n                  }\n                } else {\n                  const resourceProps = stylePropsFromRawProps(styleRawProps);\n                  resource = createStyleResource(styleResources, resourceRoot, href, precedence, resourceProps);\n                  immediatelyPreloadStyleResource(resource);\n                }\n\n                return resource;\n              }\n\n              return null;\n            }\n\n          case 'preload':\n            {\n              if (__DEV__) {\n                validateLinkPropsForPreloadResource(pendingProps);\n              }\n\n              const {\n                href\n              } = pendingProps;\n\n              if (typeof href === 'string') {\n                // We've asserted all the specific types for PreloadQualifyingProps\n                const preloadRawProps = pendingProps;\n                let resource = preloadResources.get(href);\n\n                if (resource) {\n                  if (__DEV__) {\n                    const originallyImplicit = resource._dev_implicit_construction === true;\n                    const latestProps = preloadPropsFromRawProps(preloadRawProps);\n                    validatePreloadResourceDifference(resource.props, originallyImplicit, latestProps, false);\n                  }\n                } else {\n                  const resourceProps = preloadPropsFromRawProps(preloadRawProps);\n                  resource = createPreloadResource(getDocumentFromRoot(resourceRoot), href, resourceProps);\n                }\n\n                return resource;\n              }\n\n              return null;\n            }\n\n          default:\n            {\n              const {\n                href,\n                sizes,\n                media\n              } = pendingProps;\n\n              if (typeof rel === 'string' && typeof href === 'string') {\n                const sizeKey = '::sizes:' + (typeof sizes === 'string' ? sizes : '');\n                const mediaKey = '::media:' + (typeof media === 'string' ? media : '');\n                const key = 'rel:' + rel + '::href:' + href + sizeKey + mediaKey;\n                const headRoot = getDocumentFromRoot(resourceRoot);\n                const headResources = getResourcesFromRoot(headRoot).head;\n                let resource = headResources.get(key);\n\n                if (!resource) {\n                  resource = {\n                    type: 'link',\n                    props: Object.assign({}, pendingProps),\n                    count: 0,\n                    instance: null,\n                    root: headRoot\n                  };\n                  headResources.set(key, resource);\n                }\n\n                return resource;\n              }\n\n              if (__DEV__) {\n                warnOnMissingHrefAndRel(pendingProps, currentProps);\n              }\n\n              return null;\n            }\n        }\n      }\n\n    case 'script':\n      {\n        const scriptResources = getResourcesFromRoot(resourceRoot).scripts;\n        let didWarn;\n\n        if (__DEV__) {\n          if (currentProps) {\n            didWarn = validateURLKeyedUpdatedProps(pendingProps, currentProps, 'script', 'src');\n          }\n        }\n\n        const {\n          src,\n          async\n        } = pendingProps;\n\n        if (async && typeof src === 'string') {\n          const scriptRawProps = pendingProps;\n          let resource = scriptResources.get(src);\n\n          if (resource) {\n            if (__DEV__) {\n              if (!didWarn) {\n                const latestProps = scriptPropsFromRawProps(scriptRawProps);\n\n                if (resource._dev_preload_props) {\n                  adoptPreloadPropsForScript(latestProps, resource._dev_preload_props);\n                }\n\n                validateScriptResourceDifference(resource.props, latestProps);\n              }\n            }\n          } else {\n            const resourceProps = scriptPropsFromRawProps(scriptRawProps);\n            resource = createScriptResource(scriptResources, resourceRoot, src, resourceProps);\n          }\n\n          return resource;\n        }\n\n        return null;\n      }\n\n    default:\n      {\n        throw new Error(`getResource encountered a resource type it did not expect: \"${type}\". this is a bug in React.`);\n      }\n  }\n}\n\nfunction preloadPropsFromRawProps(rawBorrowedProps) {\n  return Object.assign({}, rawBorrowedProps);\n}\n\nfunction titlePropsFromRawProps(child, rawProps) {\n  const props = Object.assign({}, rawProps);\n  props.children = child;\n  return props;\n}\n\nfunction stylePropsFromRawProps(rawProps) {\n  const props = Object.assign({}, rawProps);\n  props['data-precedence'] = rawProps.precedence;\n  props.precedence = null;\n  return props;\n}\n\nfunction scriptPropsFromRawProps(rawProps) {\n  const props = Object.assign({}, rawProps);\n  return props;\n} // --------------------------------------\n//      Resource Reconciliation\n// --------------------------------------\n\n\nexport function acquireResource(resource) {\n  switch (resource.type) {\n    case 'base':\n    case 'title':\n    case 'link':\n    case 'meta':\n      {\n        return acquireHeadResource(resource);\n      }\n\n    case 'style':\n      {\n        return acquireStyleResource(resource);\n      }\n\n    case 'script':\n      {\n        return acquireScriptResource(resource);\n      }\n\n    case 'preload':\n      {\n        return resource.instance;\n      }\n\n    default:\n      {\n        throw new Error(`acquireResource encountered a resource type it did not expect: \"${resource.type}\". this is a bug in React.`);\n      }\n  }\n}\nexport function releaseResource(resource) {\n  switch (resource.type) {\n    case 'link':\n    case 'title':\n    case 'meta':\n      {\n        return releaseHeadResource(resource);\n      }\n\n    case 'style':\n      {\n        resource.count--;\n        return;\n      }\n  }\n}\n\nfunction releaseHeadResource(resource) {\n  if (--resource.count === 0) {\n    // the instance will have existed since we acquired it\n    const instance = resource.instance;\n    const parent = instance.parentNode;\n\n    if (parent) {\n      parent.removeChild(instance);\n    }\n\n    resource.instance = null;\n  }\n}\n\nfunction createResourceInstance(type, props, ownerDocument) {\n  const element = createElement(type, props, ownerDocument, HTML_NAMESPACE);\n  setInitialProperties(element, type, props);\n  markNodeAsResource(element);\n  return element;\n}\n\nfunction createStyleResource(styleResources, root, href, precedence, props) {\n  if (__DEV__) {\n    if (styleResources.has(href)) {\n      console.error('createStyleResource was called when a style Resource matching the same href already exists. This is a bug in React.');\n    }\n  }\n\n  const limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);\n  const existingEl = root.querySelector(`link[rel=\"stylesheet\"][href=\"${limitedEscapedHref}\"]`);\n  const resource = {\n    type: 'style',\n    count: 0,\n    href,\n    precedence,\n    props,\n    hint: null,\n    preloaded: false,\n    loaded: false,\n    error: false,\n    root,\n    instance: null\n  };\n  styleResources.set(href, resource);\n\n  if (existingEl) {\n    // If we have an existing element in the DOM we don't need to preload this resource nor can we\n    // adopt props from any preload that might exist already for this resource. We do need to try\n    // to reify the Resource loading state the best we can.\n    const loadingState = existingEl._p;\n\n    if (loadingState) {\n      switch (loadingState.s) {\n        case 'l':\n          {\n            resource.loaded = true;\n            break;\n          }\n\n        case 'e':\n          {\n            resource.error = true;\n            break;\n          }\n\n        default:\n          {\n            attachLoadListeners(existingEl, resource);\n          }\n      }\n    } else {\n      // This is unfortunately just an assumption. The rationale here is that stylesheets without\n      // a loading state must have been flushed in the shell and would have blocked until loading\n      // or error. we can't know afterwards which happened for all types of stylesheets (cross origin)\n      // for instance) and the techniques for determining if a sheet has loaded that we do have still\n      // fail if the sheet loaded zero rules. At the moment we are going to just opt to assume the\n      // sheet is loaded if it was flushed in the shell\n      resource.loaded = true;\n    }\n  } else {\n    const hint = preloadResources.get(href);\n\n    if (hint) {\n      // $FlowFixMe[incompatible-type]: found when upgrading Flow\n      resource.hint = hint; // If a preload for this style Resource already exists there are certain props we want to adopt\n      // on the style Resource, primarily focussed on making sure the style network pathways utilize\n      // the preload pathways. For instance if you have diffreent crossOrigin attributes for a preload\n      // and a stylesheet the stylesheet will make a new request even if the preload had already loaded\n\n      const preloadProps = hint.props;\n      adoptPreloadPropsForStyle(resource.props, hint.props);\n\n      if (__DEV__) {\n        resource._dev_preload_props = preloadProps;\n      }\n    }\n  }\n\n  return resource;\n}\n\nfunction adoptPreloadPropsForStyle(styleProps, preloadProps) {\n  if (styleProps.crossOrigin == null) styleProps.crossOrigin = preloadProps.crossOrigin;\n  if (styleProps.referrerPolicy == null) styleProps.referrerPolicy = preloadProps.referrerPolicy;\n  if (styleProps.title == null) styleProps.title = preloadProps.title;\n}\n\nfunction immediatelyPreloadStyleResource(resource) {\n  // This function must be called synchronously after creating a styleResource otherwise it may\n  // violate assumptions around the existence of a preload. The reason it is extracted out is we\n  // don't always want to preload a style, in particular when we are going to synchronously insert\n  // that style. We confirm the style resource has no preload already and then construct it. If\n  // we wait and call this later it is possible a preload will already exist for this href\n  if (resource.loaded === false && resource.hint === null) {\n    const {\n      href,\n      props\n    } = resource;\n    const preloadProps = preloadPropsFromStyleProps(props);\n    resource.hint = createPreloadResource(getDocumentFromRoot(resource.root), href, preloadProps);\n  }\n}\n\nfunction preloadPropsFromStyleProps(props) {\n  return {\n    rel: 'preload',\n    as: 'style',\n    href: props.href,\n    crossOrigin: props.crossOrigin,\n    integrity: props.integrity,\n    media: props.media,\n    hrefLang: props.hrefLang,\n    referrerPolicy: props.referrerPolicy\n  };\n}\n\nfunction createScriptResource(scriptResources, root, src, props) {\n  if (__DEV__) {\n    if (scriptResources.has(src)) {\n      console.error('createScriptResource was called when a script Resource matching the same src already exists. This is a bug in React.');\n    }\n  }\n\n  const limitedEscapedSrc = escapeSelectorAttributeValueInsideDoubleQuotes(src);\n  const existingEl = root.querySelector(`script[async][src=\"${limitedEscapedSrc}\"]`);\n  const resource = {\n    type: 'script',\n    src,\n    props,\n    root,\n    instance: existingEl || null\n  };\n  scriptResources.set(src, resource);\n\n  if (!existingEl) {\n    const hint = preloadResources.get(src);\n\n    if (hint) {\n      // If a preload for this style Resource already exists there are certain props we want to adopt\n      // on the style Resource, primarily focussed on making sure the style network pathways utilize\n      // the preload pathways. For instance if you have diffreent crossOrigin attributes for a preload\n      // and a stylesheet the stylesheet will make a new request even if the preload had already loaded\n      const preloadProps = hint.props;\n      adoptPreloadPropsForScript(props, hint.props);\n\n      if (__DEV__) {\n        resource._dev_preload_props = preloadProps;\n      }\n    }\n  } else {\n    markNodeAsResource(existingEl);\n  }\n\n  return resource;\n}\n\nfunction adoptPreloadPropsForScript(scriptProps, preloadProps) {\n  if (scriptProps.crossOrigin == null) scriptProps.crossOrigin = preloadProps.crossOrigin;\n  if (scriptProps.referrerPolicy == null) scriptProps.referrerPolicy = preloadProps.referrerPolicy;\n  if (scriptProps.integrity == null) scriptProps.referrerPolicy = preloadProps.integrity;\n}\n\nfunction createPreloadResource(ownerDocument, href, props) {\n  const limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);\n  let element = ownerDocument.querySelector(`link[rel=\"preload\"][href=\"${limitedEscapedHref}\"]`);\n\n  if (!element) {\n    element = createResourceInstance('link', props, ownerDocument);\n    insertResourceInstanceBefore(ownerDocument, element, null);\n  } else {\n    markNodeAsResource(element);\n  }\n\n  return {\n    type: 'preload',\n    href: href,\n    ownerDocument,\n    props,\n    instance: element\n  };\n}\n\nfunction acquireHeadResource(resource) {\n  resource.count++;\n  let instance = resource.instance;\n\n  if (!instance) {\n    const {\n      props,\n      root,\n      type\n    } = resource;\n\n    switch (type) {\n      case 'title':\n        {\n          const titles = root.querySelectorAll('title');\n\n          for (let i = 0; i < titles.length; i++) {\n            if (titles[i].textContent === props.children) {\n              instance = resource.instance = titles[i];\n              markNodeAsResource(instance);\n              return instance;\n            }\n          }\n\n          instance = resource.instance = createResourceInstance(type, props, root);\n          const firstTitle = titles[0];\n          insertResourceInstanceBefore(root, instance, firstTitle && firstTitle.namespaceURI !== SVG_NAMESPACE ? firstTitle : null);\n          break;\n        }\n\n      case 'meta':\n        {\n          let insertBefore = null;\n          const metaResource = resource;\n          const {\n            matcher,\n            property,\n            parentResource\n          } = metaResource;\n\n          if (parentResource && typeof property === 'string') {\n            // This resoruce is a structured meta type with a parent.\n            // Instead of using the matcher we just traverse forward\n            // siblings of the parent instance until we find a match\n            // or exhaust.\n            const parent = parentResource.instance;\n\n            if (parent) {\n              let node = null;\n              let nextNode = insertBefore = parent.nextSibling;\n\n              while (node = nextNode) {\n                nextNode = node.nextSibling;\n\n                if (node.nodeName === 'META') {\n                  const meta = node;\n                  const propertyAttr = meta.getAttribute('property');\n\n                  if (typeof propertyAttr !== 'string') {\n                    continue;\n                  } else if (propertyAttr === property && meta.getAttribute('content') === props.content) {\n                    resource.instance = meta;\n                    markNodeAsResource(meta);\n                    return meta;\n                  } else if (property.startsWith(propertyAttr + ':')) {\n                    // This meta starts a new instance of a parent structure for this meta type\n                    // We need to halt our search here because even if we find a later match it\n                    // is for a different parent element\n                    break;\n                  }\n                }\n              }\n            }\n          } else if (instance = root.querySelector(matcher)) {\n            resource.instance = instance;\n            markNodeAsResource(instance);\n            return instance;\n          }\n\n          instance = resource.instance = createResourceInstance(type, props, root);\n          insertResourceInstanceBefore(root, instance, insertBefore);\n          break;\n        }\n\n      case 'link':\n        {\n          const linkProps = props;\n          const limitedEscapedRel = escapeSelectorAttributeValueInsideDoubleQuotes(linkProps.rel);\n          const limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(linkProps.href);\n          let selector = `link[rel=\"${limitedEscapedRel}\"][href=\"${limitedEscapedHref}\"]`;\n\n          if (typeof linkProps.sizes === 'string') {\n            const limitedEscapedSizes = escapeSelectorAttributeValueInsideDoubleQuotes(linkProps.sizes);\n            selector += `[sizes=\"${limitedEscapedSizes}\"]`;\n          }\n\n          if (typeof linkProps.media === 'string') {\n            const limitedEscapedMedia = escapeSelectorAttributeValueInsideDoubleQuotes(linkProps.media);\n            selector += `[media=\"${limitedEscapedMedia}\"]`;\n          }\n\n          const existingEl = root.querySelector(selector);\n\n          if (existingEl) {\n            instance = resource.instance = existingEl;\n            markNodeAsResource(instance);\n            return instance;\n          }\n\n          instance = resource.instance = createResourceInstance(type, props, root);\n          insertResourceInstanceBefore(root, instance, null);\n          return instance;\n        }\n\n      case 'base':\n        {\n          const baseResource = resource;\n          const {\n            matcher\n          } = baseResource;\n          const base = root.querySelector(matcher);\n\n          if (base) {\n            instance = resource.instance = base;\n            markNodeAsResource(instance);\n          } else {\n            instance = resource.instance = createResourceInstance(type, props, root);\n            insertResourceInstanceBefore(root, instance, root.querySelector('base'));\n          }\n\n          return instance;\n        }\n\n      default:\n        {\n          throw new Error(`acquireHeadResource encountered a resource type it did not expect: \"${type}\". This is a bug in React.`);\n        }\n    }\n  }\n\n  return instance;\n}\n\nfunction acquireStyleResource(resource) {\n  let instance = resource.instance;\n\n  if (!instance) {\n    const {\n      props,\n      root,\n      precedence\n    } = resource;\n    const limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(props.href);\n    const existingEl = root.querySelector(`link[rel=\"stylesheet\"][data-precedence][href=\"${limitedEscapedHref}\"]`);\n\n    if (existingEl) {\n      instance = resource.instance = existingEl;\n      markNodeAsResource(instance);\n      resource.preloaded = true;\n      const loadingState = existingEl._p;\n\n      if (loadingState) {\n        // if an existingEl is found there should always be a loadingState because if\n        // the resource was flushed in the head it should have already been found when\n        // the resource was first created. Still defensively we gate this\n        switch (loadingState.s) {\n          case 'l':\n            {\n              resource.loaded = true;\n              resource.error = false;\n              break;\n            }\n\n          case 'e':\n            {\n              resource.error = true;\n              break;\n            }\n\n          default:\n            {\n              attachLoadListeners(existingEl, resource);\n            }\n        }\n      } else {\n        resource.loaded = true;\n      }\n    } else {\n      instance = resource.instance = createResourceInstance('link', resource.props, getDocumentFromRoot(root));\n      attachLoadListeners(instance, resource);\n      insertStyleInstance(instance, precedence, root);\n    }\n  }\n\n  resource.count++;\n  return instance;\n}\n\nfunction acquireScriptResource(resource) {\n  let instance = resource.instance;\n\n  if (!instance) {\n    const {\n      props,\n      root\n    } = resource;\n    const limitedEscapedSrc = escapeSelectorAttributeValueInsideDoubleQuotes(props.src);\n    const existingEl = root.querySelector(`script[async][src=\"${limitedEscapedSrc}\"]`);\n\n    if (existingEl) {\n      instance = resource.instance = existingEl;\n      markNodeAsResource(instance);\n    } else {\n      instance = resource.instance = createResourceInstance('script', resource.props, getDocumentFromRoot(root));\n      insertResourceInstanceBefore(getDocumentFromRoot(root), instance, null);\n    }\n  }\n\n  return instance;\n}\n\nfunction attachLoadListeners(instance, resource) {\n  const listeners = {};\n  listeners.load = onResourceLoad.bind(null, instance, resource, listeners, loadAndErrorEventListenerOptions);\n  listeners.error = onResourceError.bind(null, instance, resource, listeners, loadAndErrorEventListenerOptions);\n  instance.addEventListener('load', listeners.load, loadAndErrorEventListenerOptions);\n  instance.addEventListener('error', listeners.error, loadAndErrorEventListenerOptions);\n}\n\nconst loadAndErrorEventListenerOptions = {\n  passive: true\n};\n\nfunction onResourceLoad(instance, resource, listeners, listenerOptions) {\n  resource.loaded = true;\n  resource.error = false;\n\n  for (const event in listeners) {\n    instance.removeEventListener(event, listeners[event], listenerOptions);\n  }\n}\n\nfunction onResourceError(instance, resource, listeners, listenerOptions) {\n  resource.loaded = false;\n  resource.error = true;\n\n  for (const event in listeners) {\n    instance.removeEventListener(event, listeners[event], listenerOptions);\n  }\n}\n\nfunction insertStyleInstance(instance, precedence, root) {\n  const nodes = root.querySelectorAll('link[rel=\"stylesheet\"][data-precedence]');\n  const last = nodes.length ? nodes[nodes.length - 1] : null;\n  let prior = last;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const nodePrecedence = node.dataset.precedence;\n\n    if (nodePrecedence === precedence) {\n      prior = node;\n    } else if (prior !== last) {\n      break;\n    }\n  }\n\n  if (prior) {\n    // We get the prior from the document so we know it is in the tree.\n    // We also know that links can't be the topmost Node so the parentNode\n    // must exist.\n    prior.parentNode.insertBefore(instance, prior.nextSibling);\n  } else {\n    const parent = root.nodeType === DOCUMENT_NODE ? root.head : root;\n\n    if (parent) {\n      parent.insertBefore(instance, parent.firstChild);\n    } else {\n      throw new Error('While attempting to insert a Resource, React expected the Document to contain' + ' a head element but it was not found.');\n    }\n  }\n}\n\nfunction insertResourceInstanceBefore(ownerDocument, instance, before) {\n  if (__DEV__) {\n    if (instance.tagName === 'LINK' && instance.rel === 'stylesheet') {\n      console.error('insertResourceInstanceBefore was called with a stylesheet. Stylesheets must be' + ' inserted with insertStyleInstance instead. This is a bug in React.');\n    }\n  }\n\n  const parent = before && before.parentNode || ownerDocument.head;\n\n  if (parent) {\n    parent.insertBefore(instance, before);\n  } else {\n    throw new Error('While attempting to insert a Resource, React expected the Document to contain' + ' a head element but it was not found.');\n  }\n} // When passing user input into querySelector(All) the embedded string must not alter\n// the semantics of the query. This escape function is safe to use when we know the\n// provided value is going to be wrapped in double quotes as part of an attribute selector\n// Do not use it anywhere else\n// we escape double quotes and backslashes\n\n\nconst escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\\n\\\"\\\\]/g;\n\nfunction escapeSelectorAttributeValueInsideDoubleQuotes(value) {\n  return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, ch => '\\\\' + ch.charCodeAt(0).toString(16));\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-dom-bindings/src/client/ReactDOMFloatClient.js"],"names":["ReactDOMSharedInternals","Dispatcher","DOCUMENT_NODE","warnOnMissingHrefAndRel","validatePreloadResourceDifference","validateURLKeyedUpdatedProps","validateStyleResourceDifference","validateScriptResourceDifference","validateLinkPropsForStyleResource","validateLinkPropsForPreloadResource","validatePreloadArguments","validatePreinitArguments","createElement","setInitialProperties","getResourcesFromRoot","markNodeAsResource","HTML_NAMESPACE","SVG_NAMESPACE","getCurrentRootHostContainer","lastCurrentDocument","previousDispatcher","prepareToRenderResources","rootContainer","rootNode","getRootNode","getDocumentFromRoot","current","ReactDOMClientDispatcher","cleanupAfterRenderResources","preload","preinit","preloadResources","Map","container","ownerDocument","getCurrentResourceRoot","currentContainer","resetInstance","resource","instance","undefined","clearRootResources","resources","scripts","forEach","head","getDocumentForPreloads","root","window","document","error","href","options","__DEV__","as","get","originallyImplicit","_dev_implicit_construction","latestProps","preloadPropsFromPreloadOptions","props","resourceProps","createPreloadResource","rel","crossOrigin","integrity","resourceRoot","preloadDocument","preloadResource","preloadProps","preloadPropsFromPreinitOptions","styleResources","styles","precedence","stylePropsFromPreinitOptions","createStyleResource","acquireResource","src","scriptResources","scriptPropsFromPreinitOptions","createScriptResource","async","getTitleKey","child","getResource","type","pendingProps","currentProps","Error","headRoot","headResources","target","matcher","escapeSelectorAttributeValueInsideDoubleQuotes","Object","assign","count","set","propertyString","parentResource","charSet","content","httpEquiv","name","itemProp","property","lastStructuredMeta","parentPropertyPath","split","slice","join","children","Array","isArray","length","childString","key","titleProps","titlePropsFromRawProps","didWarn","styleRawProps","stylePropsFromRawProps","_dev_preload_props","adoptPreloadPropsForStyle","immediatelyPreloadStyleResource","preloadRawProps","preloadPropsFromRawProps","sizes","media","sizeKey","mediaKey","scriptRawProps","scriptPropsFromRawProps","adoptPreloadPropsForScript","rawBorrowedProps","rawProps","acquireHeadResource","acquireStyleResource","acquireScriptResource","releaseResource","releaseHeadResource","parent","parentNode","removeChild","createResourceInstance","element","has","console","limitedEscapedHref","existingEl","querySelector","hint","preloaded","loaded","loadingState","_p","s","attachLoadListeners","styleProps","referrerPolicy","title","preloadPropsFromStyleProps","hrefLang","limitedEscapedSrc","scriptProps","insertResourceInstanceBefore","titles","querySelectorAll","i","textContent","firstTitle","namespaceURI","insertBefore","metaResource","node","nextNode","nextSibling","nodeName","meta","propertyAttr","getAttribute","startsWith","linkProps","limitedEscapedRel","selector","limitedEscapedSizes","limitedEscapedMedia","baseResource","base","insertStyleInstance","listeners","load","onResourceLoad","bind","loadAndErrorEventListenerOptions","onResourceError","addEventListener","passive","listenerOptions","event","removeEventListener","nodes","last","prior","nodePrecedence","dataset","nodeType","firstChild","before","tagName","escapeSelectorAttributeValueInsideDoubleQuotesRegex","value","replace","ch","charCodeAt","toString"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Instance, Container} from './ReactDOMHostConfig';\n\nimport ReactDOMSharedInternals from 'shared/ReactDOMSharedInternals.js';\nconst {Dispatcher} = ReactDOMSharedInternals;\nimport {DOCUMENT_NODE} from '../shared/HTMLNodeType';\nimport {\n  warnOnMissingHrefAndRel,\n  validatePreloadResourceDifference,\n  validateURLKeyedUpdatedProps,\n  validateStyleResourceDifference,\n  validateScriptResourceDifference,\n  validateLinkPropsForStyleResource,\n  validateLinkPropsForPreloadResource,\n  validatePreloadArguments,\n  validatePreinitArguments,\n} from '../shared/ReactDOMResourceValidation';\nimport {createElement, setInitialProperties} from './ReactDOMComponent';\nimport {\n  getResourcesFromRoot,\n  markNodeAsResource,\n} from './ReactDOMComponentTree';\nimport {HTML_NAMESPACE, SVG_NAMESPACE} from '../shared/DOMNamespaces';\nimport {getCurrentRootHostContainer} from 'react-reconciler/src/ReactFiberHostContext';\n\n// The resource types we support. currently they match the form for the as argument.\n// In the future this may need to change, especially when modules / scripts are supported\ntype ResourceType = 'style' | 'font' | 'script';\n\ntype PreloadProps = {\n  rel: 'preload',\n  href: string,\n  [string]: mixed,\n};\ntype PreloadResource = {\n  type: 'preload',\n  href: string,\n  ownerDocument: Document,\n  props: PreloadProps,\n  instance: Element,\n};\n\ntype StyleProps = {\n  rel: 'stylesheet',\n  href: string,\n  'data-precedence': string,\n  [string]: mixed,\n};\ntype StyleResource = {\n  type: 'style',\n\n  // Ref count for resource\n  count: number,\n\n  // Resource Descriptors\n  href: string,\n  precedence: string,\n  props: StyleProps,\n\n  // Related Resources\n  hint: ?PreloadResource,\n\n  // Insertion\n  preloaded: boolean,\n  loaded: boolean,\n  error: mixed,\n  instance: ?Element,\n  root: FloatRoot,\n};\ntype ScriptProps = {\n  src: string,\n  [string]: mixed,\n};\ntype ScriptResource = {\n  type: 'script',\n  src: string,\n  props: ScriptProps,\n\n  instance: ?Element,\n  root: FloatRoot,\n};\n\ntype TitleProps = {\n  [string]: mixed,\n};\ntype TitleResource = {\n  type: 'title',\n  props: TitleProps,\n\n  count: number,\n  instance: ?Element,\n  root: Document,\n};\n\ntype MetaProps = {\n  [string]: mixed,\n};\ntype MetaResource = {\n  type: 'meta',\n  matcher: string,\n  property: ?string,\n  parentResource: ?MetaResource,\n  props: MetaProps,\n\n  count: number,\n  instance: ?Element,\n  root: Document,\n};\n\ntype LinkProps = {\n  href: string,\n  rel: string,\n  [string]: mixed,\n};\ntype LinkResource = {\n  type: 'link',\n  props: LinkProps,\n\n  count: number,\n  instance: ?Element,\n  root: Document,\n};\n\ntype BaseResource = {\n  type: 'base',\n  matcher: string,\n  props: Props,\n\n  count: number,\n  instance: ?Element,\n  root: Document,\n};\n\ntype Props = {[string]: mixed};\n\ntype HeadResource = TitleResource | MetaResource | LinkResource | BaseResource;\ntype Resource = StyleResource | ScriptResource | PreloadResource | HeadResource;\n\nexport type RootResources = {\n  styles: Map<string, StyleResource>,\n  scripts: Map<string, ScriptResource>,\n  head: Map<string, HeadResource>,\n  lastStructuredMeta: Map<string, MetaResource>,\n};\n\n// Brief on purpose due to insertion by script when streaming late boundaries\n// s = Status\n// l = loaded\n// e = errored\ntype StyleResourceLoadingState = Promise<mixed> & {s?: 'l' | 'e'};\n\n// It is valid to preload even when we aren't actively rendering. For cases where Float functions are\n// called when there is no rendering we track the last used document. It is not safe to insert\n// arbitrary resources into the lastCurrentDocument b/c it may not actually be the document\n// that the resource is meant to apply too (for example stylesheets or scripts). This is only\n// appropriate for resources that don't really have a strict tie to the document itself for example\n// preloads\nlet lastCurrentDocument: ?Document = null;\n\nlet previousDispatcher = null;\nexport function prepareToRenderResources(rootContainer: Container) {\n  const rootNode = getRootNode(rootContainer);\n  lastCurrentDocument = getDocumentFromRoot(rootNode);\n\n  previousDispatcher = Dispatcher.current;\n  Dispatcher.current = ReactDOMClientDispatcher;\n}\n\nexport function cleanupAfterRenderResources() {\n  Dispatcher.current = previousDispatcher;\n  previousDispatcher = null;\n}\n\n// We want this to be the default dispatcher on ReactDOMSharedInternals but we don't want to mutate\n// internals in Module scope. Instead we export it and Internals will import it. There is already a cycle\n// from Internals -> ReactDOM -> FloatClient -> Internals so this doesn't introduce a new one.\nexport const ReactDOMClientDispatcher = {preload, preinit};\n\nexport type FloatRoot = Document | ShadowRoot;\n\n// global maps of Resources\nconst preloadResources: Map<string, PreloadResource> = new Map();\n\n// getRootNode is missing from IE and old jsdom versions\nfunction getRootNode(container: Container): FloatRoot {\n  // $FlowFixMe[method-unbinding]\n  return typeof container.getRootNode === 'function'\n    ? /* $FlowFixMe[incompatible-return] Flow types this as returning a `Node`,\n       * but it's either a `Document` or `ShadowRoot`. */\n      container.getRootNode()\n    : container.ownerDocument;\n}\n\nfunction getCurrentResourceRoot(): null | FloatRoot {\n  const currentContainer = getCurrentRootHostContainer();\n  // $FlowFixMe flow should know currentContainer is a Node and has getRootNode\n  return currentContainer ? getRootNode(currentContainer) : null;\n}\n\n// This resource type constraint can be loosened. It really is everything except PreloadResource\n// because that is the only one that does not have an optional instance type. Expand as needed.\nfunction resetInstance(resource: ScriptResource | HeadResource) {\n  resource.instance = undefined;\n}\n\nexport function clearRootResources(rootContainer: Container): void {\n  const rootNode = getRootNode(rootContainer);\n  const resources = getResourcesFromRoot(rootNode);\n\n  // We can't actually delete the resource cache because this function is called\n  // during commit after we have rendered. Instead we detatch any instances from\n  // the Resource object if they are going to be cleared\n\n  // Styles stay put\n  // Scripts get reset\n  resources.scripts.forEach(resetInstance);\n  // Head Resources get reset\n  resources.head.forEach(resetInstance);\n  // lastStructuredMeta stays put\n}\n\n// Preloads are somewhat special. Even if we don't have the Document\n// used by the root that is rendering a component trying to insert a preload\n// we can still seed the file cache by doing the preload on any document we have\n// access to. We prefer the currentDocument if it exists, we also prefer the\n// lastCurrentDocument if that exists. As a fallback we will use the window.document\n// if available.\nfunction getDocumentForPreloads(): ?Document {\n  const root = getCurrentResourceRoot();\n  if (root) {\n    return root.ownerDocument || root;\n  } else {\n    try {\n      return lastCurrentDocument || window.document;\n    } catch (error) {\n      return null;\n    }\n  }\n}\n\nfunction getDocumentFromRoot(root: FloatRoot): Document {\n  return root.ownerDocument || root;\n}\n\n// --------------------------------------\n//      ReactDOM.Preload\n// --------------------------------------\ntype PreloadAs = ResourceType;\ntype PreloadOptions = {as: PreloadAs, crossOrigin?: string, integrity?: string};\nfunction preload(href: string, options: PreloadOptions) {\n  if (__DEV__) {\n    validatePreloadArguments(href, options);\n  }\n  const ownerDocument = getDocumentForPreloads();\n  if (\n    typeof href === 'string' &&\n    href &&\n    typeof options === 'object' &&\n    options !== null &&\n    ownerDocument\n  ) {\n    const as = options.as;\n    const resource = preloadResources.get(href);\n    if (resource) {\n      if (__DEV__) {\n        const originallyImplicit =\n          (resource: any)._dev_implicit_construction === true;\n        const latestProps = preloadPropsFromPreloadOptions(href, as, options);\n        validatePreloadResourceDifference(\n          resource.props,\n          originallyImplicit,\n          latestProps,\n          false,\n        );\n      }\n    } else {\n      const resourceProps = preloadPropsFromPreloadOptions(href, as, options);\n      createPreloadResource(ownerDocument, href, resourceProps);\n    }\n  }\n}\n\nfunction preloadPropsFromPreloadOptions(\n  href: string,\n  as: ResourceType,\n  options: PreloadOptions,\n): PreloadProps {\n  return {\n    href,\n    rel: 'preload',\n    as,\n    crossOrigin: as === 'font' ? '' : options.crossOrigin,\n    integrity: options.integrity,\n  };\n}\n\n// --------------------------------------\n//      ReactDOM.preinit\n// --------------------------------------\n\ntype PreinitAs = 'style' | 'script';\ntype PreinitOptions = {\n  as: PreinitAs,\n  precedence?: string,\n  crossOrigin?: string,\n  integrity?: string,\n};\nfunction preinit(href: string, options: PreinitOptions) {\n  if (__DEV__) {\n    validatePreinitArguments(href, options);\n  }\n\n  if (\n    typeof href === 'string' &&\n    href &&\n    typeof options === 'object' &&\n    options !== null\n  ) {\n    const resourceRoot = getCurrentResourceRoot();\n    const as = options.as;\n    if (!resourceRoot) {\n      // We are going to emit a preload as a best effort fallback since this preinit\n      // was called outside of a render. Given the passive nature of this fallback\n      // we do not warn in dev when props disagree if there happens to already be a\n      // matching preload with this href\n      const preloadDocument = getDocumentForPreloads();\n      if (preloadDocument) {\n        const preloadResource = preloadResources.get(href);\n        if (!preloadResource) {\n          const preloadProps = preloadPropsFromPreinitOptions(\n            href,\n            as,\n            options,\n          );\n          createPreloadResource(preloadDocument, href, preloadProps);\n        }\n      }\n      return;\n    }\n\n    switch (as) {\n      case 'style': {\n        const styleResources = getResourcesFromRoot(resourceRoot).styles;\n        const precedence = options.precedence || 'default';\n        let resource = styleResources.get(href);\n        if (resource) {\n          if (__DEV__) {\n            const latestProps = stylePropsFromPreinitOptions(\n              href,\n              precedence,\n              options,\n            );\n            validateStyleResourceDifference(resource.props, latestProps);\n          }\n        } else {\n          const resourceProps = stylePropsFromPreinitOptions(\n            href,\n            precedence,\n            options,\n          );\n          resource = createStyleResource(\n            styleResources,\n            resourceRoot,\n            href,\n            precedence,\n            resourceProps,\n          );\n        }\n        acquireResource(resource);\n        return;\n      }\n      case 'script': {\n        const src = href;\n        const scriptResources = getResourcesFromRoot(resourceRoot).scripts;\n        let resource = scriptResources.get(src);\n        if (resource) {\n          if (__DEV__) {\n            const latestProps = scriptPropsFromPreinitOptions(src, options);\n            validateScriptResourceDifference(resource.props, latestProps);\n          }\n        } else {\n          const resourceProps = scriptPropsFromPreinitOptions(src, options);\n          resource = createScriptResource(\n            scriptResources,\n            resourceRoot,\n            src,\n            resourceProps,\n          );\n        }\n        acquireResource(resource);\n        return;\n      }\n    }\n  }\n}\n\nfunction preloadPropsFromPreinitOptions(\n  href: string,\n  as: ResourceType,\n  options: PreinitOptions,\n): PreloadProps {\n  return {\n    href,\n    rel: 'preload',\n    as,\n    crossOrigin: as === 'font' ? '' : options.crossOrigin,\n    integrity: options.integrity,\n  };\n}\n\nfunction stylePropsFromPreinitOptions(\n  href: string,\n  precedence: string,\n  options: PreinitOptions,\n): StyleProps {\n  return {\n    rel: 'stylesheet',\n    href,\n    'data-precedence': precedence,\n    crossOrigin: options.crossOrigin,\n  };\n}\n\nfunction scriptPropsFromPreinitOptions(\n  src: string,\n  options: PreinitOptions,\n): ScriptProps {\n  return {\n    src,\n    async: true,\n    crossOrigin: options.crossOrigin,\n    integrity: options.integrity,\n  };\n}\n\n// --------------------------------------\n//      Resources from render\n// --------------------------------------\n\ntype StyleQualifyingProps = {\n  rel: 'stylesheet',\n  href: string,\n  precedence: string,\n  [string]: mixed,\n};\ntype PreloadQualifyingProps = {\n  rel: 'preload',\n  href: string,\n  [string]: mixed,\n};\ntype ScriptQualifyingProps = {\n  src: string,\n  async: true,\n  [string]: mixed,\n};\n\nfunction getTitleKey(child: string | number): string {\n  return 'title:' + child;\n}\n\n// This function is called in begin work and we should always have a currentDocument set\nexport function getResource(\n  type: string,\n  pendingProps: Props,\n  currentProps: null | Props,\n): null | Resource {\n  const resourceRoot = getCurrentResourceRoot();\n  if (!resourceRoot) {\n    throw new Error(\n      '\"resourceRoot\" was expected to exist. This is a bug in React.',\n    );\n  }\n  switch (type) {\n    case 'base': {\n      const headRoot: Document = getDocumentFromRoot(resourceRoot);\n      const headResources = getResourcesFromRoot(headRoot).head;\n      const {target, href} = pendingProps;\n      let matcher = 'base';\n      matcher +=\n        typeof href === 'string'\n          ? `[href=\"${escapeSelectorAttributeValueInsideDoubleQuotes(href)}\"]`\n          : ':not([href])';\n      matcher +=\n        typeof target === 'string'\n          ? `[target=\"${escapeSelectorAttributeValueInsideDoubleQuotes(\n              target,\n            )}\"]`\n          : ':not([target])';\n      let resource = headResources.get(matcher);\n      if (!resource) {\n        resource = {\n          type: 'base',\n          matcher,\n          props: Object.assign({}, pendingProps),\n          count: 0,\n          instance: null,\n          root: headRoot,\n        };\n        headResources.set(matcher, resource);\n      }\n      return resource;\n    }\n    case 'meta': {\n      let matcher, propertyString, parentResource;\n      const {\n        charSet,\n        content,\n        httpEquiv,\n        name,\n        itemProp,\n        property,\n      } = pendingProps;\n      const headRoot: Document = getDocumentFromRoot(resourceRoot);\n      const {head: headResources, lastStructuredMeta} = getResourcesFromRoot(\n        headRoot,\n      );\n      if (typeof charSet === 'string') {\n        matcher = 'meta[charset]';\n      } else if (typeof content === 'string') {\n        if (typeof httpEquiv === 'string') {\n          matcher = `meta[http-equiv=\"${escapeSelectorAttributeValueInsideDoubleQuotes(\n            httpEquiv,\n          )}\"][content=\"${escapeSelectorAttributeValueInsideDoubleQuotes(\n            content,\n          )}\"]`;\n        } else if (typeof property === 'string') {\n          propertyString = property;\n          matcher = `meta[property=\"${escapeSelectorAttributeValueInsideDoubleQuotes(\n            property,\n          )}\"][content=\"${escapeSelectorAttributeValueInsideDoubleQuotes(\n            content,\n          )}\"]`;\n\n          const parentPropertyPath = property\n            .split(':')\n            .slice(0, -1)\n            .join(':');\n          parentResource = lastStructuredMeta.get(parentPropertyPath);\n          if (parentResource) {\n            // When using parentResource the matcher is not functional for locating\n            // the instance in the DOM but it still serves as a unique key.\n            matcher = parentResource.matcher + matcher;\n          }\n        } else if (typeof name === 'string') {\n          matcher = `meta[name=\"${escapeSelectorAttributeValueInsideDoubleQuotes(\n            name,\n          )}\"][content=\"${escapeSelectorAttributeValueInsideDoubleQuotes(\n            content,\n          )}\"]`;\n        } else if (typeof itemProp === 'string') {\n          matcher = `meta[itemprop=\"${escapeSelectorAttributeValueInsideDoubleQuotes(\n            itemProp,\n          )}\"][content=\"${escapeSelectorAttributeValueInsideDoubleQuotes(\n            content,\n          )}\"]`;\n        }\n      }\n      if (matcher) {\n        let resource = headResources.get(matcher);\n        if (!resource) {\n          resource = {\n            type: 'meta',\n            matcher,\n            property: propertyString,\n            parentResource,\n            props: Object.assign({}, pendingProps),\n            count: 0,\n            instance: null,\n            root: headRoot,\n          };\n          headResources.set(matcher, resource);\n        }\n        if (typeof resource.property === 'string') {\n          // We cast because flow doesn't know that this resource must be a Meta resource\n          lastStructuredMeta.set(resource.property, (resource: any));\n        }\n        return resource;\n      }\n      return null;\n    }\n    case 'title': {\n      const children = pendingProps.children;\n      let child;\n      if (Array.isArray(children)) {\n        child = children.length === 1 ? children[0] : null;\n      } else {\n        child = children;\n      }\n      if (\n        typeof child !== 'function' &&\n        typeof child !== 'symbol' &&\n        child !== null &&\n        child !== undefined\n      ) {\n        // eslint-disable-next-line react-internal/safe-string-coercion\n        const childString = '' + (child: any);\n        const headRoot: Document = getDocumentFromRoot(resourceRoot);\n        const headResources = getResourcesFromRoot(headRoot).head;\n        const key = getTitleKey(childString);\n        let resource = headResources.get(key);\n        if (!resource) {\n          const titleProps = titlePropsFromRawProps(childString, pendingProps);\n          resource = {\n            type: 'title',\n            props: titleProps,\n            count: 0,\n            instance: null,\n            root: headRoot,\n          };\n          headResources.set(key, resource);\n        }\n        return resource;\n      }\n      return null;\n    }\n    case 'link': {\n      const {rel} = pendingProps;\n      switch (rel) {\n        case 'stylesheet': {\n          const styleResources = getResourcesFromRoot(resourceRoot).styles;\n          let didWarn;\n          if (__DEV__) {\n            if (currentProps) {\n              didWarn = validateURLKeyedUpdatedProps(\n                pendingProps,\n                currentProps,\n                'style',\n                'href',\n              );\n            }\n            if (!didWarn) {\n              didWarn = validateLinkPropsForStyleResource(pendingProps);\n            }\n          }\n          const {precedence, href} = pendingProps;\n          if (typeof href === 'string' && typeof precedence === 'string') {\n            // We've asserted all the specific types for StyleQualifyingProps\n            const styleRawProps: StyleQualifyingProps = (pendingProps: any);\n\n            // We construct or get an existing resource for the style itself and return it\n            let resource = styleResources.get(href);\n            if (resource) {\n              if (__DEV__) {\n                if (!didWarn) {\n                  const latestProps = stylePropsFromRawProps(styleRawProps);\n                  if ((resource: any)._dev_preload_props) {\n                    adoptPreloadPropsForStyle(\n                      latestProps,\n                      (resource: any)._dev_preload_props,\n                    );\n                  }\n                  validateStyleResourceDifference(resource.props, latestProps);\n                }\n              }\n            } else {\n              const resourceProps = stylePropsFromRawProps(styleRawProps);\n              resource = createStyleResource(\n                styleResources,\n                resourceRoot,\n                href,\n                precedence,\n                resourceProps,\n              );\n              immediatelyPreloadStyleResource(resource);\n            }\n            return resource;\n          }\n          return null;\n        }\n        case 'preload': {\n          if (__DEV__) {\n            validateLinkPropsForPreloadResource(pendingProps);\n          }\n          const {href} = pendingProps;\n          if (typeof href === 'string') {\n            // We've asserted all the specific types for PreloadQualifyingProps\n            const preloadRawProps: PreloadQualifyingProps = (pendingProps: any);\n            let resource = preloadResources.get(href);\n            if (resource) {\n              if (__DEV__) {\n                const originallyImplicit =\n                  (resource: any)._dev_implicit_construction === true;\n                const latestProps = preloadPropsFromRawProps(preloadRawProps);\n                validatePreloadResourceDifference(\n                  resource.props,\n                  originallyImplicit,\n                  latestProps,\n                  false,\n                );\n              }\n            } else {\n              const resourceProps = preloadPropsFromRawProps(preloadRawProps);\n              resource = createPreloadResource(\n                getDocumentFromRoot(resourceRoot),\n                href,\n                resourceProps,\n              );\n            }\n            return resource;\n          }\n          return null;\n        }\n        default: {\n          const {href, sizes, media} = pendingProps;\n          if (typeof rel === 'string' && typeof href === 'string') {\n            const sizeKey =\n              '::sizes:' + (typeof sizes === 'string' ? sizes : '');\n            const mediaKey =\n              '::media:' + (typeof media === 'string' ? media : '');\n            const key = 'rel:' + rel + '::href:' + href + sizeKey + mediaKey;\n            const headRoot = getDocumentFromRoot(resourceRoot);\n            const headResources = getResourcesFromRoot(headRoot).head;\n            let resource = headResources.get(key);\n            if (!resource) {\n              resource = {\n                type: 'link',\n                props: Object.assign({}, pendingProps),\n                count: 0,\n                instance: null,\n                root: headRoot,\n              };\n              headResources.set(key, resource);\n            }\n            return resource;\n          }\n          if (__DEV__) {\n            warnOnMissingHrefAndRel(pendingProps, currentProps);\n          }\n          return null;\n        }\n      }\n    }\n    case 'script': {\n      const scriptResources = getResourcesFromRoot(resourceRoot).scripts;\n      let didWarn;\n      if (__DEV__) {\n        if (currentProps) {\n          didWarn = validateURLKeyedUpdatedProps(\n            pendingProps,\n            currentProps,\n            'script',\n            'src',\n          );\n        }\n      }\n      const {src, async} = pendingProps;\n      if (async && typeof src === 'string') {\n        const scriptRawProps: ScriptQualifyingProps = (pendingProps: any);\n        let resource = scriptResources.get(src);\n        if (resource) {\n          if (__DEV__) {\n            if (!didWarn) {\n              const latestProps = scriptPropsFromRawProps(scriptRawProps);\n              if ((resource: any)._dev_preload_props) {\n                adoptPreloadPropsForScript(\n                  latestProps,\n                  (resource: any)._dev_preload_props,\n                );\n              }\n              validateScriptResourceDifference(resource.props, latestProps);\n            }\n          }\n        } else {\n          const resourceProps = scriptPropsFromRawProps(scriptRawProps);\n          resource = createScriptResource(\n            scriptResources,\n            resourceRoot,\n            src,\n            resourceProps,\n          );\n        }\n        return resource;\n      }\n      return null;\n    }\n    default: {\n      throw new Error(\n        `getResource encountered a resource type it did not expect: \"${type}\". this is a bug in React.`,\n      );\n    }\n  }\n}\n\nfunction preloadPropsFromRawProps(\n  rawBorrowedProps: PreloadQualifyingProps,\n): PreloadProps {\n  return Object.assign({}, rawBorrowedProps);\n}\n\nfunction titlePropsFromRawProps(\n  child: string | number,\n  rawProps: Props,\n): TitleProps {\n  const props: TitleProps = Object.assign({}, rawProps);\n  props.children = child;\n  return props;\n}\n\nfunction stylePropsFromRawProps(rawProps: StyleQualifyingProps): StyleProps {\n  const props: StyleProps = Object.assign({}, rawProps);\n  props['data-precedence'] = rawProps.precedence;\n  props.precedence = null;\n\n  return props;\n}\n\nfunction scriptPropsFromRawProps(rawProps: ScriptQualifyingProps): ScriptProps {\n  const props: ScriptProps = Object.assign({}, rawProps);\n  return props;\n}\n\n// --------------------------------------\n//      Resource Reconciliation\n// --------------------------------------\n\nexport function acquireResource(resource: Resource): Instance {\n  switch (resource.type) {\n    case 'base':\n    case 'title':\n    case 'link':\n    case 'meta': {\n      return acquireHeadResource(resource);\n    }\n    case 'style': {\n      return acquireStyleResource(resource);\n    }\n    case 'script': {\n      return acquireScriptResource(resource);\n    }\n    case 'preload': {\n      return resource.instance;\n    }\n    default: {\n      throw new Error(\n        `acquireResource encountered a resource type it did not expect: \"${resource.type}\". this is a bug in React.`,\n      );\n    }\n  }\n}\n\nexport function releaseResource(resource: Resource): void {\n  switch (resource.type) {\n    case 'link':\n    case 'title':\n    case 'meta': {\n      return releaseHeadResource(resource);\n    }\n    case 'style': {\n      resource.count--;\n      return;\n    }\n  }\n}\n\nfunction releaseHeadResource(resource: HeadResource): void {\n  if (--resource.count === 0) {\n    // the instance will have existed since we acquired it\n    const instance: Instance = (resource.instance: any);\n    const parent = instance.parentNode;\n    if (parent) {\n      parent.removeChild(instance);\n    }\n    resource.instance = null;\n  }\n}\n\nfunction createResourceInstance(\n  type: string,\n  props: Object,\n  ownerDocument: Document,\n): Instance {\n  const element = createElement(type, props, ownerDocument, HTML_NAMESPACE);\n  setInitialProperties(element, type, props);\n  markNodeAsResource(element);\n  return element;\n}\n\nfunction createStyleResource(\n  styleResources: Map<string, StyleResource>,\n  root: FloatRoot,\n  href: string,\n  precedence: string,\n  props: StyleProps,\n): StyleResource {\n  if (__DEV__) {\n    if (styleResources.has(href)) {\n      console.error(\n        'createStyleResource was called when a style Resource matching the same href already exists. This is a bug in React.',\n      );\n    }\n  }\n\n  const limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(\n    href,\n  );\n  const existingEl = root.querySelector(\n    `link[rel=\"stylesheet\"][href=\"${limitedEscapedHref}\"]`,\n  );\n  const resource = {\n    type: 'style',\n    count: 0,\n    href,\n    precedence,\n    props,\n    hint: null,\n    preloaded: false,\n    loaded: false,\n    error: false,\n    root,\n    instance: null,\n  };\n  styleResources.set(href, resource);\n\n  if (existingEl) {\n    // If we have an existing element in the DOM we don't need to preload this resource nor can we\n    // adopt props from any preload that might exist already for this resource. We do need to try\n    // to reify the Resource loading state the best we can.\n    const loadingState: ?StyleResourceLoadingState = (existingEl: any)._p;\n    if (loadingState) {\n      switch (loadingState.s) {\n        case 'l': {\n          resource.loaded = true;\n          break;\n        }\n        case 'e': {\n          resource.error = true;\n          break;\n        }\n        default: {\n          attachLoadListeners(existingEl, resource);\n        }\n      }\n    } else {\n      // This is unfortunately just an assumption. The rationale here is that stylesheets without\n      // a loading state must have been flushed in the shell and would have blocked until loading\n      // or error. we can't know afterwards which happened for all types of stylesheets (cross origin)\n      // for instance) and the techniques for determining if a sheet has loaded that we do have still\n      // fail if the sheet loaded zero rules. At the moment we are going to just opt to assume the\n      // sheet is loaded if it was flushed in the shell\n      resource.loaded = true;\n    }\n  } else {\n    const hint = preloadResources.get(href);\n    if (hint) {\n      // $FlowFixMe[incompatible-type]: found when upgrading Flow\n      resource.hint = hint;\n      // If a preload for this style Resource already exists there are certain props we want to adopt\n      // on the style Resource, primarily focussed on making sure the style network pathways utilize\n      // the preload pathways. For instance if you have diffreent crossOrigin attributes for a preload\n      // and a stylesheet the stylesheet will make a new request even if the preload had already loaded\n      const preloadProps = hint.props;\n      adoptPreloadPropsForStyle(resource.props, hint.props);\n      if (__DEV__) {\n        (resource: any)._dev_preload_props = preloadProps;\n      }\n    }\n  }\n\n  return resource;\n}\n\nfunction adoptPreloadPropsForStyle(\n  styleProps: StyleProps,\n  preloadProps: PreloadProps,\n): void {\n  if (styleProps.crossOrigin == null)\n    styleProps.crossOrigin = preloadProps.crossOrigin;\n  if (styleProps.referrerPolicy == null)\n    styleProps.referrerPolicy = preloadProps.referrerPolicy;\n  if (styleProps.title == null) styleProps.title = preloadProps.title;\n}\n\nfunction immediatelyPreloadStyleResource(resource: StyleResource) {\n  // This function must be called synchronously after creating a styleResource otherwise it may\n  // violate assumptions around the existence of a preload. The reason it is extracted out is we\n  // don't always want to preload a style, in particular when we are going to synchronously insert\n  // that style. We confirm the style resource has no preload already and then construct it. If\n  // we wait and call this later it is possible a preload will already exist for this href\n  if (resource.loaded === false && resource.hint === null) {\n    const {href, props} = resource;\n    const preloadProps = preloadPropsFromStyleProps(props);\n    resource.hint = createPreloadResource(\n      getDocumentFromRoot(resource.root),\n      href,\n      preloadProps,\n    );\n  }\n}\n\nfunction preloadPropsFromStyleProps(props: StyleProps): PreloadProps {\n  return {\n    rel: 'preload',\n    as: 'style',\n    href: props.href,\n    crossOrigin: props.crossOrigin,\n    integrity: props.integrity,\n    media: props.media,\n    hrefLang: props.hrefLang,\n    referrerPolicy: props.referrerPolicy,\n  };\n}\n\nfunction createScriptResource(\n  scriptResources: Map<string, ScriptResource>,\n  root: FloatRoot,\n  src: string,\n  props: ScriptProps,\n): ScriptResource {\n  if (__DEV__) {\n    if (scriptResources.has(src)) {\n      console.error(\n        'createScriptResource was called when a script Resource matching the same src already exists. This is a bug in React.',\n      );\n    }\n  }\n\n  const limitedEscapedSrc = escapeSelectorAttributeValueInsideDoubleQuotes(src);\n  const existingEl = root.querySelector(\n    `script[async][src=\"${limitedEscapedSrc}\"]`,\n  );\n  const resource = {\n    type: 'script',\n    src,\n    props,\n    root,\n    instance: existingEl || null,\n  };\n  scriptResources.set(src, resource);\n\n  if (!existingEl) {\n    const hint = preloadResources.get(src);\n    if (hint) {\n      // If a preload for this style Resource already exists there are certain props we want to adopt\n      // on the style Resource, primarily focussed on making sure the style network pathways utilize\n      // the preload pathways. For instance if you have diffreent crossOrigin attributes for a preload\n      // and a stylesheet the stylesheet will make a new request even if the preload had already loaded\n      const preloadProps = hint.props;\n      adoptPreloadPropsForScript(props, hint.props);\n      if (__DEV__) {\n        (resource: any)._dev_preload_props = preloadProps;\n      }\n    }\n  } else {\n    markNodeAsResource(existingEl);\n  }\n\n  return resource;\n}\n\nfunction adoptPreloadPropsForScript(\n  scriptProps: ScriptProps,\n  preloadProps: PreloadProps,\n): void {\n  if (scriptProps.crossOrigin == null)\n    scriptProps.crossOrigin = preloadProps.crossOrigin;\n  if (scriptProps.referrerPolicy == null)\n    scriptProps.referrerPolicy = preloadProps.referrerPolicy;\n  if (scriptProps.integrity == null)\n    scriptProps.referrerPolicy = preloadProps.integrity;\n}\n\nfunction createPreloadResource(\n  ownerDocument: Document,\n  href: string,\n  props: PreloadProps,\n): PreloadResource {\n  const limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(\n    href,\n  );\n  let element: null | Instance | HTMLElement = ownerDocument.querySelector(\n    `link[rel=\"preload\"][href=\"${limitedEscapedHref}\"]`,\n  );\n  if (!element) {\n    element = createResourceInstance('link', props, ownerDocument);\n    insertResourceInstanceBefore(ownerDocument, element, null);\n  } else {\n    markNodeAsResource(element);\n  }\n  return {\n    type: 'preload',\n    href: href,\n    ownerDocument,\n    props,\n    instance: element,\n  };\n}\n\nfunction acquireHeadResource(resource: HeadResource): Instance {\n  resource.count++;\n  let instance = resource.instance;\n  if (!instance) {\n    const {props, root, type} = resource;\n    switch (type) {\n      case 'title': {\n        const titles = root.querySelectorAll('title');\n        for (let i = 0; i < titles.length; i++) {\n          if (titles[i].textContent === props.children) {\n            instance = resource.instance = titles[i];\n            markNodeAsResource(instance);\n            return instance;\n          }\n        }\n        instance = resource.instance = createResourceInstance(\n          type,\n          props,\n          root,\n        );\n        const firstTitle = titles[0];\n        insertResourceInstanceBefore(\n          root,\n          instance,\n          firstTitle && firstTitle.namespaceURI !== SVG_NAMESPACE\n            ? firstTitle\n            : null,\n        );\n        break;\n      }\n      case 'meta': {\n        let insertBefore = null;\n\n        const metaResource: MetaResource = (resource: any);\n        const {matcher, property, parentResource} = metaResource;\n\n        if (parentResource && typeof property === 'string') {\n          // This resoruce is a structured meta type with a parent.\n          // Instead of using the matcher we just traverse forward\n          // siblings of the parent instance until we find a match\n          // or exhaust.\n          const parent = parentResource.instance;\n          if (parent) {\n            let node = null;\n            let nextNode = (insertBefore = parent.nextSibling);\n            while ((node = nextNode)) {\n              nextNode = node.nextSibling;\n              if (node.nodeName === 'META') {\n                const meta: Element = (node: any);\n                const propertyAttr = meta.getAttribute('property');\n                if (typeof propertyAttr !== 'string') {\n                  continue;\n                } else if (\n                  propertyAttr === property &&\n                  meta.getAttribute('content') === props.content\n                ) {\n                  resource.instance = meta;\n                  markNodeAsResource(meta);\n                  return meta;\n                } else if (property.startsWith(propertyAttr + ':')) {\n                  // This meta starts a new instance of a parent structure for this meta type\n                  // We need to halt our search here because even if we find a later match it\n                  // is for a different parent element\n                  break;\n                }\n              }\n            }\n          }\n        } else if ((instance = root.querySelector(matcher))) {\n          resource.instance = instance;\n          markNodeAsResource(instance);\n          return instance;\n        }\n        instance = resource.instance = createResourceInstance(\n          type,\n          props,\n          root,\n        );\n        insertResourceInstanceBefore(root, instance, insertBefore);\n        break;\n      }\n      case 'link': {\n        const linkProps: LinkProps = (props: any);\n        const limitedEscapedRel = escapeSelectorAttributeValueInsideDoubleQuotes(\n          linkProps.rel,\n        );\n        const limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(\n          linkProps.href,\n        );\n        let selector = `link[rel=\"${limitedEscapedRel}\"][href=\"${limitedEscapedHref}\"]`;\n        if (typeof linkProps.sizes === 'string') {\n          const limitedEscapedSizes = escapeSelectorAttributeValueInsideDoubleQuotes(\n            linkProps.sizes,\n          );\n          selector += `[sizes=\"${limitedEscapedSizes}\"]`;\n        }\n        if (typeof linkProps.media === 'string') {\n          const limitedEscapedMedia = escapeSelectorAttributeValueInsideDoubleQuotes(\n            linkProps.media,\n          );\n          selector += `[media=\"${limitedEscapedMedia}\"]`;\n        }\n        const existingEl = root.querySelector(selector);\n        if (existingEl) {\n          instance = resource.instance = existingEl;\n          markNodeAsResource(instance);\n          return instance;\n        }\n        instance = resource.instance = createResourceInstance(\n          type,\n          props,\n          root,\n        );\n        insertResourceInstanceBefore(root, instance, null);\n        return instance;\n      }\n      case 'base': {\n        const baseResource: BaseResource = (resource: any);\n        const {matcher} = baseResource;\n        const base = root.querySelector(matcher);\n        if (base) {\n          instance = resource.instance = base;\n          markNodeAsResource(instance);\n        } else {\n          instance = resource.instance = createResourceInstance(\n            type,\n            props,\n            root,\n          );\n          insertResourceInstanceBefore(\n            root,\n            instance,\n            root.querySelector('base'),\n          );\n        }\n        return instance;\n      }\n      default: {\n        throw new Error(\n          `acquireHeadResource encountered a resource type it did not expect: \"${type}\". This is a bug in React.`,\n        );\n      }\n    }\n  }\n  return instance;\n}\n\nfunction acquireStyleResource(resource: StyleResource): Instance {\n  let instance = resource.instance;\n  if (!instance) {\n    const {props, root, precedence} = resource;\n    const limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(\n      props.href,\n    );\n    const existingEl = root.querySelector(\n      `link[rel=\"stylesheet\"][data-precedence][href=\"${limitedEscapedHref}\"]`,\n    );\n    if (existingEl) {\n      instance = resource.instance = existingEl;\n      markNodeAsResource(instance);\n      resource.preloaded = true;\n      const loadingState: ?StyleResourceLoadingState = (existingEl: any)._p;\n      if (loadingState) {\n        // if an existingEl is found there should always be a loadingState because if\n        // the resource was flushed in the head it should have already been found when\n        // the resource was first created. Still defensively we gate this\n        switch (loadingState.s) {\n          case 'l': {\n            resource.loaded = true;\n            resource.error = false;\n            break;\n          }\n          case 'e': {\n            resource.error = true;\n            break;\n          }\n          default: {\n            attachLoadListeners(existingEl, resource);\n          }\n        }\n      } else {\n        resource.loaded = true;\n      }\n    } else {\n      instance = resource.instance = createResourceInstance(\n        'link',\n        resource.props,\n        getDocumentFromRoot(root),\n      );\n\n      attachLoadListeners(instance, resource);\n      insertStyleInstance(instance, precedence, root);\n    }\n  }\n  resource.count++;\n  return instance;\n}\n\nfunction acquireScriptResource(resource: ScriptResource): Instance {\n  let instance = resource.instance;\n  if (!instance) {\n    const {props, root} = resource;\n    const limitedEscapedSrc = escapeSelectorAttributeValueInsideDoubleQuotes(\n      props.src,\n    );\n    const existingEl = root.querySelector(\n      `script[async][src=\"${limitedEscapedSrc}\"]`,\n    );\n    if (existingEl) {\n      instance = resource.instance = existingEl;\n      markNodeAsResource(instance);\n    } else {\n      instance = resource.instance = createResourceInstance(\n        'script',\n        resource.props,\n        getDocumentFromRoot(root),\n      );\n\n      insertResourceInstanceBefore(getDocumentFromRoot(root), instance, null);\n    }\n  }\n  return instance;\n}\n\nfunction attachLoadListeners(instance: Instance, resource: StyleResource) {\n  const listeners = {};\n  listeners.load = onResourceLoad.bind(\n    null,\n    instance,\n    resource,\n    listeners,\n    loadAndErrorEventListenerOptions,\n  );\n  listeners.error = onResourceError.bind(\n    null,\n    instance,\n    resource,\n    listeners,\n    loadAndErrorEventListenerOptions,\n  );\n\n  instance.addEventListener(\n    'load',\n    listeners.load,\n    loadAndErrorEventListenerOptions,\n  );\n  instance.addEventListener(\n    'error',\n    listeners.error,\n    loadAndErrorEventListenerOptions,\n  );\n}\n\nconst loadAndErrorEventListenerOptions = {\n  passive: true,\n};\n\nfunction onResourceLoad(\n  instance: Instance,\n  resource: StyleResource,\n  listeners: {[string]: () => mixed},\n  listenerOptions: typeof loadAndErrorEventListenerOptions,\n) {\n  resource.loaded = true;\n  resource.error = false;\n  for (const event in listeners) {\n    instance.removeEventListener(event, listeners[event], listenerOptions);\n  }\n}\n\nfunction onResourceError(\n  instance: Instance,\n  resource: StyleResource,\n  listeners: {[string]: () => mixed},\n  listenerOptions: typeof loadAndErrorEventListenerOptions,\n) {\n  resource.loaded = false;\n  resource.error = true;\n  for (const event in listeners) {\n    instance.removeEventListener(event, listeners[event], listenerOptions);\n  }\n}\n\nfunction insertStyleInstance(\n  instance: Instance,\n  precedence: string,\n  root: FloatRoot,\n): void {\n  const nodes = root.querySelectorAll(\n    'link[rel=\"stylesheet\"][data-precedence]',\n  );\n  const last = nodes.length ? nodes[nodes.length - 1] : null;\n  let prior = last;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const nodePrecedence = node.dataset.precedence;\n    if (nodePrecedence === precedence) {\n      prior = node;\n    } else if (prior !== last) {\n      break;\n    }\n  }\n  if (prior) {\n    // We get the prior from the document so we know it is in the tree.\n    // We also know that links can't be the topmost Node so the parentNode\n    // must exist.\n    ((prior.parentNode: any): Node).insertBefore(instance, prior.nextSibling);\n  } else {\n    const parent =\n      root.nodeType === DOCUMENT_NODE ? ((root: any): Document).head : root;\n    if (parent) {\n      parent.insertBefore(instance, parent.firstChild);\n    } else {\n      throw new Error(\n        'While attempting to insert a Resource, React expected the Document to contain' +\n          ' a head element but it was not found.',\n      );\n    }\n  }\n}\n\nfunction insertResourceInstanceBefore(\n  ownerDocument: Document,\n  instance: Instance,\n  before: ?Node,\n): void {\n  if (__DEV__) {\n    if (instance.tagName === 'LINK' && (instance: any).rel === 'stylesheet') {\n      console.error(\n        'insertResourceInstanceBefore was called with a stylesheet. Stylesheets must be' +\n          ' inserted with insertStyleInstance instead. This is a bug in React.',\n      );\n    }\n  }\n  const parent = (before && before.parentNode) || ownerDocument.head;\n  if (parent) {\n    parent.insertBefore(instance, before);\n  } else {\n    throw new Error(\n      'While attempting to insert a Resource, React expected the Document to contain' +\n        ' a head element but it was not found.',\n    );\n  }\n}\n\n// When passing user input into querySelector(All) the embedded string must not alter\n// the semantics of the query. This escape function is safe to use when we know the\n// provided value is going to be wrapped in double quotes as part of an attribute selector\n// Do not use it anywhere else\n// we escape double quotes and backslashes\nconst escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\\n\\\"\\\\]/g;\nfunction escapeSelectorAttributeValueInsideDoubleQuotes(value: string): string {\n  return value.replace(\n    escapeSelectorAttributeValueInsideDoubleQuotesRegex,\n    ch => '\\\\' + ch.charCodeAt(0).toString(16),\n  );\n}\n"]},"metadata":{},"sourceType":"module"}