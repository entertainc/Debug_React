{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { precacheFiberNode, updateFiberProps, getClosestInstanceFromNode, getFiberFromScopeInstance, getInstanceFromNode as getInstanceFromNodeDOMTree, isContainerMarkedAsRoot, detachDeletedInstance, isMarkedResource } from './ReactDOMComponentTree';\nexport { detachDeletedInstance };\nimport { hasRole } from './DOMAccessibilityRoles';\nimport { createElement, createTextNode, setInitialProperties, diffProperties, updateProperties, diffHydratedProperties, diffHydratedText, trapClickOnNonInteractiveElement, checkForUnmatchedText, warnForDeletedHydratableElement, warnForDeletedHydratableText, warnForInsertedHydratedElement, warnForInsertedHydratedText, getOwnerDocumentFromRootContainer } from './ReactDOMComponent';\nimport { getSelectionInformation, restoreSelection } from './ReactInputSelection';\nimport setTextContent from './setTextContent';\nimport { validateDOMNesting, updatedAncestorInfoDev } from './validateDOMNesting';\nimport { isEnabled as ReactBrowserEventEmitterIsEnabled, setEnabled as ReactBrowserEventEmitterSetEnabled, getEventPriority } from '../events/ReactDOMEventListener';\nimport { getChildNamespace, SVG_NAMESPACE } from '../shared/DOMNamespaces';\nimport { ELEMENT_NODE, TEXT_NODE, COMMENT_NODE, DOCUMENT_NODE, DOCUMENT_TYPE_NODE, DOCUMENT_FRAGMENT_NODE } from '../shared/HTMLNodeType';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\nimport { retryIfBlockedOn } from '../events/ReactDOMEventReplaying';\nimport { enableCreateEventHandleAPI, enableScopeAPI, enableFloat, enableHostSingletons } from 'shared/ReactFeatureFlags';\nimport { HostComponent, HostResource, HostText, HostSingleton } from 'react-reconciler/src/ReactWorkTags';\nimport { listenToAllSupportedEvents } from '../events/DOMPluginEventSystem';\nimport { DefaultEventPriority } from 'react-reconciler/src/ReactEventPriorities'; // TODO: Remove this deep import when we delete the legacy root API\n\nimport { ConcurrentMode, NoMode } from 'react-reconciler/src/ReactTypeOfMode';\nimport { prepareToRenderResources, cleanupAfterRenderResources, clearRootResources } from './ReactDOMFloatClient';\nimport { validateLinkPropsForStyleResource } from '../shared/ReactDOMResourceValidation';\nconst SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\nconst SUSPENSE_START_DATA = '$';\nconst SUSPENSE_END_DATA = '/$';\nconst SUSPENSE_PENDING_START_DATA = '$?';\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\nconst STYLE = 'style';\nlet eventsEnabled = null;\nlet selectionInformation = null;\nexport * from 'react-reconciler/src/ReactFiberHostConfigWithNoPersistence';\nexport function getRootHostContext(rootContainerInstance) {\n  let type;\n  let namespace;\n  const nodeType = rootContainerInstance.nodeType;\n\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      {\n        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n        const root = rootContainerInstance.documentElement;\n        namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n        break;\n      }\n\n    default:\n      {\n        const container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n        const ownNamespace = container.namespaceURI || null;\n        type = container.tagName;\n        namespace = getChildNamespace(ownNamespace, type);\n        break;\n      }\n  }\n\n  if (__DEV__) {\n    const validatedTag = type.toLowerCase();\n    const ancestorInfo = updatedAncestorInfoDev(null, validatedTag);\n    return {\n      namespace,\n      ancestorInfo\n    };\n  }\n\n  return namespace;\n}\nexport function getChildHostContext(parentHostContext, type) {\n  if (__DEV__) {\n    const parentHostContextDev = parentHostContext;\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    const ancestorInfo = updatedAncestorInfoDev(parentHostContextDev.ancestorInfo, type);\n    return {\n      namespace,\n      ancestorInfo\n    };\n  }\n\n  const parentNamespace = parentHostContext;\n  return getChildNamespace(parentNamespace, type);\n}\nexport function getPublicInstance(instance) {\n  return instance;\n}\nexport function prepareForCommit(containerInfo) {\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\n  selectionInformation = getSelectionInformation();\n  let activeInstance = null;\n\n  if (enableCreateEventHandleAPI) {\n    const focusedElem = selectionInformation.focusedElem;\n\n    if (focusedElem !== null) {\n      activeInstance = getClosestInstanceFromNode(focusedElem);\n    }\n  }\n\n  ReactBrowserEventEmitterSetEnabled(false);\n  return activeInstance;\n}\nexport function beforeActiveInstanceBlur(internalInstanceHandle) {\n  if (enableCreateEventHandleAPI) {\n    ReactBrowserEventEmitterSetEnabled(true);\n    dispatchBeforeDetachedBlur(selectionInformation.focusedElem, internalInstanceHandle);\n    ReactBrowserEventEmitterSetEnabled(false);\n  }\n}\nexport function afterActiveInstanceBlur() {\n  if (enableCreateEventHandleAPI) {\n    ReactBrowserEventEmitterSetEnabled(true);\n    dispatchAfterDetachedBlur(selectionInformation.focusedElem);\n    ReactBrowserEventEmitterSetEnabled(false);\n  }\n}\nexport function resetAfterCommit(containerInfo) {\n  restoreSelection(selectionInformation);\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\n  eventsEnabled = null;\n  selectionInformation = null;\n}\nexport function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  let parentNamespace;\n\n  if (__DEV__) {\n    // TODO: take namespace into account when validating.\n    const hostContextDev = hostContext;\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n\n    if (typeof props.children === 'string' || typeof props.children === 'number') {\n      const string = '' + props.children;\n      const ownAncestorInfo = updatedAncestorInfoDev(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = hostContext;\n  }\n\n  const domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\nexport function appendInitialChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\nexport function finalizeInitialChildren(domElement, type, props, hostContext) {\n  setInitialProperties(domElement, type, props);\n\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n\n    case 'img':\n      return true;\n\n    default:\n      return false;\n  }\n}\nexport function prepareUpdate(domElement, type, oldProps, newProps, hostContext) {\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n\n    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n      const string = '' + newProps.children;\n      const ownAncestorInfo = updatedAncestorInfoDev(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n\n  return diffProperties(domElement, type, oldProps, newProps);\n}\nexport function shouldSetTextContent(type, props) {\n  return type === 'textarea' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\n}\nexport function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n\n  const textNode = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\nexport function getCurrentEventPriority() {\n  const currentEvent = window.event;\n\n  if (currentEvent === undefined) {\n    return DefaultEventPriority;\n  }\n\n  return getEventPriority(currentEvent.type);\n}\nexport const isPrimaryRenderer = true;\nexport const warnsIfNotActing = true; // This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\n\nexport const scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nexport const cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\nexport const noTimeout = -1;\nconst localPromise = typeof Promise === 'function' ? Promise : undefined;\nconst localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : scheduleTimeout;\nexport function getInstanceFromNode(node) {\n  return getClosestInstanceFromNode(node) || null;\n}\nexport function preparePortalMount(portalInstance) {\n  listenToAllSupportedEvents(portalInstance);\n}\nexport function prepareScopeUpdate(scopeInstance, internalInstanceHandle) {\n  if (enableScopeAPI) {\n    precacheFiberNode(internalInstanceHandle, scopeInstance);\n  }\n}\nexport function getInstanceFromScope(scopeInstance) {\n  if (enableScopeAPI) {\n    return getFiberFromScopeInstance(scopeInstance);\n  }\n\n  return null;\n} // -------------------\n//     Microtasks\n// -------------------\n\nexport const supportsMicrotasks = true;\nexport const scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : typeof localPromise !== 'undefined' ? callback => localPromise.resolve(null).then(callback).catch(handleErrorInNextTick) : scheduleTimeout; // TODO: Determine the best fallback here.\n\nfunction handleErrorInNextTick(error) {\n  setTimeout(() => {\n    throw error;\n  });\n} // -------------------\n//     Mutation\n// -------------------\n\n\nexport const supportsMutation = true;\nexport function commitMount(domElement, type, newProps, internalInstanceHandle) {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      if (newProps.autoFocus) {\n        domElement.focus();\n      }\n\n      return;\n\n    case 'img':\n      {\n        if (newProps.src) {\n          domElement.src = newProps.src;\n        }\n\n        return;\n      }\n  }\n}\nexport function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps); // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n\n  updateFiberProps(domElement, newProps);\n}\nexport function resetTextContent(domElement) {\n  setTextContent(domElement, '');\n}\nexport function commitTextUpdate(textInstance, oldText, newText) {\n  textInstance.nodeValue = newText;\n}\nexport function appendChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\nexport function appendChildToContainer(container, child) {\n  let parentNode;\n\n  if (container.nodeType === COMMENT_NODE) {\n    parentNode = container.parentNode;\n    parentNode.insertBefore(child, container);\n  } else {\n    parentNode = container;\n    parentNode.appendChild(child);\n  } // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that non React root containers have inline onclick\n  // defined.\n  // https://github.com/facebook/react/issues/11918\n\n\n  const reactRootContainer = container._reactRootContainer;\n\n  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(parentNode);\n  }\n}\nexport function insertBefore(parentInstance, child, beforeChild) {\n  parentInstance.insertBefore(child, beforeChild);\n}\nexport function insertInContainerBefore(container, child, beforeChild) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nfunction createEvent(type, bubbles) {\n  const event = document.createEvent('Event');\n  event.initEvent(type, bubbles, false);\n  return event;\n}\n\nfunction dispatchBeforeDetachedBlur(target, internalInstanceHandle) {\n  if (enableCreateEventHandleAPI) {\n    const event = createEvent('beforeblur', true); // Dispatch \"beforeblur\" directly on the target,\n    // so it gets picked up by the event system and\n    // can propagate through the React internal tree.\n    // $FlowFixMe: internal field\n\n    event._detachedInterceptFiber = internalInstanceHandle;\n    target.dispatchEvent(event);\n  }\n}\n\nfunction dispatchAfterDetachedBlur(target) {\n  if (enableCreateEventHandleAPI) {\n    const event = createEvent('afterblur', false); // So we know what was detached, make the relatedTarget the\n    // detached target on the \"afterblur\" event.\n\n    event.relatedTarget = target; // Dispatch the event on the document.\n\n    document.dispatchEvent(event);\n  }\n}\n\nexport function removeChild(parentInstance, child) {\n  parentInstance.removeChild(child);\n}\nexport function removeChildFromContainer(container, child) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\nexport function clearSuspenseBoundary(parentInstance, suspenseInstance) {\n  let node = suspenseInstance; // Delete all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  do {\n    const nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n      const data = nextNode.data;\n\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          parentInstance.removeChild(nextNode); // Retry if any event replaying was blocked on this.\n\n          retryIfBlockedOn(suspenseInstance);\n          return;\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {\n        depth++;\n      }\n    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n\n\n    node = nextNode;\n  } while (node); // TODO: Warn, we didn't find the end comment boundary.\n  // Retry if any event replaying was blocked on this.\n\n\n  retryIfBlockedOn(suspenseInstance);\n}\nexport function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {\n  if (container.nodeType === COMMENT_NODE) {\n    clearSuspenseBoundary(container.parentNode, suspenseInstance);\n  } else if (container.nodeType === ELEMENT_NODE) {\n    clearSuspenseBoundary(container, suspenseInstance);\n  } else {// Document nodes should never contain suspense boundaries.\n  } // Retry if any event replaying was blocked on this.\n\n\n  retryIfBlockedOn(container);\n}\nexport function hideInstance(instance) {\n  // TODO: Does this work for all element types? What about MathML? Should we\n  // pass host context to this method?\n  instance = instance;\n  const style = instance.style; // $FlowFixMe[method-unbinding]\n\n  if (typeof style.setProperty === 'function') {\n    style.setProperty('display', 'none', 'important');\n  } else {\n    style.display = 'none';\n  }\n}\nexport function hideTextInstance(textInstance) {\n  textInstance.nodeValue = '';\n}\nexport function unhideInstance(instance, props) {\n  instance = instance;\n  const styleProp = props[STYLE];\n  const display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;\n  instance.style.display = dangerousStyleValue('display', display);\n}\nexport function unhideTextInstance(textInstance, text) {\n  textInstance.nodeValue = text;\n}\nexport function clearContainer(container) {\n  if (enableHostSingletons) {\n    const nodeType = container.nodeType;\n\n    if (nodeType === DOCUMENT_NODE) {\n      clearRootResources(container);\n      clearContainerSparingly(container);\n    } else if (nodeType === ELEMENT_NODE) {\n      switch (container.nodeName) {\n        case 'HEAD':\n          {\n            // If we are clearing document.head as a container we are essentially clearing everything\n            // that was hoisted to the head and should forget the instances that will no longer be in the DOM\n            clearRootResources(container); // fall through to clear child contents\n          }\n        // eslint-disable-next-line-no-fallthrough\n\n        case 'HTML':\n        case 'BODY':\n          clearContainerSparingly(container);\n          return;\n\n        default:\n          {\n            container.textContent = '';\n          }\n      }\n    }\n  } else {\n    if (container.nodeType === ELEMENT_NODE) {\n      // We have refined the container to Element type\n      const element = container;\n      element.textContent = '';\n    } else if (container.nodeType === DOCUMENT_NODE) {\n      // We have refined the container to Document type\n      const doc = container;\n\n      if (doc.documentElement) {\n        doc.removeChild(doc.documentElement);\n      }\n    }\n  }\n}\n\nfunction clearContainerSparingly(container) {\n  let node;\n  let nextNode = container.firstChild;\n\n  if (nextNode && nextNode.nodeType === DOCUMENT_TYPE_NODE) {\n    nextNode = nextNode.nextSibling;\n  }\n\n  while (nextNode) {\n    node = nextNode;\n    nextNode = nextNode.nextSibling;\n\n    switch (node.nodeName) {\n      case 'HTML':\n      case 'HEAD':\n      case 'BODY':\n        {\n          const element = node;\n          clearContainerSparingly(element); // If these singleton instances had previously been rendered with React they\n          // may still hold on to references to the previous fiber tree. We detatch them\n          // prospectively to reset them to a baseline starting state since we cannot create\n          // new instances.\n\n          detachDeletedInstance(element);\n          continue;\n        }\n\n      case 'STYLE':\n        {\n          continue;\n        }\n\n      case 'LINK':\n        {\n          if (node.rel.toLowerCase() === 'stylesheet') {\n            continue;\n          }\n        }\n    }\n\n    container.removeChild(node);\n  }\n\n  return;\n} // Making this so we can eventually move all of the instance caching to the commit phase.\n// Currently this is only used to associate fiber and props to instances for hydrating\n// HostSingletons. The reason we need it here is we only want to make this binding on commit\n// because only one fiber can own the instance at a time and render can fail/restart\n\n\nexport function bindInstance(instance, props, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, instance);\n  updateFiberProps(instance, props);\n} // -------------------\n//     Hydration\n// -------------------\n\nexport const supportsHydration = true; // With Resources, some HostComponent types will never be server rendered and need to be\n// inserted without breaking hydration\n\nexport function isHydratable(type, props) {\n  if (enableFloat) {\n    if (type === 'link') {\n      if (props.rel === 'stylesheet' && typeof props.precedence !== 'string') {\n        return true;\n      }\n\n      return false;\n    } else if (type === 'script') {\n      const {\n        async,\n        onLoad,\n        onError\n      } = props;\n      return !(async && (onLoad || onError));\n    }\n\n    return true;\n  } else {\n    return true;\n  }\n}\nexport function canHydrateInstance(instance, type, props) {\n  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n    return null;\n  } // This has now been refined to an element node.\n\n\n  return instance;\n}\nexport function canHydrateTextInstance(instance, text) {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  } // This has now been refined to a text node.\n\n\n  return instance;\n}\nexport function canHydrateSuspenseInstance(instance) {\n  if (instance.nodeType !== COMMENT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  } // This has now been refined to a suspense node.\n\n\n  return instance;\n}\nexport function isSuspenseInstancePending(instance) {\n  return instance.data === SUSPENSE_PENDING_START_DATA;\n}\nexport function isSuspenseInstanceFallback(instance) {\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\n}\nexport function getSuspenseInstanceFallbackErrorDetails(instance) {\n  const dataset = instance.nextSibling && instance.nextSibling.dataset;\n  let digest, message, stack;\n\n  if (dataset) {\n    digest = dataset.dgst;\n\n    if (__DEV__) {\n      message = dataset.msg;\n      stack = dataset.stck;\n    }\n  }\n\n  if (__DEV__) {\n    return {\n      message,\n      digest,\n      stack\n    };\n  } else {\n    // Object gets DCE'd if constructed in tail position and matches callsite destructuring\n    return {\n      digest\n    };\n  }\n}\nexport function registerSuspenseInstanceRetry(instance, callback) {\n  instance._reactRetry = callback;\n}\n\nfunction getNextHydratable(node) {\n  // Skip non-hydratable nodes.\n  for (; node != null; node = node.nextSibling) {\n    const nodeType = node.nodeType;\n\n    if (enableFloat && enableHostSingletons) {\n      if (nodeType === ELEMENT_NODE) {\n        const element = node;\n\n        switch (element.tagName) {\n          // This is subtle. in SVG scope the title tag is case sensitive. we don't want to skip\n          // titles in svg but we do want to skip them outside of svg. there is an edge case where\n          // you could do `React.createElement('TITLE', ...)` inside an svg scope but the SSR serializer\n          // will still emit lowercase. Practically speaking the only time the DOM will have a non-uppercased\n          // title tagName is if it is inside an svg.\n          // Other Resource types like META, BASE, LINK, and SCRIPT should be treated as resources even inside\n          // svg scope because they are invalid otherwise. We still don't need to handle the lowercase variant\n          // because if they are present in the DOM already they would have been hoisted outside the SVG scope\n          // as Resources. So while it would be correct to skip a <link> inside <svg> and this algorithm won't\n          // skip that link because the tagName will not be uppercased it functionally is irrelevant. If one\n          // tries to render incompatible types such as a non-resource stylesheet inside an svg the server will\n          // emit that invalid html and hydration will fail. In Dev this will present warnings guiding the\n          // developer on how to fix.\n          case 'TITLE':\n          case 'META':\n          case 'BASE':\n          case 'HTML':\n          case 'HEAD':\n          case 'BODY':\n            {\n              continue;\n            }\n\n          case 'LINK':\n            {\n              const linkEl = element; // All links that are server rendered are resources except\n              // stylesheets that do not have a precedence\n\n              if (linkEl.rel === 'stylesheet' && !linkEl.hasAttribute('data-precedence')) {\n                break;\n              }\n\n              continue;\n            }\n\n          case 'STYLE':\n            {\n              const styleEl = element;\n\n              if (styleEl.hasAttribute('data-precedence')) {\n                continue;\n              }\n\n              break;\n            }\n\n          case 'SCRIPT':\n            {\n              const scriptEl = element;\n\n              if (scriptEl.hasAttribute('async')) {\n                continue;\n              }\n\n              break;\n            }\n        }\n\n        break;\n      } else if (nodeType === TEXT_NODE) {\n        break;\n      }\n    } else if (enableFloat) {\n      if (nodeType === ELEMENT_NODE) {\n        const element = node;\n\n        switch (element.tagName) {\n          case 'TITLE':\n          case 'META':\n          case 'BASE':\n            {\n              continue;\n            }\n\n          case 'LINK':\n            {\n              const linkEl = element; // All links that are server rendered are resources except\n              // stylesheets that do not have a precedence\n\n              if (linkEl.rel === 'stylesheet' && !linkEl.hasAttribute('data-precedence')) {\n                break;\n              }\n\n              continue;\n            }\n\n          case 'STYLE':\n            {\n              const styleEl = element;\n\n              if (styleEl.hasAttribute('data-precedence')) {\n                continue;\n              }\n\n              break;\n            }\n\n          case 'SCRIPT':\n            {\n              const scriptEl = element;\n\n              if (scriptEl.hasAttribute('async')) {\n                continue;\n              }\n\n              break;\n            }\n        }\n\n        break;\n      } else if (nodeType === TEXT_NODE) {\n        break;\n      }\n    } else if (enableHostSingletons) {\n      if (nodeType === ELEMENT_NODE) {\n        const tag = node.tagName;\n\n        if (tag === 'HTML' || tag === 'HEAD' || tag === 'BODY') {\n          continue;\n        }\n\n        break;\n      } else if (nodeType === TEXT_NODE) {\n        break;\n      }\n    } else {\n      if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n        break;\n      }\n    }\n\n    if (nodeType === COMMENT_NODE) {\n      const nodeData = node.data;\n\n      if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {\n        break;\n      }\n\n      if (nodeData === SUSPENSE_END_DATA) {\n        return null;\n      }\n    }\n  }\n\n  return node;\n}\n\nexport function getNextHydratableSibling(instance) {\n  return getNextHydratable(instance.nextSibling);\n}\nexport function getFirstHydratableChild(parentInstance) {\n  return getNextHydratable(parentInstance.firstChild);\n}\nexport function getFirstHydratableChildWithinContainer(parentContainer) {\n  return getNextHydratable(parentContainer.firstChild);\n}\nexport function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {\n  return getNextHydratable(parentInstance.nextSibling);\n}\nexport function hydrateInstance(instance, type, props, hostContext, internalInstanceHandle, shouldWarnDev) {\n  precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n\n  updateFiberProps(instance, props);\n  let parentNamespace;\n\n  if (__DEV__) {\n    const hostContextDev = hostContext;\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = hostContext;\n  } // TODO: Temporary hack to check if we're in a concurrent root. We can delete\n  // when the legacy root API is removed.\n\n\n  const isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;\n  return diffHydratedProperties(instance, type, props, parentNamespace, isConcurrentMode, shouldWarnDev);\n}\nexport function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {\n  precacheFiberNode(internalInstanceHandle, textInstance); // TODO: Temporary hack to check if we're in a concurrent root. We can delete\n  // when the legacy root API is removed.\n\n  const isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;\n  return diffHydratedText(textInstance, text, isConcurrentMode);\n}\nexport function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, suspenseInstance);\n}\nexport function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\n  let node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      const data = node.data;\n\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          return getNextHydratableSibling(node);\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n        depth++;\n      }\n    }\n\n    node = node.nextSibling;\n  } // TODO: Warn, we didn't find the end comment boundary.\n\n\n  return null;\n} // Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\n\nexport function getParentSuspenseInstance(targetInstance) {\n  let node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n\n  let depth = 0;\n\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      const data = node.data;\n\n      if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n        if (depth === 0) {\n          return node;\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_END_DATA) {\n        depth++;\n      }\n    }\n\n    node = node.previousSibling;\n  }\n\n  return null;\n}\nexport function commitHydratedContainer(container) {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(container);\n}\nexport function commitHydratedSuspenseInstance(suspenseInstance) {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(suspenseInstance);\n} // @TODO remove this function once float lands and hydrated tail nodes\n// are controlled by HostSingleton fibers\n\nexport function shouldDeleteUnhydratedTailInstances(parentType) {\n  return parentType !== 'head' && parentType !== 'body';\n}\nexport function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode, shouldWarnDev) {\n  checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);\n}\nexport function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode, shouldWarnDev) {\n  if (parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);\n  }\n}\nexport function didNotHydrateInstanceWithinContainer(parentContainer, instance) {\n  if (__DEV__) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, instance);\n    } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentContainer, instance);\n    }\n  }\n}\nexport function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode = parentInstance.parentNode;\n\n    if (parentNode !== null) {\n      if (instance.nodeType === ELEMENT_NODE) {\n        warnForDeletedHydratableElement(parentNode, instance);\n      } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n      } else {\n        warnForDeletedHydratableText(parentNode, instance);\n      }\n    }\n  }\n}\nexport function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {\n  if (__DEV__) {\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n      if (instance.nodeType === ELEMENT_NODE) {\n        warnForDeletedHydratableElement(parentInstance, instance);\n      } else if (instance.nodeType === COMMENT_NODE) {// TODO: warnForDeletedHydratableSuspenseBoundary\n      } else {\n        warnForDeletedHydratableText(parentInstance, instance);\n      }\n    }\n  }\n}\nexport function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {\n  if (__DEV__) {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\nexport function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {\n  if (__DEV__) {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\nexport function didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer) {\n  if (__DEV__) {// TODO: warnForInsertedHydratedSuspense(parentContainer);\n  }\n}\nexport function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode = parentInstance.parentNode;\n    if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type, props);\n  }\n}\nexport function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode = parentInstance.parentNode;\n    if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);\n  }\n}\nexport function didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(parentInstance) {\n  if (__DEV__) {// const parentNode: Element | Document | null = parentInstance.parentNode;\n    // TODO: warnForInsertedHydratedSuspense(parentNode);\n  }\n}\nexport function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {\n  if (__DEV__) {\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n      warnForInsertedHydratedElement(parentInstance, type, props);\n    }\n  }\n}\nexport function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {\n  if (__DEV__) {\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n      warnForInsertedHydratedText(parentInstance, text);\n    }\n  }\n}\nexport function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {\n  if (__DEV__) {// TODO: warnForInsertedHydratedSuspense(parentInstance);\n  }\n}\nexport function errorHydratingContainer(parentContainer) {\n  if (__DEV__) {\n    // TODO: This gets logged by onRecoverableError, too, so we should be\n    // able to remove it.\n    console.error('An error occurred during hydration. The server HTML was replaced with client content in <%s>.', parentContainer.nodeName.toLowerCase());\n  }\n} // -------------------\n//     Test Selectors\n// -------------------\n\nexport const supportsTestSelectors = true;\nexport function findFiberRoot(node) {\n  const stack = [node];\n  let index = 0;\n\n  while (index < stack.length) {\n    const current = stack[index++];\n\n    if (isContainerMarkedAsRoot(current)) {\n      return getInstanceFromNodeDOMTree(current);\n    }\n\n    stack.push(...current.children);\n  }\n\n  return null;\n}\nexport function getBoundingRect(node) {\n  const rect = node.getBoundingClientRect();\n  return {\n    x: rect.left,\n    y: rect.top,\n    width: rect.width,\n    height: rect.height\n  };\n}\nexport function matchAccessibilityRole(node, role) {\n  if (hasRole(node, role)) {\n    return true;\n  }\n\n  return false;\n}\nexport function getTextContent(fiber) {\n  switch (fiber.tag) {\n    case HostResource:\n    case HostSingleton:\n    case HostComponent:\n      let textContent = '';\n      const childNodes = fiber.stateNode.childNodes;\n\n      for (let i = 0; i < childNodes.length; i++) {\n        const childNode = childNodes[i];\n\n        if (childNode.nodeType === Node.TEXT_NODE) {\n          textContent += childNode.textContent;\n        }\n      }\n\n      return textContent;\n\n    case HostText:\n      return fiber.stateNode.textContent;\n  }\n\n  return null;\n}\nexport function isHiddenSubtree(fiber) {\n  return fiber.tag === HostComponent && fiber.memoizedProps.hidden === true;\n}\nexport function setFocusIfFocusable(node) {\n  // The logic for determining if an element is focusable is kind of complex,\n  // and since we want to actually change focus anyway- we can just skip it.\n  // Instead we'll just listen for a \"focus\" event to verify that focus was set.\n  //\n  // We could compare the node to document.activeElement after focus,\n  // but this would not handle the case where application code managed focus to automatically blur.\n  let didFocus = false;\n\n  const handleFocus = () => {\n    didFocus = true;\n  };\n\n  const element = node;\n\n  try {\n    element.addEventListener('focus', handleFocus); // $FlowFixMe[method-unbinding]\n\n    (element.focus || HTMLElement.prototype.focus).call(element);\n  } finally {\n    element.removeEventListener('focus', handleFocus);\n  }\n\n  return didFocus;\n}\nexport function setupIntersectionObserver(targets, callback, options) {\n  const rectRatioCache = new Map();\n  targets.forEach(target => {\n    rectRatioCache.set(target, {\n      rect: getBoundingRect(target),\n      ratio: 0\n    });\n  });\n\n  const handleIntersection = entries => {\n    entries.forEach(entry => {\n      const {\n        boundingClientRect,\n        intersectionRatio,\n        target\n      } = entry;\n      rectRatioCache.set(target, {\n        rect: {\n          x: boundingClientRect.left,\n          y: boundingClientRect.top,\n          width: boundingClientRect.width,\n          height: boundingClientRect.height\n        },\n        ratio: intersectionRatio\n      });\n    });\n    callback(Array.from(rectRatioCache.values()));\n  };\n\n  const observer = new IntersectionObserver(handleIntersection, options);\n  targets.forEach(target => {\n    observer.observe(target);\n  });\n  return {\n    disconnect: () => observer.disconnect(),\n    observe: target => {\n      rectRatioCache.set(target, {\n        rect: getBoundingRect(target),\n        ratio: 0\n      });\n      observer.observe(target);\n    },\n    unobserve: target => {\n      rectRatioCache.delete(target);\n      observer.unobserve(target);\n    }\n  };\n}\nexport function requestPostPaintCallback(callback) {\n  localRequestAnimationFrame(() => {\n    localRequestAnimationFrame(time => callback(time));\n  });\n} // -------------------\n//     Resources\n// -------------------\n\nexport const supportsResources = true;\nexport function isHostResourceType(type, props, hostContext) {\n  let outsideHostContainerContext;\n  let namespace;\n\n  if (__DEV__) {\n    const hostContextDev = hostContext; // We can only render resources when we are not within the host container context\n\n    outsideHostContainerContext = !hostContextDev.ancestorInfo.containerTagInScope;\n    namespace = hostContextDev.namespace;\n  } else {\n    const hostContextProd = hostContext;\n    namespace = hostContextProd;\n  }\n\n  switch (type) {\n    case 'base':\n    case 'meta':\n      {\n        return true;\n      }\n\n    case 'title':\n      {\n        return namespace !== SVG_NAMESPACE;\n      }\n\n    case 'link':\n      {\n        const {\n          onLoad,\n          onError\n        } = props;\n\n        if (onLoad || onError) {\n          if (__DEV__) {\n            if (outsideHostContainerContext) {\n              console.error('Cannot render a <link> with onLoad or onError listeners outside the main document.' + ' Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or' + ' somewhere in the <body>.');\n            } else if (namespace === SVG_NAMESPACE) {\n              console.error('Cannot render a <link> with onLoad or onError listeners as a descendent of <svg>.' + ' Try removing onLoad={...} and onError={...} or moving it above the <svg> ancestor.');\n            }\n          }\n\n          return false;\n        }\n\n        switch (props.rel) {\n          case 'stylesheet':\n            {\n              const {\n                href,\n                precedence,\n                disabled\n              } = props;\n\n              if (__DEV__) {\n                validateLinkPropsForStyleResource(props);\n\n                if (typeof precedence !== 'string') {\n                  if (outsideHostContainerContext) {\n                    console.error('Cannot render a <link rel=\"stylesheet\" /> outside the main document without knowing its precedence.' + ' Consider adding precedence=\"default\" or moving it into the root <head> tag.');\n                  } else if (namespace === SVG_NAMESPACE) {\n                    console.error('Cannot render a <link rel=\"stylesheet\" /> as a descendent of an <svg> element without knowing its precedence.' + ' Consider adding precedence=\"default\" or moving it above the <svg> ancestor.');\n                  }\n                }\n              }\n\n              return typeof href === 'string' && typeof precedence === 'string' && disabled == null;\n            }\n\n          default:\n            {\n              const {\n                rel,\n                href\n              } = props;\n              return typeof href === 'string' && typeof rel === 'string';\n            }\n        }\n      }\n\n    case 'script':\n      {\n        // We don't validate because it is valid to use async with onLoad/onError unlike combining\n        // precedence with these for style resources\n        const {\n          src,\n          async,\n          onLoad,\n          onError\n        } = props;\n\n        if (__DEV__) {\n          if (async !== true) {\n            if (outsideHostContainerContext) {\n              console.error('Cannot render a sync or defer <script> outside the main document without knowing its order.' + ' Try adding async=\"\" or moving it into the root <head> tag.');\n            } else if (namespace === SVG_NAMESPACE) {\n              console.error('Cannot render a sync or defer <script> as a descendent of an <svg> element.' + ' Try adding async=\"\" or moving it above the ancestor <svg> element.');\n            }\n          } else if (onLoad || onError) {\n            if (outsideHostContainerContext) {\n              console.error('Cannot render a <script> with onLoad or onError listeners outside the main document.' + ' Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or' + ' somewhere in the <body>.');\n            } else if (namespace === SVG_NAMESPACE) {\n              console.error('Cannot render a <script> with onLoad or onError listeners as a descendent of an <svg> element.' + ' Try removing onLoad={...} and onError={...} or moving it above the ancestor <svg> element.');\n            }\n          }\n        }\n\n        return async && typeof src === 'string' && !onLoad && !onError;\n      }\n\n    case 'noscript':\n    case 'template':\n    case 'style':\n      {\n        if (__DEV__) {\n          if (outsideHostContainerContext) {\n            console.error('Cannot render <%s> outside the main document. Try moving it into the root <head> tag.', type);\n          }\n        }\n\n        return false;\n      }\n  }\n\n  return false;\n}\nexport function prepareRendererToRender(rootContainer) {\n  if (enableFloat) {\n    prepareToRenderResources(rootContainer);\n  }\n}\nexport function resetRendererAfterRender() {\n  if (enableFloat) {\n    cleanupAfterRenderResources();\n  }\n}\nexport { getResource, acquireResource, releaseResource } from './ReactDOMFloatClient'; // -------------------\n//     Singletons\n// -------------------\n\nexport const supportsSingletons = true;\nexport function isHostSingletonType(type) {\n  return type === 'html' || type === 'head' || type === 'body';\n}\nexport function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {\n  if (__DEV__) {\n    if (validateDOMNestingDev) {\n      const hostContextDev = hostContext;\n      validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n    }\n  }\n\n  const ownerDocument = getOwnerDocumentFromRootContainer(rootContainerInstance);\n\n  switch (type) {\n    case 'html':\n      {\n        const documentElement = ownerDocument.documentElement;\n\n        if (!documentElement) {\n          throw new Error('React expected an <html> element (document.documentElement) to exist in the Document but one was' + ' not found. React never removes the documentElement for any Document it renders into so' + ' the cause is likely in some other script running on this page.');\n        }\n\n        return documentElement;\n      }\n\n    case 'head':\n      {\n        const head = ownerDocument.head;\n\n        if (!head) {\n          throw new Error('React expected a <head> element (document.head) to exist in the Document but one was' + ' not found. React never removes the head for any Document it renders into so' + ' the cause is likely in some other script running on this page.');\n        }\n\n        return head;\n      }\n\n    case 'body':\n      {\n        const body = ownerDocument.body;\n\n        if (!body) {\n          throw new Error('React expected a <body> element (document.body) to exist in the Document but one was' + ' not found. React never removes the body for any Document it renders into so' + ' the cause is likely in some other script running on this page.');\n        }\n\n        return body;\n      }\n\n    default:\n      {\n        throw new Error('resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.');\n      }\n  }\n}\nexport function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {\n  if (__DEV__) {\n    const currentInstanceHandle = getInstanceFromNodeDOMTree(instance);\n\n    if (currentInstanceHandle) {\n      const tagName = instance.tagName.toLowerCase();\n      console.error('You are mounting a new %s component when a previous one has not first unmounted. It is an' + ' error to render more than one %s component at a time and attributes and children of these' + ' components will likely fail in unpredictable ways. Please only render a single instance of' + ' <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.', tagName, tagName, tagName);\n    }\n\n    switch (type) {\n      case 'html':\n      case 'head':\n      case 'body':\n        {\n          break;\n        }\n\n      default:\n        {\n          console.error('acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.');\n        }\n    }\n  }\n\n  const attributes = instance.attributes;\n\n  while (attributes.length) {\n    instance.removeAttributeNode(attributes[0]);\n  }\n\n  setInitialProperties(instance, type, props);\n  precacheFiberNode(internalInstanceHandle, instance);\n  updateFiberProps(instance, props);\n}\nexport function releaseSingletonInstance(instance) {\n  const attributes = instance.attributes;\n\n  while (attributes.length) {\n    instance.removeAttributeNode(attributes[0]);\n  }\n\n  detachDeletedInstance(instance);\n}\nexport function clearSingleton(instance) {\n  const element = instance;\n  let node = element.firstChild;\n\n  while (node) {\n    const nextNode = node.nextSibling;\n    const nodeName = node.nodeName;\n\n    if (isMarkedResource(node) || nodeName === 'HEAD' || nodeName === 'BODY' || nodeName === 'STYLE' || nodeName === 'LINK' && node.rel.toLowerCase() === 'stylesheet') {// retain these nodes\n    } else {\n      element.removeChild(node);\n    }\n\n    node = nextNode;\n  }\n\n  return;\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-dom-bindings/src/client/ReactDOMHostConfig.js"],"names":["precacheFiberNode","updateFiberProps","getClosestInstanceFromNode","getFiberFromScopeInstance","getInstanceFromNode","getInstanceFromNodeDOMTree","isContainerMarkedAsRoot","detachDeletedInstance","isMarkedResource","hasRole","createElement","createTextNode","setInitialProperties","diffProperties","updateProperties","diffHydratedProperties","diffHydratedText","trapClickOnNonInteractiveElement","checkForUnmatchedText","warnForDeletedHydratableElement","warnForDeletedHydratableText","warnForInsertedHydratedElement","warnForInsertedHydratedText","getOwnerDocumentFromRootContainer","getSelectionInformation","restoreSelection","setTextContent","validateDOMNesting","updatedAncestorInfoDev","isEnabled","ReactBrowserEventEmitterIsEnabled","setEnabled","ReactBrowserEventEmitterSetEnabled","getEventPriority","getChildNamespace","SVG_NAMESPACE","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","dangerousStyleValue","retryIfBlockedOn","enableCreateEventHandleAPI","enableScopeAPI","enableFloat","enableHostSingletons","HostComponent","HostResource","HostText","HostSingleton","listenToAllSupportedEvents","DefaultEventPriority","ConcurrentMode","NoMode","prepareToRenderResources","cleanupAfterRenderResources","clearRootResources","validateLinkPropsForStyleResource","SUPPRESS_HYDRATION_WARNING","SUSPENSE_START_DATA","SUSPENSE_END_DATA","SUSPENSE_PENDING_START_DATA","SUSPENSE_FALLBACK_START_DATA","STYLE","eventsEnabled","selectionInformation","getRootHostContext","rootContainerInstance","type","namespace","nodeType","root","documentElement","namespaceURI","container","parentNode","ownNamespace","tagName","__DEV__","validatedTag","toLowerCase","ancestorInfo","getChildHostContext","parentHostContext","parentHostContextDev","parentNamespace","getPublicInstance","instance","prepareForCommit","containerInfo","activeInstance","focusedElem","beforeActiveInstanceBlur","internalInstanceHandle","dispatchBeforeDetachedBlur","afterActiveInstanceBlur","dispatchAfterDetachedBlur","resetAfterCommit","createInstance","props","hostContext","hostContextDev","children","string","ownAncestorInfo","domElement","appendInitialChild","parentInstance","child","appendChild","finalizeInitialChildren","autoFocus","prepareUpdate","oldProps","newProps","shouldSetTextContent","dangerouslySetInnerHTML","__html","createTextInstance","text","textNode","getCurrentEventPriority","currentEvent","window","event","undefined","isPrimaryRenderer","warnsIfNotActing","scheduleTimeout","setTimeout","cancelTimeout","clearTimeout","noTimeout","localPromise","Promise","localRequestAnimationFrame","requestAnimationFrame","node","preparePortalMount","portalInstance","prepareScopeUpdate","scopeInstance","getInstanceFromScope","supportsMicrotasks","scheduleMicrotask","queueMicrotask","callback","resolve","then","catch","handleErrorInNextTick","error","supportsMutation","commitMount","focus","src","commitUpdate","updatePayload","resetTextContent","commitTextUpdate","textInstance","oldText","newText","nodeValue","appendChildToContainer","insertBefore","reactRootContainer","_reactRootContainer","onclick","beforeChild","insertInContainerBefore","createEvent","bubbles","document","initEvent","target","_detachedInterceptFiber","dispatchEvent","relatedTarget","removeChild","removeChildFromContainer","clearSuspenseBoundary","suspenseInstance","depth","nextNode","nextSibling","data","clearSuspenseBoundaryFromContainer","hideInstance","style","setProperty","display","hideTextInstance","unhideInstance","styleProp","hasOwnProperty","unhideTextInstance","clearContainer","clearContainerSparingly","nodeName","textContent","element","doc","firstChild","rel","bindInstance","supportsHydration","isHydratable","precedence","async","onLoad","onError","canHydrateInstance","canHydrateTextInstance","canHydrateSuspenseInstance","isSuspenseInstancePending","isSuspenseInstanceFallback","getSuspenseInstanceFallbackErrorDetails","dataset","digest","message","stack","dgst","msg","stck","registerSuspenseInstanceRetry","_reactRetry","getNextHydratable","linkEl","hasAttribute","styleEl","scriptEl","tag","nodeData","getNextHydratableSibling","getFirstHydratableChild","getFirstHydratableChildWithinContainer","parentContainer","getFirstHydratableChildWithinSuspenseInstance","hydrateInstance","shouldWarnDev","isConcurrentMode","mode","hydrateTextInstance","hydrateSuspenseInstance","getNextHydratableInstanceAfterSuspenseInstance","getParentSuspenseInstance","targetInstance","previousSibling","commitHydratedContainer","commitHydratedSuspenseInstance","shouldDeleteUnhydratedTailInstances","parentType","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","parentProps","didNotHydrateInstanceWithinContainer","didNotHydrateInstanceWithinSuspenseInstance","didNotHydrateInstance","didNotFindHydratableInstanceWithinContainer","didNotFindHydratableTextInstanceWithinContainer","didNotFindHydratableSuspenseInstanceWithinContainer","didNotFindHydratableInstanceWithinSuspenseInstance","didNotFindHydratableTextInstanceWithinSuspenseInstance","didNotFindHydratableSuspenseInstanceWithinSuspenseInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","didNotFindHydratableSuspenseInstance","errorHydratingContainer","console","supportsTestSelectors","findFiberRoot","index","length","current","push","getBoundingRect","rect","getBoundingClientRect","x","left","y","top","width","height","matchAccessibilityRole","role","getTextContent","fiber","childNodes","stateNode","i","childNode","Node","isHiddenSubtree","memoizedProps","hidden","setFocusIfFocusable","didFocus","handleFocus","addEventListener","HTMLElement","prototype","call","removeEventListener","setupIntersectionObserver","targets","options","rectRatioCache","Map","forEach","set","ratio","handleIntersection","entries","entry","boundingClientRect","intersectionRatio","Array","from","values","observer","IntersectionObserver","observe","disconnect","unobserve","delete","requestPostPaintCallback","time","supportsResources","isHostResourceType","outsideHostContainerContext","containerTagInScope","hostContextProd","href","disabled","prepareRendererToRender","rootContainer","resetRendererAfterRender","getResource","acquireResource","releaseResource","supportsSingletons","isHostSingletonType","resolveSingletonInstance","validateDOMNestingDev","ownerDocument","Error","head","body","acquireSingletonInstance","currentInstanceHandle","attributes","removeAttributeNode","releaseSingletonInstance","clearSingleton"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {EventPriority} from 'react-reconciler/src/ReactEventPriorities';\nimport type {DOMEventName} from '../events/DOMEventNames';\nimport type {Fiber, FiberRoot} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  BoundingRect,\n  IntersectionObserverOptions,\n  ObserveVisibleRectsCallback,\n} from 'react-reconciler/src/ReactTestSelectors';\nimport type {ReactScopeInstance} from 'shared/ReactTypes';\nimport type {AncestorInfoDev} from './validateDOMNesting';\n\nimport {\n  precacheFiberNode,\n  updateFiberProps,\n  getClosestInstanceFromNode,\n  getFiberFromScopeInstance,\n  getInstanceFromNode as getInstanceFromNodeDOMTree,\n  isContainerMarkedAsRoot,\n  detachDeletedInstance,\n  isMarkedResource,\n} from './ReactDOMComponentTree';\nexport {detachDeletedInstance};\nimport {hasRole} from './DOMAccessibilityRoles';\nimport {\n  createElement,\n  createTextNode,\n  setInitialProperties,\n  diffProperties,\n  updateProperties,\n  diffHydratedProperties,\n  diffHydratedText,\n  trapClickOnNonInteractiveElement,\n  checkForUnmatchedText,\n  warnForDeletedHydratableElement,\n  warnForDeletedHydratableText,\n  warnForInsertedHydratedElement,\n  warnForInsertedHydratedText,\n  getOwnerDocumentFromRootContainer,\n} from './ReactDOMComponent';\nimport {getSelectionInformation, restoreSelection} from './ReactInputSelection';\nimport setTextContent from './setTextContent';\nimport {validateDOMNesting, updatedAncestorInfoDev} from './validateDOMNesting';\nimport {\n  isEnabled as ReactBrowserEventEmitterIsEnabled,\n  setEnabled as ReactBrowserEventEmitterSetEnabled,\n  getEventPriority,\n} from '../events/ReactDOMEventListener';\nimport {getChildNamespace, SVG_NAMESPACE} from '../shared/DOMNamespaces';\nimport {\n  ELEMENT_NODE,\n  TEXT_NODE,\n  COMMENT_NODE,\n  DOCUMENT_NODE,\n  DOCUMENT_TYPE_NODE,\n  DOCUMENT_FRAGMENT_NODE,\n} from '../shared/HTMLNodeType';\nimport dangerousStyleValue from '../shared/dangerousStyleValue';\n\nimport {retryIfBlockedOn} from '../events/ReactDOMEventReplaying';\n\nimport {\n  enableCreateEventHandleAPI,\n  enableScopeAPI,\n  enableFloat,\n  enableHostSingletons,\n} from 'shared/ReactFeatureFlags';\nimport {\n  HostComponent,\n  HostResource,\n  HostText,\n  HostSingleton,\n} from 'react-reconciler/src/ReactWorkTags';\nimport {listenToAllSupportedEvents} from '../events/DOMPluginEventSystem';\n\nimport {DefaultEventPriority} from 'react-reconciler/src/ReactEventPriorities';\n\n// TODO: Remove this deep import when we delete the legacy root API\nimport {ConcurrentMode, NoMode} from 'react-reconciler/src/ReactTypeOfMode';\n\nimport {\n  prepareToRenderResources,\n  cleanupAfterRenderResources,\n  clearRootResources,\n} from './ReactDOMFloatClient';\nimport {validateLinkPropsForStyleResource} from '../shared/ReactDOMResourceValidation';\n\nexport type Type = string;\nexport type Props = {\n  autoFocus?: boolean,\n  children?: mixed,\n  disabled?: boolean,\n  hidden?: boolean,\n  suppressHydrationWarning?: boolean,\n  dangerouslySetInnerHTML?: mixed,\n  style?: {display?: string, ...},\n  bottom?: null | number,\n  left?: null | number,\n  right?: null | number,\n  top?: null | number,\n  ...\n};\ntype RawProps = {\n  [string]: mixed,\n};\nexport type EventTargetChildElement = {\n  type: string,\n  props: null | {\n    style?: {\n      position?: string,\n      zIndex?: number,\n      bottom?: string,\n      left?: string,\n      right?: string,\n      top?: string,\n      ...\n    },\n    ...\n  },\n  ...\n};\nexport type Container =\n  | interface extends Element {_reactRootContainer?: FiberRoot}\n  | interface extends Document {_reactRootContainer?: FiberRoot}\n  | interface extends DocumentFragment {_reactRootContainer?: FiberRoot};\nexport type Instance = Element;\nexport type TextInstance = Text;\nexport interface SuspenseInstance extends Comment {\n  _reactRetry?: () => void;\n}\nexport type HydratableInstance = Instance | TextInstance | SuspenseInstance;\nexport type PublicInstance = Element | Text;\ntype HostContextDev = {\n  namespace: string,\n  ancestorInfo: AncestorInfoDev,\n};\ntype HostContextProd = string;\nexport type HostContext = HostContextDev | HostContextProd;\nexport type UpdatePayload = Array<mixed>;\nexport type ChildSet = void; // Unused\nexport type TimeoutHandle = TimeoutID;\nexport type NoTimeout = -1;\nexport type RendererInspectionConfig = $ReadOnly<{}>;\n\ntype SelectionInformation = {\n  focusedElem: null | HTMLElement,\n  selectionRange: mixed,\n};\n\nconst SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n\nconst SUSPENSE_START_DATA = '$';\nconst SUSPENSE_END_DATA = '/$';\nconst SUSPENSE_PENDING_START_DATA = '$?';\nconst SUSPENSE_FALLBACK_START_DATA = '$!';\n\nconst STYLE = 'style';\n\nlet eventsEnabled: ?boolean = null;\nlet selectionInformation: null | SelectionInformation = null;\n\nexport * from 'react-reconciler/src/ReactFiberHostConfigWithNoPersistence';\n\nexport function getRootHostContext(\n  rootContainerInstance: Container,\n): HostContext {\n  let type;\n  let namespace;\n  const nodeType = rootContainerInstance.nodeType;\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE: {\n      type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n      const root = (rootContainerInstance: any).documentElement;\n      namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n      break;\n    }\n    default: {\n      const container: any =\n        nodeType === COMMENT_NODE\n          ? rootContainerInstance.parentNode\n          : rootContainerInstance;\n      const ownNamespace = container.namespaceURI || null;\n      type = container.tagName;\n      namespace = getChildNamespace(ownNamespace, type);\n      break;\n    }\n  }\n  if (__DEV__) {\n    const validatedTag = type.toLowerCase();\n    const ancestorInfo = updatedAncestorInfoDev(null, validatedTag);\n    return {namespace, ancestorInfo};\n  }\n  return namespace;\n}\n\nexport function getChildHostContext(\n  parentHostContext: HostContext,\n  type: string,\n): HostContext {\n  if (__DEV__) {\n    const parentHostContextDev = ((parentHostContext: any): HostContextDev);\n    const namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    const ancestorInfo = updatedAncestorInfoDev(\n      parentHostContextDev.ancestorInfo,\n      type,\n    );\n    return {namespace, ancestorInfo};\n  }\n  const parentNamespace = ((parentHostContext: any): HostContextProd);\n  return getChildNamespace(parentNamespace, type);\n}\n\nexport function getPublicInstance(instance: Instance): Instance {\n  return instance;\n}\n\nexport function prepareForCommit(containerInfo: Container): Object | null {\n  eventsEnabled = ReactBrowserEventEmitterIsEnabled();\n  selectionInformation = getSelectionInformation();\n  let activeInstance = null;\n  if (enableCreateEventHandleAPI) {\n    const focusedElem = selectionInformation.focusedElem;\n    if (focusedElem !== null) {\n      activeInstance = getClosestInstanceFromNode(focusedElem);\n    }\n  }\n  ReactBrowserEventEmitterSetEnabled(false);\n  return activeInstance;\n}\n\nexport function beforeActiveInstanceBlur(internalInstanceHandle: Object): void {\n  if (enableCreateEventHandleAPI) {\n    ReactBrowserEventEmitterSetEnabled(true);\n    dispatchBeforeDetachedBlur(\n      (selectionInformation: any).focusedElem,\n      internalInstanceHandle,\n    );\n    ReactBrowserEventEmitterSetEnabled(false);\n  }\n}\n\nexport function afterActiveInstanceBlur(): void {\n  if (enableCreateEventHandleAPI) {\n    ReactBrowserEventEmitterSetEnabled(true);\n    dispatchAfterDetachedBlur((selectionInformation: any).focusedElem);\n    ReactBrowserEventEmitterSetEnabled(false);\n  }\n}\n\nexport function resetAfterCommit(containerInfo: Container): void {\n  restoreSelection(selectionInformation);\n  ReactBrowserEventEmitterSetEnabled(eventsEnabled);\n  eventsEnabled = null;\n  selectionInformation = null;\n}\n\nexport function createInstance(\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): Instance {\n  let parentNamespace: string;\n  if (__DEV__) {\n    // TODO: take namespace into account when validating.\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n    if (\n      typeof props.children === 'string' ||\n      typeof props.children === 'number'\n    ) {\n      const string = '' + props.children;\n      const ownAncestorInfo = updatedAncestorInfoDev(\n        hostContextDev.ancestorInfo,\n        type,\n      );\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = ((hostContext: any): HostContextProd);\n  }\n  const domElement: Instance = createElement(\n    type,\n    props,\n    rootContainerInstance,\n    parentNamespace,\n  );\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\n\nexport function appendInitialChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\nexport function finalizeInitialChildren(\n  domElement: Instance,\n  type: string,\n  props: Props,\n  hostContext: HostContext,\n): boolean {\n  setInitialProperties(domElement, type, props);\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n    case 'img':\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport function prepareUpdate(\n  domElement: Instance,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  hostContext: HostContext,\n): null | Array<mixed> {\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    if (\n      typeof newProps.children !== typeof oldProps.children &&\n      (typeof newProps.children === 'string' ||\n        typeof newProps.children === 'number')\n    ) {\n      const string = '' + newProps.children;\n      const ownAncestorInfo = updatedAncestorInfoDev(\n        hostContextDev.ancestorInfo,\n        type,\n      );\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n  return diffProperties(domElement, type, oldProps, newProps);\n}\n\nexport function shouldSetTextContent(type: string, props: Props): boolean {\n  return (\n    type === 'textarea' ||\n    type === 'noscript' ||\n    typeof props.children === 'string' ||\n    typeof props.children === 'number' ||\n    (typeof props.dangerouslySetInnerHTML === 'object' &&\n      props.dangerouslySetInnerHTML !== null &&\n      props.dangerouslySetInnerHTML.__html != null)\n  );\n}\n\nexport function createTextInstance(\n  text: string,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n): TextInstance {\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n  const textNode: TextInstance = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\n\nexport function getCurrentEventPriority(): EventPriority {\n  const currentEvent = window.event;\n  if (currentEvent === undefined) {\n    return DefaultEventPriority;\n  }\n  return getEventPriority(currentEvent.type);\n}\n\nexport const isPrimaryRenderer = true;\nexport const warnsIfNotActing = true;\n// This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nexport const scheduleTimeout: any =\n  typeof setTimeout === 'function' ? setTimeout : (undefined: any);\nexport const cancelTimeout: any =\n  typeof clearTimeout === 'function' ? clearTimeout : (undefined: any);\nexport const noTimeout = -1;\nconst localPromise = typeof Promise === 'function' ? Promise : undefined;\nconst localRequestAnimationFrame =\n  typeof requestAnimationFrame === 'function'\n    ? requestAnimationFrame\n    : scheduleTimeout;\n\nexport function getInstanceFromNode(node: HTMLElement): null | Object {\n  return getClosestInstanceFromNode(node) || null;\n}\n\nexport function preparePortalMount(portalInstance: Instance): void {\n  listenToAllSupportedEvents(portalInstance);\n}\n\nexport function prepareScopeUpdate(\n  scopeInstance: ReactScopeInstance,\n  internalInstanceHandle: Object,\n): void {\n  if (enableScopeAPI) {\n    precacheFiberNode(internalInstanceHandle, scopeInstance);\n  }\n}\n\nexport function getInstanceFromScope(\n  scopeInstance: ReactScopeInstance,\n): null | Object {\n  if (enableScopeAPI) {\n    return getFiberFromScopeInstance(scopeInstance);\n  }\n  return null;\n}\n\n// -------------------\n//     Microtasks\n// -------------------\nexport const supportsMicrotasks = true;\nexport const scheduleMicrotask: any =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : typeof localPromise !== 'undefined'\n    ? callback =>\n        localPromise\n          .resolve(null)\n          .then(callback)\n          .catch(handleErrorInNextTick)\n    : scheduleTimeout; // TODO: Determine the best fallback here.\n\nfunction handleErrorInNextTick(error) {\n  setTimeout(() => {\n    throw error;\n  });\n}\n\n// -------------------\n//     Mutation\n// -------------------\n\nexport const supportsMutation = true;\n\nexport function commitMount(\n  domElement: Instance,\n  type: string,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      if (newProps.autoFocus) {\n        ((domElement: any):\n          | HTMLButtonElement\n          | HTMLInputElement\n          | HTMLSelectElement\n          | HTMLTextAreaElement).focus();\n      }\n      return;\n    case 'img': {\n      if ((newProps: any).src) {\n        ((domElement: any): HTMLImageElement).src = (newProps: any).src;\n      }\n      return;\n    }\n  }\n}\n\nexport function commitUpdate(\n  domElement: Instance,\n  updatePayload: Array<mixed>,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps);\n}\n\nexport function resetTextContent(domElement: Instance): void {\n  setTextContent(domElement, '');\n}\n\nexport function commitTextUpdate(\n  textInstance: TextInstance,\n  oldText: string,\n  newText: string,\n): void {\n  textInstance.nodeValue = newText;\n}\n\nexport function appendChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\nexport function appendChildToContainer(\n  container: Container,\n  child: Instance | TextInstance,\n): void {\n  let parentNode;\n  if (container.nodeType === COMMENT_NODE) {\n    parentNode = (container.parentNode: any);\n    parentNode.insertBefore(child, container);\n  } else {\n    parentNode = container;\n    parentNode.appendChild(child);\n  }\n  // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that non React root containers have inline onclick\n  // defined.\n  // https://github.com/facebook/react/issues/11918\n  const reactRootContainer = container._reactRootContainer;\n  if (\n    (reactRootContainer === null || reactRootContainer === undefined) &&\n    parentNode.onclick === null\n  ) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(((parentNode: any): HTMLElement));\n  }\n}\n\nexport function insertBefore(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.insertBefore(child, beforeChild);\n}\n\nexport function insertInContainerBefore(\n  container: Container,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    (container.parentNode: any).insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nfunction createEvent(type: DOMEventName, bubbles: boolean): Event {\n  const event = document.createEvent('Event');\n  event.initEvent(((type: any): string), bubbles, false);\n  return event;\n}\n\nfunction dispatchBeforeDetachedBlur(\n  target: HTMLElement,\n  internalInstanceHandle: Object,\n): void {\n  if (enableCreateEventHandleAPI) {\n    const event = createEvent('beforeblur', true);\n    // Dispatch \"beforeblur\" directly on the target,\n    // so it gets picked up by the event system and\n    // can propagate through the React internal tree.\n    // $FlowFixMe: internal field\n    event._detachedInterceptFiber = internalInstanceHandle;\n    target.dispatchEvent(event);\n  }\n}\n\nfunction dispatchAfterDetachedBlur(target: HTMLElement): void {\n  if (enableCreateEventHandleAPI) {\n    const event = createEvent('afterblur', false);\n    // So we know what was detached, make the relatedTarget the\n    // detached target on the \"afterblur\" event.\n    (event: any).relatedTarget = target;\n    // Dispatch the event on the document.\n    document.dispatchEvent(event);\n  }\n}\n\nexport function removeChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.removeChild(child);\n}\n\nexport function removeChildFromContainer(\n  container: Container,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    (container.parentNode: any).removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\n\nexport function clearSuspenseBoundary(\n  parentInstance: Instance,\n  suspenseInstance: SuspenseInstance,\n): void {\n  let node: Node = suspenseInstance;\n  // Delete all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  do {\n    const nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n      const data = ((nextNode: any).data: string);\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          parentInstance.removeChild(nextNode);\n          // Retry if any event replaying was blocked on this.\n          retryIfBlockedOn(suspenseInstance);\n          return;\n        } else {\n          depth--;\n        }\n      } else if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA\n      ) {\n        depth++;\n      }\n    }\n    // $FlowFixMe[incompatible-type] we bail out when we get a null\n    node = nextNode;\n  } while (node);\n  // TODO: Warn, we didn't find the end comment boundary.\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(suspenseInstance);\n}\n\nexport function clearSuspenseBoundaryFromContainer(\n  container: Container,\n  suspenseInstance: SuspenseInstance,\n): void {\n  if (container.nodeType === COMMENT_NODE) {\n    clearSuspenseBoundary((container.parentNode: any), suspenseInstance);\n  } else if (container.nodeType === ELEMENT_NODE) {\n    clearSuspenseBoundary((container: any), suspenseInstance);\n  } else {\n    // Document nodes should never contain suspense boundaries.\n  }\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(container);\n}\n\nexport function hideInstance(instance: Instance): void {\n  // TODO: Does this work for all element types? What about MathML? Should we\n  // pass host context to this method?\n  instance = ((instance: any): HTMLElement);\n  const style = instance.style;\n  // $FlowFixMe[method-unbinding]\n  if (typeof style.setProperty === 'function') {\n    style.setProperty('display', 'none', 'important');\n  } else {\n    style.display = 'none';\n  }\n}\n\nexport function hideTextInstance(textInstance: TextInstance): void {\n  textInstance.nodeValue = '';\n}\n\nexport function unhideInstance(instance: Instance, props: Props): void {\n  instance = ((instance: any): HTMLElement);\n  const styleProp = props[STYLE];\n  const display =\n    styleProp !== undefined &&\n    styleProp !== null &&\n    styleProp.hasOwnProperty('display')\n      ? styleProp.display\n      : null;\n  instance.style.display = dangerousStyleValue('display', display);\n}\n\nexport function unhideTextInstance(\n  textInstance: TextInstance,\n  text: string,\n): void {\n  textInstance.nodeValue = text;\n}\n\nexport function clearContainer(container: Container): void {\n  if (enableHostSingletons) {\n    const nodeType = container.nodeType;\n    if (nodeType === DOCUMENT_NODE) {\n      clearRootResources(container);\n      clearContainerSparingly(container);\n    } else if (nodeType === ELEMENT_NODE) {\n      switch (container.nodeName) {\n        case 'HEAD': {\n          // If we are clearing document.head as a container we are essentially clearing everything\n          // that was hoisted to the head and should forget the instances that will no longer be in the DOM\n          clearRootResources(container);\n          // fall through to clear child contents\n        }\n        // eslint-disable-next-line-no-fallthrough\n        case 'HTML':\n        case 'BODY':\n          clearContainerSparingly(container);\n          return;\n        default: {\n          container.textContent = '';\n        }\n      }\n    }\n  } else {\n    if (container.nodeType === ELEMENT_NODE) {\n      // We have refined the container to Element type\n      const element: Element = (container: any);\n      element.textContent = '';\n    } else if (container.nodeType === DOCUMENT_NODE) {\n      // We have refined the container to Document type\n      const doc: Document = (container: any);\n      if (doc.documentElement) {\n        doc.removeChild(doc.documentElement);\n      }\n    }\n  }\n}\n\nfunction clearContainerSparingly(container: Node) {\n  let node;\n  let nextNode: ?Node = container.firstChild;\n  if (nextNode && nextNode.nodeType === DOCUMENT_TYPE_NODE) {\n    nextNode = nextNode.nextSibling;\n  }\n  while (nextNode) {\n    node = nextNode;\n    nextNode = nextNode.nextSibling;\n    switch (node.nodeName) {\n      case 'HTML':\n      case 'HEAD':\n      case 'BODY': {\n        const element: Element = (node: any);\n        clearContainerSparingly(element);\n        // If these singleton instances had previously been rendered with React they\n        // may still hold on to references to the previous fiber tree. We detatch them\n        // prospectively to reset them to a baseline starting state since we cannot create\n        // new instances.\n        detachDeletedInstance(element);\n        continue;\n      }\n      case 'STYLE': {\n        continue;\n      }\n      case 'LINK': {\n        if (((node: any): HTMLLinkElement).rel.toLowerCase() === 'stylesheet') {\n          continue;\n        }\n      }\n    }\n    container.removeChild(node);\n  }\n  return;\n}\n\n// Making this so we can eventually move all of the instance caching to the commit phase.\n// Currently this is only used to associate fiber and props to instances for hydrating\n// HostSingletons. The reason we need it here is we only want to make this binding on commit\n// because only one fiber can own the instance at a time and render can fail/restart\nexport function bindInstance(\n  instance: Instance,\n  props: Props,\n  internalInstanceHandle: mixed,\n) {\n  precacheFiberNode((internalInstanceHandle: any), instance);\n  updateFiberProps(instance, props);\n}\n\n// -------------------\n//     Hydration\n// -------------------\n\nexport const supportsHydration = true;\n\n// With Resources, some HostComponent types will never be server rendered and need to be\n// inserted without breaking hydration\nexport function isHydratable(type: string, props: Props): boolean {\n  if (enableFloat) {\n    if (type === 'link') {\n      if (\n        (props: any).rel === 'stylesheet' &&\n        typeof (props: any).precedence !== 'string'\n      ) {\n        return true;\n      }\n      return false;\n    } else if (type === 'script') {\n      const {async, onLoad, onError} = (props: any);\n      return !(async && (onLoad || onError));\n    }\n    return true;\n  } else {\n    return true;\n  }\n}\n\nexport function canHydrateInstance(\n  instance: HydratableInstance,\n  type: string,\n  props: Props,\n): null | Instance {\n  if (\n    instance.nodeType !== ELEMENT_NODE ||\n    type.toLowerCase() !== instance.nodeName.toLowerCase()\n  ) {\n    return null;\n  }\n  // This has now been refined to an element node.\n  return ((instance: any): Instance);\n}\n\nexport function canHydrateTextInstance(\n  instance: HydratableInstance,\n  text: string,\n): null | TextInstance {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a text node.\n  return ((instance: any): TextInstance);\n}\n\nexport function canHydrateSuspenseInstance(\n  instance: HydratableInstance,\n): null | SuspenseInstance {\n  if (instance.nodeType !== COMMENT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a suspense node.\n  return ((instance: any): SuspenseInstance);\n}\n\nexport function isSuspenseInstancePending(instance: SuspenseInstance): boolean {\n  return instance.data === SUSPENSE_PENDING_START_DATA;\n}\n\nexport function isSuspenseInstanceFallback(\n  instance: SuspenseInstance,\n): boolean {\n  return instance.data === SUSPENSE_FALLBACK_START_DATA;\n}\n\nexport function getSuspenseInstanceFallbackErrorDetails(\n  instance: SuspenseInstance,\n): {digest: ?string, message?: string, stack?: string} {\n  const dataset =\n    instance.nextSibling && ((instance.nextSibling: any): HTMLElement).dataset;\n  let digest, message, stack;\n  if (dataset) {\n    digest = dataset.dgst;\n    if (__DEV__) {\n      message = dataset.msg;\n      stack = dataset.stck;\n    }\n  }\n  if (__DEV__) {\n    return {\n      message,\n      digest,\n      stack,\n    };\n  } else {\n    // Object gets DCE'd if constructed in tail position and matches callsite destructuring\n    return {\n      digest,\n    };\n  }\n}\n\nexport function registerSuspenseInstanceRetry(\n  instance: SuspenseInstance,\n  callback: () => void,\n) {\n  instance._reactRetry = callback;\n}\n\nfunction getNextHydratable(node) {\n  // Skip non-hydratable nodes.\n  for (; node != null; node = ((node: any): Node).nextSibling) {\n    const nodeType = node.nodeType;\n    if (enableFloat && enableHostSingletons) {\n      if (nodeType === ELEMENT_NODE) {\n        const element: Element = (node: any);\n        switch (element.tagName) {\n          // This is subtle. in SVG scope the title tag is case sensitive. we don't want to skip\n          // titles in svg but we do want to skip them outside of svg. there is an edge case where\n          // you could do `React.createElement('TITLE', ...)` inside an svg scope but the SSR serializer\n          // will still emit lowercase. Practically speaking the only time the DOM will have a non-uppercased\n          // title tagName is if it is inside an svg.\n          // Other Resource types like META, BASE, LINK, and SCRIPT should be treated as resources even inside\n          // svg scope because they are invalid otherwise. We still don't need to handle the lowercase variant\n          // because if they are present in the DOM already they would have been hoisted outside the SVG scope\n          // as Resources. So while it would be correct to skip a <link> inside <svg> and this algorithm won't\n          // skip that link because the tagName will not be uppercased it functionally is irrelevant. If one\n          // tries to render incompatible types such as a non-resource stylesheet inside an svg the server will\n          // emit that invalid html and hydration will fail. In Dev this will present warnings guiding the\n          // developer on how to fix.\n          case 'TITLE':\n          case 'META':\n          case 'BASE':\n          case 'HTML':\n          case 'HEAD':\n          case 'BODY': {\n            continue;\n          }\n          case 'LINK': {\n            const linkEl: HTMLLinkElement = (element: any);\n            // All links that are server rendered are resources except\n            // stylesheets that do not have a precedence\n            if (\n              linkEl.rel === 'stylesheet' &&\n              !linkEl.hasAttribute('data-precedence')\n            ) {\n              break;\n            }\n            continue;\n          }\n          case 'STYLE': {\n            const styleEl: HTMLStyleElement = (element: any);\n            if (styleEl.hasAttribute('data-precedence')) {\n              continue;\n            }\n            break;\n          }\n          case 'SCRIPT': {\n            const scriptEl: HTMLScriptElement = (element: any);\n            if (scriptEl.hasAttribute('async')) {\n              continue;\n            }\n            break;\n          }\n        }\n        break;\n      } else if (nodeType === TEXT_NODE) {\n        break;\n      }\n    } else if (enableFloat) {\n      if (nodeType === ELEMENT_NODE) {\n        const element: Element = (node: any);\n        switch (element.tagName) {\n          case 'TITLE':\n          case 'META':\n          case 'BASE': {\n            continue;\n          }\n          case 'LINK': {\n            const linkEl: HTMLLinkElement = (element: any);\n            // All links that are server rendered are resources except\n            // stylesheets that do not have a precedence\n            if (\n              linkEl.rel === 'stylesheet' &&\n              !linkEl.hasAttribute('data-precedence')\n            ) {\n              break;\n            }\n            continue;\n          }\n          case 'STYLE': {\n            const styleEl: HTMLStyleElement = (element: any);\n            if (styleEl.hasAttribute('data-precedence')) {\n              continue;\n            }\n            break;\n          }\n          case 'SCRIPT': {\n            const scriptEl: HTMLScriptElement = (element: any);\n            if (scriptEl.hasAttribute('async')) {\n              continue;\n            }\n            break;\n          }\n        }\n        break;\n      } else if (nodeType === TEXT_NODE) {\n        break;\n      }\n    } else if (enableHostSingletons) {\n      if (nodeType === ELEMENT_NODE) {\n        const tag: string = (node: any).tagName;\n        if (tag === 'HTML' || tag === 'HEAD' || tag === 'BODY') {\n          continue;\n        }\n        break;\n      } else if (nodeType === TEXT_NODE) {\n        break;\n      }\n    } else {\n      if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n        break;\n      }\n    }\n    if (nodeType === COMMENT_NODE) {\n      const nodeData = (node: any).data;\n      if (\n        nodeData === SUSPENSE_START_DATA ||\n        nodeData === SUSPENSE_FALLBACK_START_DATA ||\n        nodeData === SUSPENSE_PENDING_START_DATA\n      ) {\n        break;\n      }\n      if (nodeData === SUSPENSE_END_DATA) {\n        return null;\n      }\n    }\n  }\n  return (node: any);\n}\n\nexport function getNextHydratableSibling(\n  instance: HydratableInstance,\n): null | HydratableInstance {\n  return getNextHydratable(instance.nextSibling);\n}\n\nexport function getFirstHydratableChild(\n  parentInstance: Instance,\n): null | HydratableInstance {\n  return getNextHydratable(parentInstance.firstChild);\n}\n\nexport function getFirstHydratableChildWithinContainer(\n  parentContainer: Container,\n): null | HydratableInstance {\n  return getNextHydratable(parentContainer.firstChild);\n}\n\nexport function getFirstHydratableChildWithinSuspenseInstance(\n  parentInstance: SuspenseInstance,\n): null | HydratableInstance {\n  return getNextHydratable(parentInstance.nextSibling);\n}\n\nexport function hydrateInstance(\n  instance: Instance,\n  type: string,\n  props: Props,\n  hostContext: HostContext,\n  internalInstanceHandle: Object,\n  shouldWarnDev: boolean,\n): null | Array<mixed> {\n  precacheFiberNode(internalInstanceHandle, instance);\n  // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n  updateFiberProps(instance, props);\n  let parentNamespace: string;\n  if (__DEV__) {\n    const hostContextDev = ((hostContext: any): HostContextDev);\n    parentNamespace = hostContextDev.namespace;\n  } else {\n    parentNamespace = ((hostContext: any): HostContextProd);\n  }\n\n  // TODO: Temporary hack to check if we're in a concurrent root. We can delete\n  // when the legacy root API is removed.\n  const isConcurrentMode =\n    ((internalInstanceHandle: Fiber).mode & ConcurrentMode) !== NoMode;\n\n  return diffHydratedProperties(\n    instance,\n    type,\n    props,\n    parentNamespace,\n    isConcurrentMode,\n    shouldWarnDev,\n  );\n}\n\nexport function hydrateTextInstance(\n  textInstance: TextInstance,\n  text: string,\n  internalInstanceHandle: Object,\n  shouldWarnDev: boolean,\n): boolean {\n  precacheFiberNode(internalInstanceHandle, textInstance);\n\n  // TODO: Temporary hack to check if we're in a concurrent root. We can delete\n  // when the legacy root API is removed.\n  const isConcurrentMode =\n    ((internalInstanceHandle: Fiber).mode & ConcurrentMode) !== NoMode;\n\n  return diffHydratedText(textInstance, text, isConcurrentMode);\n}\n\nexport function hydrateSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n  internalInstanceHandle: Object,\n) {\n  precacheFiberNode(internalInstanceHandle, suspenseInstance);\n}\n\nexport function getNextHydratableInstanceAfterSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n): null | HydratableInstance {\n  let node = suspenseInstance.nextSibling;\n  // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      const data = ((node: any).data: string);\n      if (data === SUSPENSE_END_DATA) {\n        if (depth === 0) {\n          return getNextHydratableSibling((node: any));\n        } else {\n          depth--;\n        }\n      } else if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA\n      ) {\n        depth++;\n      }\n    }\n    node = node.nextSibling;\n  }\n  // TODO: Warn, we didn't find the end comment boundary.\n  return null;\n}\n\n// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nexport function getParentSuspenseInstance(\n  targetInstance: Node,\n): null | SuspenseInstance {\n  let node = targetInstance.previousSibling;\n  // Skip past all nodes within this suspense boundary.\n  // There might be nested nodes so we need to keep track of how\n  // deep we are and only break out when we're back on top.\n  let depth = 0;\n  while (node) {\n    if (node.nodeType === COMMENT_NODE) {\n      const data = ((node: any).data: string);\n      if (\n        data === SUSPENSE_START_DATA ||\n        data === SUSPENSE_FALLBACK_START_DATA ||\n        data === SUSPENSE_PENDING_START_DATA\n      ) {\n        if (depth === 0) {\n          return ((node: any): SuspenseInstance);\n        } else {\n          depth--;\n        }\n      } else if (data === SUSPENSE_END_DATA) {\n        depth++;\n      }\n    }\n    node = node.previousSibling;\n  }\n  return null;\n}\n\nexport function commitHydratedContainer(container: Container): void {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(container);\n}\n\nexport function commitHydratedSuspenseInstance(\n  suspenseInstance: SuspenseInstance,\n): void {\n  // Retry if any event replaying was blocked on this.\n  retryIfBlockedOn(suspenseInstance);\n}\n\n// @TODO remove this function once float lands and hydrated tail nodes\n// are controlled by HostSingleton fibers\nexport function shouldDeleteUnhydratedTailInstances(\n  parentType: string,\n): boolean {\n  return parentType !== 'head' && parentType !== 'body';\n}\n\nexport function didNotMatchHydratedContainerTextInstance(\n  parentContainer: Container,\n  textInstance: TextInstance,\n  text: string,\n  isConcurrentMode: boolean,\n  shouldWarnDev: boolean,\n) {\n  checkForUnmatchedText(\n    textInstance.nodeValue,\n    text,\n    isConcurrentMode,\n    shouldWarnDev,\n  );\n}\n\nexport function didNotMatchHydratedTextInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  textInstance: TextInstance,\n  text: string,\n  isConcurrentMode: boolean,\n  shouldWarnDev: boolean,\n) {\n  if (parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    checkForUnmatchedText(\n      textInstance.nodeValue,\n      text,\n      isConcurrentMode,\n      shouldWarnDev,\n    );\n  }\n}\n\nexport function didNotHydrateInstanceWithinContainer(\n  parentContainer: Container,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, (instance: any));\n    } else if (instance.nodeType === COMMENT_NODE) {\n      // TODO: warnForDeletedHydratableSuspenseBoundary\n    } else {\n      warnForDeletedHydratableText(parentContainer, (instance: any));\n    }\n  }\n}\n\nexport function didNotHydrateInstanceWithinSuspenseInstance(\n  parentInstance: SuspenseInstance,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode: Element | Document | null = parentInstance.parentNode;\n    if (parentNode !== null) {\n      if (instance.nodeType === ELEMENT_NODE) {\n        warnForDeletedHydratableElement(parentNode, (instance: any));\n      } else if (instance.nodeType === COMMENT_NODE) {\n        // TODO: warnForDeletedHydratableSuspenseBoundary\n      } else {\n        warnForDeletedHydratableText(parentNode, (instance: any));\n      }\n    }\n  }\n}\n\nexport function didNotHydrateInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  instance: HydratableInstance,\n  isConcurrentMode: boolean,\n) {\n  if (__DEV__) {\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n      if (instance.nodeType === ELEMENT_NODE) {\n        warnForDeletedHydratableElement(parentInstance, (instance: any));\n      } else if (instance.nodeType === COMMENT_NODE) {\n        // TODO: warnForDeletedHydratableSuspenseBoundary\n      } else {\n        warnForDeletedHydratableText(parentInstance, (instance: any));\n      }\n    }\n  }\n}\n\nexport function didNotFindHydratableInstanceWithinContainer(\n  parentContainer: Container,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__) {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\n\nexport function didNotFindHydratableTextInstanceWithinContainer(\n  parentContainer: Container,\n  text: string,\n) {\n  if (__DEV__) {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\n\nexport function didNotFindHydratableSuspenseInstanceWithinContainer(\n  parentContainer: Container,\n) {\n  if (__DEV__) {\n    // TODO: warnForInsertedHydratedSuspense(parentContainer);\n  }\n}\n\nexport function didNotFindHydratableInstanceWithinSuspenseInstance(\n  parentInstance: SuspenseInstance,\n  type: string,\n  props: Props,\n) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode: Element | Document | null = parentInstance.parentNode;\n    if (parentNode !== null)\n      warnForInsertedHydratedElement(parentNode, type, props);\n  }\n}\n\nexport function didNotFindHydratableTextInstanceWithinSuspenseInstance(\n  parentInstance: SuspenseInstance,\n  text: string,\n) {\n  if (__DEV__) {\n    // $FlowFixMe: Only Element or Document can be parent nodes.\n    const parentNode: Element | Document | null = parentInstance.parentNode;\n    if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);\n  }\n}\n\nexport function didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(\n  parentInstance: SuspenseInstance,\n) {\n  if (__DEV__) {\n    // const parentNode: Element | Document | null = parentInstance.parentNode;\n    // TODO: warnForInsertedHydratedSuspense(parentNode);\n  }\n}\n\nexport function didNotFindHydratableInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  type: string,\n  props: Props,\n  isConcurrentMode: boolean,\n) {\n  if (__DEV__) {\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n      warnForInsertedHydratedElement(parentInstance, type, props);\n    }\n  }\n}\n\nexport function didNotFindHydratableTextInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n  text: string,\n  isConcurrentMode: boolean,\n) {\n  if (__DEV__) {\n    if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n      warnForInsertedHydratedText(parentInstance, text);\n    }\n  }\n}\n\nexport function didNotFindHydratableSuspenseInstance(\n  parentType: string,\n  parentProps: Props,\n  parentInstance: Instance,\n) {\n  if (__DEV__) {\n    // TODO: warnForInsertedHydratedSuspense(parentInstance);\n  }\n}\n\nexport function errorHydratingContainer(parentContainer: Container): void {\n  if (__DEV__) {\n    // TODO: This gets logged by onRecoverableError, too, so we should be\n    // able to remove it.\n    console.error(\n      'An error occurred during hydration. The server HTML was replaced with client content in <%s>.',\n      parentContainer.nodeName.toLowerCase(),\n    );\n  }\n}\n\n// -------------------\n//     Test Selectors\n// -------------------\n\nexport const supportsTestSelectors = true;\n\nexport function findFiberRoot(node: Instance): null | FiberRoot {\n  const stack = [node];\n  let index = 0;\n  while (index < stack.length) {\n    const current = stack[index++];\n    if (isContainerMarkedAsRoot(current)) {\n      return ((getInstanceFromNodeDOMTree(current): any): FiberRoot);\n    }\n    stack.push(...current.children);\n  }\n  return null;\n}\n\nexport function getBoundingRect(node: Instance): BoundingRect {\n  const rect = node.getBoundingClientRect();\n  return {\n    x: rect.left,\n    y: rect.top,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n\nexport function matchAccessibilityRole(node: Instance, role: string): boolean {\n  if (hasRole(node, role)) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function getTextContent(fiber: Fiber): string | null {\n  switch (fiber.tag) {\n    case HostResource:\n    case HostSingleton:\n    case HostComponent:\n      let textContent = '';\n      const childNodes = fiber.stateNode.childNodes;\n      for (let i = 0; i < childNodes.length; i++) {\n        const childNode = childNodes[i];\n        if (childNode.nodeType === Node.TEXT_NODE) {\n          textContent += childNode.textContent;\n        }\n      }\n      return textContent;\n    case HostText:\n      return fiber.stateNode.textContent;\n  }\n\n  return null;\n}\n\nexport function isHiddenSubtree(fiber: Fiber): boolean {\n  return fiber.tag === HostComponent && fiber.memoizedProps.hidden === true;\n}\n\nexport function setFocusIfFocusable(node: Instance): boolean {\n  // The logic for determining if an element is focusable is kind of complex,\n  // and since we want to actually change focus anyway- we can just skip it.\n  // Instead we'll just listen for a \"focus\" event to verify that focus was set.\n  //\n  // We could compare the node to document.activeElement after focus,\n  // but this would not handle the case where application code managed focus to automatically blur.\n  let didFocus = false;\n  const handleFocus = () => {\n    didFocus = true;\n  };\n\n  const element = ((node: any): HTMLElement);\n  try {\n    element.addEventListener('focus', handleFocus);\n    // $FlowFixMe[method-unbinding]\n    (element.focus || HTMLElement.prototype.focus).call(element);\n  } finally {\n    element.removeEventListener('focus', handleFocus);\n  }\n\n  return didFocus;\n}\n\ntype RectRatio = {\n  ratio: number,\n  rect: BoundingRect,\n};\n\nexport function setupIntersectionObserver(\n  targets: Array<Instance>,\n  callback: ObserveVisibleRectsCallback,\n  options?: IntersectionObserverOptions,\n): {\n  disconnect: () => void,\n  observe: (instance: Instance) => void,\n  unobserve: (instance: Instance) => void,\n} {\n  const rectRatioCache: Map<Instance, RectRatio> = new Map();\n  targets.forEach(target => {\n    rectRatioCache.set(target, {\n      rect: getBoundingRect(target),\n      ratio: 0,\n    });\n  });\n\n  const handleIntersection = (entries: Array<IntersectionObserverEntry>) => {\n    entries.forEach(entry => {\n      const {boundingClientRect, intersectionRatio, target} = entry;\n      rectRatioCache.set(target, {\n        rect: {\n          x: boundingClientRect.left,\n          y: boundingClientRect.top,\n          width: boundingClientRect.width,\n          height: boundingClientRect.height,\n        },\n        ratio: intersectionRatio,\n      });\n    });\n\n    callback(Array.from(rectRatioCache.values()));\n  };\n\n  const observer = new IntersectionObserver(handleIntersection, options);\n  targets.forEach(target => {\n    observer.observe((target: any));\n  });\n\n  return {\n    disconnect: () => observer.disconnect(),\n    observe: target => {\n      rectRatioCache.set(target, {\n        rect: getBoundingRect(target),\n        ratio: 0,\n      });\n      observer.observe((target: any));\n    },\n    unobserve: target => {\n      rectRatioCache.delete(target);\n      observer.unobserve((target: any));\n    },\n  };\n}\n\nexport function requestPostPaintCallback(callback: (time: number) => void) {\n  localRequestAnimationFrame(() => {\n    localRequestAnimationFrame(time => callback(time));\n  });\n}\n// -------------------\n//     Resources\n// -------------------\n\nexport const supportsResources = true;\n\nexport function isHostResourceType(\n  type: string,\n  props: RawProps,\n  hostContext: HostContext,\n): boolean {\n  let outsideHostContainerContext: boolean;\n  let namespace: string;\n  if (__DEV__) {\n    const hostContextDev: HostContextDev = (hostContext: any);\n    // We can only render resources when we are not within the host container context\n    outsideHostContainerContext = !hostContextDev.ancestorInfo\n      .containerTagInScope;\n    namespace = hostContextDev.namespace;\n  } else {\n    const hostContextProd: HostContextProd = (hostContext: any);\n    namespace = hostContextProd;\n  }\n  switch (type) {\n    case 'base':\n    case 'meta': {\n      return true;\n    }\n    case 'title': {\n      return namespace !== SVG_NAMESPACE;\n    }\n    case 'link': {\n      const {onLoad, onError} = props;\n      if (onLoad || onError) {\n        if (__DEV__) {\n          if (outsideHostContainerContext) {\n            console.error(\n              'Cannot render a <link> with onLoad or onError listeners outside the main document.' +\n                ' Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or' +\n                ' somewhere in the <body>.',\n            );\n          } else if (namespace === SVG_NAMESPACE) {\n            console.error(\n              'Cannot render a <link> with onLoad or onError listeners as a descendent of <svg>.' +\n                ' Try removing onLoad={...} and onError={...} or moving it above the <svg> ancestor.',\n            );\n          }\n        }\n        return false;\n      }\n      switch (props.rel) {\n        case 'stylesheet': {\n          const {href, precedence, disabled} = props;\n          if (__DEV__) {\n            validateLinkPropsForStyleResource(props);\n            if (typeof precedence !== 'string') {\n              if (outsideHostContainerContext) {\n                console.error(\n                  'Cannot render a <link rel=\"stylesheet\" /> outside the main document without knowing its precedence.' +\n                    ' Consider adding precedence=\"default\" or moving it into the root <head> tag.',\n                );\n              } else if (namespace === SVG_NAMESPACE) {\n                console.error(\n                  'Cannot render a <link rel=\"stylesheet\" /> as a descendent of an <svg> element without knowing its precedence.' +\n                    ' Consider adding precedence=\"default\" or moving it above the <svg> ancestor.',\n                );\n              }\n            }\n          }\n          return (\n            typeof href === 'string' &&\n            typeof precedence === 'string' &&\n            disabled == null\n          );\n        }\n        default: {\n          const {rel, href} = props;\n          return typeof href === 'string' && typeof rel === 'string';\n        }\n      }\n    }\n    case 'script': {\n      // We don't validate because it is valid to use async with onLoad/onError unlike combining\n      // precedence with these for style resources\n      const {src, async, onLoad, onError} = props;\n      if (__DEV__) {\n        if (async !== true) {\n          if (outsideHostContainerContext) {\n            console.error(\n              'Cannot render a sync or defer <script> outside the main document without knowing its order.' +\n                ' Try adding async=\"\" or moving it into the root <head> tag.',\n            );\n          } else if (namespace === SVG_NAMESPACE) {\n            console.error(\n              'Cannot render a sync or defer <script> as a descendent of an <svg> element.' +\n                ' Try adding async=\"\" or moving it above the ancestor <svg> element.',\n            );\n          }\n        } else if (onLoad || onError) {\n          if (outsideHostContainerContext) {\n            console.error(\n              'Cannot render a <script> with onLoad or onError listeners outside the main document.' +\n                ' Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or' +\n                ' somewhere in the <body>.',\n            );\n          } else if (namespace === SVG_NAMESPACE) {\n            console.error(\n              'Cannot render a <script> with onLoad or onError listeners as a descendent of an <svg> element.' +\n                ' Try removing onLoad={...} and onError={...} or moving it above the ancestor <svg> element.',\n            );\n          }\n        }\n      }\n      return (async: any) && typeof src === 'string' && !onLoad && !onError;\n    }\n    case 'noscript':\n    case 'template':\n    case 'style': {\n      if (__DEV__) {\n        if (outsideHostContainerContext) {\n          console.error(\n            'Cannot render <%s> outside the main document. Try moving it into the root <head> tag.',\n            type,\n          );\n        }\n      }\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function prepareRendererToRender(rootContainer: Container) {\n  if (enableFloat) {\n    prepareToRenderResources(rootContainer);\n  }\n}\n\nexport function resetRendererAfterRender() {\n  if (enableFloat) {\n    cleanupAfterRenderResources();\n  }\n}\n\nexport {\n  getResource,\n  acquireResource,\n  releaseResource,\n} from './ReactDOMFloatClient';\n\n// -------------------\n//     Singletons\n// -------------------\n\nexport const supportsSingletons = true;\n\nexport function isHostSingletonType(type: string): boolean {\n  return type === 'html' || type === 'head' || type === 'body';\n}\n\nexport function resolveSingletonInstance(\n  type: string,\n  props: Props,\n  rootContainerInstance: Container,\n  hostContext: HostContext,\n  validateDOMNestingDev: boolean,\n): Instance {\n  if (__DEV__) {\n    if (validateDOMNestingDev) {\n      const hostContextDev = ((hostContext: any): HostContextDev);\n      validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n    }\n  }\n  const ownerDocument = getOwnerDocumentFromRootContainer(\n    rootContainerInstance,\n  );\n  switch (type) {\n    case 'html': {\n      const documentElement = ownerDocument.documentElement;\n      if (!documentElement) {\n        throw new Error(\n          'React expected an <html> element (document.documentElement) to exist in the Document but one was' +\n            ' not found. React never removes the documentElement for any Document it renders into so' +\n            ' the cause is likely in some other script running on this page.',\n        );\n      }\n      return documentElement;\n    }\n    case 'head': {\n      const head = ownerDocument.head;\n      if (!head) {\n        throw new Error(\n          'React expected a <head> element (document.head) to exist in the Document but one was' +\n            ' not found. React never removes the head for any Document it renders into so' +\n            ' the cause is likely in some other script running on this page.',\n        );\n      }\n      return head;\n    }\n    case 'body': {\n      const body = ownerDocument.body;\n      if (!body) {\n        throw new Error(\n          'React expected a <body> element (document.body) to exist in the Document but one was' +\n            ' not found. React never removes the body for any Document it renders into so' +\n            ' the cause is likely in some other script running on this page.',\n        );\n      }\n      return body;\n    }\n    default: {\n      throw new Error(\n        'resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.',\n      );\n    }\n  }\n}\n\nexport function acquireSingletonInstance(\n  type: string,\n  props: Props,\n  instance: Instance,\n  internalInstanceHandle: Object,\n): void {\n  if (__DEV__) {\n    const currentInstanceHandle = getInstanceFromNodeDOMTree(instance);\n    if (currentInstanceHandle) {\n      const tagName = instance.tagName.toLowerCase();\n      console.error(\n        'You are mounting a new %s component when a previous one has not first unmounted. It is an' +\n          ' error to render more than one %s component at a time and attributes and children of these' +\n          ' components will likely fail in unpredictable ways. Please only render a single instance of' +\n          ' <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.',\n        tagName,\n        tagName,\n        tagName,\n      );\n    }\n    switch (type) {\n      case 'html':\n      case 'head':\n      case 'body': {\n        break;\n      }\n      default: {\n        console.error(\n          'acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.',\n        );\n      }\n    }\n  }\n\n  const attributes = instance.attributes;\n  while (attributes.length) {\n    instance.removeAttributeNode(attributes[0]);\n  }\n\n  setInitialProperties(instance, type, props);\n  precacheFiberNode(internalInstanceHandle, instance);\n  updateFiberProps(instance, props);\n}\n\nexport function releaseSingletonInstance(instance: Instance): void {\n  const attributes = instance.attributes;\n  while (attributes.length) {\n    instance.removeAttributeNode(attributes[0]);\n  }\n  detachDeletedInstance(instance);\n}\n\nexport function clearSingleton(instance: Instance): void {\n  const element: Element = (instance: any);\n  let node = element.firstChild;\n  while (node) {\n    const nextNode = node.nextSibling;\n    const nodeName = node.nodeName;\n    if (\n      isMarkedResource(node) ||\n      nodeName === 'HEAD' ||\n      nodeName === 'BODY' ||\n      nodeName === 'STYLE' ||\n      (nodeName === 'LINK' &&\n        ((node: any): HTMLLinkElement).rel.toLowerCase() === 'stylesheet')\n    ) {\n      // retain these nodes\n    } else {\n      element.removeChild(node);\n    }\n    node = nextNode;\n  }\n  return;\n}\n"]},"metadata":{},"sourceType":"module"}