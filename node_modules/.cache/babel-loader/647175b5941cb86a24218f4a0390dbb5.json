{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { enableDebugTracing, enableSchedulingProfiler, enableCache, enableUseRefAccessWarning, enableLazyContextPropagation, enableUseMutableSource, enableTransitionTracing, enableUseHook, enableUseMemoCacheHook, enableUseEffectEventHook, enableLegacyCache, debugRenderPhaseSideEffectsForStrictMode } from 'shared/ReactFeatureFlags';\nimport { REACT_CONTEXT_TYPE, REACT_SERVER_CONTEXT_TYPE, REACT_MEMO_CACHE_SENTINEL } from 'shared/ReactSymbols';\nimport { NoMode, ConcurrentMode, DebugTracingMode, StrictEffectsMode, StrictLegacyMode } from './ReactTypeOfMode';\nimport { NoLane, SyncLane, OffscreenLane, NoLanes, isSubsetOfLanes, includesBlockingLane, includesOnlyNonUrgentLanes, claimNextTransitionLane, mergeLanes, removeLanes, intersectLanes, isTransitionLane, markRootEntangled, markRootMutableRead, NoTimestamp } from './ReactFiberLane';\nimport { ContinuousEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority, higherEventPriority } from './ReactEventPriorities';\nimport { readContext, checkIfContextChanged } from './ReactFiberNewContext';\nimport { HostRoot, CacheComponent } from './ReactWorkTags';\nimport { LayoutStatic as LayoutStaticEffect, Passive as PassiveEffect, PassiveStatic as PassiveStaticEffect, StaticMask as StaticMaskEffect, Update as UpdateEffect, StoreConsistency, MountLayoutDev as MountLayoutDevEffect, MountPassiveDev as MountPassiveDevEffect } from './ReactFiberFlags';\nimport { HasEffect as HookHasEffect, Layout as HookLayout, Passive as HookPassive, Insertion as HookInsertion } from './ReactHookEffectTags';\nimport { getWorkInProgressRoot, getWorkInProgressRootRenderLanes, scheduleUpdateOnFiber, requestUpdateLane, requestEventTime, markSkippedUpdateLanes, isInvalidExecutionContextForEventFunction } from './ReactFiberWorkLoop';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport is from 'shared/objectIs';\nimport isArray from 'shared/isArray';\nimport { markWorkInProgressReceivedUpdate, checkIfWorkInProgressReceivedUpdate } from './ReactFiberBeginWork';\nimport { getIsHydrating } from './ReactFiberHydrationContext';\nimport { getWorkInProgressVersion, markSourceAsDirty, setWorkInProgressVersion, warnAboutMultipleRenderersDEV } from './ReactMutableSource';\nimport { logStateUpdateScheduled } from './DebugTracing';\nimport { markStateUpdateScheduled, setIsStrictModeForDevtools } from './ReactFiberDevToolsHook';\nimport { createCache } from './ReactFiberCacheComponent';\nimport { createUpdate as createLegacyQueueUpdate, enqueueUpdate as enqueueLegacyQueueUpdate, entangleTransitions as entangleLegacyQueueTransitions } from './ReactFiberClassUpdateQueue';\nimport { enqueueConcurrentHookUpdate, enqueueConcurrentHookUpdateAndEagerlyBailout, enqueueConcurrentRenderForLane } from './ReactFiberConcurrentUpdates';\nimport { getTreeId } from './ReactFiberTreeContext';\nimport { now } from './Scheduler';\nimport { trackUsedThenable, checkIfUseWrappedInTryCatch, createThenableState } from './ReactFiberThenable';\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentBatchConfig\n} = ReactSharedInternals;\nlet didWarnAboutMismatchedHooksForComponent;\nlet didWarnUncachedGetSnapshot;\nlet didWarnAboutUseWrappedInTryCatch;\n\nif (__DEV__) {\n  didWarnAboutMismatchedHooksForComponent = new Set();\n  didWarnAboutUseWrappedInTryCatch = new Set();\n}\n\n// These are set right before calling the component.\nlet renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\n\nlet currentlyRenderingFiber = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\n\nlet currentHook = null;\nlet workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\n\nlet didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n\nlet didScheduleRenderPhaseUpdateDuringThisPass = false;\nlet shouldDoubleInvokeUserFnsInHooksDEV = false; // Counts the number of useId hooks in this component.\n\nlet localIdCounter = 0; // Counts number of `use`-d thenables\n\nlet thenableIndexCounter = 0;\nlet thenableState = null; // Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\n\nlet globalClientIdCounter = 0;\nconst RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n\nlet currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\n\nlet hookTypesDev = null;\nlet hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\n\nlet ignorePreviousDependencies = false;\n\nfunction mountHookTypesDev() {\n  if (__DEV__) {\n    const hookName = currentHookNameInDev;\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  if (__DEV__) {\n    const hookName = currentHookNameInDev;\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps) {\n  if (__DEV__) {\n    if (deps !== undefined && deps !== null && !isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      console.error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName) {\n  if (__DEV__) {\n    const componentName = getComponentNameFromFiber(currentlyRenderingFiber);\n\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        let table = '';\n        const secondColumnStart = 30;\n\n        for (let i = 0; i <= hookTypesUpdateIndexDev; i++) {\n          const oldHookName = hookTypesDev[i];\n          const newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n          let row = `${i + 1}. ${oldHookName}`; // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n          table += row;\n        }\n\n        console.error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n}\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (__DEV__) {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    if (__DEV__) {\n      console.error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n    }\n\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      console.error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, `[${prevDeps.join(', ')}]`, `[${nextDeps.join(', ')}]`);\n    }\n  } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    // $FlowFixMe[incompatible-use] found when upgrading Flow\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nexport function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber = workInProgress;\n\n  if (__DEV__) {\n    hookTypesDev = current !== null ? current._debugHookTypes : null;\n    hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n\n    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = NoLanes; // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n  // didScheduleRenderPhaseUpdate = false;\n  // localIdCounter = 0;\n  // thenableIndexCounter = 0;\n  // thenableState = null;\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n\n  if (__DEV__) {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;\n  } // In Strict Mode, during development, user functions are double invoked to\n  // help detect side effects. The logic for how this is implemented for in\n  // hook components is a bit complex so let's break it down.\n  //\n  // We will invoke the entire component function twice. However, during the\n  // second invocation of the component, the hook state from the first\n  // invocation will be reused. That means things like `useMemo` functions won't\n  // run again, because the deps will match and the memoized result will\n  // be reused.\n  //\n  // We want memoized functions to run twice, too, so account for this, user\n  // functions are double invoked during the *first* invocation of the component\n  // function, and are *not* double invoked during the second incovation:\n  //\n  // - First execution of component function: user functions are double invoked\n  // - Second execution of component function (in Strict Mode, during\n  //   development): user functions are not double invoked.\n  //\n  // This is intentional for a few reasons; most importantly, it's because of\n  // how `use` works when something suspends: it reuses the promise that was\n  // passed during the first attempt. This is itself a form of memoization.\n  // We need to be able to memoize the reactive inputs to the `use` call using\n  // a hook (i.e. `useMemo`), which means, the reactive inputs to `use` must\n  // come from the same component invocation as the output.\n  //\n  // There are plenty of tests to ensure this behavior is correct.\n\n\n  const shouldDoubleRenderDEV = __DEV__ && debugRenderPhaseSideEffectsForStrictMode && (workInProgress.mode & StrictLegacyMode) !== NoMode;\n  shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;\n  let children = Component(props, secondArg);\n  shouldDoubleInvokeUserFnsInHooksDEV = false; // Check if there was a render phase update\n\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    // Keep rendering until the component stabilizes (there are no more render\n    // phase updates).\n    children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n  }\n\n  if (shouldDoubleRenderDEV) {\n    // In development, components are invoked twice to help detect side effects.\n    setIsStrictModeForDevtools(true);\n\n    try {\n      children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n    } finally {\n      setIsStrictModeForDevtools(false);\n    }\n  }\n\n  finishRenderingHooks(current, workInProgress);\n  return children;\n}\n\nfunction finishRenderingHooks(current, workInProgress) {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (__DEV__) {\n    workInProgress._debugHookTypes = hookTypesDev;\n  } // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n\n\n  const didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n    // render. If this fires, it suggests that we incorrectly reset the static\n    // flags in some other part of the codebase. This has happened before, for\n    // example, in the SuspenseList implementation.\n\n    if (current !== null && (current.flags & StaticMaskEffect) !== (workInProgress.flags & StaticMaskEffect) && // Disable this warning in legacy mode, because legacy Suspense is weird\n    // and creates false positives. To make this work in legacy mode, we'd\n    // need to mark fibers that commit in an incomplete state, somehow. For\n    // now I'll disable the warning that most of the bugs that would trigger\n    // it are either exclusive to concurrent mode or exist in both.\n    (current.mode & ConcurrentMode) !== NoMode) {\n      console.error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n    }\n  }\n\n  didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n  // localIdCounter = 0;\n\n  thenableIndexCounter = 0;\n  thenableState = null;\n\n  if (didRenderTooFewHooks) {\n    throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n  }\n\n  if (enableLazyContextPropagation) {\n    if (current !== null) {\n      if (!checkIfWorkInProgressReceivedUpdate()) {\n        // If there were no changes to props or state, we need to check if there\n        // was a context change. We didn't already do this because there's no\n        // 1:1 correspondence between dependencies and hooks. Although, because\n        // there almost always is in the common case (`readContext` is an\n        // internal API), we could compare in there. OTOH, we only hit this case\n        // if everything else bails out, so on the whole it might be better to\n        // keep the comparison out of the common path.\n        const currentDependencies = current.dependencies;\n\n        if (currentDependencies !== null && checkIfContextChanged(currentDependencies)) {\n          markWorkInProgressReceivedUpdate();\n        }\n      }\n    }\n  }\n\n  if (__DEV__) {\n    if (checkIfUseWrappedInTryCatch()) {\n      const componentName = getComponentNameFromFiber(workInProgress) || 'Unknown';\n\n      if (!didWarnAboutUseWrappedInTryCatch.has(componentName)) {\n        didWarnAboutUseWrappedInTryCatch.add(componentName);\n        console.error('`use` was called from inside a try/catch block. This is not allowed ' + 'and can lead to unexpected behavior. To handle errors triggered ' + 'by `use`, wrap your component in a error boundary.');\n      }\n    }\n  }\n}\n\nexport function replaySuspendedComponentWithHooks(current, workInProgress, Component, props, secondArg) {\n  // This function is used to replay a component that previously suspended,\n  // after its data resolves.\n  //\n  // It's a simplified version of renderWithHooks, but it doesn't need to do\n  // most of the set up work because they weren't reset when we suspended; they\n  // only get reset when the component either completes (finishRenderingHooks)\n  // or unwinds (resetHooksOnUnwind).\n  if (__DEV__) {\n    hookTypesDev = current !== null ? current._debugHookTypes : null;\n    hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n\n    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n  }\n\n  const children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n  finishRenderingHooks(current, workInProgress);\n  return children;\n}\n\nfunction renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n  // This is used to perform another render pass. It's used when setState is\n  // called during render, and for double invoking components in Strict Mode\n  // during development.\n  //\n  // The state from the previous pass is reused whenever possible. So, state\n  // updates that were already processed are not processed again, and memoized\n  // functions (`useMemo`) are not invoked again.\n  //\n  // Keep rendering in a loop for as long as render phase updates continue to\n  // be scheduled. Use a counter to prevent infinite loops.\n  let numberOfReRenders = 0;\n  let children;\n\n  do {\n    didScheduleRenderPhaseUpdateDuringThisPass = false;\n    thenableIndexCounter = 0;\n\n    if (numberOfReRenders >= RE_RENDER_LIMIT) {\n      throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n    }\n\n    numberOfReRenders += 1;\n\n    if (__DEV__) {\n      // Even when hot reloading, allow dependencies to stabilize\n      // after first render to prevent infinite render phase updates.\n      ignorePreviousDependencies = false;\n    } // Start over from the beginning of the list\n\n\n    currentHook = null;\n    workInProgressHook = null;\n    workInProgress.updateQueue = null;\n\n    if (__DEV__) {\n      // Also validate hook order for cascading updates.\n      hookTypesUpdateIndexDev = -1;\n    }\n\n    ReactCurrentDispatcher.current = __DEV__ ? HooksDispatcherOnRerenderInDEV : HooksDispatcherOnRerender;\n    children = Component(props, secondArg);\n  } while (didScheduleRenderPhaseUpdateDuringThisPass);\n\n  return children;\n}\n\nexport function checkDidRenderIdHook() {\n  // This should be called immediately after every renderWithHooks call.\n  // Conceptually, it's part of the return value of renderWithHooks; it's only a\n  // separate function to avoid using an array tuple.\n  const didRenderIdHook = localIdCounter !== 0;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\nexport function bailoutHooks(current, workInProgress, lanes) {\n  workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n  // complete phase (bubbleProperties).\n\n  if (__DEV__ && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n    workInProgress.flags &= ~(MountPassiveDevEffect | MountLayoutDevEffect | PassiveEffect | UpdateEffect);\n  } else {\n    workInProgress.flags &= ~(PassiveEffect | UpdateEffect);\n  }\n\n  current.lanes = removeLanes(current.lanes, lanes);\n}\nexport function resetHooksAfterThrow() {\n  // This is called immediaetly after a throw. It shouldn't reset the entire\n  // module state, because the work loop might decide to replay the component\n  // again without rewinding.\n  //\n  // It should only reset things like the current dispatcher, to prevent hooks\n  // from being called outside of a component.\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n}\nexport function resetHooksOnUnwind() {\n  if (didScheduleRenderPhaseUpdate) {\n    // There were render phase updates. These are only valid for this render\n    // phase, which we are now aborting. Remove the updates from the queues so\n    // they do not persist to the next render. Do not remove updates from hooks\n    // that weren't processed.\n    //\n    // Only reset the updates from the queue if it has a clone. If it does\n    // not have a clone, that means it wasn't processed, and the updates were\n    // scheduled before we entered the render phase.\n    let hook = currentlyRenderingFiber.memoizedState;\n\n    while (hook !== null) {\n      const queue = hook.queue;\n\n      if (queue !== null) {\n        queue.pending = null;\n      }\n\n      hook = hook.next;\n    }\n\n    didScheduleRenderPhaseUpdate = false;\n  }\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n    currentHookNameInDev = null;\n  }\n\n  didScheduleRenderPhaseUpdateDuringThisPass = false;\n  localIdCounter = 0;\n  thenableIndexCounter = 0;\n  thenableState = null;\n}\n\nfunction mountWorkInProgressHook() {\n  const hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook() {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  let nextCurrentHook;\n\n  if (currentHook === null) {\n    const current = currentlyRenderingFiber.alternate;\n\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    nextCurrentHook = currentHook.next;\n  }\n\n  let nextWorkInProgressHook;\n\n  if (workInProgressHook === null) {\n    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n    currentHook = nextCurrentHook;\n  } else {\n    // Clone from the current hook.\n    if (nextCurrentHook === null) {\n      const currentFiber = currentlyRenderingFiber.alternate;\n\n      if (currentFiber === null) {\n        // This is the initial render. This branch is reached when the component\n        // suspends, resumes, then renders an additional hook.\n        const newHook = {\n          memoizedState: null,\n          baseState: null,\n          baseQueue: null,\n          queue: null,\n          next: null\n        };\n        nextCurrentHook = newHook;\n      } else {\n        // This is an update. We should always have a current hook.\n        throw new Error('Rendered more hooks than during the previous render.');\n      }\n    }\n\n    currentHook = nextCurrentHook;\n    const newHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n\n  return workInProgressHook;\n} // NOTE: defining two versions of this function to avoid size impact when this feature is disabled.\n// Previously this function was inlined, the additional `memoCache` property makes it not inlined.\n\n\nlet createFunctionComponentUpdateQueue;\n\nif (enableUseMemoCacheHook) {\n  createFunctionComponentUpdateQueue = () => {\n    return {\n      lastEffect: null,\n      events: null,\n      stores: null,\n      memoCache: null\n    };\n  };\n} else {\n  createFunctionComponentUpdateQueue = () => {\n    return {\n      lastEffect: null,\n      events: null,\n      stores: null\n    };\n  };\n}\n\nfunction use(usable) {\n  if (usable !== null && typeof usable === 'object') {\n    // $FlowFixMe[method-unbinding]\n    if (typeof usable.then === 'function') {\n      // This is a thenable.\n      const thenable = usable; // Track the position of the thenable within this fiber.\n\n      const index = thenableIndexCounter;\n      thenableIndexCounter += 1;\n\n      if (thenableState === null) {\n        thenableState = createThenableState();\n      }\n\n      return trackUsedThenable(thenableState, thenable, index);\n    } else if (usable.$$typeof === REACT_CONTEXT_TYPE || usable.$$typeof === REACT_SERVER_CONTEXT_TYPE) {\n      const context = usable;\n      return readContext(context);\n    }\n  } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n  throw new Error('An unsupported type was passed to use(): ' + String(usable));\n}\n\nfunction useMemoCache(size) {\n  let memoCache = null; // Fast-path, load memo cache from wip fiber if already prepared\n\n  let updateQueue = currentlyRenderingFiber.updateQueue;\n\n  if (updateQueue !== null) {\n    memoCache = updateQueue.memoCache;\n  } // Otherwise clone from the current fiber\n\n\n  if (memoCache == null) {\n    const current = currentlyRenderingFiber.alternate;\n\n    if (current !== null) {\n      const currentUpdateQueue = current.updateQueue;\n\n      if (currentUpdateQueue !== null) {\n        const currentMemoCache = currentUpdateQueue.memoCache;\n\n        if (currentMemoCache != null) {\n          memoCache = {\n            data: currentMemoCache.data.map(array => array.slice()),\n            index: 0\n          };\n        }\n      }\n    }\n  } // Finally fall back to allocating a fresh instance of the cache\n\n\n  if (memoCache == null) {\n    memoCache = {\n      data: [],\n      index: 0\n    };\n  }\n\n  if (updateQueue === null) {\n    updateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = updateQueue;\n  }\n\n  updateQueue.memoCache = memoCache;\n  let data = memoCache.data[memoCache.index];\n\n  if (data === undefined) {\n    data = memoCache.data[memoCache.index] = new Array(size);\n\n    for (let i = 0; i < size; i++) {\n      data[i] = REACT_MEMO_CACHE_SENTINEL;\n    }\n  } else if (data.length !== size) {\n    // TODO: consider warning or throwing here\n    if (__DEV__) {\n      console.error('Expected a constant size argument for each invocation of useMemoCache. ' + 'The previous cache was allocated with size %s but size %s was requested.', data.length, size);\n    }\n  }\n\n  memoCache.index++;\n  return data;\n}\n\nfunction basicStateReducer(state, action) {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer(reducer, initialArg, init) {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = initialArg;\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  const dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer(reducer, initialArg, init) {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer;\n  const current = currentHook;\n  console.log('useState-current = ', current); // The last rebase update that is NOT part of the base state.\n\n  let baseQueue = current.baseQueue;\n  console.log('useState-baseQueue = ', baseQueue); // The last pending update that hasn't been processed yet.\n\n  const pendingQueue = queue.pending;\n\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      const baseFirst = baseQueue.next;\n      const pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n\n    if (__DEV__) {\n      if (current.baseQueue !== baseQueue) {\n        // Internal invariant that should never happen, but feasibly could in\n        // the future if we implement resuming, or some form of that.\n        console.error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n      }\n    }\n\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  console.log('useState-pendingQueue = ', pendingQueue);\n\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    const first = baseQueue.next;\n    let newState = current.baseState;\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n    let update = first;\n\n    do {\n      // An extra OffscreenLane bit is added to updates that were made to\n      // a hidden tree, so that we can distinguish them from updates that were\n      // already there when the tree was hidden.\n      const updateLane = removeLanes(update.lane, OffscreenLane);\n      const isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then\n      // it's not a \"base\" update and we should disregard the extra base lanes\n      // that were added to renderLanes when we entered the Offscreen tree.\n\n      const shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);\n\n      if (shouldSkipUpdate) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null\n        };\n\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Update the remaining priority in the queue.\n        // TODO: Don't need to accumulate this. Instead, we can remove\n        // renderLanes from the original lanes.\n\n\n        currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, updateLane);\n        markSkippedUpdateLanes(updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newBaseQueueLast !== null) {\n          const clone = {\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null\n          };\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Process this update.\n\n\n        const action = update.action;\n\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n          reducer(newState, action);\n        }\n\n        console.log('T-update = ', update);\n\n        if (update.hasEagerState) {\n          // If this update is a state update (not a reducer) and was processed eagerly,\n          // we can use the eagerly computed state\n          newState = update.eagerState;\n        } else {\n          newState = reducer(newState, action);\n        }\n\n        console.log('useState-newState = ', newState);\n      }\n\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = newBaseQueueFirst;\n    } // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n    console.log('useState-updateHook = ', hook);\n    queue.lastRenderedState = newState;\n  }\n\n  if (baseQueue === null) {\n    // `queue.lanes` is used for entangling transitions. We can set it back to\n    // zero once the queue is empty.\n    queue.lanes = NoLanes;\n  }\n\n  console.log('useState-current = ', current);\n  console.log('useState-workInProgress = ', hook);\n  const dispatch = queue.dispatch;\n  return [hook.memoizedState, dispatch];\n}\n\nfunction rerenderReducer(reducer, initialArg, init) {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n  // work-in-progress hook.\n\n  const dispatch = queue.dispatch;\n  const lastRenderPhaseUpdate = queue.pending;\n  let newState = hook.memoizedState;\n\n  if (lastRenderPhaseUpdate !== null) {\n    // The queue doesn't persist past this render pass.\n    queue.pending = null;\n    const firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n    let update = firstRenderPhaseUpdate;\n\n    do {\n      // Process this render phase update. We don't have to check the\n      // priority because it will always be the same as the current\n      // render's.\n      const action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n    // the base state unless the queue is empty.\n    // TODO: Not sure if this is the desired semantics, but it's what we\n    // do for gDSFP. I can't remember why.\n\n    if (hook.baseQueue === null) {\n      hook.baseState = newState;\n    }\n\n    queue.lastRenderedState = newState;\n  }\n\n  return [newState, dispatch];\n}\n\nfunction readFromUnsubscribedMutableSource(root, source, getSnapshot) {\n  if (__DEV__) {\n    warnAboutMultipleRenderersDEV(source);\n  }\n\n  const getVersion = source._getVersion;\n  const version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?\n\n  let isSafeToReadFromSource = false; // Check the version first.\n  // If this render has already been started with a specific version,\n  // we can use it alone to determine if we can safely read from the source.\n\n  const currentRenderVersion = getWorkInProgressVersion(source);\n\n  if (currentRenderVersion !== null) {\n    // It's safe to read if the store hasn't been mutated since the last time\n    // we read something.\n    isSafeToReadFromSource = currentRenderVersion === version;\n  } else {\n    // If there's no version, then this is the first time we've read from the\n    // source during the current render pass, so we need to do a bit more work.\n    // What we need to determine is if there are any hooks that already\n    // subscribed to the source, and if so, whether there are any pending\n    // mutations that haven't been synchronized yet.\n    //\n    // If there are no pending mutations, then `root.mutableReadLanes` will be\n    // empty, and we know we can safely read.\n    //\n    // If there *are* pending mutations, we may still be able to safely read\n    // if the currently rendering lanes are inclusive of the pending mutation\n    // lanes, since that guarantees that the value we're about to read from\n    // the source is consistent with the values that we read during the most\n    // recent mutation.\n    isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root.mutableReadLanes);\n\n    if (isSafeToReadFromSource) {\n      // If it's safe to read from this source during the current render,\n      // store the version in case other components read from it.\n      // A changed version number will let those components know to throw and restart the render.\n      setWorkInProgressVersion(source, version);\n    }\n  }\n\n  if (isSafeToReadFromSource) {\n    const snapshot = getSnapshot(source._source);\n\n    if (__DEV__) {\n      if (typeof snapshot === 'function') {\n        console.error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');\n      }\n    }\n\n    return snapshot;\n  } else {\n    // This handles the special case of a mutable source being shared between renderers.\n    // In that case, if the source is mutated between the first and second renderer,\n    // The second renderer don't know that it needs to reset the WIP version during unwind,\n    // (because the hook only marks sources as dirty if it's written to their WIP version).\n    // That would cause this tear check to throw again and eventually be visible to the user.\n    // We can avoid this infinite loop by explicitly marking the source as dirty.\n    //\n    // This can lead to tearing in the first renderer when it resumes,\n    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).\n    markSourceAsDirty(source); // Intentioally throw an error to force React to retry synchronously. During\n    // the synchronous retry, it will block interleaved mutations, so we should\n    // get a consistent read. Therefore, the following error should never be\n    // visible to the user.\n    // We expect this error not to be thrown during the synchronous retry,\n    // because we blocked interleaved mutations.\n\n    throw new Error('Cannot read from mutable source during the current render without tearing. This may be a bug in React. Please file an issue.');\n  }\n}\n\nfunction useMutableSource(hook, source, getSnapshot, subscribe) {\n  if (!enableUseMutableSource) {\n    return undefined;\n  }\n\n  const root = getWorkInProgressRoot();\n\n  if (root === null) {\n    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n  }\n\n  const getVersion = source._getVersion;\n  const version = getVersion(source._source);\n  const dispatcher = ReactCurrentDispatcher.current; // eslint-disable-next-line prefer-const\n\n  let [currentSnapshot, setSnapshot] = dispatcher.useState(() => readFromUnsubscribedMutableSource(root, source, getSnapshot));\n  let snapshot = currentSnapshot; // Grab a handle to the state hook as well.\n  // We use it to clear the pending update queue if we have a new source.\n\n  const stateHook = workInProgressHook;\n  const memoizedState = hook.memoizedState;\n  const refs = memoizedState.refs;\n  const prevGetSnapshot = refs.getSnapshot;\n  const prevSource = memoizedState.source;\n  const prevSubscribe = memoizedState.subscribe;\n  const fiber = currentlyRenderingFiber;\n  hook.memoizedState = {\n    refs,\n    source,\n    subscribe\n  }; // Sync the values needed by our subscription handler after each commit.\n\n  dispatcher.useEffect(() => {\n    refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,\n    // but this hook recreates the queue in certain cases  to avoid updates from stale sources.\n    // handleChange() below needs to reference the dispatch function without re-subscribing,\n    // so we use a ref to ensure that it always has the latest version.\n\n    refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.\n\n    const maybeNewVersion = getVersion(source._source);\n\n    if (!is(version, maybeNewVersion)) {\n      const maybeNewSnapshot = getSnapshot(source._source);\n\n      if (__DEV__) {\n        if (typeof maybeNewSnapshot === 'function') {\n          console.error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');\n        }\n      }\n\n      if (!is(snapshot, maybeNewSnapshot)) {\n        setSnapshot(maybeNewSnapshot);\n        const lane = requestUpdateLane(fiber);\n        markRootMutableRead(root, lane);\n      } // If the source mutated between render and now,\n      // there may be state updates already scheduled from the old source.\n      // Entangle the updates so that they render in the same batch.\n\n\n      markRootEntangled(root, root.mutableReadLanes);\n    }\n  }, [getSnapshot, source, subscribe]); // If we got a new source or subscribe function, re-subscribe in a passive effect.\n\n  dispatcher.useEffect(() => {\n    const handleChange = () => {\n      const latestGetSnapshot = refs.getSnapshot;\n      const latestSetSnapshot = refs.setSnapshot;\n\n      try {\n        latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.\n\n        const lane = requestUpdateLane(fiber);\n        markRootMutableRead(root, lane);\n      } catch (error) {\n        // A selector might throw after a source mutation.\n        // e.g. it might try to read from a part of the store that no longer exists.\n        // In this case we should still schedule an update with React.\n        // Worst case the selector will throw again and then an error boundary will handle it.\n        latestSetSnapshot(() => {\n          throw error;\n        });\n      }\n    };\n\n    const unsubscribe = subscribe(source._source, handleChange);\n\n    if (__DEV__) {\n      if (typeof unsubscribe !== 'function') {\n        console.error('Mutable source subscribe function must return an unsubscribe function.');\n      }\n    }\n\n    return unsubscribe;\n  }, [source, subscribe]); // If any of the inputs to useMutableSource change, reading is potentially unsafe.\n  //\n  // If either the source or the subscription have changed we can't can't trust the update queue.\n  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.\n  //\n  // If the getSnapshot function changed, we also shouldn't rely on the update queue.\n  // It's possible that the underlying source was mutated between the when the last \"change\" event fired,\n  // and when the current render (with the new getSnapshot function) is processed.\n  //\n  // In both cases, we need to throw away pending updates (since they are no longer relevant)\n  // and treat reading from the source as we do in the mount case.\n\n  if (!is(prevGetSnapshot, getSnapshot) || !is(prevSource, source) || !is(prevSubscribe, subscribe)) {\n    // Create a new queue and setState method,\n    // So if there are interleaved updates, they get pushed to the older queue.\n    // When this becomes current, the previous queue and dispatch method will be discarded,\n    // including any interleaving updates that occur.\n    const newQueue = {\n      pending: null,\n      lanes: NoLanes,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: snapshot\n    };\n    newQueue.dispatch = setSnapshot = dispatchSetState.bind(null, currentlyRenderingFiber, newQueue);\n    stateHook.queue = newQueue;\n    stateHook.baseQueue = null;\n    snapshot = readFromUnsubscribedMutableSource(root, source, getSnapshot);\n    stateHook.memoizedState = stateHook.baseState = snapshot;\n  }\n\n  return snapshot;\n}\n\nfunction mountMutableSource(source, getSnapshot, subscribe) {\n  if (!enableUseMutableSource) {\n    return undefined;\n  }\n\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = {\n    refs: {\n      getSnapshot,\n      setSnapshot: null\n    },\n    source,\n    subscribe\n  };\n  return useMutableSource(hook, source, getSnapshot, subscribe);\n}\n\nfunction updateMutableSource(source, getSnapshot, subscribe) {\n  if (!enableUseMutableSource) {\n    return undefined;\n  }\n\n  const hook = updateWorkInProgressHook();\n  return useMutableSource(hook, source, getSnapshot, subscribe);\n}\n\nfunction mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  const fiber = currentlyRenderingFiber;\n  const hook = mountWorkInProgressHook();\n  let nextSnapshot;\n  const isHydrating = getIsHydrating();\n\n  if (isHydrating) {\n    if (getServerSnapshot === undefined) {\n      throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n    }\n\n    nextSnapshot = getServerSnapshot();\n\n    if (__DEV__) {\n      if (!didWarnUncachedGetSnapshot) {\n        if (nextSnapshot !== getServerSnapshot()) {\n          console.error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    }\n  } else {\n    nextSnapshot = getSnapshot();\n\n    if (__DEV__) {\n      if (!didWarnUncachedGetSnapshot) {\n        const cachedSnapshot = getSnapshot();\n\n        if (!is(nextSnapshot, cachedSnapshot)) {\n          console.error('The result of getSnapshot should be cached to avoid an infinite loop');\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    } // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n    //\n    // We won't do this if we're hydrating server-rendered content, because if\n    // the content is stale, it's already visible anyway. Instead we'll patch\n    // it up in a passive effect.\n\n\n    const root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  } // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n\n  hook.memoizedState = nextSnapshot;\n  const inst = {\n    value: nextSnapshot,\n    getSnapshot\n  };\n  hook.queue = inst; // Schedule an effect to subscribe to the store.\n\n  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Schedule an effect to update the mutable instance fields. We will update\n  // this whenever subscribe, getSnapshot, or value changes. Because there's no\n  // clean-up function, and we track the deps correctly, we can call pushEffect\n  // directly, without storing any additional state. For the same reason, we\n  // don't need to set a static flag, either.\n  // TODO: We can move this to the passive phase once we add a pre-commit\n  // consistency check. See the next comment.\n\n  fiber.flags |= PassiveEffect;\n  pushEffect(HookHasEffect | HookPassive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n  return nextSnapshot;\n}\n\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  const fiber = currentlyRenderingFiber;\n  const hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n  const nextSnapshot = getSnapshot();\n\n  if (__DEV__) {\n    if (!didWarnUncachedGetSnapshot) {\n      const cachedSnapshot = getSnapshot();\n\n      if (!is(nextSnapshot, cachedSnapshot)) {\n        console.error('The result of getSnapshot should be cached to avoid an infinite loop');\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  }\n\n  const prevSnapshot = (currentHook || hook).memoizedState;\n  const snapshotChanged = !is(prevSnapshot, nextSnapshot);\n\n  if (snapshotChanged) {\n    hook.memoizedState = nextSnapshot;\n    markWorkInProgressReceivedUpdate();\n  }\n\n  const inst = hook.queue;\n  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Whenever getSnapshot or subscribe changes, we need to check in the\n  // commit phase if there was an interleaved mutation. In concurrent mode\n  // this can happen all the time, but even in synchronous mode, an earlier\n  // effect may have mutated the store.\n\n  if (inst.getSnapshot !== getSnapshot || snapshotChanged || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HookHasEffect) {\n    fiber.flags |= PassiveEffect;\n    pushEffect(HookHasEffect | HookPassive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n\n    const root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n  fiber.flags |= StoreConsistency;\n  const check = {\n    getSnapshot,\n    value: renderedSnapshot\n  };\n  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.stores = [check];\n  } else {\n    const stores = componentUpdateQueue.stores;\n\n    if (stores === null) {\n      componentUpdateQueue.stores = [check];\n    } else {\n      stores.push(check);\n    }\n  }\n}\n\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n  // These are updated in the passive phase\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n  // have been in an event that fired before the passive effects, or it could\n  // have been in a layout effect. In that case, we would have used the old\n  // snapsho and getSnapshot values to bail out. We need to check one more time.\n\n  if (checkIfSnapshotChanged(inst)) {\n    // Force a re-render.\n    forceStoreRerender(fiber);\n  }\n}\n\nfunction subscribeToStore(fiber, inst, subscribe) {\n  const handleStoreChange = () => {\n    // The store changed. Check if the snapshot changed since the last time we\n    // read from the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceStoreRerender(fiber);\n    }\n  }; // Subscribe to the store and return a clean-up function.\n\n\n  return subscribe(handleStoreChange);\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  const latestGetSnapshot = inst.getSnapshot;\n  const prevValue = inst.value;\n\n  try {\n    const nextValue = latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction forceStoreRerender(fiber) {\n  const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n  if (root !== null) {\n    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n  }\n}\n\nfunction mountState(initialState) {\n  const hook = mountWorkInProgressHook();\n\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  const queue = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  const dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue); // console.log('mountCurrent = ', current);\n\n  console.log('useState-mountWorkInProgress = ', hook);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState(initialState) {\n  return updateReducer(basicStateReducer, initialState);\n}\n\nfunction rerenderState(initialState) {\n  return rerenderReducer(basicStateReducer, initialState);\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  const effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: null\n  };\n  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n\n  return effect;\n}\n\nlet stackContainsErrorMessage = null;\n\nfunction getCallerStackFrame() {\n  // eslint-disable-next-line react-internal/prod-error-codes\n  const stackFrames = new Error('Error message').stack.split('\\n'); // Some browsers (e.g. Chrome) include the error message in the stack\n  // but others (e.g. Firefox) do not.\n\n  if (stackContainsErrorMessage === null) {\n    stackContainsErrorMessage = stackFrames[0].includes('Error message');\n  }\n\n  return stackContainsErrorMessage ? stackFrames.slice(3, 4).join('\\n') : stackFrames.slice(2, 3).join('\\n');\n}\n\nfunction mountRef(initialValue) {\n  const hook = mountWorkInProgressHook();\n\n  if (enableUseRefAccessWarning) {\n    if (__DEV__) {\n      // Support lazy initialization pattern shown in docs.\n      // We need to store the caller stack frame so that we don't warn on subsequent renders.\n      let hasBeenInitialized = initialValue != null;\n      let lazyInitGetterStack = null;\n      let didCheckForLazyInit = false; // Only warn once per component+hook.\n\n      let didWarnAboutRead = false;\n      let didWarnAboutWrite = false;\n      let current = initialValue;\n      const ref = {\n        get current() {\n          if (!hasBeenInitialized) {\n            didCheckForLazyInit = true;\n            lazyInitGetterStack = getCallerStackFrame();\n          } else if (currentlyRenderingFiber !== null && !didWarnAboutRead) {\n            if (lazyInitGetterStack === null || lazyInitGetterStack !== getCallerStackFrame()) {\n              didWarnAboutRead = true;\n              console.warn('%s: Unsafe read of a mutable value during render.\\n\\n' + 'Reading from a ref during render is only safe if:\\n' + '1. The ref value has not been updated, or\\n' + '2. The ref holds a lazily-initialized value that is only set once.\\n', getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown');\n            }\n          }\n\n          return current;\n        },\n\n        set current(value) {\n          if (currentlyRenderingFiber !== null && !didWarnAboutWrite) {\n            if (hasBeenInitialized || !didCheckForLazyInit) {\n              didWarnAboutWrite = true;\n              console.warn('%s: Unsafe write of a mutable value during render.\\n\\n' + 'Writing to a ref during render is only safe if the ref holds ' + 'a lazily-initialized value that is only set once.\\n', getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown');\n            }\n          }\n\n          hasBeenInitialized = true;\n          current = value;\n        }\n\n      };\n      Object.seal(ref);\n      hook.memoizedState = ref; // console.log('mountCurrent = ', current);\n\n      console.log('mountWorkInProgress = ', hook);\n      return ref;\n    } else {\n      const ref = {\n        current: initialValue\n      };\n      hook.memoizedState = ref; // console.log('mountCurrent = ', current);\n\n      console.log('mountWorkInProgress = ', hook);\n      return ref;\n    }\n  } else {\n    const ref = {\n      current: initialValue\n    };\n    hook.memoizedState = ref; // console.log('mountCurrent = ', current);\n\n    console.log('useRef - mountWorkInProgress = ', hook);\n    return ref;\n  }\n}\n\nfunction updateRef(initialValue) {\n  const hook = updateWorkInProgressHook(); // console.log('current = ', current);\n\n  console.log('useRef - workInProgress = ', hook);\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, undefined, nextDeps); // console.log('mountCurrent = ', current);\n\n  console.log('useEffect - mountWorkInProgress = ', hook);\n}\n\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HookHasEffect | hookFlags, create, destroy, nextDeps); // console.log('current = ', current);\n\n  console.log('useEffect - workInProgress = ', hook);\n}\n\nfunction mountEffect(create, deps) {\n  if (__DEV__ && (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode) {\n    mountEffectImpl(MountPassiveDevEffect | PassiveEffect | PassiveStaticEffect, HookPassive, create, deps);\n  } else {\n    mountEffectImpl(PassiveEffect | PassiveStaticEffect, HookPassive, create, deps);\n  }\n}\n\nfunction updateEffect(create, deps) {\n  updateEffectImpl(PassiveEffect, HookPassive, create, deps);\n}\n\nfunction useEffectEventImpl(payload) {\n  currentlyRenderingFiber.flags |= UpdateEffect;\n  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.events = [payload];\n  } else {\n    const events = componentUpdateQueue.events;\n\n    if (events === null) {\n      componentUpdateQueue.events = [payload];\n    } else {\n      events.push(payload);\n    }\n  }\n}\n\nfunction mountEvent(callback) {\n  const hook = mountWorkInProgressHook();\n  const ref = {\n    impl: callback\n  };\n  hook.memoizedState = ref; // $FlowIgnore[incompatible-return]\n\n  return function eventFn() {\n    if (isInvalidExecutionContextForEventFunction()) {\n      throw new Error(\"A function wrapped in useEffectEvent can't be called during rendering.\");\n    }\n\n    return ref.impl.apply(undefined, arguments);\n  };\n}\n\nfunction updateEvent(callback) {\n  const hook = updateWorkInProgressHook();\n  const ref = hook.memoizedState;\n  useEffectEventImpl({\n    ref,\n    nextImpl: callback\n  }); // $FlowIgnore[incompatible-return]\n\n  return function eventFn() {\n    if (isInvalidExecutionContextForEventFunction()) {\n      throw new Error(\"A function wrapped in useEffectEvent can't be called during rendering.\");\n    }\n\n    return ref.impl.apply(undefined, arguments);\n  };\n}\n\nfunction mountInsertionEffect(create, deps) {\n  mountEffectImpl(UpdateEffect, HookInsertion, create, deps);\n}\n\nfunction updateInsertionEffect(create, deps) {\n  return updateEffectImpl(UpdateEffect, HookInsertion, create, deps);\n}\n\nfunction mountLayoutEffect(create, deps) {\n  let fiberFlags = UpdateEffect | LayoutStaticEffect;\n\n  if (__DEV__ && (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDevEffect;\n  }\n\n  return mountEffectImpl(fiberFlags, HookLayout, create, deps);\n}\n\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);\n}\n\nfunction imperativeHandleEffect(create, ref) {\n  if (typeof ref === 'function') {\n    const refCallback = ref;\n    const inst = create();\n    refCallback(inst);\n    return () => {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref;\n\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty('current')) {\n        console.error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n      }\n    }\n\n    const inst = create();\n    refObject.current = inst;\n    return () => {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle(ref, create, deps) {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  const effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  let fiberFlags = UpdateEffect | LayoutStaticEffect;\n\n  if (__DEV__ && (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDevEffect;\n  }\n\n  mountEffectImpl(fiberFlags, HookLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction updateImperativeHandle(ref, create, deps) {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  const effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  updateEffectImpl(UpdateEffect, HookLayout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction mountDebugValue(value, formatterFn) {// This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n\nfunction mountCallback(callback, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps]; // console.log('mountCurrent = ', current);\n\n  console.log('useCallback - mountWorkInProgress = ', hook);\n  return callback;\n}\n\nfunction updateCallback(callback, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  hook.memoizedState = [callback, nextDeps]; // console.log('current = ', current);\n\n  console.log('useCallback - workInProgress = ', hook);\n  return callback;\n}\n\nfunction mountMemo(nextCreate, deps) {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\n    nextCreate();\n  }\n\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps]; // console.log('mountCurrent = ', current);\n\n  console.log('useMemo - mountWorkInProgress = ', hook);\n  return nextValue;\n}\n\nfunction updateMemo(nextCreate, deps) {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      const prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\n    nextCreate();\n  }\n\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps]; // console.log('current = ', current);\n\n  console.log('useMemo - workInProgress = ', hook);\n  return nextValue;\n}\n\nfunction mountDeferredValue(value) {\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = value;\n  return value;\n}\n\nfunction updateDeferredValue(value) {\n  const hook = updateWorkInProgressHook();\n  const resolvedCurrentHook = currentHook;\n  const prevValue = resolvedCurrentHook.memoizedState;\n  return updateDeferredValueImpl(hook, prevValue, value);\n}\n\nfunction rerenderDeferredValue(value) {\n  const hook = updateWorkInProgressHook();\n\n  if (currentHook === null) {\n    // This is a rerender during a mount.\n    hook.memoizedState = value;\n    return value;\n  } else {\n    // This is a rerender during an update.\n    const prevValue = currentHook.memoizedState;\n    return updateDeferredValueImpl(hook, prevValue, value);\n  }\n}\n\nfunction updateDeferredValueImpl(hook, prevValue, value) {\n  const shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n\n  if (shouldDeferValue) {\n    // This is an urgent update. If the value has changed, keep using the\n    // previous value and spawn a deferred render to update it later.\n    if (!is(value, prevValue)) {\n      // Schedule a deferred render\n      const deferredLane = claimNextTransitionLane();\n      currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, deferredLane);\n      markSkippedUpdateLanes(deferredLane); // Set this to true to indicate that the rendered value is inconsistent\n      // from the latest value. The name \"baseState\" doesn't really match how we\n      // use it because we're reusing a state hook field instead of creating a\n      // new one.\n\n      hook.baseState = true;\n    } // Reuse the previous value\n\n\n    return prevValue;\n  } else {\n    // This is not an urgent update, so we can use the latest value regardless\n    // of what it is. No need to defer it.\n    // However, if we're currently inside a spawned render, then we need to mark\n    // this as an update to prevent the fiber from bailing out.\n    //\n    // `baseState` is true when the current value is different from the rendered\n    // value. The name doesn't really match how we use it because we're reusing\n    // a state hook field instead of creating a new one.\n    if (hook.baseState) {\n      // Flip this back to false.\n      hook.baseState = false;\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = value;\n    return value;\n  }\n}\n\nfunction startTransition(setPending, callback, options) {\n  const previousPriority = getCurrentUpdatePriority();\n  setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n  setPending(true);\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = {};\n  const currentTransition = ReactCurrentBatchConfig.transition;\n\n  if (enableTransitionTracing) {\n    if (options !== undefined && options.name !== undefined) {\n      ReactCurrentBatchConfig.transition.name = options.name;\n      ReactCurrentBatchConfig.transition.startTime = now();\n    }\n  }\n\n  if (__DEV__) {\n    ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n  }\n\n  try {\n    setPending(false);\n    callback();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    if (__DEV__) {\n      if (prevTransition === null && currentTransition._updatedFibers) {\n        const updatedFibersCount = currentTransition._updatedFibers.size;\n\n        if (updatedFibersCount > 10) {\n          console.warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n        }\n\n        currentTransition._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nfunction mountTransition() {\n  const [isPending, setPending] = mountState(false); // The `start` method never changes.\n\n  const start = startTransition.bind(null, setPending);\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = start;\n  return [isPending, start];\n}\n\nfunction updateTransition() {\n  const [isPending] = updateState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n\nfunction rerenderTransition() {\n  const [isPending] = rerenderState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n\nfunction mountId() {\n  const hook = mountWorkInProgressHook();\n  const root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n  // should do this in Fiber, too? Deferring this decision for now because\n  // there's no other place to store the prefix except for an internal field on\n  // the public createRoot object, which the fiber tree does not currently have\n  // a reference to.\n\n  const identifierPrefix = root.identifierPrefix;\n  let id;\n\n  if (getIsHydrating()) {\n    const treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n\n    id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end\n    // that represents the position of this useId hook among all the useId\n    // hooks for this fiber.\n\n    const localId = localIdCounter++;\n\n    if (localId > 0) {\n      id += 'H' + localId.toString(32);\n    }\n\n    id += ':';\n  } else {\n    // Use a lowercase r prefix for client-generated ids.\n    const globalClientId = globalClientIdCounter++;\n    id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n  }\n\n  hook.memoizedState = id;\n  return id;\n}\n\nfunction updateId() {\n  const hook = updateWorkInProgressHook();\n  const id = hook.memoizedState;\n  return id;\n}\n\nfunction mountRefresh() {\n  const hook = mountWorkInProgressHook();\n  const refresh = hook.memoizedState = refreshCache.bind(null, currentlyRenderingFiber);\n  return refresh;\n}\n\nfunction updateRefresh() {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction refreshCache(fiber, seedKey, seedValue) {\n  if (!enableCache) {\n    return;\n  } // TODO: Does Cache work in legacy mode? Should decide and write a test.\n  // TODO: Consider warning if the refresh is at discrete priority, or if we\n  // otherwise suspect that it wasn't batched properly.\n\n\n  let provider = fiber.return;\n\n  while (provider !== null) {\n    switch (provider.tag) {\n      case CacheComponent:\n      case HostRoot:\n        {\n          // Schedule an update on the cache boundary to trigger a refresh.\n          const lane = requestUpdateLane(provider);\n          const eventTime = requestEventTime();\n          const refreshUpdate = createLegacyQueueUpdate(eventTime, lane);\n          const root = enqueueLegacyQueueUpdate(provider, refreshUpdate, lane);\n\n          if (root !== null) {\n            scheduleUpdateOnFiber(root, provider, lane, eventTime);\n            entangleLegacyQueueTransitions(root, provider, lane);\n          } // TODO: If a refresh never commits, the new cache created here must be\n          // released. A simple case is start refreshing a cache boundary, but then\n          // unmount that boundary before the refresh completes.\n\n\n          const seededCache = createCache();\n\n          if (seedKey !== null && seedKey !== undefined && root !== null) {\n            if (enableLegacyCache) {\n              // Seed the cache with the value passed by the caller. This could be\n              // from a server mutation, or it could be a streaming response.\n              seededCache.data.set(seedKey, seedValue);\n            } else {\n              if (__DEV__) {\n                console.error('The seed argument is not enabled outside experimental channels.');\n              }\n            }\n          }\n\n          const payload = {\n            cache: seededCache\n          };\n          refreshUpdate.payload = payload;\n          return;\n        }\n    }\n\n    provider = provider.return;\n  } // TODO: Warn if unmounted?\n\n}\n\nfunction dispatchReducerAction(fiber, queue, action) {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  const lane = requestUpdateLane(fiber);\n  const update = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n\n    if (root !== null) {\n      const eventTime = requestEventTime();\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane, action);\n}\n\nfunction dispatchSetState(fiber, queue, action) {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  const lane = requestUpdateLane(fiber);\n  const update = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    const alternate = fiber.alternate;\n\n    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      const lastRenderedReducer = queue.lastRenderedReducer;\n\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n\n        try {\n          const currentState = queue.lastRenderedState;\n          const eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n\n          update.hasEagerState = true;\n          update.eagerState = eagerState;\n\n          if (is(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            // TODO: Do we still need to entangle transitions in this case?\n            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);\n            return;\n          }\n        } catch (error) {// Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n\n    const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n\n    if (root !== null) {\n      const eventTime = requestEventTime();\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane, action);\n}\n\nfunction isRenderPhaseUpdate(fiber) {\n  const alternate = fiber.alternate;\n  return fiber === currentlyRenderingFiber || alternate !== null && alternate === currentlyRenderingFiber;\n}\n\nfunction enqueueRenderPhaseUpdate(queue, update) {\n  // This is a render phase update. Stash it in a lazily-created map of\n  // queue -> linked list of updates. After this render pass, we'll restart\n  // and apply the stashed updates on top of the work-in-progress hook.\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n  const pending = queue.pending;\n\n  if (pending === null) {\n    // This is the first update. Create a circular list.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n\n  queue.pending = update;\n} // TODO: Move to ReactFiberConcurrentUpdates?\n\n\nfunction entangleTransitionUpdate(root, queue, lane) {\n  if (isTransitionLane(lane)) {\n    let queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n    // must have finished. We can remove them from the shared queue, which\n    // represents a superset of the actually pending lanes. In some cases we\n    // may entangle more than we need to, but that's OK. In fact it's worse if\n    // we *don't* entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    const newQueueLanes = mergeLanes(queueLanes, lane);\n    queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\n\nfunction markUpdateInDevTools(fiber, lane, action) {\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      if (fiber.mode & DebugTracingMode) {\n        const name = getComponentNameFromFiber(fiber) || 'Unknown';\n        logStateUpdateScheduled(name, lane, action);\n      }\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markStateUpdateScheduled(fiber, lane);\n  }\n}\n\nexport const ContextOnlyDispatcher = {\n  readContext,\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useMutableSource: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError\n};\n\nif (enableCache) {\n  ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n}\n\nif (enableUseHook) {\n  ContextOnlyDispatcher.use = throwInvalidHookError;\n}\n\nif (enableUseMemoCacheHook) {\n  ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n}\n\nif (enableUseEffectEventHook) {\n  ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;\n}\n\nconst HooksDispatcherOnMount = {\n  readContext,\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useInsertionEffect: mountInsertionEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n  useDeferredValue: mountDeferredValue,\n  useTransition: mountTransition,\n  useMutableSource: mountMutableSource,\n  useSyncExternalStore: mountSyncExternalStore,\n  useId: mountId\n};\n\nif (enableCache) {\n  // $FlowFixMe[escaped-generic] discovered when updating Flow\n  HooksDispatcherOnMount.useCacheRefresh = mountRefresh;\n}\n\nif (enableUseHook) {\n  HooksDispatcherOnMount.use = use;\n}\n\nif (enableUseMemoCacheHook) {\n  HooksDispatcherOnMount.useMemoCache = useMemoCache;\n}\n\nif (enableUseEffectEventHook) {\n  HooksDispatcherOnMount.useEffectEvent = mountEvent;\n}\n\nconst HooksDispatcherOnUpdate = {\n  readContext,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: updateDeferredValue,\n  useTransition: updateTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId\n};\n\nif (enableCache) {\n  HooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;\n}\n\nif (enableUseMemoCacheHook) {\n  HooksDispatcherOnUpdate.useMemoCache = useMemoCache;\n}\n\nif (enableUseHook) {\n  HooksDispatcherOnUpdate.use = use;\n}\n\nif (enableUseEffectEventHook) {\n  HooksDispatcherOnUpdate.useEffectEvent = updateEvent;\n}\n\nconst HooksDispatcherOnRerender = {\n  readContext,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: rerenderReducer,\n  useRef: updateRef,\n  useState: rerenderState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: rerenderDeferredValue,\n  useTransition: rerenderTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId\n};\n\nif (enableCache) {\n  HooksDispatcherOnRerender.useCacheRefresh = updateRefresh;\n}\n\nif (enableUseHook) {\n  HooksDispatcherOnRerender.use = use;\n}\n\nif (enableUseMemoCacheHook) {\n  HooksDispatcherOnRerender.useMemoCache = useMemoCache;\n}\n\nif (enableUseEffectEventHook) {\n  HooksDispatcherOnRerender.useEffectEvent = updateEvent;\n}\n\nlet HooksDispatcherOnMountInDEV = null;\nlet HooksDispatcherOnMountWithHookTypesInDEV = null;\nlet HooksDispatcherOnUpdateInDEV = null;\nlet HooksDispatcherOnRerenderInDEV = null;\nlet InvalidNestedHooksDispatcherOnMountInDEV = null;\nlet InvalidNestedHooksDispatcherOnUpdateInDEV = null;\nlet InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n\nif (__DEV__) {\n  const warnInvalidContextAccess = () => {\n    console.error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n  };\n\n  const warnInvalidHookAccess = () => {\n    console.error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      mountHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      mountHookTypesDev();\n      return mountId();\n    }\n\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      mountHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  if (enableUseHook) {\n    HooksDispatcherOnMountInDEV.use = use;\n  }\n\n  if (enableUseMemoCacheHook) {\n    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n  }\n\n  if (enableUseEffectEventHook) {\n    HooksDispatcherOnMountInDEV.useEffectEvent = function useEffectEvent(callback) {\n      currentHookNameInDev = 'useEffectEvent';\n      mountHookTypesDev();\n      return mountEvent(callback);\n    };\n  }\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return mountId();\n    }\n\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnMountWithHookTypesInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  if (enableUseHook) {\n    HooksDispatcherOnMountWithHookTypesInDEV.use = use;\n  }\n\n  if (enableUseMemoCacheHook) {\n    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n  }\n\n  if (enableUseEffectEventHook) {\n    HooksDispatcherOnMountWithHookTypesInDEV.useEffectEvent = function useEffectEvent(callback) {\n      currentHookNameInDev = 'useEffectEvent';\n      updateHookTypesDev();\n      return mountEvent(callback);\n    };\n  }\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    }\n\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  if (enableUseHook) {\n    HooksDispatcherOnUpdateInDEV.use = use;\n  }\n\n  if (enableUseMemoCacheHook) {\n    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n  }\n\n  if (enableUseEffectEventHook) {\n    HooksDispatcherOnUpdateInDEV.useEffectEvent = function useEffectEvent(callback) {\n      currentHookNameInDev = 'useEffectEvent';\n      updateHookTypesDev();\n      return updateEvent(callback);\n    };\n  }\n\n  HooksDispatcherOnRerenderInDEV = {\n    readContext(context) {\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    }\n\n  };\n\n  if (enableCache) {\n    HooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  if (enableUseHook) {\n    HooksDispatcherOnRerenderInDEV.use = use;\n  }\n\n  if (enableUseMemoCacheHook) {\n    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n  }\n\n  if (enableUseEffectEventHook) {\n    HooksDispatcherOnRerenderInDEV.useEffectEvent = function useEffectEvent(callback) {\n      currentHookNameInDev = 'useEffectEvent';\n      updateHookTypesDev();\n      return updateEvent(callback);\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext(context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountId();\n    }\n\n  };\n\n  if (enableCache) {\n    InvalidNestedHooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      mountHookTypesDev();\n      return mountRefresh();\n    };\n  }\n\n  if (enableUseHook) {\n    InvalidNestedHooksDispatcherOnMountInDEV.use = function (usable) {\n      warnInvalidHookAccess();\n      return use(usable);\n    };\n  }\n\n  if (enableUseMemoCacheHook) {\n    InvalidNestedHooksDispatcherOnMountInDEV.useMemoCache = function (size) {\n      warnInvalidHookAccess();\n      return useMemoCache(size);\n    };\n  }\n\n  if (enableUseEffectEventHook) {\n    InvalidNestedHooksDispatcherOnMountInDEV.useEffectEvent = function useEffectEvent(callback) {\n      currentHookNameInDev = 'useEffectEvent';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEvent(callback);\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext(context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    }\n\n  };\n\n  if (enableCache) {\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  if (enableUseHook) {\n    InvalidNestedHooksDispatcherOnUpdateInDEV.use = function (usable) {\n      warnInvalidHookAccess();\n      return use(usable);\n    };\n  }\n\n  if (enableUseMemoCacheHook) {\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useMemoCache = function (size) {\n      warnInvalidHookAccess();\n      return useMemoCache(size);\n    };\n  }\n\n  if (enableUseEffectEventHook) {\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useEffectEvent = function useEffectEvent(callback) {\n      currentHookNameInDev = 'useEffectEvent';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEvent(callback);\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n    readContext(context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback(callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n\n    useContext(context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n\n    useEffect(create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n\n    useImperativeHandle(ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n\n    useInsertionEffect(create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n\n    useLayoutEffect(create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n\n    useMemo(create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useReducer(reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useRef(initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n\n    useState(initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n\n    useDebugValue(value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n\n    useDeferredValue(value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n\n    useTransition() {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n\n    useMutableSource(source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n\n    useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n\n    useId() {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    }\n\n  };\n\n  if (enableCache) {\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n\n  if (enableUseHook) {\n    InvalidNestedHooksDispatcherOnRerenderInDEV.use = function (usable) {\n      warnInvalidHookAccess();\n      return use(usable);\n    };\n  }\n\n  if (enableUseMemoCacheHook) {\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useMemoCache = function (size) {\n      warnInvalidHookAccess();\n      return useMemoCache(size);\n    };\n  }\n\n  if (enableUseEffectEventHook) {\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useEffectEvent = function useEffectEvent(callback) {\n      currentHookNameInDev = 'useEffectEvent';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEvent(callback);\n    };\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberHooks.js"],"names":["ReactSharedInternals","enableDebugTracing","enableSchedulingProfiler","enableCache","enableUseRefAccessWarning","enableLazyContextPropagation","enableUseMutableSource","enableTransitionTracing","enableUseHook","enableUseMemoCacheHook","enableUseEffectEventHook","enableLegacyCache","debugRenderPhaseSideEffectsForStrictMode","REACT_CONTEXT_TYPE","REACT_SERVER_CONTEXT_TYPE","REACT_MEMO_CACHE_SENTINEL","NoMode","ConcurrentMode","DebugTracingMode","StrictEffectsMode","StrictLegacyMode","NoLane","SyncLane","OffscreenLane","NoLanes","isSubsetOfLanes","includesBlockingLane","includesOnlyNonUrgentLanes","claimNextTransitionLane","mergeLanes","removeLanes","intersectLanes","isTransitionLane","markRootEntangled","markRootMutableRead","NoTimestamp","ContinuousEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","higherEventPriority","readContext","checkIfContextChanged","HostRoot","CacheComponent","LayoutStatic","LayoutStaticEffect","Passive","PassiveEffect","PassiveStatic","PassiveStaticEffect","StaticMask","StaticMaskEffect","Update","UpdateEffect","StoreConsistency","MountLayoutDev","MountLayoutDevEffect","MountPassiveDev","MountPassiveDevEffect","HasEffect","HookHasEffect","Layout","HookLayout","HookPassive","Insertion","HookInsertion","getWorkInProgressRoot","getWorkInProgressRootRenderLanes","scheduleUpdateOnFiber","requestUpdateLane","requestEventTime","markSkippedUpdateLanes","isInvalidExecutionContextForEventFunction","getComponentNameFromFiber","is","isArray","markWorkInProgressReceivedUpdate","checkIfWorkInProgressReceivedUpdate","getIsHydrating","getWorkInProgressVersion","markSourceAsDirty","setWorkInProgressVersion","warnAboutMultipleRenderersDEV","logStateUpdateScheduled","markStateUpdateScheduled","setIsStrictModeForDevtools","createCache","createUpdate","createLegacyQueueUpdate","enqueueUpdate","enqueueLegacyQueueUpdate","entangleTransitions","entangleLegacyQueueTransitions","enqueueConcurrentHookUpdate","enqueueConcurrentHookUpdateAndEagerlyBailout","enqueueConcurrentRenderForLane","getTreeId","now","trackUsedThenable","checkIfUseWrappedInTryCatch","createThenableState","ReactCurrentDispatcher","ReactCurrentBatchConfig","didWarnAboutMismatchedHooksForComponent","didWarnUncachedGetSnapshot","didWarnAboutUseWrappedInTryCatch","__DEV__","Set","renderLanes","currentlyRenderingFiber","currentHook","workInProgressHook","didScheduleRenderPhaseUpdate","didScheduleRenderPhaseUpdateDuringThisPass","shouldDoubleInvokeUserFnsInHooksDEV","localIdCounter","thenableIndexCounter","thenableState","globalClientIdCounter","RE_RENDER_LIMIT","currentHookNameInDev","hookTypesDev","hookTypesUpdateIndexDev","ignorePreviousDependencies","mountHookTypesDev","hookName","push","updateHookTypesDev","warnOnHookMismatchInDev","checkDepsAreArrayDev","deps","undefined","console","error","currentHookName","componentName","has","add","table","secondColumnStart","i","oldHookName","newHookName","row","length","throwInvalidHookError","Error","areHookInputsEqual","nextDeps","prevDeps","join","renderWithHooks","current","workInProgress","Component","props","secondArg","nextRenderLanes","_debugHookTypes","type","memoizedState","updateQueue","lanes","HooksDispatcherOnUpdateInDEV","HooksDispatcherOnMountWithHookTypesInDEV","HooksDispatcherOnMountInDEV","HooksDispatcherOnMount","HooksDispatcherOnUpdate","shouldDoubleRenderDEV","mode","children","renderWithHooksAgain","finishRenderingHooks","ContextOnlyDispatcher","didRenderTooFewHooks","next","flags","currentDependencies","dependencies","replaySuspendedComponentWithHooks","numberOfReRenders","HooksDispatcherOnRerenderInDEV","HooksDispatcherOnRerender","checkDidRenderIdHook","didRenderIdHook","bailoutHooks","resetHooksAfterThrow","resetHooksOnUnwind","hook","queue","pending","mountWorkInProgressHook","baseState","baseQueue","updateWorkInProgressHook","nextCurrentHook","alternate","nextWorkInProgressHook","currentFiber","newHook","createFunctionComponentUpdateQueue","lastEffect","events","stores","memoCache","use","usable","then","thenable","index","$$typeof","context","String","useMemoCache","size","currentUpdateQueue","currentMemoCache","data","map","array","slice","Array","basicStateReducer","state","action","mountReducer","reducer","initialArg","init","initialState","dispatch","lastRenderedReducer","lastRenderedState","dispatchReducerAction","bind","updateReducer","log","pendingQueue","baseFirst","pendingFirst","first","newState","newBaseState","newBaseQueueFirst","newBaseQueueLast","update","updateLane","lane","isHiddenUpdate","shouldSkipUpdate","clone","hasEagerState","eagerState","rerenderReducer","lastRenderPhaseUpdate","firstRenderPhaseUpdate","readFromUnsubscribedMutableSource","root","source","getSnapshot","getVersion","_getVersion","version","_source","isSafeToReadFromSource","currentRenderVersion","mutableReadLanes","snapshot","useMutableSource","subscribe","dispatcher","currentSnapshot","setSnapshot","useState","stateHook","refs","prevGetSnapshot","prevSource","prevSubscribe","fiber","useEffect","maybeNewVersion","maybeNewSnapshot","handleChange","latestGetSnapshot","latestSetSnapshot","unsubscribe","newQueue","dispatchSetState","mountMutableSource","updateMutableSource","mountSyncExternalStore","getServerSnapshot","nextSnapshot","isHydrating","cachedSnapshot","pushStoreConsistencyCheck","inst","value","mountEffect","subscribeToStore","pushEffect","updateStoreInstance","updateSyncExternalStore","prevSnapshot","snapshotChanged","updateEffect","tag","renderedSnapshot","check","componentUpdateQueue","checkIfSnapshotChanged","forceStoreRerender","handleStoreChange","prevValue","nextValue","mountState","updateState","rerenderState","create","destroy","effect","firstEffect","stackContainsErrorMessage","getCallerStackFrame","stackFrames","stack","split","includes","mountRef","initialValue","hasBeenInitialized","lazyInitGetterStack","didCheckForLazyInit","didWarnAboutRead","didWarnAboutWrite","ref","warn","Object","seal","updateRef","mountEffectImpl","fiberFlags","hookFlags","updateEffectImpl","prevEffect","useEffectEventImpl","payload","mountEvent","callback","impl","eventFn","apply","arguments","updateEvent","nextImpl","mountInsertionEffect","updateInsertionEffect","mountLayoutEffect","updateLayoutEffect","imperativeHandleEffect","refCallback","refObject","hasOwnProperty","keys","mountImperativeHandle","effectDeps","concat","updateImperativeHandle","mountDebugValue","formatterFn","updateDebugValue","mountCallback","updateCallback","prevState","mountMemo","nextCreate","updateMemo","mountDeferredValue","updateDeferredValue","resolvedCurrentHook","updateDeferredValueImpl","rerenderDeferredValue","shouldDeferValue","deferredLane","startTransition","setPending","options","previousPriority","prevTransition","transition","currentTransition","name","startTime","_updatedFibers","updatedFibersCount","clear","mountTransition","isPending","start","updateTransition","rerenderTransition","mountId","identifierPrefix","id","treeId","localId","toString","globalClientId","updateId","mountRefresh","refresh","refreshCache","updateRefresh","seedKey","seedValue","provider","return","eventTime","refreshUpdate","seededCache","set","cache","isRenderPhaseUpdate","enqueueRenderPhaseUpdate","entangleTransitionUpdate","markUpdateInDevTools","prevDispatcher","InvalidNestedHooksDispatcherOnUpdateInDEV","currentState","queueLanes","pendingLanes","newQueueLanes","useCallback","useContext","useImperativeHandle","useInsertionEffect","useLayoutEffect","useMemo","useReducer","useRef","useDebugValue","useDeferredValue","useTransition","useSyncExternalStore","useId","useCacheRefresh","useEffectEvent","InvalidNestedHooksDispatcherOnMountInDEV","InvalidNestedHooksDispatcherOnRerenderInDEV","warnInvalidContextAccess","warnInvalidHookAccess"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  MutableSource,\n  MutableSourceGetSnapshotFn,\n  MutableSourceSubscribeFn,\n  ReactContext,\n  StartTransitionOptions,\n  Usable,\n  Thenable,\n} from 'shared/ReactTypes';\nimport type {\n  Fiber,\n  FiberRoot,\n  Dispatcher,\n  HookType,\n  MemoCache,\n} from './ReactInternalTypes';\nimport type {Lanes, Lane} from './ReactFiberLane';\nimport type {HookFlags} from './ReactHookEffectTags';\nimport type {Flags} from './ReactFiberFlags';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {\n  enableDebugTracing,\n  enableSchedulingProfiler,\n  enableCache,\n  enableUseRefAccessWarning,\n  enableLazyContextPropagation,\n  enableUseMutableSource,\n  enableTransitionTracing,\n  enableUseHook,\n  enableUseMemoCacheHook,\n  enableUseEffectEventHook,\n  enableLegacyCache,\n  debugRenderPhaseSideEffectsForStrictMode,\n} from 'shared/ReactFeatureFlags';\nimport {\n  REACT_CONTEXT_TYPE,\n  REACT_SERVER_CONTEXT_TYPE,\n  REACT_MEMO_CACHE_SENTINEL,\n} from 'shared/ReactSymbols';\n\nimport {\n  NoMode,\n  ConcurrentMode,\n  DebugTracingMode,\n  StrictEffectsMode,\n  StrictLegacyMode,\n} from './ReactTypeOfMode';\nimport {\n  NoLane,\n  SyncLane,\n  OffscreenLane,\n  NoLanes,\n  isSubsetOfLanes,\n  includesBlockingLane,\n  includesOnlyNonUrgentLanes,\n  claimNextTransitionLane,\n  mergeLanes,\n  removeLanes,\n  intersectLanes,\n  isTransitionLane,\n  markRootEntangled,\n  markRootMutableRead,\n  NoTimestamp,\n} from './ReactFiberLane';\nimport {\n  ContinuousEventPriority,\n  getCurrentUpdatePriority,\n  setCurrentUpdatePriority,\n  higherEventPriority,\n} from './ReactEventPriorities';\nimport {readContext, checkIfContextChanged} from './ReactFiberNewContext';\nimport {HostRoot, CacheComponent} from './ReactWorkTags';\nimport {\n  LayoutStatic as LayoutStaticEffect,\n  Passive as PassiveEffect,\n  PassiveStatic as PassiveStaticEffect,\n  StaticMask as StaticMaskEffect,\n  Update as UpdateEffect,\n  StoreConsistency,\n  MountLayoutDev as MountLayoutDevEffect,\n  MountPassiveDev as MountPassiveDevEffect,\n} from './ReactFiberFlags';\nimport {\n  HasEffect as HookHasEffect,\n  Layout as HookLayout,\n  Passive as HookPassive,\n  Insertion as HookInsertion,\n} from './ReactHookEffectTags';\nimport {\n  getWorkInProgressRoot,\n  getWorkInProgressRootRenderLanes,\n  scheduleUpdateOnFiber,\n  requestUpdateLane,\n  requestEventTime,\n  markSkippedUpdateLanes,\n  isInvalidExecutionContextForEventFunction,\n} from './ReactFiberWorkLoop';\n\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport is from 'shared/objectIs';\nimport isArray from 'shared/isArray';\nimport {\n  markWorkInProgressReceivedUpdate,\n  checkIfWorkInProgressReceivedUpdate,\n} from './ReactFiberBeginWork';\nimport {getIsHydrating} from './ReactFiberHydrationContext';\nimport {\n  getWorkInProgressVersion,\n  markSourceAsDirty,\n  setWorkInProgressVersion,\n  warnAboutMultipleRenderersDEV,\n} from './ReactMutableSource';\nimport {logStateUpdateScheduled} from './DebugTracing';\nimport {\n  markStateUpdateScheduled,\n  setIsStrictModeForDevtools,\n} from './ReactFiberDevToolsHook';\nimport {createCache} from './ReactFiberCacheComponent';\nimport {\n  createUpdate as createLegacyQueueUpdate,\n  enqueueUpdate as enqueueLegacyQueueUpdate,\n  entangleTransitions as entangleLegacyQueueTransitions,\n} from './ReactFiberClassUpdateQueue';\nimport {\n  enqueueConcurrentHookUpdate,\n  enqueueConcurrentHookUpdateAndEagerlyBailout,\n  enqueueConcurrentRenderForLane,\n} from './ReactFiberConcurrentUpdates';\nimport {getTreeId} from './ReactFiberTreeContext';\nimport {now} from './Scheduler';\nimport {\n  trackUsedThenable,\n  checkIfUseWrappedInTryCatch,\n  createThenableState,\n} from './ReactFiberThenable';\nimport type {ThenableState} from './ReactFiberThenable';\n\nconst {ReactCurrentDispatcher, ReactCurrentBatchConfig} = ReactSharedInternals;\n\nexport type Update<S, A> = {\n  lane: Lane,\n  action: A,\n  hasEagerState: boolean,\n  eagerState: S | null,\n  next: Update<S, A>,\n};\n\nexport type UpdateQueue<S, A> = {\n  pending: Update<S, A> | null,\n  lanes: Lanes,\n  dispatch: (A => mixed) | null,\n  lastRenderedReducer: ((S, A) => S) | null,\n  lastRenderedState: S | null,\n};\n\nlet didWarnAboutMismatchedHooksForComponent;\nlet didWarnUncachedGetSnapshot;\nlet didWarnAboutUseWrappedInTryCatch;\nif (__DEV__) {\n  didWarnAboutMismatchedHooksForComponent = new Set();\n  didWarnAboutUseWrappedInTryCatch = new Set();\n}\n\nexport type Hook = {\n  memoizedState: any,\n  baseState: any,\n  baseQueue: Update<any, any> | null,\n  queue: any,\n  next: Hook | null,\n};\n\nexport type Effect = {\n  tag: HookFlags,\n  create: () => (() => void) | void,\n  destroy: (() => void) | void,\n  deps: Array<mixed> | void | null,\n  next: Effect,\n};\n\ntype StoreInstance<T> = {\n  value: T,\n  getSnapshot: () => T,\n};\n\ntype StoreConsistencyCheck<T> = {\n  value: T,\n  getSnapshot: () => T,\n};\n\ntype EventFunctionPayload<Args, Return, F: (...Array<Args>) => Return> = {\n  ref: {\n    eventFn: F,\n    impl: F,\n  },\n  nextImpl: F,\n};\n\nexport type FunctionComponentUpdateQueue = {\n  lastEffect: Effect | null,\n  events: Array<EventFunctionPayload<any, any, any>> | null,\n  stores: Array<StoreConsistencyCheck<any>> | null,\n  // NOTE: optional, only set when enableUseMemoCacheHook is enabled\n  memoCache?: MemoCache | null,\n};\n\ntype BasicStateAction<S> = (S => S) | S;\n\ntype Dispatch<A> = A => void;\n\n// These are set right before calling the component.\nlet renderLanes: Lanes = NoLanes;\n// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nlet currentlyRenderingFiber: Fiber = (null: any);\n\n// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nlet currentHook: Hook | null = null;\nlet workInProgressHook: Hook | null = null;\n\n// Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\nlet didScheduleRenderPhaseUpdate: boolean = false;\n// Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\nlet didScheduleRenderPhaseUpdateDuringThisPass: boolean = false;\nlet shouldDoubleInvokeUserFnsInHooksDEV: boolean = false;\n// Counts the number of useId hooks in this component.\nlet localIdCounter: number = 0;\n// Counts number of `use`-d thenables\nlet thenableIndexCounter: number = 0;\nlet thenableState: ThenableState | null = null;\n\n// Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\nlet globalClientIdCounter: number = 0;\n\nconst RE_RENDER_LIMIT = 25;\n\n// In DEV, this is the name of the currently executing primitive hook\nlet currentHookNameInDev: ?HookType = null;\n\n// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nlet hookTypesDev: Array<HookType> | null = null;\nlet hookTypesUpdateIndexDev: number = -1;\n\n// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nlet ignorePreviousDependencies: boolean = false;\n\nfunction mountHookTypesDev(): void {\n  if (__DEV__) {\n    const hookName = ((currentHookNameInDev: any): HookType);\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev(): void {\n  if (__DEV__) {\n    const hookName = ((currentHookNameInDev: any): HookType);\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps: mixed): void {\n  if (__DEV__) {\n    if (deps !== undefined && deps !== null && !isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      console.error(\n        '%s received a final argument that is not an array (instead, received `%s`). When ' +\n          'specified, the final argument must be an array.',\n        currentHookNameInDev,\n        typeof deps,\n      );\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName: HookType): void {\n  if (__DEV__) {\n    const componentName = getComponentNameFromFiber(currentlyRenderingFiber);\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        let table = '';\n\n        const secondColumnStart = 30;\n\n        for (let i = 0; i <= ((hookTypesUpdateIndexDev: any): number); i++) {\n          const oldHookName = hookTypesDev[i];\n          const newHookName =\n            i === ((hookTypesUpdateIndexDev: any): number)\n              ? currentHookName\n              : oldHookName;\n\n          let row = `${i + 1}. ${oldHookName}`;\n\n          // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n\n          table += row;\n        }\n\n        console.error(\n          'React has detected a change in the order of Hooks called by %s. ' +\n            'This will lead to bugs and errors if not fixed. ' +\n            'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' +\n            '   Previous render            Next render\\n' +\n            '   ------------------------------------------------------\\n' +\n            '%s' +\n            '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',\n          componentName,\n          table,\n        );\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  throw new Error(\n    'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n      ' one of the following reasons:\\n' +\n      '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n      '2. You might be breaking the Rules of Hooks\\n' +\n      '3. You might have more than one copy of React in the same app\\n' +\n      'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',\n  );\n}\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n): boolean {\n  if (__DEV__) {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    if (__DEV__) {\n      console.error(\n        '%s received a final argument during this render, but not during ' +\n          'the previous render. Even though the final argument is optional, ' +\n          'its type cannot change between renders.',\n        currentHookNameInDev,\n      );\n    }\n    return false;\n  }\n\n  if (__DEV__) {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      console.error(\n        'The final argument passed to %s changed size between renders. The ' +\n          'order and size of this array must remain constant.\\n\\n' +\n          'Previous: %s\\n' +\n          'Incoming: %s',\n        currentHookNameInDev,\n        `[${prevDeps.join(', ')}]`,\n        `[${nextDeps.join(', ')}]`,\n      );\n    }\n  }\n  // $FlowFixMe[incompatible-use] found when upgrading Flow\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    // $FlowFixMe[incompatible-use] found when upgrading Flow\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nexport function renderWithHooks<Props, SecondArg>(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: (p: Props, arg: SecondArg) => any,\n  props: Props,\n  secondArg: SecondArg,\n  nextRenderLanes: Lanes,\n): any {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber = workInProgress;\n\n  if (__DEV__) {\n    hookTypesDev =\n      current !== null\n        ? ((current._debugHookTypes: any): Array<HookType>)\n        : null;\n    hookTypesUpdateIndexDev = -1;\n    // Used for hot reloading:\n    ignorePreviousDependencies =\n      current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = NoLanes;\n\n  // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n\n  // didScheduleRenderPhaseUpdate = false;\n  // localIdCounter = 0;\n  // thenableIndexCounter = 0;\n  // thenableState = null;\n\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n  if (__DEV__) {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV;\n    }\n  } else {\n    ReactCurrentDispatcher.current =\n      current === null || current.memoizedState === null\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate;\n  }\n\n  // In Strict Mode, during development, user functions are double invoked to\n  // help detect side effects. The logic for how this is implemented for in\n  // hook components is a bit complex so let's break it down.\n  //\n  // We will invoke the entire component function twice. However, during the\n  // second invocation of the component, the hook state from the first\n  // invocation will be reused. That means things like `useMemo` functions won't\n  // run again, because the deps will match and the memoized result will\n  // be reused.\n  //\n  // We want memoized functions to run twice, too, so account for this, user\n  // functions are double invoked during the *first* invocation of the component\n  // function, and are *not* double invoked during the second incovation:\n  //\n  // - First execution of component function: user functions are double invoked\n  // - Second execution of component function (in Strict Mode, during\n  //   development): user functions are not double invoked.\n  //\n  // This is intentional for a few reasons; most importantly, it's because of\n  // how `use` works when something suspends: it reuses the promise that was\n  // passed during the first attempt. This is itself a form of memoization.\n  // We need to be able to memoize the reactive inputs to the `use` call using\n  // a hook (i.e. `useMemo`), which means, the reactive inputs to `use` must\n  // come from the same component invocation as the output.\n  //\n  // There are plenty of tests to ensure this behavior is correct.\n  const shouldDoubleRenderDEV =\n    __DEV__ &&\n    debugRenderPhaseSideEffectsForStrictMode &&\n    (workInProgress.mode & StrictLegacyMode) !== NoMode;\n\n  shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;\n  let children = Component(props, secondArg);\n  shouldDoubleInvokeUserFnsInHooksDEV = false;\n\n  // Check if there was a render phase update\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    // Keep rendering until the component stabilizes (there are no more render\n    // phase updates).\n    children = renderWithHooksAgain(\n      workInProgress,\n      Component,\n      props,\n      secondArg,\n    );\n  }\n\n  if (shouldDoubleRenderDEV) {\n    // In development, components are invoked twice to help detect side effects.\n    setIsStrictModeForDevtools(true);\n    try {\n      children = renderWithHooksAgain(\n        workInProgress,\n        Component,\n        props,\n        secondArg,\n      );\n    } finally {\n      setIsStrictModeForDevtools(false);\n    }\n  }\n\n  finishRenderingHooks(current, workInProgress);\n\n  return children;\n}\n\nfunction finishRenderingHooks(current: Fiber | null, workInProgress: Fiber) {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (__DEV__) {\n    workInProgress._debugHookTypes = hookTypesDev;\n  }\n\n  // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n  const didRenderTooFewHooks =\n    currentHook !== null && currentHook.next !== null;\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = (null: any);\n\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n\n    // Confirm that a static flag was not added or removed since the last\n    // render. If this fires, it suggests that we incorrectly reset the static\n    // flags in some other part of the codebase. This has happened before, for\n    // example, in the SuspenseList implementation.\n    if (\n      current !== null &&\n      (current.flags & StaticMaskEffect) !==\n        (workInProgress.flags & StaticMaskEffect) &&\n      // Disable this warning in legacy mode, because legacy Suspense is weird\n      // and creates false positives. To make this work in legacy mode, we'd\n      // need to mark fibers that commit in an incomplete state, somehow. For\n      // now I'll disable the warning that most of the bugs that would trigger\n      // it are either exclusive to concurrent mode or exist in both.\n      (current.mode & ConcurrentMode) !== NoMode\n    ) {\n      console.error(\n        'Internal React error: Expected static flag was missing. Please ' +\n          'notify the React team.',\n      );\n    }\n  }\n\n  didScheduleRenderPhaseUpdate = false;\n  // This is reset by checkDidRenderIdHook\n  // localIdCounter = 0;\n\n  thenableIndexCounter = 0;\n  thenableState = null;\n\n  if (didRenderTooFewHooks) {\n    throw new Error(\n      'Rendered fewer hooks than expected. This may be caused by an accidental ' +\n        'early return statement.',\n    );\n  }\n\n  if (enableLazyContextPropagation) {\n    if (current !== null) {\n      if (!checkIfWorkInProgressReceivedUpdate()) {\n        // If there were no changes to props or state, we need to check if there\n        // was a context change. We didn't already do this because there's no\n        // 1:1 correspondence between dependencies and hooks. Although, because\n        // there almost always is in the common case (`readContext` is an\n        // internal API), we could compare in there. OTOH, we only hit this case\n        // if everything else bails out, so on the whole it might be better to\n        // keep the comparison out of the common path.\n        const currentDependencies = current.dependencies;\n        if (\n          currentDependencies !== null &&\n          checkIfContextChanged(currentDependencies)\n        ) {\n          markWorkInProgressReceivedUpdate();\n        }\n      }\n    }\n  }\n\n  if (__DEV__) {\n    if (checkIfUseWrappedInTryCatch()) {\n      const componentName =\n        getComponentNameFromFiber(workInProgress) || 'Unknown';\n      if (!didWarnAboutUseWrappedInTryCatch.has(componentName)) {\n        didWarnAboutUseWrappedInTryCatch.add(componentName);\n        console.error(\n          '`use` was called from inside a try/catch block. This is not allowed ' +\n            'and can lead to unexpected behavior. To handle errors triggered ' +\n            'by `use`, wrap your component in a error boundary.',\n        );\n      }\n    }\n  }\n}\n\nexport function replaySuspendedComponentWithHooks<Props, SecondArg>(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: (p: Props, arg: SecondArg) => any,\n  props: Props,\n  secondArg: SecondArg,\n): any {\n  // This function is used to replay a component that previously suspended,\n  // after its data resolves.\n  //\n  // It's a simplified version of renderWithHooks, but it doesn't need to do\n  // most of the set up work because they weren't reset when we suspended; they\n  // only get reset when the component either completes (finishRenderingHooks)\n  // or unwinds (resetHooksOnUnwind).\n  if (__DEV__) {\n    hookTypesDev =\n      current !== null\n        ? ((current._debugHookTypes: any): Array<HookType>)\n        : null;\n    hookTypesUpdateIndexDev = -1;\n    // Used for hot reloading:\n    ignorePreviousDependencies =\n      current !== null && current.type !== workInProgress.type;\n  }\n  const children = renderWithHooksAgain(\n    workInProgress,\n    Component,\n    props,\n    secondArg,\n  );\n  finishRenderingHooks(current, workInProgress);\n  return children;\n}\n\nfunction renderWithHooksAgain<Props, SecondArg>(\n  workInProgress: Fiber,\n  Component: (p: Props, arg: SecondArg) => any,\n  props: Props,\n  secondArg: SecondArg,\n): any {\n  // This is used to perform another render pass. It's used when setState is\n  // called during render, and for double invoking components in Strict Mode\n  // during development.\n  //\n  // The state from the previous pass is reused whenever possible. So, state\n  // updates that were already processed are not processed again, and memoized\n  // functions (`useMemo`) are not invoked again.\n  //\n  // Keep rendering in a loop for as long as render phase updates continue to\n  // be scheduled. Use a counter to prevent infinite loops.\n  let numberOfReRenders: number = 0;\n  let children;\n  do {\n    didScheduleRenderPhaseUpdateDuringThisPass = false;\n    thenableIndexCounter = 0;\n\n    if (numberOfReRenders >= RE_RENDER_LIMIT) {\n      throw new Error(\n        'Too many re-renders. React limits the number of renders to prevent ' +\n          'an infinite loop.',\n      );\n    }\n\n    numberOfReRenders += 1;\n    if (__DEV__) {\n      // Even when hot reloading, allow dependencies to stabilize\n      // after first render to prevent infinite render phase updates.\n      ignorePreviousDependencies = false;\n    }\n\n    // Start over from the beginning of the list\n    currentHook = null;\n    workInProgressHook = null;\n\n    workInProgress.updateQueue = null;\n\n    if (__DEV__) {\n      // Also validate hook order for cascading updates.\n      hookTypesUpdateIndexDev = -1;\n    }\n\n    ReactCurrentDispatcher.current = __DEV__\n      ? HooksDispatcherOnRerenderInDEV\n      : HooksDispatcherOnRerender;\n\n    children = Component(props, secondArg);\n  } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  return children;\n}\n\nexport function checkDidRenderIdHook(): boolean {\n  // This should be called immediately after every renderWithHooks call.\n  // Conceptually, it's part of the return value of renderWithHooks; it's only a\n  // separate function to avoid using an array tuple.\n  const didRenderIdHook = localIdCounter !== 0;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\n\nexport function bailoutHooks(\n  current: Fiber,\n  workInProgress: Fiber,\n  lanes: Lanes,\n): void {\n  workInProgress.updateQueue = current.updateQueue;\n  // TODO: Don't need to reset the flags here, because they're reset in the\n  // complete phase (bubbleProperties).\n  if (__DEV__ && (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n    workInProgress.flags &= ~(\n      MountPassiveDevEffect |\n      MountLayoutDevEffect |\n      PassiveEffect |\n      UpdateEffect\n    );\n  } else {\n    workInProgress.flags &= ~(PassiveEffect | UpdateEffect);\n  }\n  current.lanes = removeLanes(current.lanes, lanes);\n}\n\nexport function resetHooksAfterThrow(): void {\n  // This is called immediaetly after a throw. It shouldn't reset the entire\n  // module state, because the work loop might decide to replay the component\n  // again without rewinding.\n  //\n  // It should only reset things like the current dispatcher, to prevent hooks\n  // from being called outside of a component.\n\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n}\n\nexport function resetHooksOnUnwind(): void {\n  if (didScheduleRenderPhaseUpdate) {\n    // There were render phase updates. These are only valid for this render\n    // phase, which we are now aborting. Remove the updates from the queues so\n    // they do not persist to the next render. Do not remove updates from hooks\n    // that weren't processed.\n    //\n    // Only reset the updates from the queue if it has a clone. If it does\n    // not have a clone, that means it wasn't processed, and the updates were\n    // scheduled before we entered the render phase.\n    let hook: Hook | null = currentlyRenderingFiber.memoizedState;\n    while (hook !== null) {\n      const queue = hook.queue;\n      if (queue !== null) {\n        queue.pending = null;\n      }\n      hook = hook.next;\n    }\n    didScheduleRenderPhaseUpdate = false;\n  }\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber = (null: any);\n\n  currentHook = null;\n  workInProgressHook = null;\n\n  if (__DEV__) {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n\n    currentHookNameInDev = null;\n  }\n\n  didScheduleRenderPhaseUpdateDuringThisPass = false;\n  localIdCounter = 0;\n  thenableIndexCounter = 0;\n  thenableState = null;\n}\n\nfunction mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n\n    next: null,\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook(): Hook {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  let nextCurrentHook: null | Hook;\n  if (currentHook === null) {\n    const current = currentlyRenderingFiber.alternate;\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    nextCurrentHook = currentHook.next;\n  }\n\n  let nextWorkInProgressHook: null | Hook;\n  if (workInProgressHook === null) {\n    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n\n    currentHook = nextCurrentHook;\n  } else {\n    // Clone from the current hook.\n\n    if (nextCurrentHook === null) {\n      const currentFiber = currentlyRenderingFiber.alternate;\n      if (currentFiber === null) {\n        // This is the initial render. This branch is reached when the component\n        // suspends, resumes, then renders an additional hook.\n        const newHook: Hook = {\n          memoizedState: null,\n\n          baseState: null,\n          baseQueue: null,\n          queue: null,\n\n          next: null,\n        };\n        nextCurrentHook = newHook;\n      } else {\n        // This is an update. We should always have a current hook.\n        throw new Error('Rendered more hooks than during the previous render.');\n      }\n    }\n\n    currentHook = nextCurrentHook;\n\n    const newHook: Hook = {\n      memoizedState: currentHook.memoizedState,\n\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n\n      next: null,\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n  return workInProgressHook;\n}\n\n// NOTE: defining two versions of this function to avoid size impact when this feature is disabled.\n// Previously this function was inlined, the additional `memoCache` property makes it not inlined.\nlet createFunctionComponentUpdateQueue: () => FunctionComponentUpdateQueue;\nif (enableUseMemoCacheHook) {\n  createFunctionComponentUpdateQueue = () => {\n    return {\n      lastEffect: null,\n      events: null,\n      stores: null,\n      memoCache: null,\n    };\n  };\n} else {\n  createFunctionComponentUpdateQueue = () => {\n    return {\n      lastEffect: null,\n      events: null,\n      stores: null,\n    };\n  };\n}\n\nfunction use<T>(usable: Usable<T>): T {\n  if (usable !== null && typeof usable === 'object') {\n    // $FlowFixMe[method-unbinding]\n    if (typeof usable.then === 'function') {\n      // This is a thenable.\n      const thenable: Thenable<T> = (usable: any);\n\n      // Track the position of the thenable within this fiber.\n      const index = thenableIndexCounter;\n      thenableIndexCounter += 1;\n\n      if (thenableState === null) {\n        thenableState = createThenableState();\n      }\n      return trackUsedThenable(thenableState, thenable, index);\n    } else if (\n      usable.$$typeof === REACT_CONTEXT_TYPE ||\n      usable.$$typeof === REACT_SERVER_CONTEXT_TYPE\n    ) {\n      const context: ReactContext<T> = (usable: any);\n      return readContext(context);\n    }\n  }\n\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  throw new Error('An unsupported type was passed to use(): ' + String(usable));\n}\n\nfunction useMemoCache(size: number): Array<any> {\n  let memoCache = null;\n  // Fast-path, load memo cache from wip fiber if already prepared\n  let updateQueue: FunctionComponentUpdateQueue | null = (currentlyRenderingFiber.updateQueue: any);\n  if (updateQueue !== null) {\n    memoCache = updateQueue.memoCache;\n  }\n  // Otherwise clone from the current fiber\n  if (memoCache == null) {\n    const current: Fiber | null = currentlyRenderingFiber.alternate;\n    if (current !== null) {\n      const currentUpdateQueue: FunctionComponentUpdateQueue | null = (current.updateQueue: any);\n      if (currentUpdateQueue !== null) {\n        const currentMemoCache: ?MemoCache = currentUpdateQueue.memoCache;\n        if (currentMemoCache != null) {\n          memoCache = {\n            data: currentMemoCache.data.map(array => array.slice()),\n            index: 0,\n          };\n        }\n      }\n    }\n  }\n  // Finally fall back to allocating a fresh instance of the cache\n  if (memoCache == null) {\n    memoCache = {\n      data: [],\n      index: 0,\n    };\n  }\n  if (updateQueue === null) {\n    updateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = updateQueue;\n  }\n  updateQueue.memoCache = memoCache;\n\n  let data = memoCache.data[memoCache.index];\n  if (data === undefined) {\n    data = memoCache.data[memoCache.index] = new Array(size);\n    for (let i = 0; i < size; i++) {\n      data[i] = REACT_MEMO_CACHE_SENTINEL;\n    }\n  } else if (data.length !== size) {\n    // TODO: consider warning or throwing here\n    if (__DEV__) {\n      console.error(\n        'Expected a constant size argument for each invocation of useMemoCache. ' +\n          'The previous cache was allocated with size %s but size %s was requested.',\n        data.length,\n        size,\n      );\n    }\n  }\n  memoCache.index++;\n  return data;\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = mountWorkInProgressHook();\n  let initialState;\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = ((initialArg: any): S);\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue: UpdateQueue<S, A> = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: (initialState: any),\n  };\n  hook.queue = queue;\n  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchReducerAction.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error(\n      'Should have a queue. This is likely a bug in React. Please file an issue.',\n    );\n  }\n\n  queue.lastRenderedReducer = reducer;\n\n  const current: Hook = (currentHook: any);\n\n  console.log('useState-current = ', current);\n  // The last rebase update that is NOT part of the base state.\n  let baseQueue = current.baseQueue;\n  console.log('useState-baseQueue = ', baseQueue);\n  // The last pending update that hasn't been processed yet.\n  const pendingQueue = queue.pending;\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      const baseFirst = baseQueue.next;\n      const pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n    if (__DEV__) {\n      if (current.baseQueue !== baseQueue) {\n        // Internal invariant that should never happen, but feasibly could in\n        // the future if we implement resuming, or some form of that.\n        console.error(\n          'Internal error: Expected work-in-progress queue to be a clone. ' +\n            'This is a bug in React.',\n        );\n      }\n    }\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  console.log('useState-pendingQueue = ', pendingQueue);\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    const first = baseQueue.next;\n    let newState = current.baseState;\n\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n    let update = first;\n    do {\n      // An extra OffscreenLane bit is added to updates that were made to\n      // a hidden tree, so that we can distinguish them from updates that were\n      // already there when the tree was hidden.\n      const updateLane = removeLanes(update.lane, OffscreenLane);\n      const isHiddenUpdate = updateLane !== update.lane;\n\n      // Check if this update was made while the tree was hidden. If so, then\n      // it's not a \"base\" update and we should disregard the extra base lanes\n      // that were added to renderLanes when we entered the Offscreen tree.\n      const shouldSkipUpdate = isHiddenUpdate\n        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)\n        : !isSubsetOfLanes(renderLanes, updateLane);\n\n      if (shouldSkipUpdate) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone: Update<S, A> = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: (null: any),\n        };\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        }\n        // Update the remaining priority in the queue.\n        // TODO: Don't need to accumulate this. Instead, we can remove\n        // renderLanes from the original lanes.\n        currentlyRenderingFiber.lanes = mergeLanes(\n          currentlyRenderingFiber.lanes,\n          updateLane,\n        );\n        markSkippedUpdateLanes(updateLane);\n      } else {\n        // This update does have sufficient priority.\n\n        if (newBaseQueueLast !== null) {\n          const clone: Update<S, A> = {\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: (null: any),\n          };\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        }\n\n        // Process this update.\n        const action = update.action;\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n          reducer(newState, action);\n        }\n        console.log('T-update = ', update);\n        if (update.hasEagerState) {\n          // If this update is a state update (not a reducer) and was processed eagerly,\n          // we can use the eagerly computed state\n          newState = ((update.eagerState: any): S);\n        } else {\n          newState = reducer(newState, action);\n        }\n        console.log('useState-newState = ', newState);\n      }\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = (newBaseQueueFirst: any);\n    }\n\n    // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n    console.log('useState-updateHook = ', hook);\n    queue.lastRenderedState = newState;\n  }\n\n  if (baseQueue === null) {\n    // `queue.lanes` is used for entangling transitions. We can set it back to\n    // zero once the queue is empty.\n    queue.lanes = NoLanes;\n  }\n  console.log('useState-current = ', current);\n  console.log('useState-workInProgress = ', hook)\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction rerenderReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error(\n      'Should have a queue. This is likely a bug in React. Please file an issue.',\n    );\n  }\n\n  queue.lastRenderedReducer = reducer;\n\n  // This is a re-render. Apply the new render phase updates to the previous\n  // work-in-progress hook.\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  const lastRenderPhaseUpdate = queue.pending;\n  let newState = hook.memoizedState;\n  if (lastRenderPhaseUpdate !== null) {\n    // The queue doesn't persist past this render pass.\n    queue.pending = null;\n\n    const firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n    let update = firstRenderPhaseUpdate;\n    do {\n      // Process this render phase update. We don't have to check the\n      // priority because it will always be the same as the current\n      // render's.\n      const action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== firstRenderPhaseUpdate);\n\n    // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    // Don't persist the state accumulated from the render phase updates to\n    // the base state unless the queue is empty.\n    // TODO: Not sure if this is the desired semantics, but it's what we\n    // do for gDSFP. I can't remember why.\n    if (hook.baseQueue === null) {\n      hook.baseState = newState;\n    }\n\n    queue.lastRenderedState = newState;\n  }\n  return [newState, dispatch];\n}\n\ntype MutableSourceMemoizedState<Source, Snapshot> = {\n  refs: {\n    getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n    setSnapshot: Snapshot => void,\n  },\n  source: MutableSource<any>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n};\n\nfunction readFromUnsubscribedMutableSource<Source, Snapshot>(\n  root: FiberRoot,\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n): Snapshot {\n  if (__DEV__) {\n    warnAboutMultipleRenderersDEV(source);\n  }\n\n  const getVersion = source._getVersion;\n  const version = getVersion(source._source);\n\n  // Is it safe for this component to read from this source during the current render?\n  let isSafeToReadFromSource = false;\n\n  // Check the version first.\n  // If this render has already been started with a specific version,\n  // we can use it alone to determine if we can safely read from the source.\n  const currentRenderVersion = getWorkInProgressVersion(source);\n  if (currentRenderVersion !== null) {\n    // It's safe to read if the store hasn't been mutated since the last time\n    // we read something.\n    isSafeToReadFromSource = currentRenderVersion === version;\n  } else {\n    // If there's no version, then this is the first time we've read from the\n    // source during the current render pass, so we need to do a bit more work.\n    // What we need to determine is if there are any hooks that already\n    // subscribed to the source, and if so, whether there are any pending\n    // mutations that haven't been synchronized yet.\n    //\n    // If there are no pending mutations, then `root.mutableReadLanes` will be\n    // empty, and we know we can safely read.\n    //\n    // If there *are* pending mutations, we may still be able to safely read\n    // if the currently rendering lanes are inclusive of the pending mutation\n    // lanes, since that guarantees that the value we're about to read from\n    // the source is consistent with the values that we read during the most\n    // recent mutation.\n    isSafeToReadFromSource = isSubsetOfLanes(\n      renderLanes,\n      root.mutableReadLanes,\n    );\n\n    if (isSafeToReadFromSource) {\n      // If it's safe to read from this source during the current render,\n      // store the version in case other components read from it.\n      // A changed version number will let those components know to throw and restart the render.\n      setWorkInProgressVersion(source, version);\n    }\n  }\n\n  if (isSafeToReadFromSource) {\n    const snapshot = getSnapshot(source._source);\n    if (__DEV__) {\n      if (typeof snapshot === 'function') {\n        console.error(\n          'Mutable source should not return a function as the snapshot value. ' +\n            'Functions may close over mutable values and cause tearing.',\n        );\n      }\n    }\n    return snapshot;\n  } else {\n    // This handles the special case of a mutable source being shared between renderers.\n    // In that case, if the source is mutated between the first and second renderer,\n    // The second renderer don't know that it needs to reset the WIP version during unwind,\n    // (because the hook only marks sources as dirty if it's written to their WIP version).\n    // That would cause this tear check to throw again and eventually be visible to the user.\n    // We can avoid this infinite loop by explicitly marking the source as dirty.\n    //\n    // This can lead to tearing in the first renderer when it resumes,\n    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).\n    markSourceAsDirty(source);\n\n    // Intentioally throw an error to force React to retry synchronously. During\n    // the synchronous retry, it will block interleaved mutations, so we should\n    // get a consistent read. Therefore, the following error should never be\n    // visible to the user.\n\n    // We expect this error not to be thrown during the synchronous retry,\n    // because we blocked interleaved mutations.\n    throw new Error(\n      'Cannot read from mutable source during the current render without tearing. This may be a bug in React. Please file an issue.',\n    );\n  }\n}\n\nfunction useMutableSource<Source, Snapshot>(\n  hook: Hook,\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n): Snapshot {\n  if (!enableUseMutableSource) {\n    return (undefined: any);\n  }\n\n  const root = ((getWorkInProgressRoot(): any): FiberRoot);\n\n  if (root === null) {\n    throw new Error(\n      'Expected a work-in-progress root. This is a bug in React. Please file an issue.',\n    );\n  }\n\n  const getVersion = source._getVersion;\n  const version = getVersion(source._source);\n\n  const dispatcher = ReactCurrentDispatcher.current;\n\n  // eslint-disable-next-line prefer-const\n  let [currentSnapshot, setSnapshot] = dispatcher.useState(() =>\n    readFromUnsubscribedMutableSource(root, source, getSnapshot),\n  );\n  let snapshot = currentSnapshot;\n\n  // Grab a handle to the state hook as well.\n  // We use it to clear the pending update queue if we have a new source.\n  const stateHook = ((workInProgressHook: any): Hook);\n\n  const memoizedState = ((hook.memoizedState: any): MutableSourceMemoizedState<\n    Source,\n    Snapshot,\n  >);\n  const refs = memoizedState.refs;\n  const prevGetSnapshot = refs.getSnapshot;\n  const prevSource = memoizedState.source;\n  const prevSubscribe = memoizedState.subscribe;\n\n  const fiber = currentlyRenderingFiber;\n\n  hook.memoizedState = ({\n    refs,\n    source,\n    subscribe,\n  }: MutableSourceMemoizedState<Source, Snapshot>);\n\n  // Sync the values needed by our subscription handler after each commit.\n  dispatcher.useEffect(() => {\n    refs.getSnapshot = getSnapshot;\n\n    // Normally the dispatch function for a state hook never changes,\n    // but this hook recreates the queue in certain cases  to avoid updates from stale sources.\n    // handleChange() below needs to reference the dispatch function without re-subscribing,\n    // so we use a ref to ensure that it always has the latest version.\n    refs.setSnapshot = setSnapshot;\n\n    // Check for a possible change between when we last rendered now.\n    const maybeNewVersion = getVersion(source._source);\n    if (!is(version, maybeNewVersion)) {\n      const maybeNewSnapshot = getSnapshot(source._source);\n      if (__DEV__) {\n        if (typeof maybeNewSnapshot === 'function') {\n          console.error(\n            'Mutable source should not return a function as the snapshot value. ' +\n              'Functions may close over mutable values and cause tearing.',\n          );\n        }\n      }\n\n      if (!is(snapshot, maybeNewSnapshot)) {\n        setSnapshot(maybeNewSnapshot);\n\n        const lane = requestUpdateLane(fiber);\n        markRootMutableRead(root, lane);\n      }\n      // If the source mutated between render and now,\n      // there may be state updates already scheduled from the old source.\n      // Entangle the updates so that they render in the same batch.\n      markRootEntangled(root, root.mutableReadLanes);\n    }\n  }, [getSnapshot, source, subscribe]);\n\n  // If we got a new source or subscribe function, re-subscribe in a passive effect.\n  dispatcher.useEffect(() => {\n    const handleChange = () => {\n      const latestGetSnapshot = refs.getSnapshot;\n      const latestSetSnapshot = refs.setSnapshot;\n\n      try {\n        latestSetSnapshot(latestGetSnapshot(source._source));\n\n        // Record a pending mutable source update with the same expiration time.\n        const lane = requestUpdateLane(fiber);\n\n        markRootMutableRead(root, lane);\n      } catch (error) {\n        // A selector might throw after a source mutation.\n        // e.g. it might try to read from a part of the store that no longer exists.\n        // In this case we should still schedule an update with React.\n        // Worst case the selector will throw again and then an error boundary will handle it.\n        latestSetSnapshot(\n          (() => {\n            throw error;\n          }: any),\n        );\n      }\n    };\n\n    const unsubscribe = subscribe(source._source, handleChange);\n    if (__DEV__) {\n      if (typeof unsubscribe !== 'function') {\n        console.error(\n          'Mutable source subscribe function must return an unsubscribe function.',\n        );\n      }\n    }\n\n    return unsubscribe;\n  }, [source, subscribe]);\n\n  // If any of the inputs to useMutableSource change, reading is potentially unsafe.\n  //\n  // If either the source or the subscription have changed we can't can't trust the update queue.\n  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.\n  //\n  // If the getSnapshot function changed, we also shouldn't rely on the update queue.\n  // It's possible that the underlying source was mutated between the when the last \"change\" event fired,\n  // and when the current render (with the new getSnapshot function) is processed.\n  //\n  // In both cases, we need to throw away pending updates (since they are no longer relevant)\n  // and treat reading from the source as we do in the mount case.\n  if (\n    !is(prevGetSnapshot, getSnapshot) ||\n    !is(prevSource, source) ||\n    !is(prevSubscribe, subscribe)\n  ) {\n    // Create a new queue and setState method,\n    // So if there are interleaved updates, they get pushed to the older queue.\n    // When this becomes current, the previous queue and dispatch method will be discarded,\n    // including any interleaving updates that occur.\n    const newQueue: UpdateQueue<Snapshot, BasicStateAction<Snapshot>> = {\n      pending: null,\n      lanes: NoLanes,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: snapshot,\n    };\n    newQueue.dispatch = setSnapshot = (dispatchSetState.bind(\n      null,\n      currentlyRenderingFiber,\n      newQueue,\n    ): any);\n    stateHook.queue = newQueue;\n    stateHook.baseQueue = null;\n    snapshot = readFromUnsubscribedMutableSource(root, source, getSnapshot);\n    stateHook.memoizedState = stateHook.baseState = snapshot;\n  }\n\n  return snapshot;\n}\n\nfunction mountMutableSource<Source, Snapshot>(\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n): Snapshot {\n  if (!enableUseMutableSource) {\n    return (undefined: any);\n  }\n\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = ({\n    refs: {\n      getSnapshot,\n      setSnapshot: (null: any),\n    },\n    source,\n    subscribe,\n  }: MutableSourceMemoizedState<Source, Snapshot>);\n  return useMutableSource(hook, source, getSnapshot, subscribe);\n}\n\nfunction updateMutableSource<Source, Snapshot>(\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n): Snapshot {\n  if (!enableUseMutableSource) {\n    return (undefined: any);\n  }\n\n  const hook = updateWorkInProgressHook();\n  return useMutableSource(hook, source, getSnapshot, subscribe);\n}\n\nfunction mountSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const fiber = currentlyRenderingFiber;\n  const hook = mountWorkInProgressHook();\n\n  let nextSnapshot;\n  const isHydrating = getIsHydrating();\n  if (isHydrating) {\n    if (getServerSnapshot === undefined) {\n      throw new Error(\n        'Missing getServerSnapshot, which is required for ' +\n          'server-rendered content. Will revert to client rendering.',\n      );\n    }\n    nextSnapshot = getServerSnapshot();\n    if (__DEV__) {\n      if (!didWarnUncachedGetSnapshot) {\n        if (nextSnapshot !== getServerSnapshot()) {\n          console.error(\n            'The result of getServerSnapshot should be cached to avoid an infinite loop',\n          );\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    }\n  } else {\n    nextSnapshot = getSnapshot();\n    if (__DEV__) {\n      if (!didWarnUncachedGetSnapshot) {\n        const cachedSnapshot = getSnapshot();\n        if (!is(nextSnapshot, cachedSnapshot)) {\n          console.error(\n            'The result of getSnapshot should be cached to avoid an infinite loop',\n          );\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    }\n    // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n    //\n    // We won't do this if we're hydrating server-rendered content, because if\n    // the content is stale, it's already visible anyway. Instead we'll patch\n    // it up in a passive effect.\n    const root: FiberRoot | null = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error(\n        'Expected a work-in-progress root. This is a bug in React. Please file an issue.',\n      );\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n  hook.memoizedState = nextSnapshot;\n  const inst: StoreInstance<T> = {\n    value: nextSnapshot,\n    getSnapshot,\n  };\n  hook.queue = inst;\n\n  // Schedule an effect to subscribe to the store.\n  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);\n\n  // Schedule an effect to update the mutable instance fields. We will update\n  // this whenever subscribe, getSnapshot, or value changes. Because there's no\n  // clean-up function, and we track the deps correctly, we can call pushEffect\n  // directly, without storing any additional state. For the same reason, we\n  // don't need to set a static flag, either.\n  // TODO: We can move this to the passive phase once we add a pre-commit\n  // consistency check. See the next comment.\n  fiber.flags |= PassiveEffect;\n  pushEffect(\n    HookHasEffect | HookPassive,\n    updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),\n    undefined,\n    null,\n  );\n\n  return nextSnapshot;\n}\n\nfunction updateSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const fiber = currentlyRenderingFiber;\n  const hook = updateWorkInProgressHook();\n  // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n  const nextSnapshot = getSnapshot();\n  if (__DEV__) {\n    if (!didWarnUncachedGetSnapshot) {\n      const cachedSnapshot = getSnapshot();\n      if (!is(nextSnapshot, cachedSnapshot)) {\n        console.error(\n          'The result of getSnapshot should be cached to avoid an infinite loop',\n        );\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  }\n  const prevSnapshot = (currentHook || hook).memoizedState;\n  const snapshotChanged = !is(prevSnapshot, nextSnapshot);\n  if (snapshotChanged) {\n    hook.memoizedState = nextSnapshot;\n    markWorkInProgressReceivedUpdate();\n  }\n  const inst = hook.queue;\n\n  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n    subscribe,\n  ]);\n\n  // Whenever getSnapshot or subscribe changes, we need to check in the\n  // commit phase if there was an interleaved mutation. In concurrent mode\n  // this can happen all the time, but even in synchronous mode, an earlier\n  // effect may have mutated the store.\n  if (\n    inst.getSnapshot !== getSnapshot ||\n    snapshotChanged ||\n    // Check if the susbcribe function changed. We can save some memory by\n    // checking whether we scheduled a subscription effect above.\n    (workInProgressHook !== null &&\n      workInProgressHook.memoizedState.tag & HookHasEffect)\n  ) {\n    fiber.flags |= PassiveEffect;\n    pushEffect(\n      HookHasEffect | HookPassive,\n      updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),\n      undefined,\n      null,\n    );\n\n    // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n    const root: FiberRoot | null = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error(\n        'Expected a work-in-progress root. This is a bug in React. Please file an issue.',\n      );\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction pushStoreConsistencyCheck<T>(\n  fiber: Fiber,\n  getSnapshot: () => T,\n  renderedSnapshot: T,\n): void {\n  fiber.flags |= StoreConsistency;\n  const check: StoreConsistencyCheck<T> = {\n    getSnapshot,\n    value: renderedSnapshot,\n  };\n  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\n    componentUpdateQueue.stores = [check];\n  } else {\n    const stores = componentUpdateQueue.stores;\n    if (stores === null) {\n      componentUpdateQueue.stores = [check];\n    } else {\n      stores.push(check);\n    }\n  }\n}\n\nfunction updateStoreInstance<T>(\n  fiber: Fiber,\n  inst: StoreInstance<T>,\n  nextSnapshot: T,\n  getSnapshot: () => T,\n): void {\n  // These are updated in the passive phase\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot;\n\n  // Something may have been mutated in between render and commit. This could\n  // have been in an event that fired before the passive effects, or it could\n  // have been in a layout effect. In that case, we would have used the old\n  // snapsho and getSnapshot values to bail out. We need to check one more time.\n  if (checkIfSnapshotChanged(inst)) {\n    // Force a re-render.\n    forceStoreRerender(fiber);\n  }\n}\n\nfunction subscribeToStore<T>(\n  fiber: Fiber,\n  inst: StoreInstance<T>,\n  subscribe: (() => void) => () => void,\n): any {\n  const handleStoreChange = () => {\n    // The store changed. Check if the snapshot changed since the last time we\n    // read from the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceStoreRerender(fiber);\n    }\n  };\n  // Subscribe to the store and return a clean-up function.\n  return subscribe(handleStoreChange);\n}\n\nfunction checkIfSnapshotChanged<T>(inst: StoreInstance<T>): boolean {\n  const latestGetSnapshot = inst.getSnapshot;\n  const prevValue = inst.value;\n  try {\n    const nextValue = latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction forceStoreRerender(fiber) {\n  const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n  if (root !== null) {\n    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n  }\n}\n\nfunction mountState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const hook = mountWorkInProgressHook();\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  const queue: UpdateQueue<S, BasicStateAction<S>> = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState: any),\n  };\n  hook.queue = queue;\n  const dispatch: Dispatch<\n    BasicStateAction<S>,\n  > = (queue.dispatch = (dispatchSetState.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  // console.log('mountCurrent = ', current);\n  console.log('useState-mountWorkInProgress = ', hook);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n\nfunction rerenderState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return rerenderReducer(basicStateReducer, (initialState: any));\n}\n\nfunction pushEffect(\n  tag: HookFlags,\n  create: () => (() => void) | void,\n  destroy: (() => void) | void,\n  deps: Array<mixed> | void | null,\n): Effect {\n  const effect: Effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: (null: any),\n  };\n  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n  return effect;\n}\n\nlet stackContainsErrorMessage: boolean | null = null;\n\nfunction getCallerStackFrame(): string {\n  // eslint-disable-next-line react-internal/prod-error-codes\n  const stackFrames = new Error('Error message').stack.split('\\n');\n\n  // Some browsers (e.g. Chrome) include the error message in the stack\n  // but others (e.g. Firefox) do not.\n  if (stackContainsErrorMessage === null) {\n    stackContainsErrorMessage = stackFrames[0].includes('Error message');\n  }\n\n  return stackContainsErrorMessage\n    ? stackFrames.slice(3, 4).join('\\n')\n    : stackFrames.slice(2, 3).join('\\n');\n}\n\nfunction mountRef<T>(initialValue: T): {current: T} {\n  const hook = mountWorkInProgressHook();\n  if (enableUseRefAccessWarning) {\n    if (__DEV__) {\n      // Support lazy initialization pattern shown in docs.\n      // We need to store the caller stack frame so that we don't warn on subsequent renders.\n      let hasBeenInitialized = initialValue != null;\n      let lazyInitGetterStack = null;\n      let didCheckForLazyInit = false;\n\n      // Only warn once per component+hook.\n      let didWarnAboutRead = false;\n      let didWarnAboutWrite = false;\n\n      let current = initialValue;\n      const ref = {\n        get current() {\n          if (!hasBeenInitialized) {\n            didCheckForLazyInit = true;\n            lazyInitGetterStack = getCallerStackFrame();\n          } else if (currentlyRenderingFiber !== null && !didWarnAboutRead) {\n            if (\n              lazyInitGetterStack === null ||\n              lazyInitGetterStack !== getCallerStackFrame()\n            ) {\n              didWarnAboutRead = true;\n              console.warn(\n                '%s: Unsafe read of a mutable value during render.\\n\\n' +\n                  'Reading from a ref during render is only safe if:\\n' +\n                  '1. The ref value has not been updated, or\\n' +\n                  '2. The ref holds a lazily-initialized value that is only set once.\\n',\n                getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown',\n              );\n            }\n          }\n          return current;\n        },\n        set current(value) {\n          if (currentlyRenderingFiber !== null && !didWarnAboutWrite) {\n            if (hasBeenInitialized || !didCheckForLazyInit) {\n              didWarnAboutWrite = true;\n              console.warn(\n                '%s: Unsafe write of a mutable value during render.\\n\\n' +\n                  'Writing to a ref during render is only safe if the ref holds ' +\n                  'a lazily-initialized value that is only set once.\\n',\n                getComponentNameFromFiber(currentlyRenderingFiber) || 'Unknown',\n              );\n            }\n          }\n\n          hasBeenInitialized = true;\n          current = value;\n        },\n      };\n      Object.seal(ref);\n      hook.memoizedState = ref;\n      // console.log('mountCurrent = ', current);\n      console.log('mountWorkInProgress = ', hook);\n      return ref;\n    } else {\n      const ref = {current: initialValue};\n      hook.memoizedState = ref;\n      // console.log('mountCurrent = ', current);\n      console.log('mountWorkInProgress = ', hook);\n      return ref;\n    }\n  } else {\n    const ref = {current: initialValue};\n    hook.memoizedState = ref;\n    // console.log('mountCurrent = ', current);\n    console.log('useRef - mountWorkInProgress = ', hook);\n    return ref;\n  }\n}\n\nfunction updateRef<T>(initialValue: T): {current: T} {\n  const hook = updateWorkInProgressHook();\n  // console.log('current = ', current);\n  console.log('useRef - workInProgress = ', hook)\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(\n  fiberFlags: Flags,\n  hookFlags: HookFlags,\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookFlags,\n    create,\n    undefined,\n    nextDeps,\n  );\n  // console.log('mountCurrent = ', current);\n  console.log('useEffect - mountWorkInProgress = ', hook);\n}\n\nfunction updateEffectImpl(\n  fiberFlags: Flags,\n  hookFlags: HookFlags,\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber.flags |= fiberFlags;\n\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookFlags,\n    create,\n    destroy,\n    nextDeps,\n  );\n  // console.log('current = ', current);\n  console.log('useEffect - workInProgress = ', hook)\n}\n\nfunction mountEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (\n    __DEV__ &&\n    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode\n  ) {\n    mountEffectImpl(\n      MountPassiveDevEffect | PassiveEffect | PassiveStaticEffect,\n      HookPassive,\n      create,\n      deps,\n    );\n  } else {\n    mountEffectImpl(\n      PassiveEffect | PassiveStaticEffect,\n      HookPassive,\n      create,\n      deps,\n    );\n  }\n}\n\nfunction updateEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  updateEffectImpl(PassiveEffect, HookPassive, create, deps);\n}\n\nfunction useEffectEventImpl<Args, Return, F: (...Array<Args>) => Return>(\n  payload: EventFunctionPayload<Args, Return, F>,\n) {\n  currentlyRenderingFiber.flags |= UpdateEffect;\n  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\n    componentUpdateQueue.events = [payload];\n  } else {\n    const events = componentUpdateQueue.events;\n    if (events === null) {\n      componentUpdateQueue.events = [payload];\n    } else {\n      events.push(payload);\n    }\n  }\n}\n\nfunction mountEvent<Args, Return, F: (...Array<Args>) => Return>(\n  callback: F,\n): F {\n  const hook = mountWorkInProgressHook();\n  const ref = {impl: callback};\n  hook.memoizedState = ref;\n  // $FlowIgnore[incompatible-return]\n  return function eventFn() {\n    if (isInvalidExecutionContextForEventFunction()) {\n      throw new Error(\n        \"A function wrapped in useEffectEvent can't be called during rendering.\",\n      );\n    }\n    return ref.impl.apply(undefined, arguments);\n  };\n}\n\nfunction updateEvent<Args, Return, F: (...Array<Args>) => Return>(\n  callback: F,\n): F {\n  const hook = updateWorkInProgressHook();\n  const ref = hook.memoizedState;\n  useEffectEventImpl({ref, nextImpl: callback});\n  // $FlowIgnore[incompatible-return]\n  return function eventFn() {\n    if (isInvalidExecutionContextForEventFunction()) {\n      throw new Error(\n        \"A function wrapped in useEffectEvent can't be called during rendering.\",\n      );\n    }\n    return ref.impl.apply(undefined, arguments);\n  };\n}\n\nfunction mountInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  mountEffectImpl(UpdateEffect, HookInsertion, create, deps);\n}\n\nfunction updateInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return updateEffectImpl(UpdateEffect, HookInsertion, create, deps);\n}\n\nfunction mountLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  let fiberFlags: Flags = UpdateEffect | LayoutStaticEffect;\n  if (\n    __DEV__ &&\n    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode\n  ) {\n    fiberFlags |= MountLayoutDevEffect;\n  }\n  return mountEffectImpl(fiberFlags, HookLayout, create, deps);\n}\n\nfunction updateLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  return updateEffectImpl(UpdateEffect, HookLayout, create, deps);\n}\n\nfunction imperativeHandleEffect<T>(\n  create: () => T,\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n): void | (() => void) {\n  if (typeof ref === 'function') {\n    const refCallback = ref;\n    const inst = create();\n    refCallback(inst);\n    return () => {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    const refObject = ref;\n    if (__DEV__) {\n      if (!refObject.hasOwnProperty('current')) {\n        console.error(\n          'Expected useImperativeHandle() first argument to either be a ' +\n            'ref callback or React.createRef() object. Instead received: %s.',\n          'an object with keys {' + Object.keys(refObject).join(', ') + '}',\n        );\n      }\n    }\n    const inst = create();\n    refObject.current = inst;\n    return () => {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error(\n        'Expected useImperativeHandle() second argument to be a function ' +\n          'that creates a handle. Instead received: %s.',\n        create !== null ? typeof create : 'null',\n      );\n    }\n  }\n\n  // TODO: If deps are provided, should we skip comparing the ref itself?\n  const effectDeps =\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\n  let fiberFlags: Flags = UpdateEffect | LayoutStaticEffect;\n  if (\n    __DEV__ &&\n    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode\n  ) {\n    fiberFlags |= MountLayoutDevEffect;\n  }\n  mountEffectImpl(\n    fiberFlags,\n    HookLayout,\n    imperativeHandleEffect.bind(null, create, ref),\n    effectDeps,\n  );\n}\n\nfunction updateImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (typeof create !== 'function') {\n      console.error(\n        'Expected useImperativeHandle() second argument to be a function ' +\n          'that creates a handle. Instead received: %s.',\n        create !== null ? typeof create : 'null',\n      );\n    }\n  }\n\n  // TODO: If deps are provided, should we skip comparing the ref itself?\n  const effectDeps =\n    deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n\n  updateEffectImpl(\n    UpdateEffect,\n    HookLayout,\n    imperativeHandleEffect.bind(null, create, ref),\n    effectDeps,\n  );\n}\n\nfunction mountDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n  // This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nconst updateDebugValue = mountDebugValue;\n\nfunction mountCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  // console.log('mountCurrent = ', current);\n  console.log('useCallback - mountWorkInProgress = ', hook);\n  return callback;\n}\n\nfunction updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  hook.memoizedState = [callback, nextDeps];\n  // console.log('current = ', current);\n  console.log('useCallback - workInProgress = ', hook)\n  return callback;\n}\n\nfunction mountMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\n    nextCreate();\n  }\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  // console.log('mountCurrent = ', current);\n  console.log('useMemo - mountWorkInProgress = ', hook);\n  return nextValue;\n}\n\nfunction updateMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      const prevDeps: Array<mixed> | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\n    nextCreate();\n  }\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  // console.log('current = ', current);\n  console.log('useMemo - workInProgress = ', hook)\n  return nextValue;\n}\n\nfunction mountDeferredValue<T>(value: T): T {\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = value;\n  return value;\n}\n\nfunction updateDeferredValue<T>(value: T): T {\n  const hook = updateWorkInProgressHook();\n  const resolvedCurrentHook: Hook = (currentHook: any);\n  const prevValue: T = resolvedCurrentHook.memoizedState;\n  return updateDeferredValueImpl(hook, prevValue, value);\n}\n\nfunction rerenderDeferredValue<T>(value: T): T {\n  const hook = updateWorkInProgressHook();\n  if (currentHook === null) {\n    // This is a rerender during a mount.\n    hook.memoizedState = value;\n    return value;\n  } else {\n    // This is a rerender during an update.\n    const prevValue: T = currentHook.memoizedState;\n    return updateDeferredValueImpl(hook, prevValue, value);\n  }\n}\n\nfunction updateDeferredValueImpl<T>(hook: Hook, prevValue: T, value: T): T {\n  const shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n  if (shouldDeferValue) {\n    // This is an urgent update. If the value has changed, keep using the\n    // previous value and spawn a deferred render to update it later.\n\n    if (!is(value, prevValue)) {\n      // Schedule a deferred render\n      const deferredLane = claimNextTransitionLane();\n      currentlyRenderingFiber.lanes = mergeLanes(\n        currentlyRenderingFiber.lanes,\n        deferredLane,\n      );\n      markSkippedUpdateLanes(deferredLane);\n\n      // Set this to true to indicate that the rendered value is inconsistent\n      // from the latest value. The name \"baseState\" doesn't really match how we\n      // use it because we're reusing a state hook field instead of creating a\n      // new one.\n      hook.baseState = true;\n    }\n\n    // Reuse the previous value\n    return prevValue;\n  } else {\n    // This is not an urgent update, so we can use the latest value regardless\n    // of what it is. No need to defer it.\n\n    // However, if we're currently inside a spawned render, then we need to mark\n    // this as an update to prevent the fiber from bailing out.\n    //\n    // `baseState` is true when the current value is different from the rendered\n    // value. The name doesn't really match how we use it because we're reusing\n    // a state hook field instead of creating a new one.\n    if (hook.baseState) {\n      // Flip this back to false.\n      hook.baseState = false;\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = value;\n    return value;\n  }\n}\n\nfunction startTransition(\n  setPending: boolean => void,\n  callback: () => void,\n  options?: StartTransitionOptions,\n): void {\n  const previousPriority = getCurrentUpdatePriority();\n  setCurrentUpdatePriority(\n    higherEventPriority(previousPriority, ContinuousEventPriority),\n  );\n\n  setPending(true);\n\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = {};\n  const currentTransition = ReactCurrentBatchConfig.transition;\n\n  if (enableTransitionTracing) {\n    if (options !== undefined && options.name !== undefined) {\n      ReactCurrentBatchConfig.transition.name = options.name;\n      ReactCurrentBatchConfig.transition.startTime = now();\n    }\n  }\n\n  if (__DEV__) {\n    ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n  }\n\n  try {\n    setPending(false);\n    callback();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    if (__DEV__) {\n      if (prevTransition === null && currentTransition._updatedFibers) {\n        const updatedFibersCount = currentTransition._updatedFibers.size;\n        if (updatedFibersCount > 10) {\n          console.warn(\n            'Detected a large number of updates inside startTransition. ' +\n              'If this is due to a subscription please re-write it to use React provided hooks. ' +\n              'Otherwise concurrent mode guarantees are off the table.',\n          );\n        }\n        currentTransition._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nfunction mountTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const [isPending, setPending] = mountState(false);\n  // The `start` method never changes.\n  const start = startTransition.bind(null, setPending);\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = start;\n  return [isPending, start];\n}\n\nfunction updateTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const [isPending] = updateState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n\nfunction rerenderTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const [isPending] = rerenderState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n\nfunction mountId(): string {\n  const hook = mountWorkInProgressHook();\n\n  const root = ((getWorkInProgressRoot(): any): FiberRoot);\n  // TODO: In Fizz, id generation is specific to each server config. Maybe we\n  // should do this in Fiber, too? Deferring this decision for now because\n  // there's no other place to store the prefix except for an internal field on\n  // the public createRoot object, which the fiber tree does not currently have\n  // a reference to.\n  const identifierPrefix = root.identifierPrefix;\n\n  let id;\n  if (getIsHydrating()) {\n    const treeId = getTreeId();\n\n    // Use a captial R prefix for server-generated ids.\n    id = ':' + identifierPrefix + 'R' + treeId;\n\n    // Unless this is the first id at this level, append a number at the end\n    // that represents the position of this useId hook among all the useId\n    // hooks for this fiber.\n    const localId = localIdCounter++;\n    if (localId > 0) {\n      id += 'H' + localId.toString(32);\n    }\n\n    id += ':';\n  } else {\n    // Use a lowercase r prefix for client-generated ids.\n    const globalClientId = globalClientIdCounter++;\n    id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n  }\n\n  hook.memoizedState = id;\n  return id;\n}\n\nfunction updateId(): string {\n  const hook = updateWorkInProgressHook();\n  const id: string = hook.memoizedState;\n  return id;\n}\n\nfunction mountRefresh(): any {\n  const hook = mountWorkInProgressHook();\n  const refresh = (hook.memoizedState = refreshCache.bind(\n    null,\n    currentlyRenderingFiber,\n  ));\n  return refresh;\n}\n\nfunction updateRefresh(): any {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction refreshCache<T>(fiber: Fiber, seedKey: ?() => T, seedValue: T): void {\n  if (!enableCache) {\n    return;\n  }\n  // TODO: Does Cache work in legacy mode? Should decide and write a test.\n  // TODO: Consider warning if the refresh is at discrete priority, or if we\n  // otherwise suspect that it wasn't batched properly.\n  let provider = fiber.return;\n  while (provider !== null) {\n    switch (provider.tag) {\n      case CacheComponent:\n      case HostRoot: {\n        // Schedule an update on the cache boundary to trigger a refresh.\n        const lane = requestUpdateLane(provider);\n        const eventTime = requestEventTime();\n        const refreshUpdate = createLegacyQueueUpdate(eventTime, lane);\n        const root = enqueueLegacyQueueUpdate(provider, refreshUpdate, lane);\n        if (root !== null) {\n          scheduleUpdateOnFiber(root, provider, lane, eventTime);\n          entangleLegacyQueueTransitions(root, provider, lane);\n        }\n\n        // TODO: If a refresh never commits, the new cache created here must be\n        // released. A simple case is start refreshing a cache boundary, but then\n        // unmount that boundary before the refresh completes.\n        const seededCache = createCache();\n        if (seedKey !== null && seedKey !== undefined && root !== null) {\n          if (enableLegacyCache) {\n            // Seed the cache with the value passed by the caller. This could be\n            // from a server mutation, or it could be a streaming response.\n            seededCache.data.set(seedKey, seedValue);\n          } else {\n            if (__DEV__) {\n              console.error(\n                'The seed argument is not enabled outside experimental channels.',\n              );\n            }\n          }\n        }\n\n        const payload = {\n          cache: seededCache,\n        };\n        refreshUpdate.payload = payload;\n        return;\n      }\n    }\n    provider = provider.return;\n  }\n  // TODO: Warn if unmounted?\n}\n\nfunction dispatchReducerAction<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n): void {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\n        \"State updates from the useState() and useReducer() Hooks don't support the \" +\n          'second callback argument. To execute a side effect after ' +\n          'rendering, declare it in the component body with useEffect().',\n      );\n    }\n  }\n\n  const lane = requestUpdateLane(fiber);\n\n  const update: Update<S, A> = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: (null: any),\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n    if (root !== null) {\n      const eventTime = requestEventTime();\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane, action);\n}\n\nfunction dispatchSetState<S, A>(\n  fiber: Fiber,\n  queue: UpdateQueue<S, A>,\n  action: A,\n): void {\n  if (__DEV__) {\n    if (typeof arguments[3] === 'function') {\n      console.error(\n        \"State updates from the useState() and useReducer() Hooks don't support the \" +\n          'second callback argument. To execute a side effect after ' +\n          'rendering, declare it in the component body with useEffect().',\n      );\n    }\n  }\n\n  const lane = requestUpdateLane(fiber);\n\n  const update: Update<S, A> = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: (null: any),\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    const alternate = fiber.alternate;\n    if (\n      fiber.lanes === NoLanes &&\n      (alternate === null || alternate.lanes === NoLanes)\n    ) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      const lastRenderedReducer = queue.lastRenderedReducer;\n      if (lastRenderedReducer !== null) {\n        let prevDispatcher;\n        if (__DEV__) {\n          prevDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n        try {\n          const currentState: S = (queue.lastRenderedState: any);\n          const eagerState = lastRenderedReducer(currentState, action);\n          // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n          update.hasEagerState = true;\n          update.eagerState = eagerState;\n          if (is(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            // TODO: Do we still need to entangle transitions in this case?\n            enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);\n            return;\n          }\n        } catch (error) {\n          // Suppress the error. It will throw again in the render phase.\n        } finally {\n          if (__DEV__) {\n            ReactCurrentDispatcher.current = prevDispatcher;\n          }\n        }\n      }\n    }\n\n    const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n    if (root !== null) {\n      const eventTime = requestEventTime();\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane, action);\n}\n\nfunction isRenderPhaseUpdate(fiber: Fiber): boolean {\n  const alternate = fiber.alternate;\n  return (\n    fiber === currentlyRenderingFiber ||\n    (alternate !== null && alternate === currentlyRenderingFiber)\n  );\n}\n\nfunction enqueueRenderPhaseUpdate<S, A>(\n  queue: UpdateQueue<S, A>,\n  update: Update<S, A>,\n): void {\n  // This is a render phase update. Stash it in a lazily-created map of\n  // queue -> linked list of updates. After this render pass, we'll restart\n  // and apply the stashed updates on top of the work-in-progress hook.\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n  const pending = queue.pending;\n  if (pending === null) {\n    // This is the first update. Create a circular list.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n  queue.pending = update;\n}\n\n// TODO: Move to ReactFiberConcurrentUpdates?\nfunction entangleTransitionUpdate<S, A>(\n  root: FiberRoot,\n  queue: UpdateQueue<S, A>,\n  lane: Lane,\n): void {\n  if (isTransitionLane(lane)) {\n    let queueLanes = queue.lanes;\n\n    // If any entangled lanes are no longer pending on the root, then they\n    // must have finished. We can remove them from the shared queue, which\n    // represents a superset of the actually pending lanes. In some cases we\n    // may entangle more than we need to, but that's OK. In fact it's worse if\n    // we *don't* entangle when we should.\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes);\n\n    // Entangle the new transition lane with the other transition lanes.\n    const newQueueLanes = mergeLanes(queueLanes, lane);\n    queue.lanes = newQueueLanes;\n    // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n    markRootEntangled(root, newQueueLanes);\n  }\n}\n\nfunction markUpdateInDevTools<A>(fiber, lane, action: A): void {\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      if (fiber.mode & DebugTracingMode) {\n        const name = getComponentNameFromFiber(fiber) || 'Unknown';\n        logStateUpdateScheduled(name, lane, action);\n      }\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markStateUpdateScheduled(fiber, lane);\n  }\n}\n\nexport const ContextOnlyDispatcher: Dispatcher = {\n  readContext,\n\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useMutableSource: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError,\n};\nif (enableCache) {\n  (ContextOnlyDispatcher: Dispatcher).useCacheRefresh = throwInvalidHookError;\n}\nif (enableUseHook) {\n  (ContextOnlyDispatcher: Dispatcher).use = throwInvalidHookError;\n}\nif (enableUseMemoCacheHook) {\n  (ContextOnlyDispatcher: Dispatcher).useMemoCache = throwInvalidHookError;\n}\nif (enableUseEffectEventHook) {\n  (ContextOnlyDispatcher: Dispatcher).useEffectEvent = throwInvalidHookError;\n}\n\nconst HooksDispatcherOnMount: Dispatcher = {\n  readContext,\n\n  useCallback: mountCallback,\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: mountImperativeHandle,\n  useLayoutEffect: mountLayoutEffect,\n  useInsertionEffect: mountInsertionEffect,\n  useMemo: mountMemo,\n  useReducer: mountReducer,\n  useRef: mountRef,\n  useState: mountState,\n  useDebugValue: mountDebugValue,\n  useDeferredValue: mountDeferredValue,\n  useTransition: mountTransition,\n  useMutableSource: mountMutableSource,\n  useSyncExternalStore: mountSyncExternalStore,\n  useId: mountId,\n};\nif (enableCache) {\n  // $FlowFixMe[escaped-generic] discovered when updating Flow\n  (HooksDispatcherOnMount: Dispatcher).useCacheRefresh = mountRefresh;\n}\nif (enableUseHook) {\n  (HooksDispatcherOnMount: Dispatcher).use = use;\n}\nif (enableUseMemoCacheHook) {\n  (HooksDispatcherOnMount: Dispatcher).useMemoCache = useMemoCache;\n}\nif (enableUseEffectEventHook) {\n  (HooksDispatcherOnMount: Dispatcher).useEffectEvent = mountEvent;\n}\nconst HooksDispatcherOnUpdate: Dispatcher = {\n  readContext,\n\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: updateState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: updateDeferredValue,\n  useTransition: updateTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId,\n};\nif (enableCache) {\n  (HooksDispatcherOnUpdate: Dispatcher).useCacheRefresh = updateRefresh;\n}\nif (enableUseMemoCacheHook) {\n  (HooksDispatcherOnUpdate: Dispatcher).useMemoCache = useMemoCache;\n}\nif (enableUseHook) {\n  (HooksDispatcherOnUpdate: Dispatcher).use = use;\n}\nif (enableUseEffectEventHook) {\n  (HooksDispatcherOnUpdate: Dispatcher).useEffectEvent = updateEvent;\n}\n\nconst HooksDispatcherOnRerender: Dispatcher = {\n  readContext,\n\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: rerenderReducer,\n  useRef: updateRef,\n  useState: rerenderState,\n  useDebugValue: updateDebugValue,\n  useDeferredValue: rerenderDeferredValue,\n  useTransition: rerenderTransition,\n  useMutableSource: updateMutableSource,\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId,\n};\nif (enableCache) {\n  (HooksDispatcherOnRerender: Dispatcher).useCacheRefresh = updateRefresh;\n}\nif (enableUseHook) {\n  (HooksDispatcherOnRerender: Dispatcher).use = use;\n}\nif (enableUseMemoCacheHook) {\n  (HooksDispatcherOnRerender: Dispatcher).useMemoCache = useMemoCache;\n}\nif (enableUseEffectEventHook) {\n  (HooksDispatcherOnRerender: Dispatcher).useEffectEvent = updateEvent;\n}\n\nlet HooksDispatcherOnMountInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\nlet HooksDispatcherOnRerenderInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher | null = null;\nlet InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher | null = null;\n\nif (__DEV__) {\n  const warnInvalidContextAccess = () => {\n    console.error(\n      'Context can only be read while React is rendering. ' +\n        'In classes, you can read it in the render method or getDerivedStateFromProps. ' +\n        'In function components, you can read it directly in the function body, but not ' +\n        'inside Hooks like useReducer() or useMemo().',\n    );\n  };\n\n  const warnInvalidHookAccess = () => {\n    console.error(\n      'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' +\n        'You can only call Hooks at the top level of your React function. ' +\n        'For more information, see ' +\n        'https://reactjs.org/link/rules-of-hooks',\n    );\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      return readContext(context);\n    },\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      mountHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      mountHookTypesDev();\n      return mountId();\n    },\n  };\n  if (enableCache) {\n    (HooksDispatcherOnMountInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      mountHookTypesDev();\n      return mountRefresh();\n    };\n  }\n  if (enableUseHook) {\n    (HooksDispatcherOnMountInDEV: Dispatcher).use = use;\n  }\n  if (enableUseMemoCacheHook) {\n    (HooksDispatcherOnMountInDEV: Dispatcher).useMemoCache = useMemoCache;\n  }\n  if (enableUseEffectEventHook) {\n    (HooksDispatcherOnMountInDEV: Dispatcher).useEffectEvent = function useEffectEvent<\n      Args,\n      Return,\n      F: (...Array<Args>) => Return,\n    >(callback: F): F {\n      currentHookNameInDev = 'useEffectEvent';\n      mountHookTypesDev();\n      return mountEvent(callback);\n    };\n  }\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      return readContext(context);\n    },\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return mountId();\n    },\n  };\n  if (enableCache) {\n    (HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return mountRefresh();\n    };\n  }\n  if (enableUseHook) {\n    (HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher).use = use;\n  }\n  if (enableUseMemoCacheHook) {\n    (HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher).useMemoCache = useMemoCache;\n  }\n  if (enableUseEffectEventHook) {\n    (HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher).useEffectEvent = function useEffectEvent<\n      Args,\n      Return,\n      F: (...Array<Args>) => Return,\n    >(callback: F): F {\n      currentHookNameInDev = 'useEffectEvent';\n      updateHookTypesDev();\n      return mountEvent(callback);\n    };\n  }\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      return readContext(context);\n    },\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n  };\n  if (enableCache) {\n    (HooksDispatcherOnUpdateInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n  if (enableUseHook) {\n    (HooksDispatcherOnUpdateInDEV: Dispatcher).use = use;\n  }\n  if (enableUseMemoCacheHook) {\n    (HooksDispatcherOnUpdateInDEV: Dispatcher).useMemoCache = useMemoCache;\n  }\n  if (enableUseEffectEventHook) {\n    (HooksDispatcherOnUpdateInDEV: Dispatcher).useEffectEvent = function useEffectEvent<\n      Args,\n      Return,\n      F: (...Array<Args>) => Return,\n    >(callback: F): F {\n      currentHookNameInDev = 'useEffectEvent';\n      updateHookTypesDev();\n      return updateEvent(callback);\n    };\n  }\n\n  HooksDispatcherOnRerenderInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      return readContext(context);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n  };\n  if (enableCache) {\n    (HooksDispatcherOnRerenderInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n  if (enableUseHook) {\n    (HooksDispatcherOnRerenderInDEV: Dispatcher).use = use;\n  }\n  if (enableUseMemoCacheHook) {\n    (HooksDispatcherOnRerenderInDEV: Dispatcher).useMemoCache = useMemoCache;\n  }\n  if (enableUseEffectEventHook) {\n    (HooksDispatcherOnRerenderInDEV: Dispatcher).useEffectEvent = function useEffectEvent<\n      Args,\n      Return,\n      F: (...Array<Args>) => Return,\n    >(callback: F): F {\n      currentHookNameInDev = 'useEffectEvent';\n      updateHookTypesDev();\n      return updateEvent(callback);\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV;\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountId();\n    },\n  };\n  if (enableCache) {\n    (InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      mountHookTypesDev();\n      return mountRefresh();\n    };\n  }\n  if (enableUseHook) {\n    (InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher).use = function<T>(\n      usable: Usable<T>,\n    ): T {\n      warnInvalidHookAccess();\n      return use(usable);\n    };\n  }\n  if (enableUseMemoCacheHook) {\n    (InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher).useMemoCache = function(\n      size: number,\n    ): Array<any> {\n      warnInvalidHookAccess();\n      return useMemoCache(size);\n    };\n  }\n  if (enableUseEffectEventHook) {\n    (InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher).useEffectEvent = function useEffectEvent<\n      Args,\n      Return,\n      F: (...Array<Args>) => Return,\n    >(callback: F): F {\n      currentHookNameInDev = 'useEffectEvent';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEvent(callback);\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n  };\n  if (enableCache) {\n    (InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n  if (enableUseHook) {\n    (InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher).use = function<T>(\n      usable: Usable<T>,\n    ): T {\n      warnInvalidHookAccess();\n      return use(usable);\n    };\n  }\n  if (enableUseMemoCacheHook) {\n    (InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher).useMemoCache = function(\n      size: number,\n    ): Array<any> {\n      warnInvalidHookAccess();\n      return useMemoCache(size);\n    };\n  }\n  if (enableUseEffectEventHook) {\n    (InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher).useEffectEvent = function useEffectEvent<\n      Args,\n      Return,\n      F: (...Array<Args>) => Return,\n    >(callback: F): F {\n      currentHookNameInDev = 'useEffectEvent';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEvent(callback);\n    };\n  }\n\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n    readContext<T>(context: ReactContext<T>): T {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n\n    useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext<T>(context: ReactContext<T>): T {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle<T>(\n      ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n      create: () => T,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect(\n      create: () => (() => void) | void,\n      deps: Array<mixed> | void | null,\n    ): void {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo<T>(create: () => T, deps: Array<mixed> | void | null): T {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useReducer<S, I, A>(\n      reducer: (S, A) => S,\n      initialArg: I,\n      init?: I => S,\n    ): [S, Dispatch<A>] {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useRef<T>(initialValue: T): {current: T} {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef(initialValue);\n    },\n    useState<S>(\n      initialState: (() => S) | S,\n    ): [S, Dispatch<BasicStateAction<S>>] {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      const prevDispatcher = ReactCurrentDispatcher.current;\n      ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher.current = prevDispatcher;\n      }\n    },\n    useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue(value, formatterFn);\n    },\n    useDeferredValue<T>(value: T): T {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n    useTransition(): [boolean, (() => void) => void] {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n    useMutableSource<Source, Snapshot>(\n      source: MutableSource<Source>,\n      getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n      subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n    ): Snapshot {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource(source, getSnapshot, subscribe);\n    },\n    useSyncExternalStore<T>(\n      subscribe: (() => void) => () => void,\n      getSnapshot: () => T,\n      getServerSnapshot?: () => T,\n    ): T {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId(): string {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n  };\n  if (enableCache) {\n    (InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher).useCacheRefresh = function useCacheRefresh() {\n      currentHookNameInDev = 'useCacheRefresh';\n      updateHookTypesDev();\n      return updateRefresh();\n    };\n  }\n  if (enableUseHook) {\n    (InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher).use = function<T>(\n      usable: Usable<T>,\n    ): T {\n      warnInvalidHookAccess();\n      return use(usable);\n    };\n  }\n  if (enableUseMemoCacheHook) {\n    (InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher).useMemoCache = function(\n      size: number,\n    ): Array<any> {\n      warnInvalidHookAccess();\n      return useMemoCache(size);\n    };\n  }\n  if (enableUseEffectEventHook) {\n    (InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher).useEffectEvent = function useEffectEvent<\n      Args,\n      Return,\n      F: (...Array<Args>) => Return,\n    >(callback: F): F {\n      currentHookNameInDev = 'useEffectEvent';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEvent(callback);\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}