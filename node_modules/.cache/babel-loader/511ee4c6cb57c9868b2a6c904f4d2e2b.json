{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { warnAboutUpdateOnNotYetMountedFiberInDEV, throwIfInfiniteUpdateLoopDetected, getWorkInProgressRoot } from './ReactFiberWorkLoop';\nimport { NoLane, NoLanes, mergeLanes, markHiddenUpdate } from './ReactFiberLane';\nimport { NoFlags, Placement, Hydrating } from './ReactFiberFlags';\nimport { HostRoot, OffscreenComponent } from './ReactWorkTags';\nimport { OffscreenVisible } from './ReactFiberOffscreenComponent';\n// If a render is in progress, and we receive an update from a concurrent event,\n// we wait until the current render is over (either finished or interrupted)\n// before adding it to the fiber/hook queue. Push to this array so we can\n// access the queue, fiber, update, et al later.\nconst concurrentQueues = [];\nlet concurrentQueuesIndex = 0;\nlet concurrentlyUpdatedLanes = NoLanes;\nexport function finishQueueingConcurrentUpdates() {\n  const endIndex = concurrentQueuesIndex;\n  concurrentQueuesIndex = 0;\n  concurrentlyUpdatedLanes = NoLanes;\n  let i = 0;\n\n  while (i < endIndex) {\n    const fiber = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    const queue = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    const update = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    const lane = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n\n    if (queue !== null && update !== null) {\n      const pending = queue.pending;\n\n      if (pending === null) {\n        // This is the first update. Create a circular list.\n        update.next = update;\n      } else {\n        update.next = pending.next;\n        pending.next = update;\n      }\n\n      queue.pending = update;\n    }\n\n    if (lane !== NoLane) {\n      markUpdateLaneFromFiberToRoot(fiber, update, lane);\n    }\n  }\n}\nexport function getConcurrentlyUpdatedLanes() {\n  return concurrentlyUpdatedLanes;\n}\n\nfunction enqueueUpdate(fiber, queue, update, lane) {\n  // Don't update the `childLanes` on the return path yet. If we already in\n  // the middle of rendering, wait until after it has completed.\n  concurrentQueues[concurrentQueuesIndex++] = fiber;\n  concurrentQueues[concurrentQueuesIndex++] = queue;\n  concurrentQueues[concurrentQueuesIndex++] = update;\n  concurrentQueues[concurrentQueuesIndex++] = lane;\n  concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane); // The fiber's `lane` field is used in some places to check if any work is\n  // scheduled, to perform an eager bailout, so we need to update it immediately.\n  // TODO: We should probably move this to the \"shared\" queue instead.\n\n  fiber.lanes = mergeLanes(fiber.lanes, lane);\n  const alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n}\n\nexport function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n  const concurrentQueue = queue;\n  const concurrentUpdate = update;\n  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nexport function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update) {\n  // This function is used to queue an update that doesn't need a rerender. The\n  // only reason we queue it is in case there's a subsequent higher priority\n  // update that causes it to be rebased.\n  const lane = NoLane;\n  const concurrentQueue = queue;\n  const concurrentUpdate = update;\n  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane); // Usually we can rely on the upcoming render phase to process the concurrent\n  // queue. However, since this is a bail out, we're not scheduling any work\n  // here. So the update we just queued will leak until something else happens\n  // to schedule work (if ever).\n  //\n  // Check if we're currently in the middle of rendering a tree, and if not,\n  // process the queue immediately to prevent a leak.\n\n  const isConcurrentlyRendering = getWorkInProgressRoot() !== null;\n\n  if (!isConcurrentlyRendering) {\n    finishQueueingConcurrentUpdates();\n  }\n}\nexport function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n  const concurrentQueue = queue;\n  const concurrentUpdate = update;\n  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nexport function enqueueConcurrentRenderForLane(fiber, lane) {\n  enqueueUpdate(fiber, null, null, lane);\n  return getRootForUpdatedFiber(fiber);\n} // Calling this function outside this module should only be done for backwards\n// compatibility and should always be accompanied by a warning.\n\nexport function unsafe_markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n  // NOTE: For Hyrum's Law reasons, if an infinite update loop is detected, it\n  // should throw before `markUpdateLaneFromFiberToRoot` is called. But this is\n  // undefined behavior and we can change it if we need to; it just so happens\n  // that, at the time of this writing, there's an internal product test that\n  // happens to rely on this.\n  const root = getRootForUpdatedFiber(sourceFiber);\n  markUpdateLaneFromFiberToRoot(sourceFiber, null, lane);\n  return root;\n}\n\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n  // Update the source fiber's lanes\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n  let alternate = sourceFiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  } // Walk the parent path to the root and update the child lanes.\n\n\n  let isHidden = false;\n  let parent = sourceFiber.return;\n  let node = sourceFiber;\n\n  while (parent !== null) {\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\n    alternate = parent.alternate;\n\n    if (alternate !== null) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n    }\n\n    if (parent.tag === OffscreenComponent) {\n      // Check if this offscreen boundary is currently hidden.\n      //\n      // The instance may be null if the Offscreen parent was unmounted. Usually\n      // the parent wouldn't be reachable in that case because we disconnect\n      // fibers from the tree when they are deleted. However, there's a weird\n      // edge case where setState is called on a fiber that was interrupted\n      // before it ever mounted. Because it never mounts, it also never gets\n      // deleted. Because it never gets deleted, its return pointer never gets\n      // disconnected. Which means it may be attached to a deleted Offscreen\n      // parent node. (This discovery suggests it may be better for memory usage\n      // if we don't attach the `return` pointer until the commit phase, though\n      // in order to do that we'd need some other way to track the return\n      // pointer during the initial render, like on the stack.)\n      //\n      // This case is always accompanied by a warning, but we still need to\n      // account for it. (There may be other cases that we haven't discovered,\n      // too.)\n      const offscreenInstance = parent.stateNode;\n\n      if (offscreenInstance !== null && !(offscreenInstance._visibility & OffscreenVisible)) {\n        isHidden = true;\n      }\n    }\n\n    node = parent;\n    parent = parent.return;\n  }\n\n  if (isHidden && update !== null && node.tag === HostRoot) {\n    const root = node.stateNode;\n    markHiddenUpdate(root, update, lane);\n  }\n}\n\nfunction getRootForUpdatedFiber(sourceFiber) {\n  // TODO: We will detect and infinite update loop and throw even if this fiber\n  // has already unmounted. This isn't really necessary but it happens to be the\n  // current behavior we've used for several release cycles. Consider not\n  // performing this check if the updated fiber already unmounted, since it's\n  // not possible for that to cause an infinite update loop.\n  throwIfInfiniteUpdateLoopDetected(); // When a setState happens, we must ensure the root is scheduled. Because\n  // update queues do not have a backpointer to the root, the only way to do\n  // this currently is to walk up the return path. This used to not be a big\n  // deal because we would have to walk up the return path to set\n  // the `childLanes`, anyway, but now those two traversals happen at\n  // different times.\n  // TODO: Consider adding a `root` backpointer on the update queue.\n\n  detectUpdateOnUnmountedFiber(sourceFiber, sourceFiber);\n  let node = sourceFiber;\n  let parent = node.return;\n\n  while (parent !== null) {\n    detectUpdateOnUnmountedFiber(sourceFiber, node);\n    node = parent;\n    parent = node.return;\n  }\n\n  return node.tag === HostRoot ? node.stateNode : null;\n}\n\nfunction detectUpdateOnUnmountedFiber(sourceFiber, parent) {\n  if (__DEV__) {\n    const alternate = parent.alternate;\n\n    if (alternate === null && (parent.flags & (Placement | Hydrating)) !== NoFlags) {\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberConcurrentUpdates.js"],"names":["warnAboutUpdateOnNotYetMountedFiberInDEV","throwIfInfiniteUpdateLoopDetected","getWorkInProgressRoot","NoLane","NoLanes","mergeLanes","markHiddenUpdate","NoFlags","Placement","Hydrating","HostRoot","OffscreenComponent","OffscreenVisible","concurrentQueues","concurrentQueuesIndex","concurrentlyUpdatedLanes","finishQueueingConcurrentUpdates","endIndex","i","fiber","queue","update","lane","pending","next","markUpdateLaneFromFiberToRoot","getConcurrentlyUpdatedLanes","enqueueUpdate","lanes","alternate","enqueueConcurrentHookUpdate","concurrentQueue","concurrentUpdate","getRootForUpdatedFiber","enqueueConcurrentHookUpdateAndEagerlyBailout","isConcurrentlyRendering","enqueueConcurrentClassUpdate","enqueueConcurrentRenderForLane","unsafe_markUpdateLaneFromFiberToRoot","sourceFiber","root","isHidden","parent","return","node","childLanes","tag","offscreenInstance","stateNode","_visibility","detectUpdateOnUnmountedFiber","__DEV__","flags"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {\n  UpdateQueue as HookQueue,\n  Update as HookUpdate,\n} from './ReactFiberHooks';\nimport type {\n  SharedQueue as ClassQueue,\n  Update as ClassUpdate,\n} from './ReactFiberClassUpdateQueue';\nimport type {Lane, Lanes} from './ReactFiberLane';\nimport type {OffscreenInstance} from './ReactFiberOffscreenComponent';\n\nimport {\n  warnAboutUpdateOnNotYetMountedFiberInDEV,\n  throwIfInfiniteUpdateLoopDetected,\n  getWorkInProgressRoot,\n} from './ReactFiberWorkLoop';\nimport {NoLane, NoLanes, mergeLanes, markHiddenUpdate} from './ReactFiberLane';\nimport {NoFlags, Placement, Hydrating} from './ReactFiberFlags';\nimport {HostRoot, OffscreenComponent} from './ReactWorkTags';\nimport {OffscreenVisible} from './ReactFiberOffscreenComponent';\n\nexport type ConcurrentUpdate = {\n  next: ConcurrentUpdate,\n  lane: Lane,\n};\n\ntype ConcurrentQueue = {\n  pending: ConcurrentUpdate | null,\n};\n\n// If a render is in progress, and we receive an update from a concurrent event,\n// we wait until the current render is over (either finished or interrupted)\n// before adding it to the fiber/hook queue. Push to this array so we can\n// access the queue, fiber, update, et al later.\nconst concurrentQueues: Array<any> = [];\nlet concurrentQueuesIndex = 0;\n\nlet concurrentlyUpdatedLanes: Lanes = NoLanes;\n\nexport function finishQueueingConcurrentUpdates(): void {\n  const endIndex = concurrentQueuesIndex;\n  concurrentQueuesIndex = 0;\n\n  concurrentlyUpdatedLanes = NoLanes;\n\n  let i = 0;\n  while (i < endIndex) {\n    const fiber: Fiber = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    const queue: ConcurrentQueue = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    const update: ConcurrentUpdate = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    const lane: Lane = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n\n    if (queue !== null && update !== null) {\n      const pending = queue.pending;\n      if (pending === null) {\n        // This is the first update. Create a circular list.\n        update.next = update;\n      } else {\n        update.next = pending.next;\n        pending.next = update;\n      }\n      queue.pending = update;\n    }\n\n    if (lane !== NoLane) {\n      markUpdateLaneFromFiberToRoot(fiber, update, lane);\n    }\n  }\n}\n\nexport function getConcurrentlyUpdatedLanes(): Lanes {\n  return concurrentlyUpdatedLanes;\n}\n\nfunction enqueueUpdate(\n  fiber: Fiber,\n  queue: ConcurrentQueue | null,\n  update: ConcurrentUpdate | null,\n  lane: Lane,\n) {\n  // Don't update the `childLanes` on the return path yet. If we already in\n  // the middle of rendering, wait until after it has completed.\n  concurrentQueues[concurrentQueuesIndex++] = fiber;\n  concurrentQueues[concurrentQueuesIndex++] = queue;\n  concurrentQueues[concurrentQueuesIndex++] = update;\n  concurrentQueues[concurrentQueuesIndex++] = lane;\n\n  concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane);\n\n  // The fiber's `lane` field is used in some places to check if any work is\n  // scheduled, to perform an eager bailout, so we need to update it immediately.\n  // TODO: We should probably move this to the \"shared\" queue instead.\n  fiber.lanes = mergeLanes(fiber.lanes, lane);\n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n}\n\nexport function enqueueConcurrentHookUpdate<S, A>(\n  fiber: Fiber,\n  queue: HookQueue<S, A>,\n  update: HookUpdate<S, A>,\n  lane: Lane,\n): FiberRoot | null {\n  const concurrentQueue: ConcurrentQueue = (queue: any);\n  const concurrentUpdate: ConcurrentUpdate = (update: any);\n  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);\n  return getRootForUpdatedFiber(fiber);\n}\n\nexport function enqueueConcurrentHookUpdateAndEagerlyBailout<S, A>(\n  fiber: Fiber,\n  queue: HookQueue<S, A>,\n  update: HookUpdate<S, A>,\n): void {\n  // This function is used to queue an update that doesn't need a rerender. The\n  // only reason we queue it is in case there's a subsequent higher priority\n  // update that causes it to be rebased.\n  const lane = NoLane;\n  const concurrentQueue: ConcurrentQueue = (queue: any);\n  const concurrentUpdate: ConcurrentUpdate = (update: any);\n  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);\n\n  // Usually we can rely on the upcoming render phase to process the concurrent\n  // queue. However, since this is a bail out, we're not scheduling any work\n  // here. So the update we just queued will leak until something else happens\n  // to schedule work (if ever).\n  //\n  // Check if we're currently in the middle of rendering a tree, and if not,\n  // process the queue immediately to prevent a leak.\n  const isConcurrentlyRendering = getWorkInProgressRoot() !== null;\n  if (!isConcurrentlyRendering) {\n    finishQueueingConcurrentUpdates();\n  }\n}\n\nexport function enqueueConcurrentClassUpdate<State>(\n  fiber: Fiber,\n  queue: ClassQueue<State>,\n  update: ClassUpdate<State>,\n  lane: Lane,\n): FiberRoot | null {\n  const concurrentQueue: ConcurrentQueue = (queue: any);\n  const concurrentUpdate: ConcurrentUpdate = (update: any);\n  enqueueUpdate(fiber, concurrentQueue, concurrentUpdate, lane);\n  return getRootForUpdatedFiber(fiber);\n}\n\nexport function enqueueConcurrentRenderForLane(\n  fiber: Fiber,\n  lane: Lane,\n): FiberRoot | null {\n  enqueueUpdate(fiber, null, null, lane);\n  return getRootForUpdatedFiber(fiber);\n}\n\n// Calling this function outside this module should only be done for backwards\n// compatibility and should always be accompanied by a warning.\nexport function unsafe_markUpdateLaneFromFiberToRoot(\n  sourceFiber: Fiber,\n  lane: Lane,\n): FiberRoot | null {\n  // NOTE: For Hyrum's Law reasons, if an infinite update loop is detected, it\n  // should throw before `markUpdateLaneFromFiberToRoot` is called. But this is\n  // undefined behavior and we can change it if we need to; it just so happens\n  // that, at the time of this writing, there's an internal product test that\n  // happens to rely on this.\n  const root = getRootForUpdatedFiber(sourceFiber);\n  markUpdateLaneFromFiberToRoot(sourceFiber, null, lane);\n  return root;\n}\n\nfunction markUpdateLaneFromFiberToRoot(\n  sourceFiber: Fiber,\n  update: ConcurrentUpdate | null,\n  lane: Lane,\n): void {\n  // Update the source fiber's lanes\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n  let alternate = sourceFiber.alternate;\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n  // Walk the parent path to the root and update the child lanes.\n  let isHidden = false;\n  let parent = sourceFiber.return;\n  let node = sourceFiber;\n  while (parent !== null) {\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\n    alternate = parent.alternate;\n    if (alternate !== null) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n    }\n\n    if (parent.tag === OffscreenComponent) {\n      // Check if this offscreen boundary is currently hidden.\n      //\n      // The instance may be null if the Offscreen parent was unmounted. Usually\n      // the parent wouldn't be reachable in that case because we disconnect\n      // fibers from the tree when they are deleted. However, there's a weird\n      // edge case where setState is called on a fiber that was interrupted\n      // before it ever mounted. Because it never mounts, it also never gets\n      // deleted. Because it never gets deleted, its return pointer never gets\n      // disconnected. Which means it may be attached to a deleted Offscreen\n      // parent node. (This discovery suggests it may be better for memory usage\n      // if we don't attach the `return` pointer until the commit phase, though\n      // in order to do that we'd need some other way to track the return\n      // pointer during the initial render, like on the stack.)\n      //\n      // This case is always accompanied by a warning, but we still need to\n      // account for it. (There may be other cases that we haven't discovered,\n      // too.)\n      const offscreenInstance: OffscreenInstance | null = parent.stateNode;\n      if (\n        offscreenInstance !== null &&\n        !(offscreenInstance._visibility & OffscreenVisible)\n      ) {\n        isHidden = true;\n      }\n    }\n\n    node = parent;\n    parent = parent.return;\n  }\n\n  if (isHidden && update !== null && node.tag === HostRoot) {\n    const root: FiberRoot = node.stateNode;\n    markHiddenUpdate(root, update, lane);\n  }\n}\n\nfunction getRootForUpdatedFiber(sourceFiber: Fiber): FiberRoot | null {\n  // TODO: We will detect and infinite update loop and throw even if this fiber\n  // has already unmounted. This isn't really necessary but it happens to be the\n  // current behavior we've used for several release cycles. Consider not\n  // performing this check if the updated fiber already unmounted, since it's\n  // not possible for that to cause an infinite update loop.\n  throwIfInfiniteUpdateLoopDetected();\n\n  // When a setState happens, we must ensure the root is scheduled. Because\n  // update queues do not have a backpointer to the root, the only way to do\n  // this currently is to walk up the return path. This used to not be a big\n  // deal because we would have to walk up the return path to set\n  // the `childLanes`, anyway, but now those two traversals happen at\n  // different times.\n  // TODO: Consider adding a `root` backpointer on the update queue.\n  detectUpdateOnUnmountedFiber(sourceFiber, sourceFiber);\n  let node = sourceFiber;\n  let parent = node.return;\n  while (parent !== null) {\n    detectUpdateOnUnmountedFiber(sourceFiber, node);\n    node = parent;\n    parent = node.return;\n  }\n  return node.tag === HostRoot ? (node.stateNode: FiberRoot) : null;\n}\n\nfunction detectUpdateOnUnmountedFiber(sourceFiber: Fiber, parent: Fiber) {\n  if (__DEV__) {\n    const alternate = parent.alternate;\n    if (\n      alternate === null &&\n      (parent.flags & (Placement | Hydrating)) !== NoFlags\n    ) {\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}