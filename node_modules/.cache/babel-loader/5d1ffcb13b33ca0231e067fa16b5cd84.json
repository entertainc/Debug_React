{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// TODO: Ideally these types would be opaque but that doesn't work well with\n// our reconciler fork infra, since these leak into non-reconciler packages.\nimport { enableSchedulingProfiler, enableUpdaterTracking, allowConcurrentByDefault, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { isDevToolsPresent } from './ReactFiberDevToolsHook';\nimport { ConcurrentUpdatesByDefaultMode, NoMode } from './ReactTypeOfMode';\nimport { clz32 } from './clz32'; // Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.\n// If those values are changed that package should be rebuilt and redeployed.\n\nexport const TotalLanes = 31;\nexport const NoLanes =\n/*                        */\n0b0000000000000000000000000000000;\nexport const NoLane =\n/*                          */\n0b0000000000000000000000000000000;\nexport const SyncHydrationLane =\n/*               */\n0b0000000000000000000000000000001;\nexport const SyncLane =\n/*                        */\n0b0000000000000000000000000000010;\nexport const InputContinuousHydrationLane =\n/*    */\n0b0000000000000000000000000000100;\nexport const InputContinuousLane =\n/*             */\n0b0000000000000000000000000001000;\nexport const DefaultHydrationLane =\n/*            */\n0b0000000000000000000000000010000;\nexport const DefaultLane =\n/*                     */\n0b0000000000000000000000000100000;\nconst TransitionHydrationLane =\n/*                */\n0b0000000000000000000000001000000;\nconst TransitionLanes =\n/*                       */\n0b0000000011111111111111110000000;\nconst TransitionLane1 =\n/*                        */\n0b0000000000000000000000010000000;\nconst TransitionLane2 =\n/*                        */\n0b0000000000000000000000100000000;\nconst TransitionLane3 =\n/*                        */\n0b0000000000000000000001000000000;\nconst TransitionLane4 =\n/*                        */\n0b0000000000000000000010000000000;\nconst TransitionLane5 =\n/*                        */\n0b0000000000000000000100000000000;\nconst TransitionLane6 =\n/*                        */\n0b0000000000000000001000000000000;\nconst TransitionLane7 =\n/*                        */\n0b0000000000000000010000000000000;\nconst TransitionLane8 =\n/*                        */\n0b0000000000000000100000000000000;\nconst TransitionLane9 =\n/*                        */\n0b0000000000000001000000000000000;\nconst TransitionLane10 =\n/*                       */\n0b0000000000000010000000000000000;\nconst TransitionLane11 =\n/*                       */\n0b0000000000000100000000000000000;\nconst TransitionLane12 =\n/*                       */\n0b0000000000001000000000000000000;\nconst TransitionLane13 =\n/*                       */\n0b0000000000010000000000000000000;\nconst TransitionLane14 =\n/*                       */\n0b0000000000100000000000000000000;\nconst TransitionLane15 =\n/*                       */\n0b0000000001000000000000000000000;\nconst TransitionLane16 =\n/*                       */\n0b0000000010000000000000000000000;\nconst RetryLanes =\n/*                            */\n0b0000111100000000000000000000000;\nconst RetryLane1 =\n/*                             */\n0b0000000100000000000000000000000;\nconst RetryLane2 =\n/*                             */\n0b0000001000000000000000000000000;\nconst RetryLane3 =\n/*                             */\n0b0000010000000000000000000000000;\nconst RetryLane4 =\n/*                             */\n0b0000100000000000000000000000000;\nexport const SomeRetryLane = RetryLane1;\nexport const SelectiveHydrationLane =\n/*          */\n0b0001000000000000000000000000000;\nconst NonIdleLanes =\n/*                          */\n0b0001111111111111111111111111111;\nexport const IdleHydrationLane =\n/*               */\n0b0010000000000000000000000000000;\nexport const IdleLane =\n/*                        */\n0b0100000000000000000000000000000;\nexport const OffscreenLane =\n/*                   */\n0b1000000000000000000000000000000; // This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\n\nexport function getLabelForLane(lane) {\n  if (enableSchedulingProfiler) {\n    if (lane & SyncHydrationLane) {\n      return 'SyncHydrationLane';\n    }\n\n    if (lane & SyncLane) {\n      return 'Sync';\n    }\n\n    if (lane & InputContinuousHydrationLane) {\n      return 'InputContinuousHydration';\n    }\n\n    if (lane & InputContinuousLane) {\n      return 'InputContinuous';\n    }\n\n    if (lane & DefaultHydrationLane) {\n      return 'DefaultHydration';\n    }\n\n    if (lane & DefaultLane) {\n      return 'Default';\n    }\n\n    if (lane & TransitionHydrationLane) {\n      return 'TransitionHydration';\n    }\n\n    if (lane & TransitionLanes) {\n      return 'Transition';\n    }\n\n    if (lane & RetryLanes) {\n      return 'Retry';\n    }\n\n    if (lane & SelectiveHydrationLane) {\n      return 'SelectiveHydration';\n    }\n\n    if (lane & IdleHydrationLane) {\n      return 'IdleHydration';\n    }\n\n    if (lane & IdleLane) {\n      return 'Idle';\n    }\n\n    if (lane & OffscreenLane) {\n      return 'Offscreen';\n    }\n  }\n}\nexport const NoTimestamp = -1;\nlet nextTransitionLane = TransitionLane1;\nlet nextRetryLane = RetryLane1;\n\nfunction getHighestPriorityLanes(lanes) {\n  switch (getHighestPriorityLane(lanes)) {\n    case SyncHydrationLane:\n      return SyncHydrationLane;\n\n    case SyncLane:\n      return SyncLane;\n\n    case InputContinuousHydrationLane:\n      return InputContinuousHydrationLane;\n\n    case InputContinuousLane:\n      return InputContinuousLane;\n\n    case DefaultHydrationLane:\n      return DefaultHydrationLane;\n\n    case DefaultLane:\n      return DefaultLane;\n\n    case TransitionHydrationLane:\n      return TransitionHydrationLane;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return lanes & TransitionLanes;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n      return lanes & RetryLanes;\n\n    case SelectiveHydrationLane:\n      return SelectiveHydrationLane;\n\n    case IdleHydrationLane:\n      return IdleHydrationLane;\n\n    case IdleLane:\n      return IdleLane;\n\n    case OffscreenLane:\n      return OffscreenLane;\n\n    default:\n      if (__DEV__) {\n        console.error('Should have found matching lanes. This is a bug in React.');\n      } // This shouldn't be reachable, but as a fallback, return the entire bitmask.\n\n\n      return lanes;\n  }\n}\n\nexport function getNextLanes(root, wipLanes) {\n  // Early bailout if there's no pending work left.\n  const pendingLanes = root.pendingLanes;\n\n  if (pendingLanes === NoLanes) {\n    return NoLanes;\n  }\n\n  let nextLanes = NoLanes;\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n  // even if the work is suspended.\n\n  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n\n  if (nonIdlePendingLanes !== NoLanes) {\n    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n\n    if (nonIdleUnblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n    } else {\n      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n\n      if (nonIdlePingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n      }\n    }\n  } else {\n    // The only remaining work is Idle.\n    const unblockedLanes = pendingLanes & ~suspendedLanes;\n\n    if (unblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\n    } else {\n      if (pingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(pingedLanes);\n      }\n    }\n  }\n\n  if (nextLanes === NoLanes) {\n    // This should only be reachable if we're suspended\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\n    return NoLanes;\n  } // If we're already in the middle of a render, switching lanes will interrupt\n  // it and we'll lose our progress. We should only do this if the new lanes are\n  // higher priority.\n\n\n  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n  // bother waiting until the root is complete.\n  (wipLanes & suspendedLanes) === NoLanes) {\n    const nextLane = getHighestPriorityLane(nextLanes);\n    const wipLane = getHighestPriorityLane(wipLanes);\n\n    if ( // Tests whether the next lane is equal or lower priority than the wip\n    // one. This works because the bits decrease in priority as you go left.\n    nextLane >= wipLane || nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n      // Keep working on the existing in-progress tree. Do not interrupt.\n      return wipLanes;\n    }\n  }\n\n  if (allowConcurrentByDefault && (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode) {// Do nothing, use the lanes as they were assigned.\n  } else if ((nextLanes & InputContinuousLane) !== NoLanes) {\n    // When updates are sync by default, we entangle continuous priority updates\n    // and default updates, so they render in the same batch. The only reason\n    // they use separate lanes is because continuous updates should interrupt\n    // transitions, but default updates should not.\n    nextLanes |= pendingLanes & DefaultLane;\n  } // Check for entangled lanes and add them to the batch.\n  //\n  // A lane is said to be entangled with another when it's not allowed to render\n  // in a batch that does not also include the other lane. Typically we do this\n  // when multiple updates have the same source, and we only want to respond to\n  // the most recent event from that source.\n  //\n  // Note that we apply entanglements *after* checking for partial work above.\n  // This means that if a lane is entangled during an interleaved event while\n  // it's already rendering, we won't interrupt it. This is intentional, since\n  // entanglement is usually \"best effort\": we'll try our best to render the\n  // lanes in the same batch, but it's not worth throwing out partially\n  // completed work in order to do it.\n  // TODO: Reconsider this. The counter-argument is that the partial work\n  // represents an intermediate state, which we don't want to show to the user.\n  // And by spending extra time finishing it, we're increasing the amount of\n  // time it takes to show the final state, which is what they are actually\n  // waiting for.\n  //\n  // For those exceptions where entanglement is semantically important, like\n  // useMutableSource, we should ensure that there is no partial work at the\n  // time we apply the entanglement.\n\n\n  const entangledLanes = root.entangledLanes;\n\n  if (entangledLanes !== NoLanes) {\n    const entanglements = root.entanglements;\n    let lanes = nextLanes & entangledLanes;\n\n    while (lanes > 0) {\n      const index = pickArbitraryLaneIndex(lanes);\n      const lane = 1 << index;\n      nextLanes |= entanglements[index];\n      lanes &= ~lane;\n    }\n  }\n\n  return nextLanes;\n}\nexport function getMostRecentEventTime(root, lanes) {\n  const eventTimes = root.eventTimes;\n  let mostRecentEventTime = NoTimestamp;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    const eventTime = eventTimes[index];\n\n    if (eventTime > mostRecentEventTime) {\n      mostRecentEventTime = eventTime;\n    }\n\n    lanes &= ~lane;\n  }\n\n  return mostRecentEventTime;\n}\n\nfunction computeExpirationTime(lane, currentTime) {\n  switch (lane) {\n    case SyncHydrationLane:\n    case SyncLane:\n    case InputContinuousHydrationLane:\n    case InputContinuousLane:\n      // User interactions should expire slightly more quickly.\n      //\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\n      // When we made it larger, a product metric in www regressed, suggesting\n      // there's a user interaction that's being starved by a series of\n      // synchronous updates. If that theory is correct, the proper solution is\n      // to fix the starvation. However, this scenario supports the idea that\n      // expiration times are an important safeguard when starvation\n      // does happen.\n      return currentTime + 250;\n\n    case DefaultHydrationLane:\n    case DefaultLane:\n    case TransitionHydrationLane:\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return currentTime + 5000;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n      // TODO: Retries should be allowed to expire if they are CPU bound for\n      // too long, but when I made this change it caused a spike in browser\n      // crashes. There must be some other underlying bug; not super urgent but\n      // ideally should figure out why and fix it. Unfortunately we don't have\n      // a repro for the crashes, only detected via production metrics.\n      return NoTimestamp;\n\n    case SelectiveHydrationLane:\n    case IdleHydrationLane:\n    case IdleLane:\n    case OffscreenLane:\n      // Anything idle priority or lower should never expire.\n      return NoTimestamp;\n\n    default:\n      if (__DEV__) {\n        console.error('Should have found matching lanes. This is a bug in React.');\n      }\n\n      return NoTimestamp;\n  }\n}\n\nexport function markStarvedLanesAsExpired(root, currentTime) {\n  // TODO: This gets called every time we yield. We can optimize by storing\n  // the earliest expiration time on the root. Then use that to quickly bail out\n  // of this function.\n  const pendingLanes = root.pendingLanes;\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n  const expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n  // expiration time. If so, we'll assume the update is being starved and mark\n  // it as expired to force it to finish.\n  //\n  // We exclude retry lanes because those must always be time sliced, in order\n  // to unwrap uncached promises.\n  // TODO: Write a test for this\n\n  let lanes = pendingLanes & ~RetryLanes;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    const expirationTime = expirationTimes[index];\n\n    if (expirationTime === NoTimestamp) {\n      // Found a pending lane with no expiration time. If it's not suspended, or\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n      // using the current time.\n      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n        // Assumes timestamps are monotonically increasing.\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n      }\n    } else if (expirationTime <= currentTime) {\n      // This lane expired\n      root.expiredLanes |= lane;\n    }\n\n    lanes &= ~lane;\n  }\n} // This returns the highest priority pending lanes regardless of whether they\n// are suspended.\n\nexport function getHighestPriorityPendingLanes(root) {\n  return getHighestPriorityLanes(root.pendingLanes);\n}\nexport function getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes) {\n  if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {\n    // The error recovery mechanism is disabled until these lanes are cleared.\n    return NoLanes;\n  }\n\n  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n\n  if (everythingButOffscreen !== NoLanes) {\n    return everythingButOffscreen;\n  }\n\n  if (everythingButOffscreen & OffscreenLane) {\n    return OffscreenLane;\n  }\n\n  return NoLanes;\n}\nexport function includesSyncLane(lanes) {\n  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;\n}\nexport function includesNonIdleWork(lanes) {\n  return (lanes & NonIdleLanes) !== NoLanes;\n}\nexport function includesOnlyRetries(lanes) {\n  return (lanes & RetryLanes) === lanes;\n}\nexport function includesOnlyNonUrgentLanes(lanes) {\n  // TODO: Should hydration lanes be included here? This function is only\n  // used in `updateDeferredValueImpl`.\n  const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n  return (lanes & UrgentLanes) === NoLanes;\n}\nexport function includesOnlyTransitions(lanes) {\n  return (lanes & TransitionLanes) === lanes;\n}\nexport function includesBlockingLane(root, lanes) {\n  if (allowConcurrentByDefault && (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode) {\n    // Concurrent updates by default always use time slicing.\n    return false;\n  }\n\n  const SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n  return (lanes & SyncDefaultLanes) !== NoLanes;\n}\nexport function includesExpiredLane(root, lanes) {\n  // This is a separate check from includesBlockingLane because a lane can\n  // expire after a render has already started.\n  return (lanes & root.expiredLanes) !== NoLanes;\n}\nexport function isTransitionLane(lane) {\n  return (lane & TransitionLanes) !== NoLanes;\n}\nexport function claimNextTransitionLane() {\n  // Cycle through the lanes, assigning each new transition to the next lane.\n  // In most cases, this means every transition gets its own lane, until we\n  // run out of lanes and cycle back to the beginning.\n  const lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n\n  if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n    nextTransitionLane = TransitionLane1;\n  }\n\n  return lane;\n}\nexport function claimNextRetryLane() {\n  const lane = nextRetryLane;\n  nextRetryLane <<= 1;\n\n  if ((nextRetryLane & RetryLanes) === NoLanes) {\n    nextRetryLane = RetryLane1;\n  }\n\n  return lane;\n}\nexport function getHighestPriorityLane(lanes) {\n  return lanes & -lanes;\n}\nexport function pickArbitraryLane(lanes) {\n  // This wrapper function gets inlined. Only exists so to communicate that it\n  // doesn't matter which bit is selected; you can pick any bit without\n  // affecting the algorithms where its used. Here I'm using\n  // getHighestPriorityLane because it requires the fewest operations.\n  return getHighestPriorityLane(lanes);\n}\n\nfunction pickArbitraryLaneIndex(lanes) {\n  return 31 - clz32(lanes);\n}\n\nfunction laneToIndex(lane) {\n  return pickArbitraryLaneIndex(lane);\n}\n\nexport function includesSomeLane(a, b) {\n  return (a & b) !== NoLanes;\n}\nexport function isSubsetOfLanes(set, subset) {\n  return (set & subset) === subset;\n}\nexport function mergeLanes(a, b) {\n  return a | b;\n}\nexport function removeLanes(set, subset) {\n  return set & ~subset;\n}\nexport function intersectLanes(a, b) {\n  return a & b;\n} // Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\n\nexport function laneToLanes(lane) {\n  return lane;\n}\nexport function higherPriorityLane(a, b) {\n  // This works because the bit ranges decrease in priority as you go left.\n  return a !== NoLane && a < b ? a : b;\n}\nexport function createLaneMap(initial) {\n  // Intentionally pushing one by one.\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n  const laneMap = [];\n\n  for (let i = 0; i < TotalLanes; i++) {\n    laneMap.push(initial);\n  }\n\n  return laneMap;\n}\nexport function markRootUpdated(root, updateLane, eventTime) {\n  root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n  // could unblock them. Clear the suspended lanes so that we can try rendering\n  // them again.\n  //\n  // TODO: We really only need to unsuspend only lanes that are in the\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\n  // path. This would exclude suspended updates in an unrelated sibling tree,\n  // since there's no way for this update to unblock it.\n  //\n  // We don't do this if the incoming update is idle, because we never process\n  // idle updates until after all the regular updates have finished; there's no\n  // way it could unblock a transition.\n\n  if (updateLane !== IdleLane) {\n    root.suspendedLanes = NoLanes;\n    root.pingedLanes = NoLanes;\n  }\n\n  const eventTimes = root.eventTimes;\n  const index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\n  // recent event, and we assume time is monotonically increasing.\n\n  eventTimes[index] = eventTime;\n}\nexport function markRootSuspended(root, suspendedLanes) {\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n\n  const expirationTimes = root.expirationTimes;\n  let lanes = suspendedLanes;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nexport function markRootPinged(root, pingedLanes, eventTime) {\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n}\nexport function markRootMutableRead(root, updateLane) {\n  root.mutableReadLanes |= updateLane & root.pendingLanes;\n}\nexport function markRootFinished(root, remainingLanes) {\n  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n  root.pendingLanes = remainingLanes; // Let's try everything again\n\n  root.suspendedLanes = NoLanes;\n  root.pingedLanes = NoLanes;\n  root.expiredLanes &= remainingLanes;\n  root.mutableReadLanes &= remainingLanes;\n  root.entangledLanes &= remainingLanes;\n  root.errorRecoveryDisabledLanes &= remainingLanes;\n  const entanglements = root.entanglements;\n  const eventTimes = root.eventTimes;\n  const expirationTimes = root.expirationTimes;\n  const hiddenUpdates = root.hiddenUpdates; // Clear the lanes that no longer have pending work\n\n  let lanes = noLongerPendingLanes;\n\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    entanglements[index] = NoLanes;\n    eventTimes[index] = NoTimestamp;\n    expirationTimes[index] = NoTimestamp;\n    const hiddenUpdatesForLane = hiddenUpdates[index];\n\n    if (hiddenUpdatesForLane !== null) {\n      hiddenUpdates[index] = null; // \"Hidden\" updates are updates that were made to a hidden component. They\n      // have special logic associated with them because they may be entangled\n      // with updates that occur outside that tree. But once the outer tree\n      // commits, they behave like regular updates.\n\n      for (let i = 0; i < hiddenUpdatesForLane.length; i++) {\n        const update = hiddenUpdatesForLane[i];\n\n        if (update !== null) {\n          update.lane &= ~OffscreenLane;\n        }\n      }\n    }\n\n    lanes &= ~lane;\n  }\n}\nexport function markRootEntangled(root, entangledLanes) {\n  // In addition to entangling each of the given lanes with each other, we also\n  // have to consider _transitive_ entanglements. For each lane that is already\n  // entangled with *any* of the given lanes, that lane is now transitively\n  // entangled with *all* the given lanes.\n  //\n  // Translated: If C is entangled with A, then entangling A with B also\n  // entangles C with B.\n  //\n  // If this is hard to grasp, it might help to intentionally break this\n  // function and look at the tests that fail in ReactTransition-test.js. Try\n  // commenting out one of the conditions below.\n  const rootEntangledLanes = root.entangledLanes |= entangledLanes;\n  const entanglements = root.entanglements;\n  let lanes = rootEntangledLanes;\n\n  while (lanes) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    if ( // Is this one of the newly entangled lanes?\n    lane & entangledLanes | entanglements[index] & entangledLanes) {\n      entanglements[index] |= entangledLanes;\n    }\n\n    lanes &= ~lane;\n  }\n}\nexport function markHiddenUpdate(root, update, lane) {\n  const index = laneToIndex(lane);\n  const hiddenUpdates = root.hiddenUpdates;\n  const hiddenUpdatesForLane = hiddenUpdates[index];\n\n  if (hiddenUpdatesForLane === null) {\n    hiddenUpdates[index] = [update];\n  } else {\n    hiddenUpdatesForLane.push(update);\n  }\n\n  update.lane = lane | OffscreenLane;\n}\nexport function getBumpedLaneForHydration(root, renderLanes) {\n  const renderLane = getHighestPriorityLane(renderLanes);\n  let lane;\n\n  switch (renderLane) {\n    case SyncLane:\n      lane = SyncHydrationLane;\n      break;\n\n    case InputContinuousLane:\n      lane = InputContinuousHydrationLane;\n      break;\n\n    case DefaultLane:\n      lane = DefaultHydrationLane;\n      break;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n      lane = TransitionHydrationLane;\n      break;\n\n    case IdleLane:\n      lane = IdleHydrationLane;\n      break;\n\n    default:\n      // Everything else is already either a hydration lane, or shouldn't\n      // be retried at a hydration lane.\n      lane = NoLane;\n      break;\n  } // Check if the lane we chose is suspended. If so, that indicates that we\n  // already attempted and failed to hydrate at that level. Also check if we're\n  // already rendering that lane, which is rare but could happen.\n\n\n  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n    // Give up trying to hydrate and fall back to client render.\n    return NoLane;\n  }\n\n  return lane;\n}\nexport function addFiberToLanesMap(root, fiber, lanes) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const updaters = pendingUpdatersLaneMap[index];\n    updaters.add(fiber);\n    lanes &= ~lane;\n  }\n}\nexport function movePendingFibersToMemoized(root, lanes) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  const memoizedUpdaters = root.memoizedUpdaters;\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const updaters = pendingUpdatersLaneMap[index];\n\n    if (updaters.size > 0) {\n      updaters.forEach(fiber => {\n        const alternate = fiber.alternate;\n\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n          memoizedUpdaters.add(fiber);\n        }\n      });\n      updaters.clear();\n    }\n\n    lanes &= ~lane;\n  }\n}\nexport function addTransitionToLanesMap(root, transition, lane) {\n  if (enableTransitionTracing) {\n    const transitionLanesMap = root.transitionLanes;\n    const index = laneToIndex(lane);\n    let transitions = transitionLanesMap[index];\n\n    if (transitions === null) {\n      transitions = new Set();\n    }\n\n    transitions.add(transition);\n    transitionLanesMap[index] = transitions;\n  }\n}\nexport function getTransitionsForLanes(root, lanes) {\n  if (!enableTransitionTracing) {\n    return null;\n  }\n\n  const transitionsForLanes = [];\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const transitions = root.transitionLanes[index];\n\n    if (transitions !== null) {\n      transitions.forEach(transition => {\n        transitionsForLanes.push(transition);\n      });\n    }\n\n    lanes &= ~lane;\n  }\n\n  if (transitionsForLanes.length === 0) {\n    return null;\n  }\n\n  return transitionsForLanes;\n}\nexport function clearTransitionsForLanes(root, lanes) {\n  if (!enableTransitionTracing) {\n    return;\n  }\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const transitions = root.transitionLanes[index];\n\n    if (transitions !== null) {\n      root.transitionLanes[index] = null;\n    }\n\n    lanes &= ~lane;\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberLane.js"],"names":["enableSchedulingProfiler","enableUpdaterTracking","allowConcurrentByDefault","enableTransitionTracing","isDevToolsPresent","ConcurrentUpdatesByDefaultMode","NoMode","clz32","TotalLanes","NoLanes","NoLane","SyncHydrationLane","SyncLane","InputContinuousHydrationLane","InputContinuousLane","DefaultHydrationLane","DefaultLane","TransitionHydrationLane","TransitionLanes","TransitionLane1","TransitionLane2","TransitionLane3","TransitionLane4","TransitionLane5","TransitionLane6","TransitionLane7","TransitionLane8","TransitionLane9","TransitionLane10","TransitionLane11","TransitionLane12","TransitionLane13","TransitionLane14","TransitionLane15","TransitionLane16","RetryLanes","RetryLane1","RetryLane2","RetryLane3","RetryLane4","SomeRetryLane","SelectiveHydrationLane","NonIdleLanes","IdleHydrationLane","IdleLane","OffscreenLane","getLabelForLane","lane","NoTimestamp","nextTransitionLane","nextRetryLane","getHighestPriorityLanes","lanes","getHighestPriorityLane","__DEV__","console","error","getNextLanes","root","wipLanes","pendingLanes","nextLanes","suspendedLanes","pingedLanes","nonIdlePendingLanes","nonIdleUnblockedLanes","nonIdlePingedLanes","unblockedLanes","nextLane","wipLane","current","mode","entangledLanes","entanglements","index","pickArbitraryLaneIndex","getMostRecentEventTime","eventTimes","mostRecentEventTime","eventTime","computeExpirationTime","currentTime","markStarvedLanesAsExpired","expirationTimes","expirationTime","expiredLanes","getHighestPriorityPendingLanes","getLanesToRetrySynchronouslyOnError","originallyAttemptedLanes","errorRecoveryDisabledLanes","everythingButOffscreen","includesSyncLane","includesNonIdleWork","includesOnlyRetries","includesOnlyNonUrgentLanes","UrgentLanes","includesOnlyTransitions","includesBlockingLane","SyncDefaultLanes","includesExpiredLane","isTransitionLane","claimNextTransitionLane","claimNextRetryLane","pickArbitraryLane","laneToIndex","includesSomeLane","a","b","isSubsetOfLanes","set","subset","mergeLanes","removeLanes","intersectLanes","laneToLanes","higherPriorityLane","createLaneMap","initial","laneMap","i","push","markRootUpdated","updateLane","markRootSuspended","markRootPinged","markRootMutableRead","mutableReadLanes","markRootFinished","remainingLanes","noLongerPendingLanes","hiddenUpdates","hiddenUpdatesForLane","length","update","markRootEntangled","rootEntangledLanes","markHiddenUpdate","getBumpedLaneForHydration","renderLanes","renderLane","addFiberToLanesMap","fiber","pendingUpdatersLaneMap","updaters","add","movePendingFibersToMemoized","memoizedUpdaters","size","forEach","alternate","has","clear","addTransitionToLanesMap","transition","transitionLanesMap","transitionLanes","transitions","Set","getTransitionsForLanes","transitionsForLanes","clearTransitionsForLanes"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Transition} from './ReactFiberTracingMarkerComponent';\nimport type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';\n\n// TODO: Ideally these types would be opaque but that doesn't work well with\n// our reconciler fork infra, since these leak into non-reconciler packages.\n\nexport type Lanes = number;\nexport type Lane = number;\nexport type LaneMap<T> = Array<T>;\n\nimport {\n  enableSchedulingProfiler,\n  enableUpdaterTracking,\n  allowConcurrentByDefault,\n  enableTransitionTracing,\n} from 'shared/ReactFeatureFlags';\nimport {isDevToolsPresent} from './ReactFiberDevToolsHook';\nimport {ConcurrentUpdatesByDefaultMode, NoMode} from './ReactTypeOfMode';\nimport {clz32} from './clz32';\n\n// Lane values below should be kept in sync with getLabelForLane(), used by react-devtools-timeline.\n// If those values are changed that package should be rebuilt and redeployed.\n\nexport const TotalLanes = 31;\n\nexport const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;\nexport const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;\n\nexport const SyncHydrationLane: Lane = /*               */ 0b0000000000000000000000000000001;\nexport const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000010;\n\nexport const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000100;\nexport const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000001000;\n\nexport const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000010000;\nexport const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000100000;\n\nconst TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000001000000;\nconst TransitionLanes: Lanes = /*                       */ 0b0000000011111111111111110000000;\nconst TransitionLane1: Lane = /*                        */ 0b0000000000000000000000010000000;\nconst TransitionLane2: Lane = /*                        */ 0b0000000000000000000000100000000;\nconst TransitionLane3: Lane = /*                        */ 0b0000000000000000000001000000000;\nconst TransitionLane4: Lane = /*                        */ 0b0000000000000000000010000000000;\nconst TransitionLane5: Lane = /*                        */ 0b0000000000000000000100000000000;\nconst TransitionLane6: Lane = /*                        */ 0b0000000000000000001000000000000;\nconst TransitionLane7: Lane = /*                        */ 0b0000000000000000010000000000000;\nconst TransitionLane8: Lane = /*                        */ 0b0000000000000000100000000000000;\nconst TransitionLane9: Lane = /*                        */ 0b0000000000000001000000000000000;\nconst TransitionLane10: Lane = /*                       */ 0b0000000000000010000000000000000;\nconst TransitionLane11: Lane = /*                       */ 0b0000000000000100000000000000000;\nconst TransitionLane12: Lane = /*                       */ 0b0000000000001000000000000000000;\nconst TransitionLane13: Lane = /*                       */ 0b0000000000010000000000000000000;\nconst TransitionLane14: Lane = /*                       */ 0b0000000000100000000000000000000;\nconst TransitionLane15: Lane = /*                       */ 0b0000000001000000000000000000000;\nconst TransitionLane16: Lane = /*                       */ 0b0000000010000000000000000000000;\n\nconst RetryLanes: Lanes = /*                            */ 0b0000111100000000000000000000000;\nconst RetryLane1: Lane = /*                             */ 0b0000000100000000000000000000000;\nconst RetryLane2: Lane = /*                             */ 0b0000001000000000000000000000000;\nconst RetryLane3: Lane = /*                             */ 0b0000010000000000000000000000000;\nconst RetryLane4: Lane = /*                             */ 0b0000100000000000000000000000000;\n\nexport const SomeRetryLane: Lane = RetryLane1;\n\nexport const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;\n\nconst NonIdleLanes: Lanes = /*                          */ 0b0001111111111111111111111111111;\n\nexport const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;\nexport const IdleLane: Lane = /*                        */ 0b0100000000000000000000000000000;\n\nexport const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;\n\n// This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\nexport function getLabelForLane(lane: Lane): string | void {\n  if (enableSchedulingProfiler) {\n    if (lane & SyncHydrationLane) {\n      return 'SyncHydrationLane';\n    }\n    if (lane & SyncLane) {\n      return 'Sync';\n    }\n    if (lane & InputContinuousHydrationLane) {\n      return 'InputContinuousHydration';\n    }\n    if (lane & InputContinuousLane) {\n      return 'InputContinuous';\n    }\n    if (lane & DefaultHydrationLane) {\n      return 'DefaultHydration';\n    }\n    if (lane & DefaultLane) {\n      return 'Default';\n    }\n    if (lane & TransitionHydrationLane) {\n      return 'TransitionHydration';\n    }\n    if (lane & TransitionLanes) {\n      return 'Transition';\n    }\n    if (lane & RetryLanes) {\n      return 'Retry';\n    }\n    if (lane & SelectiveHydrationLane) {\n      return 'SelectiveHydration';\n    }\n    if (lane & IdleHydrationLane) {\n      return 'IdleHydration';\n    }\n    if (lane & IdleLane) {\n      return 'Idle';\n    }\n    if (lane & OffscreenLane) {\n      return 'Offscreen';\n    }\n  }\n}\n\nexport const NoTimestamp = -1;\n\nlet nextTransitionLane: Lane = TransitionLane1;\nlet nextRetryLane: Lane = RetryLane1;\n\nfunction getHighestPriorityLanes(lanes: Lanes | Lane): Lanes {\n  switch (getHighestPriorityLane(lanes)) {\n    case SyncHydrationLane:\n      return SyncHydrationLane;\n    case SyncLane:\n      return SyncLane;\n    case InputContinuousHydrationLane:\n      return InputContinuousHydrationLane;\n    case InputContinuousLane:\n      return InputContinuousLane;\n    case DefaultHydrationLane:\n      return DefaultHydrationLane;\n    case DefaultLane:\n      return DefaultLane;\n    case TransitionHydrationLane:\n      return TransitionHydrationLane;\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return lanes & TransitionLanes;\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n      return lanes & RetryLanes;\n    case SelectiveHydrationLane:\n      return SelectiveHydrationLane;\n    case IdleHydrationLane:\n      return IdleHydrationLane;\n    case IdleLane:\n      return IdleLane;\n    case OffscreenLane:\n      return OffscreenLane;\n    default:\n      if (__DEV__) {\n        console.error(\n          'Should have found matching lanes. This is a bug in React.',\n        );\n      }\n      // This shouldn't be reachable, but as a fallback, return the entire bitmask.\n      return lanes;\n  }\n}\n\nexport function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {\n  // Early bailout if there's no pending work left.\n  const pendingLanes = root.pendingLanes;\n  if (pendingLanes === NoLanes) {\n    return NoLanes;\n  }\n\n  let nextLanes = NoLanes;\n\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n\n  // Do not work on any idle work until all the non-idle work has finished,\n  // even if the work is suspended.\n  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n  if (nonIdlePendingLanes !== NoLanes) {\n    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n    if (nonIdleUnblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n    } else {\n      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n      if (nonIdlePingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n      }\n    }\n  } else {\n    // The only remaining work is Idle.\n    const unblockedLanes = pendingLanes & ~suspendedLanes;\n    if (unblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\n    } else {\n      if (pingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(pingedLanes);\n      }\n    }\n  }\n\n  if (nextLanes === NoLanes) {\n    // This should only be reachable if we're suspended\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\n    return NoLanes;\n  }\n\n  // If we're already in the middle of a render, switching lanes will interrupt\n  // it and we'll lose our progress. We should only do this if the new lanes are\n  // higher priority.\n  if (\n    wipLanes !== NoLanes &&\n    wipLanes !== nextLanes &&\n    // If we already suspended with a delay, then interrupting is fine. Don't\n    // bother waiting until the root is complete.\n    (wipLanes & suspendedLanes) === NoLanes\n  ) {\n    const nextLane = getHighestPriorityLane(nextLanes);\n    const wipLane = getHighestPriorityLane(wipLanes);\n    if (\n      // Tests whether the next lane is equal or lower priority than the wip\n      // one. This works because the bits decrease in priority as you go left.\n      nextLane >= wipLane ||\n      // Default priority updates should not interrupt transition updates. The\n      // only difference between default updates and transition updates is that\n      // default updates do not support refresh transitions.\n      (nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes)\n    ) {\n      // Keep working on the existing in-progress tree. Do not interrupt.\n      return wipLanes;\n    }\n  }\n\n  if (\n    allowConcurrentByDefault &&\n    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode\n  ) {\n    // Do nothing, use the lanes as they were assigned.\n  } else if ((nextLanes & InputContinuousLane) !== NoLanes) {\n    // When updates are sync by default, we entangle continuous priority updates\n    // and default updates, so they render in the same batch. The only reason\n    // they use separate lanes is because continuous updates should interrupt\n    // transitions, but default updates should not.\n    nextLanes |= pendingLanes & DefaultLane;\n  }\n\n  // Check for entangled lanes and add them to the batch.\n  //\n  // A lane is said to be entangled with another when it's not allowed to render\n  // in a batch that does not also include the other lane. Typically we do this\n  // when multiple updates have the same source, and we only want to respond to\n  // the most recent event from that source.\n  //\n  // Note that we apply entanglements *after* checking for partial work above.\n  // This means that if a lane is entangled during an interleaved event while\n  // it's already rendering, we won't interrupt it. This is intentional, since\n  // entanglement is usually \"best effort\": we'll try our best to render the\n  // lanes in the same batch, but it's not worth throwing out partially\n  // completed work in order to do it.\n  // TODO: Reconsider this. The counter-argument is that the partial work\n  // represents an intermediate state, which we don't want to show to the user.\n  // And by spending extra time finishing it, we're increasing the amount of\n  // time it takes to show the final state, which is what they are actually\n  // waiting for.\n  //\n  // For those exceptions where entanglement is semantically important, like\n  // useMutableSource, we should ensure that there is no partial work at the\n  // time we apply the entanglement.\n  const entangledLanes = root.entangledLanes;\n  if (entangledLanes !== NoLanes) {\n    const entanglements = root.entanglements;\n    let lanes = nextLanes & entangledLanes;\n    while (lanes > 0) {\n      const index = pickArbitraryLaneIndex(lanes);\n      const lane = 1 << index;\n\n      nextLanes |= entanglements[index];\n\n      lanes &= ~lane;\n    }\n  }\n\n  return nextLanes;\n}\n\nexport function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number {\n  const eventTimes = root.eventTimes;\n\n  let mostRecentEventTime = NoTimestamp;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    const eventTime = eventTimes[index];\n    if (eventTime > mostRecentEventTime) {\n      mostRecentEventTime = eventTime;\n    }\n\n    lanes &= ~lane;\n  }\n\n  return mostRecentEventTime;\n}\n\nfunction computeExpirationTime(lane: Lane, currentTime: number) {\n  switch (lane) {\n    case SyncHydrationLane:\n    case SyncLane:\n    case InputContinuousHydrationLane:\n    case InputContinuousLane:\n      // User interactions should expire slightly more quickly.\n      //\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\n      // When we made it larger, a product metric in www regressed, suggesting\n      // there's a user interaction that's being starved by a series of\n      // synchronous updates. If that theory is correct, the proper solution is\n      // to fix the starvation. However, this scenario supports the idea that\n      // expiration times are an important safeguard when starvation\n      // does happen.\n      return currentTime + 250;\n    case DefaultHydrationLane:\n    case DefaultLane:\n    case TransitionHydrationLane:\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return currentTime + 5000;\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n      // TODO: Retries should be allowed to expire if they are CPU bound for\n      // too long, but when I made this change it caused a spike in browser\n      // crashes. There must be some other underlying bug; not super urgent but\n      // ideally should figure out why and fix it. Unfortunately we don't have\n      // a repro for the crashes, only detected via production metrics.\n      return NoTimestamp;\n    case SelectiveHydrationLane:\n    case IdleHydrationLane:\n    case IdleLane:\n    case OffscreenLane:\n      // Anything idle priority or lower should never expire.\n      return NoTimestamp;\n    default:\n      if (__DEV__) {\n        console.error(\n          'Should have found matching lanes. This is a bug in React.',\n        );\n      }\n      return NoTimestamp;\n  }\n}\n\nexport function markStarvedLanesAsExpired(\n  root: FiberRoot,\n  currentTime: number,\n): void {\n  // TODO: This gets called every time we yield. We can optimize by storing\n  // the earliest expiration time on the root. Then use that to quickly bail out\n  // of this function.\n\n  const pendingLanes = root.pendingLanes;\n  const suspendedLanes = root.suspendedLanes;\n  const pingedLanes = root.pingedLanes;\n  const expirationTimes = root.expirationTimes;\n\n  // Iterate through the pending lanes and check if we've reached their\n  // expiration time. If so, we'll assume the update is being starved and mark\n  // it as expired to force it to finish.\n  //\n  // We exclude retry lanes because those must always be time sliced, in order\n  // to unwrap uncached promises.\n  // TODO: Write a test for this\n  let lanes = pendingLanes & ~RetryLanes;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    const expirationTime = expirationTimes[index];\n    if (expirationTime === NoTimestamp) {\n      // Found a pending lane with no expiration time. If it's not suspended, or\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n      // using the current time.\n      if (\n        (lane & suspendedLanes) === NoLanes ||\n        (lane & pingedLanes) !== NoLanes\n      ) {\n        // Assumes timestamps are monotonically increasing.\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n      }\n    } else if (expirationTime <= currentTime) {\n      // This lane expired\n      root.expiredLanes |= lane;\n    }\n\n    lanes &= ~lane;\n  }\n}\n\n// This returns the highest priority pending lanes regardless of whether they\n// are suspended.\nexport function getHighestPriorityPendingLanes(root: FiberRoot): Lanes {\n  return getHighestPriorityLanes(root.pendingLanes);\n}\n\nexport function getLanesToRetrySynchronouslyOnError(\n  root: FiberRoot,\n  originallyAttemptedLanes: Lanes,\n): Lanes {\n  if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {\n    // The error recovery mechanism is disabled until these lanes are cleared.\n    return NoLanes;\n  }\n\n  const everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n  if (everythingButOffscreen !== NoLanes) {\n    return everythingButOffscreen;\n  }\n  if (everythingButOffscreen & OffscreenLane) {\n    return OffscreenLane;\n  }\n  return NoLanes;\n}\n\nexport function includesSyncLane(lanes: Lanes): boolean {\n  return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;\n}\n\nexport function includesNonIdleWork(lanes: Lanes): boolean {\n  return (lanes & NonIdleLanes) !== NoLanes;\n}\nexport function includesOnlyRetries(lanes: Lanes): boolean {\n  return (lanes & RetryLanes) === lanes;\n}\nexport function includesOnlyNonUrgentLanes(lanes: Lanes): boolean {\n  // TODO: Should hydration lanes be included here? This function is only\n  // used in `updateDeferredValueImpl`.\n  const UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n  return (lanes & UrgentLanes) === NoLanes;\n}\nexport function includesOnlyTransitions(lanes: Lanes): boolean {\n  return (lanes & TransitionLanes) === lanes;\n}\n\nexport function includesBlockingLane(root: FiberRoot, lanes: Lanes): boolean {\n  if (\n    allowConcurrentByDefault &&\n    (root.current.mode & ConcurrentUpdatesByDefaultMode) !== NoMode\n  ) {\n    // Concurrent updates by default always use time slicing.\n    return false;\n  }\n  const SyncDefaultLanes =\n    InputContinuousHydrationLane |\n    InputContinuousLane |\n    DefaultHydrationLane |\n    DefaultLane;\n  return (lanes & SyncDefaultLanes) !== NoLanes;\n}\n\nexport function includesExpiredLane(root: FiberRoot, lanes: Lanes): boolean {\n  // This is a separate check from includesBlockingLane because a lane can\n  // expire after a render has already started.\n  return (lanes & root.expiredLanes) !== NoLanes;\n}\n\nexport function isTransitionLane(lane: Lane): boolean {\n  return (lane & TransitionLanes) !== NoLanes;\n}\n\nexport function claimNextTransitionLane(): Lane {\n  // Cycle through the lanes, assigning each new transition to the next lane.\n  // In most cases, this means every transition gets its own lane, until we\n  // run out of lanes and cycle back to the beginning.\n  const lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n  if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n    nextTransitionLane = TransitionLane1;\n  }\n  return lane;\n}\n\nexport function claimNextRetryLane(): Lane {\n  const lane = nextRetryLane;\n  nextRetryLane <<= 1;\n  if ((nextRetryLane & RetryLanes) === NoLanes) {\n    nextRetryLane = RetryLane1;\n  }\n  return lane;\n}\n\nexport function getHighestPriorityLane(lanes: Lanes): Lane {\n  return lanes & -lanes;\n}\n\nexport function pickArbitraryLane(lanes: Lanes): Lane {\n  // This wrapper function gets inlined. Only exists so to communicate that it\n  // doesn't matter which bit is selected; you can pick any bit without\n  // affecting the algorithms where its used. Here I'm using\n  // getHighestPriorityLane because it requires the fewest operations.\n  return getHighestPriorityLane(lanes);\n}\n\nfunction pickArbitraryLaneIndex(lanes: Lanes) {\n  return 31 - clz32(lanes);\n}\n\nfunction laneToIndex(lane: Lane) {\n  return pickArbitraryLaneIndex(lane);\n}\n\nexport function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane): boolean {\n  return (a & b) !== NoLanes;\n}\n\nexport function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane): boolean {\n  return (set & subset) === subset;\n}\n\nexport function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a | b;\n}\n\nexport function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {\n  return set & ~subset;\n}\n\nexport function intersectLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a & b;\n}\n\n// Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\nexport function laneToLanes(lane: Lane): Lanes {\n  return lane;\n}\n\nexport function higherPriorityLane(a: Lane, b: Lane): Lane {\n  // This works because the bit ranges decrease in priority as you go left.\n  return a !== NoLane && a < b ? a : b;\n}\n\nexport function createLaneMap<T>(initial: T): LaneMap<T> {\n  // Intentionally pushing one by one.\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n  const laneMap = [];\n  for (let i = 0; i < TotalLanes; i++) {\n    laneMap.push(initial);\n  }\n  return laneMap;\n}\n\nexport function markRootUpdated(\n  root: FiberRoot,\n  updateLane: Lane,\n  eventTime: number,\n) {\n  root.pendingLanes |= updateLane;\n\n  // If there are any suspended transitions, it's possible this new update\n  // could unblock them. Clear the suspended lanes so that we can try rendering\n  // them again.\n  //\n  // TODO: We really only need to unsuspend only lanes that are in the\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\n  // path. This would exclude suspended updates in an unrelated sibling tree,\n  // since there's no way for this update to unblock it.\n  //\n  // We don't do this if the incoming update is idle, because we never process\n  // idle updates until after all the regular updates have finished; there's no\n  // way it could unblock a transition.\n  if (updateLane !== IdleLane) {\n    root.suspendedLanes = NoLanes;\n    root.pingedLanes = NoLanes;\n  }\n\n  const eventTimes = root.eventTimes;\n  const index = laneToIndex(updateLane);\n  // We can always overwrite an existing timestamp because we prefer the most\n  // recent event, and we assume time is monotonically increasing.\n  eventTimes[index] = eventTime;\n}\n\nexport function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes) {\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes;\n\n  // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n  const expirationTimes = root.expirationTimes;\n  let lanes = suspendedLanes;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    expirationTimes[index] = NoTimestamp;\n\n    lanes &= ~lane;\n  }\n}\n\nexport function markRootPinged(\n  root: FiberRoot,\n  pingedLanes: Lanes,\n  eventTime: number,\n) {\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n}\n\nexport function markRootMutableRead(root: FiberRoot, updateLane: Lane) {\n  root.mutableReadLanes |= updateLane & root.pendingLanes;\n}\n\nexport function markRootFinished(root: FiberRoot, remainingLanes: Lanes) {\n  const noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n\n  root.pendingLanes = remainingLanes;\n\n  // Let's try everything again\n  root.suspendedLanes = NoLanes;\n  root.pingedLanes = NoLanes;\n\n  root.expiredLanes &= remainingLanes;\n  root.mutableReadLanes &= remainingLanes;\n\n  root.entangledLanes &= remainingLanes;\n\n  root.errorRecoveryDisabledLanes &= remainingLanes;\n\n  const entanglements = root.entanglements;\n  const eventTimes = root.eventTimes;\n  const expirationTimes = root.expirationTimes;\n  const hiddenUpdates = root.hiddenUpdates;\n\n  // Clear the lanes that no longer have pending work\n  let lanes = noLongerPendingLanes;\n  while (lanes > 0) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n\n    entanglements[index] = NoLanes;\n    eventTimes[index] = NoTimestamp;\n    expirationTimes[index] = NoTimestamp;\n\n    const hiddenUpdatesForLane = hiddenUpdates[index];\n    if (hiddenUpdatesForLane !== null) {\n      hiddenUpdates[index] = null;\n      // \"Hidden\" updates are updates that were made to a hidden component. They\n      // have special logic associated with them because they may be entangled\n      // with updates that occur outside that tree. But once the outer tree\n      // commits, they behave like regular updates.\n      for (let i = 0; i < hiddenUpdatesForLane.length; i++) {\n        const update = hiddenUpdatesForLane[i];\n        if (update !== null) {\n          update.lane &= ~OffscreenLane;\n        }\n      }\n    }\n\n    lanes &= ~lane;\n  }\n}\n\nexport function markRootEntangled(root: FiberRoot, entangledLanes: Lanes) {\n  // In addition to entangling each of the given lanes with each other, we also\n  // have to consider _transitive_ entanglements. For each lane that is already\n  // entangled with *any* of the given lanes, that lane is now transitively\n  // entangled with *all* the given lanes.\n  //\n  // Translated: If C is entangled with A, then entangling A with B also\n  // entangles C with B.\n  //\n  // If this is hard to grasp, it might help to intentionally break this\n  // function and look at the tests that fail in ReactTransition-test.js. Try\n  // commenting out one of the conditions below.\n\n  const rootEntangledLanes = (root.entangledLanes |= entangledLanes);\n  const entanglements = root.entanglements;\n  let lanes = rootEntangledLanes;\n  while (lanes) {\n    const index = pickArbitraryLaneIndex(lanes);\n    const lane = 1 << index;\n    if (\n      // Is this one of the newly entangled lanes?\n      (lane & entangledLanes) |\n      // Is this lane transitively entangled with the newly entangled lanes?\n      (entanglements[index] & entangledLanes)\n    ) {\n      entanglements[index] |= entangledLanes;\n    }\n    lanes &= ~lane;\n  }\n}\n\nexport function markHiddenUpdate(\n  root: FiberRoot,\n  update: ConcurrentUpdate,\n  lane: Lane,\n) {\n  const index = laneToIndex(lane);\n  const hiddenUpdates = root.hiddenUpdates;\n  const hiddenUpdatesForLane = hiddenUpdates[index];\n  if (hiddenUpdatesForLane === null) {\n    hiddenUpdates[index] = [update];\n  } else {\n    hiddenUpdatesForLane.push(update);\n  }\n  update.lane = lane | OffscreenLane;\n}\n\nexport function getBumpedLaneForHydration(\n  root: FiberRoot,\n  renderLanes: Lanes,\n): Lane {\n  const renderLane = getHighestPriorityLane(renderLanes);\n\n  let lane;\n  switch (renderLane) {\n    case SyncLane:\n      lane = SyncHydrationLane;\n      break;\n    case InputContinuousLane:\n      lane = InputContinuousHydrationLane;\n      break;\n    case DefaultLane:\n      lane = DefaultHydrationLane;\n      break;\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n      lane = TransitionHydrationLane;\n      break;\n    case IdleLane:\n      lane = IdleHydrationLane;\n      break;\n    default:\n      // Everything else is already either a hydration lane, or shouldn't\n      // be retried at a hydration lane.\n      lane = NoLane;\n      break;\n  }\n\n  // Check if the lane we chose is suspended. If so, that indicates that we\n  // already attempted and failed to hydrate at that level. Also check if we're\n  // already rendering that lane, which is rare but could happen.\n  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n    // Give up trying to hydrate and fall back to client render.\n    return NoLane;\n  }\n\n  return lane;\n}\n\nexport function addFiberToLanesMap(\n  root: FiberRoot,\n  fiber: Fiber,\n  lanes: Lanes | Lane,\n) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n  if (!isDevToolsPresent) {\n    return;\n  }\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n\n    const updaters = pendingUpdatersLaneMap[index];\n    updaters.add(fiber);\n\n    lanes &= ~lane;\n  }\n}\n\nexport function movePendingFibersToMemoized(root: FiberRoot, lanes: Lanes) {\n  if (!enableUpdaterTracking) {\n    return;\n  }\n  if (!isDevToolsPresent) {\n    return;\n  }\n  const pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  const memoizedUpdaters = root.memoizedUpdaters;\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n\n    const updaters = pendingUpdatersLaneMap[index];\n    if (updaters.size > 0) {\n      updaters.forEach(fiber => {\n        const alternate = fiber.alternate;\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n          memoizedUpdaters.add(fiber);\n        }\n      });\n      updaters.clear();\n    }\n\n    lanes &= ~lane;\n  }\n}\n\nexport function addTransitionToLanesMap(\n  root: FiberRoot,\n  transition: Transition,\n  lane: Lane,\n) {\n  if (enableTransitionTracing) {\n    const transitionLanesMap = root.transitionLanes;\n    const index = laneToIndex(lane);\n    let transitions = transitionLanesMap[index];\n    if (transitions === null) {\n      transitions = new Set();\n    }\n    transitions.add(transition);\n\n    transitionLanesMap[index] = transitions;\n  }\n}\n\nexport function getTransitionsForLanes(\n  root: FiberRoot,\n  lanes: Lane | Lanes,\n): Array<Transition> | null {\n  if (!enableTransitionTracing) {\n    return null;\n  }\n\n  const transitionsForLanes = [];\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n    const transitions = root.transitionLanes[index];\n    if (transitions !== null) {\n      transitions.forEach(transition => {\n        transitionsForLanes.push(transition);\n      });\n    }\n\n    lanes &= ~lane;\n  }\n\n  if (transitionsForLanes.length === 0) {\n    return null;\n  }\n\n  return transitionsForLanes;\n}\n\nexport function clearTransitionsForLanes(root: FiberRoot, lanes: Lane | Lanes) {\n  if (!enableTransitionTracing) {\n    return;\n  }\n\n  while (lanes > 0) {\n    const index = laneToIndex(lanes);\n    const lane = 1 << index;\n\n    const transitions = root.transitionLanes[index];\n    if (transitions !== null) {\n      root.transitionLanes[index] = null;\n    }\n\n    lanes &= ~lane;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}