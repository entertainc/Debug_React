{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport { Placement, ChildDeletion, Forked, PlacementDEV } from './ReactFiberFlags';\nimport { getIteratorFn, REACT_ELEMENT_TYPE, REACT_FRAGMENT_TYPE, REACT_PORTAL_TYPE, REACT_LAZY_TYPE } from 'shared/ReactSymbols';\nimport { ClassComponent, HostText, HostPortal, Fragment } from './ReactWorkTags';\nimport isArray from 'shared/isArray';\nimport { warnAboutStringRefs } from 'shared/ReactFeatureFlags';\nimport { checkPropStringCoercion } from 'shared/CheckStringCoercion';\nimport { createWorkInProgress, resetWorkInProgress, createFiberFromElement, createFiberFromFragment, createFiberFromText, createFiberFromPortal } from './ReactFiber';\nimport { isCompatibleFamilyForHotReloading } from './ReactFiberHotReloading';\nimport { StrictLegacyMode } from './ReactTypeOfMode';\nimport { getIsHydrating } from './ReactFiberHydrationContext';\nimport { pushTreeFork } from './ReactFiberTreeContext';\nlet didWarnAboutMaps;\nlet didWarnAboutGenerators;\nlet didWarnAboutStringRefs;\nlet ownerHasKeyUseWarning;\nlet ownerHasFunctionTypeWarning;\n\nlet warnForMissingKey = (child, returnFiber) => {};\n\nif (__DEV__) {\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = (child, returnFiber) => {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n\n    if (typeof child._store !== 'object') {\n      throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    } // $FlowFixMe unable to narrow type from mixed to writable object\n\n\n    child._store.validated = true;\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasKeyUseWarning[componentName]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[componentName] = true;\n    console.error('Each child in a list should have a unique ' + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');\n  };\n}\n\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\n\nfunction coerceRef(returnFiber, current, element) {\n  const mixedRef = element.ref;\n\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    if (__DEV__) {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n      // because these cannot be automatically converted to an arrow function\n      // using a codemod. Therefore, we don't have to warn about string refs again.\n      !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with \"Function components cannot have string refs\"\n      !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with \"Function components cannot be given refs\"\n      !(typeof element.type === 'function' && !isReactClass(element.type)) && // Will already throw with \"Element ref was specified as a string (someStringRef) but no owner was set\"\n      element._owner) {\n        const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n        if (!didWarnAboutStringRefs[componentName]) {\n          if (warnAboutStringRefs) {\n            console.error('Component \"%s\" contains the string ref \"%s\". Support for string refs ' + 'will be removed in a future major release. We recommend using ' + 'useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);\n          } else {\n            console.error('A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);\n          }\n\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      const owner = element._owner;\n      let inst;\n\n      if (owner) {\n        const ownerFiber = owner;\n\n        if (ownerFiber.tag !== ClassComponent) {\n          throw new Error('Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref');\n        }\n\n        inst = ownerFiber.stateNode;\n      }\n\n      if (!inst) {\n        throw new Error(`Missing owner for string ref ${mixedRef}. This error is likely caused by a ` + 'bug in React. Please file an issue.');\n      } // Assigning this to a const so Flow knows it won't change in the closure\n\n\n      const resolvedInst = inst;\n\n      if (__DEV__) {\n        checkPropStringCoercion(mixedRef, 'ref');\n      }\n\n      const stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n\n      const ref = function (value) {\n        const refs = resolvedInst.refs;\n\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      if (typeof mixedRef !== 'string') {\n        throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');\n      }\n\n      if (!element._owner) {\n        throw new Error(`Element ref was specified as a string (${mixedRef}) but no owner was set. This could happen for one of` + ' the following reasons:\\n' + '1. You may be adding a ref to a function component\\n' + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + '3. You have multiple copies of React loaded\\n' + 'See https://reactjs.org/link/refs-must-have-owner for more information.');\n      }\n    }\n  }\n\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  // $FlowFixMe[method-unbinding]\n  const childString = Object.prototype.toString.call(newChild);\n  throw new Error(`Objects are not valid as a React child (found: ${childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString}). ` + 'If you meant to render a collection of children, use an array ' + 'instead.');\n}\n\nfunction warnOnFunctionType(returnFiber) {\n  if (__DEV__) {\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasFunctionTypeWarning[componentName]) {\n      return;\n    }\n\n    ownerHasFunctionTypeWarning[componentName] = true;\n    console.error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n  }\n}\n\nfunction resolveLazy(lazyType) {\n  const payload = lazyType._payload;\n  const init = lazyType._init;\n  return init(payload);\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction createChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n\n    const deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [childToDelete];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(childToDelete);\n    }\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n\n\n    let childToDelete = currentFirstChild;\n\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren = new Map();\n    let existingChild = currentFirstChild;\n\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n\n      existingChild = existingChild.sibling;\n    }\n\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    const clone = createWorkInProgress(fiber, pendingProps);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n\n    if (!shouldTrackSideEffects) {\n      // During hydration, the useId algorithm needs to know which fibers are\n      // part of a list of children (arrays, iterators).\n      newFiber.flags |= Forked;\n      return lastPlacedIndex;\n    }\n\n    const current = newFiber.alternate;\n\n    if (current !== null) {\n      const oldIndex = current.index;\n\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.flags |= Placement | PlacementDEV;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.flags |= Placement | PlacementDEV;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.flags |= Placement | PlacementDEV;\n    }\n\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, lanes) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, lanes) {\n    const elementType = element.type;\n\n    if (elementType === REACT_FRAGMENT_TYPE) {\n      return updateFragment(returnFiber, current, element.props.children, lanes, element.key);\n    }\n\n    if (current !== null) {\n      if (current.elementType === elementType || (__DEV__ ? isCompatibleFamilyForHotReloading(current, element) : false) || typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n        // Move based on index\n        const existing = useFiber(current, element.props);\n        existing.ref = coerceRef(returnFiber, current, element);\n        existing.return = returnFiber;\n\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n\n        return existing;\n      }\n    } // Insert\n\n\n    const created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, current, element);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function updatePortal(returnFiber, current, portal, lanes) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, portal.children || []);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, fragment);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, lanes) {\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            const created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n            created.ref = coerceRef(returnFiber, null, newChild);\n            created.return = returnFiber;\n            return created;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            const created = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n            created.return = returnFiber;\n            return created;\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            const payload = newChild._payload;\n            const init = newChild._init;\n            return createChild(returnFiber, init(payload), lanes);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n    // Update the fiber if the keys match, otherwise return null.\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateElement(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            const payload = newChild._payload;\n            const init = newChild._init;\n            return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updateElement(returnFiber, matchedFiber, newChild, lanes);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            const matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, matchedFiber, newChild, lanes);\n          }\n\n        case REACT_LAZY_TYPE:\n          const payload = newChild._payload;\n          const init = newChild._init;\n          return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, matchedFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n\n\n  function warnOnInvalidKey(child, knownKeys, returnFiber) {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child, returnFiber);\n          const key = child.key;\n\n          if (typeof key !== 'string') {\n            break;\n          }\n\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n\n          console.error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);\n          break;\n\n        case REACT_LAZY_TYPE:\n          const payload = child._payload;\n          const init = child._init;\n          warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n      }\n    }\n\n    let resultingFirstChild = null;\n    let previousNewFiber = null;\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n\n        if (newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    if (getIsHydrating()) {\n      const numberOfForks = newIdx;\n      pushTreeFork(returnFiber, numberOfForks);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n\n    if (typeof iteratorFn !== 'function') {\n      throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n    }\n\n    if (__DEV__) {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag\n      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n        if (!didWarnAboutGenerators) {\n          console.error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');\n        }\n\n        didWarnAboutGenerators = true;\n      } // Warn about using Maps as children\n\n\n      if (newChildrenIterable.entries === iteratorFn) {\n        if (!didWarnAboutMaps) {\n          console.error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n        }\n\n        didWarnAboutMaps = true;\n      } // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n\n\n      const newChildren = iteratorFn.call(newChildrenIterable);\n\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n\n    if (newChildren == null) {\n      throw new Error('An iterable object provided no iterator.');\n    }\n\n    let resultingFirstChild = null;\n    let previousNewFiber = null;\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    let step = newChildren.next();\n\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      const newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        const newFiber = createChild(returnFiber, step.value, lanes);\n\n        if (newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      const newFiber = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(newFiber.key === null ? newIdx : newFiber.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    if (getIsHydrating()) {\n      const numberOfForks = newIdx;\n      pushTreeFork(returnFiber, numberOfForks);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, textContent);\n      existing.return = returnFiber;\n      return existing;\n    } // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n\n\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n    const key = element.key;\n    let child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        const elementType = element.type;\n\n        if (elementType === REACT_FRAGMENT_TYPE) {\n          if (child.tag === Fragment) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props.children);\n            existing.return = returnFiber;\n\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n\n            return existing;\n          }\n        } else {\n          if (child.elementType === elementType || (__DEV__ ? isCompatibleFamilyForHotReloading(child, element) : false) || typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props);\n            existing.ref = coerceRef(returnFiber, child, element);\n            existing.return = returnFiber;\n\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n\n            return existing;\n          }\n        } // Didn't match.\n\n\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      const created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      const created = createFiberFromElement(element, returnFiber.mode, lanes);\n      created.ref = coerceRef(returnFiber, currentFirstChild, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n    const key = portal.key;\n    let child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, portal.children || []);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  } // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n\n\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    const isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    } // Handle object types\n\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_LAZY_TYPE:\n          const payload = newChild._payload;\n          const init = newChild._init; // TODO: This function is supposed to be non-recursive.\n\n          return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n      }\n\n      if (isArray(newChild)) {\n        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      if (getIteratorFn(newChild)) {\n        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    } // Remaining cases are all treated as empty.\n\n\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nexport const reconcileChildFibers = createChildReconciler(true);\nexport const mountChildFibers = createChildReconciler(false);\nexport function cloneChildFibers(current, workInProgress) {\n  if (current !== null && workInProgress.child !== current.child) {\n    throw new Error('Resuming work not yet implemented.');\n  }\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n  newChild.return = workInProgress;\n\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n    newChild.return = workInProgress;\n  }\n\n  newChild.sibling = null;\n} // Reset a workInProgress child set to prepare it for a second pass.\n\nexport function resetChildFibers(workInProgress, lanes) {\n  let child = workInProgress.child;\n\n  while (child !== null) {\n    resetWorkInProgress(child, lanes);\n    child = child.sibling;\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactChildFiber.js"],"names":["getComponentNameFromFiber","Placement","ChildDeletion","Forked","PlacementDEV","getIteratorFn","REACT_ELEMENT_TYPE","REACT_FRAGMENT_TYPE","REACT_PORTAL_TYPE","REACT_LAZY_TYPE","ClassComponent","HostText","HostPortal","Fragment","isArray","warnAboutStringRefs","checkPropStringCoercion","createWorkInProgress","resetWorkInProgress","createFiberFromElement","createFiberFromFragment","createFiberFromText","createFiberFromPortal","isCompatibleFamilyForHotReloading","StrictLegacyMode","getIsHydrating","pushTreeFork","didWarnAboutMaps","didWarnAboutGenerators","didWarnAboutStringRefs","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","child","returnFiber","__DEV__","_store","validated","key","Error","componentName","console","error","isReactClass","type","prototype","isReactComponent","coerceRef","current","element","mixedRef","ref","mode","_owner","_self","stateNode","tag","owner","inst","ownerFiber","resolvedInst","stringRef","_stringRef","value","refs","throwOnInvalidObjectType","newChild","childString","Object","toString","call","keys","join","warnOnFunctionType","resolveLazy","lazyType","payload","_payload","init","_init","createChildReconciler","shouldTrackSideEffects","deleteChild","childToDelete","deletions","flags","push","deleteRemainingChildren","currentFirstChild","sibling","mapRemainingChildren","existingChildren","Map","existingChild","set","index","useFiber","fiber","pendingProps","clone","placeChild","newFiber","lastPlacedIndex","newIndex","alternate","oldIndex","placeSingleChild","updateTextNode","textContent","lanes","created","return","existing","updateElement","elementType","updateFragment","props","children","$$typeof","_debugSource","_source","_debugOwner","updatePortal","portal","containerInfo","implementation","fragment","createChild","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","get","warnOnInvalidKey","knownKeys","Set","add","has","reconcileChildrenArray","newChildren","i","length","resultingFirstChild","previousNewFiber","nextOldFiber","numberOfForks","delete","forEach","reconcileChildrenIterator","newChildrenIterable","iteratorFn","Symbol","toStringTag","entries","step","next","done","reconcileSingleTextNode","reconcileSingleElement","reconcileSinglePortal","reconcileChildFibers","isUnkeyedTopLevelFragment","mountChildFibers","cloneChildFibers","workInProgress","currentChild","resetChildFibers"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactElement} from 'shared/ReactElementType';\nimport type {ReactPortal} from 'shared/ReactTypes';\nimport type {Fiber} from './ReactInternalTypes';\nimport type {Lanes} from './ReactFiberLane';\n\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport {\n  Placement,\n  ChildDeletion,\n  Forked,\n  PlacementDEV,\n} from './ReactFiberFlags';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {ClassComponent, HostText, HostPortal, Fragment} from './ReactWorkTags';\nimport isArray from 'shared/isArray';\nimport {warnAboutStringRefs} from 'shared/ReactFeatureFlags';\nimport {checkPropStringCoercion} from 'shared/CheckStringCoercion';\n\nimport {\n  createWorkInProgress,\n  resetWorkInProgress,\n  createFiberFromElement,\n  createFiberFromFragment,\n  createFiberFromText,\n  createFiberFromPortal,\n} from './ReactFiber';\nimport {isCompatibleFamilyForHotReloading} from './ReactFiberHotReloading';\nimport {StrictLegacyMode} from './ReactTypeOfMode';\nimport {getIsHydrating} from './ReactFiberHydrationContext';\nimport {pushTreeFork} from './ReactFiberTreeContext';\n\nlet didWarnAboutMaps;\nlet didWarnAboutGenerators;\nlet didWarnAboutStringRefs;\nlet ownerHasKeyUseWarning;\nlet ownerHasFunctionTypeWarning;\nlet warnForMissingKey = (child: mixed, returnFiber: Fiber) => {};\n\nif (__DEV__) {\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = (child: mixed, returnFiber: Fiber) => {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n\n    if (typeof child._store !== 'object') {\n      throw new Error(\n        'React Component in warnForMissingKey should have a _store. ' +\n          'This error is likely caused by a bug in React. Please file an issue.',\n      );\n    }\n\n    // $FlowFixMe unable to narrow type from mixed to writable object\n    child._store.validated = true;\n\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasKeyUseWarning[componentName]) {\n      return;\n    }\n    ownerHasKeyUseWarning[componentName] = true;\n\n    console.error(\n      'Each child in a list should have a unique ' +\n        '\"key\" prop. See https://reactjs.org/link/warning-keys for ' +\n        'more information.',\n    );\n  };\n}\n\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\n\nfunction coerceRef(\n  returnFiber: Fiber,\n  current: Fiber | null,\n  element: ReactElement,\n) {\n  const mixedRef = element.ref;\n  if (\n    mixedRef !== null &&\n    typeof mixedRef !== 'function' &&\n    typeof mixedRef !== 'object'\n  ) {\n    if (__DEV__) {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if (\n        (returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) &&\n        // We warn in ReactElement.js if owner and self are equal for string refs\n        // because these cannot be automatically converted to an arrow function\n        // using a codemod. Therefore, we don't have to warn about string refs again.\n        !(\n          element._owner &&\n          element._self &&\n          element._owner.stateNode !== element._self\n        ) &&\n        // Will already throw with \"Function components cannot have string refs\"\n        !(\n          element._owner &&\n          ((element._owner: any): Fiber).tag !== ClassComponent\n        ) &&\n        // Will already warn with \"Function components cannot be given refs\"\n        !(typeof element.type === 'function' && !isReactClass(element.type)) &&\n        // Will already throw with \"Element ref was specified as a string (someStringRef) but no owner was set\"\n        element._owner\n      ) {\n        const componentName =\n          getComponentNameFromFiber(returnFiber) || 'Component';\n        if (!didWarnAboutStringRefs[componentName]) {\n          if (warnAboutStringRefs) {\n            console.error(\n              'Component \"%s\" contains the string ref \"%s\". Support for string refs ' +\n                'will be removed in a future major release. We recommend using ' +\n                'useRef() or createRef() instead. ' +\n                'Learn more about using refs safely here: ' +\n                'https://reactjs.org/link/strict-mode-string-ref',\n              componentName,\n              mixedRef,\n            );\n          } else {\n            console.error(\n              'A string ref, \"%s\", has been found within a strict mode tree. ' +\n                'String refs are a source of potential bugs and should be avoided. ' +\n                'We recommend using useRef() or createRef() instead. ' +\n                'Learn more about using refs safely here: ' +\n                'https://reactjs.org/link/strict-mode-string-ref',\n              mixedRef,\n            );\n          }\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      const owner: ?Fiber = (element._owner: any);\n      let inst;\n      if (owner) {\n        const ownerFiber = ((owner: any): Fiber);\n\n        if (ownerFiber.tag !== ClassComponent) {\n          throw new Error(\n            'Function components cannot have string refs. ' +\n              'We recommend using useRef() instead. ' +\n              'Learn more about using refs safely here: ' +\n              'https://reactjs.org/link/strict-mode-string-ref',\n          );\n        }\n\n        inst = ownerFiber.stateNode;\n      }\n\n      if (!inst) {\n        throw new Error(\n          `Missing owner for string ref ${mixedRef}. This error is likely caused by a ` +\n            'bug in React. Please file an issue.',\n        );\n      }\n      // Assigning this to a const so Flow knows it won't change in the closure\n      const resolvedInst = inst;\n\n      if (__DEV__) {\n        checkPropStringCoercion(mixedRef, 'ref');\n      }\n      const stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (\n        current !== null &&\n        current.ref !== null &&\n        typeof current.ref === 'function' &&\n        current.ref._stringRef === stringRef\n      ) {\n        return current.ref;\n      }\n      const ref = function(value) {\n        const refs = resolvedInst.refs;\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      if (typeof mixedRef !== 'string') {\n        throw new Error(\n          'Expected ref to be a function, a string, an object returned by React.createRef(), or null.',\n        );\n      }\n\n      if (!element._owner) {\n        throw new Error(\n          `Element ref was specified as a string (${mixedRef}) but no owner was set. This could happen for one of` +\n            ' the following reasons:\\n' +\n            '1. You may be adding a ref to a function component\\n' +\n            \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" +\n            '3. You have multiple copies of React loaded\\n' +\n            'See https://reactjs.org/link/refs-must-have-owner for more information.',\n        );\n      }\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber: Fiber, newChild: Object) {\n  // $FlowFixMe[method-unbinding]\n  const childString = Object.prototype.toString.call(newChild);\n\n  throw new Error(\n    `Objects are not valid as a React child (found: ${\n      childString === '[object Object]'\n        ? 'object with keys {' + Object.keys(newChild).join(', ') + '}'\n        : childString\n    }). ` +\n      'If you meant to render a collection of children, use an array ' +\n      'instead.',\n  );\n}\n\nfunction warnOnFunctionType(returnFiber: Fiber) {\n  if (__DEV__) {\n    const componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasFunctionTypeWarning[componentName]) {\n      return;\n    }\n    ownerHasFunctionTypeWarning[componentName] = true;\n\n    console.error(\n      'Functions are not valid as a React child. This may happen if ' +\n        'you return a Component instead of <Component /> from render. ' +\n        'Or maybe you meant to call this function rather than return it.',\n    );\n  }\n}\n\nfunction resolveLazy(lazyType) {\n  const payload = lazyType._payload;\n  const init = lazyType._init;\n  return init(payload);\n}\n\ntype ChildReconciler = (\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChild: any,\n  lanes: Lanes,\n) => Fiber | null;\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction createChildReconciler(shouldTrackSideEffects): ChildReconciler {\n  function deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    const deletions = returnFiber.deletions;\n    if (deletions === null) {\n      returnFiber.deletions = [childToDelete];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(childToDelete);\n    }\n  }\n\n  function deleteRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n  ): null {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    let childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber,\n  ): Map<string | number, Fiber> {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    const existingChildren: Map<string | number, Fiber> = new Map();\n\n    let existingChild: null | Fiber = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber: Fiber, pendingProps: mixed): Fiber {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    const clone = createWorkInProgress(fiber, pendingProps);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(\n    newFiber: Fiber,\n    lastPlacedIndex: number,\n    newIndex: number,\n  ): number {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // During hydration, the useId algorithm needs to know which fibers are\n      // part of a list of children (arrays, iterators).\n      newFiber.flags |= Forked;\n      return lastPlacedIndex;\n    }\n    const current = newFiber.alternate;\n    if (current !== null) {\n      const oldIndex = current.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.flags |= Placement | PlacementDEV;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.flags |= Placement | PlacementDEV;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber: Fiber): Fiber {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.flags |= Placement | PlacementDEV;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    textContent: string,\n    lanes: Lanes,\n  ) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    element: ReactElement,\n    lanes: Lanes,\n  ): Fiber {\n    const elementType = element.type;\n    if (elementType === REACT_FRAGMENT_TYPE) {\n      return updateFragment(\n        returnFiber,\n        current,\n        element.props.children,\n        lanes,\n        element.key,\n      );\n    }\n    if (current !== null) {\n      if (\n        current.elementType === elementType ||\n        // Keep this check inline so it only runs on the false path:\n        (__DEV__\n          ? isCompatibleFamilyForHotReloading(current, element)\n          : false) ||\n        // Lazy types should reconcile their resolved type.\n        // We need to do this after the Hot Reloading check above,\n        // because hot reloading has different semantics than prod because\n        // it doesn't resuspend. So we can't let the call below suspend.\n        (typeof elementType === 'object' &&\n          elementType !== null &&\n          elementType.$$typeof === REACT_LAZY_TYPE &&\n          resolveLazy(elementType) === current.type)\n      ) {\n        // Move based on index\n        const existing = useFiber(current, element.props);\n        existing.ref = coerceRef(returnFiber, current, element);\n        existing.return = returnFiber;\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n        return existing;\n      }\n    }\n    // Insert\n    const created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, current, element);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function updatePortal(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    portal: ReactPortal,\n    lanes: Lanes,\n  ): Fiber {\n    if (\n      current === null ||\n      current.tag !== HostPortal ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    ) {\n      // Insert\n      const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, portal.children || []);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(\n    returnFiber: Fiber,\n    current: Fiber | null,\n    fragment: Iterable<React$Node>,\n    lanes: Lanes,\n    key: null | string,\n  ): Fiber {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      const created = createFiberFromFragment(\n        fragment,\n        returnFiber.mode,\n        lanes,\n        key,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      const existing = useFiber(current, fragment);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(\n    returnFiber: Fiber,\n    newChild: any,\n    lanes: Lanes,\n  ): Fiber | null {\n    if (\n      (typeof newChild === 'string' && newChild !== '') ||\n      typeof newChild === 'number'\n    ) {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      const created = createFiberFromText(\n        '' + newChild,\n        returnFiber.mode,\n        lanes,\n      );\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const created = createFiberFromElement(\n            newChild,\n            returnFiber.mode,\n            lanes,\n          );\n          created.ref = coerceRef(returnFiber, null, newChild);\n          created.return = returnFiber;\n          return created;\n        }\n        case REACT_PORTAL_TYPE: {\n          const created = createFiberFromPortal(\n            newChild,\n            returnFiber.mode,\n            lanes,\n          );\n          created.return = returnFiber;\n          return created;\n        }\n        case REACT_LAZY_TYPE: {\n          const payload = newChild._payload;\n          const init = newChild._init;\n          return createChild(returnFiber, init(payload), lanes);\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const created = createFiberFromFragment(\n          newChild,\n          returnFiber.mode,\n          lanes,\n          null,\n        );\n        created.return = returnFiber;\n        return created;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(\n    returnFiber: Fiber,\n    oldFiber: Fiber | null,\n    newChild: any,\n    lanes: Lanes,\n  ): Fiber | null {\n    // Update the fiber if the keys match, otherwise return null.\n\n    const key = oldFiber !== null ? oldFiber.key : null;\n\n    if (\n      (typeof newChild === 'string' && newChild !== '') ||\n      typeof newChild === 'number'\n    ) {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          if (newChild.key === key) {\n            return updateElement(returnFiber, oldFiber, newChild, lanes);\n          } else {\n            return null;\n          }\n        }\n        case REACT_PORTAL_TYPE: {\n          if (newChild.key === key) {\n            return updatePortal(returnFiber, oldFiber, newChild, lanes);\n          } else {\n            return null;\n          }\n        }\n        case REACT_LAZY_TYPE: {\n          const payload = newChild._payload;\n          const init = newChild._init;\n          return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n        }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(\n    existingChildren: Map<string | number, Fiber>,\n    returnFiber: Fiber,\n    newIdx: number,\n    newChild: any,\n    lanes: Lanes,\n  ): Fiber | null {\n    if (\n      (typeof newChild === 'string' && newChild !== '') ||\n      typeof newChild === 'number'\n    ) {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE: {\n          const matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key,\n            ) || null;\n          return updateElement(returnFiber, matchedFiber, newChild, lanes);\n        }\n        case REACT_PORTAL_TYPE: {\n          const matchedFiber =\n            existingChildren.get(\n              newChild.key === null ? newIdx : newChild.key,\n            ) || null;\n          return updatePortal(returnFiber, matchedFiber, newChild, lanes);\n        }\n        case REACT_LAZY_TYPE:\n          const payload = newChild._payload;\n          const init = newChild._init;\n          return updateFromMap(\n            existingChildren,\n            returnFiber,\n            newIdx,\n            init(payload),\n            lanes,\n          );\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        const matchedFiber = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, matchedFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(\n    child: mixed,\n    knownKeys: Set<string> | null,\n    returnFiber: Fiber,\n  ): Set<string> | null {\n    if (__DEV__) {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child, returnFiber);\n          const key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          console.error(\n            'Encountered two children with the same key, `%s`. ' +\n              'Keys should be unique so that components maintain their identity ' +\n              'across updates. Non-unique keys may cause children to be ' +\n              'duplicated and/or omitted — the behavior is unsupported and ' +\n              'could change in a future version.',\n            key,\n          );\n          break;\n        case REACT_LAZY_TYPE:\n          const payload = child._payload;\n          const init = (child._init: any);\n          warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildren: Array<any>,\n    lanes: Lanes,\n  ): Fiber | null {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    if (__DEV__) {\n      // First, validate keys.\n      let knownKeys = null;\n      for (let i = 0; i < newChildren.length; i++) {\n        const child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n      }\n    }\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        lanes,\n      );\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n        if (newFiber === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        lanes,\n      );\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    if (getIsHydrating()) {\n      const numberOfForks = newIdx;\n      pushTreeFork(returnFiber, numberOfForks);\n    }\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChildrenIterable: Iterable<mixed>,\n    lanes: Lanes,\n  ): Fiber | null {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    const iteratorFn = getIteratorFn(newChildrenIterable);\n\n    if (typeof iteratorFn !== 'function') {\n      throw new Error(\n        'An object is not an iterable. This error is likely caused by a bug in ' +\n          'React. Please file an issue.',\n      );\n    }\n\n    if (__DEV__) {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (\n        typeof Symbol === 'function' &&\n        // $FlowFixMe Flow doesn't know about toStringTag\n        newChildrenIterable[Symbol.toStringTag] === 'Generator'\n      ) {\n        if (!didWarnAboutGenerators) {\n          console.error(\n            'Using Generators as children is unsupported and will likely yield ' +\n              'unexpected results because enumerating a generator mutates it. ' +\n              'You may convert it to an array with `Array.from()` or the ' +\n              '`[...spread]` operator before rendering. Keep in mind ' +\n              'you might need to polyfill these features for older browsers.',\n          );\n        }\n        didWarnAboutGenerators = true;\n      }\n\n      // Warn about using Maps as children\n      if ((newChildrenIterable: any).entries === iteratorFn) {\n        if (!didWarnAboutMaps) {\n          console.error(\n            'Using Maps as children is not supported. ' +\n              'Use an array of keyed ReactElements instead.',\n          );\n        }\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      const newChildren = iteratorFn.call(newChildrenIterable);\n      if (newChildren) {\n        let knownKeys = null;\n        let step = newChildren.next();\n        for (; !step.done; step = newChildren.next()) {\n          const child = step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n        }\n      }\n    }\n\n    const newChildren = iteratorFn.call(newChildrenIterable);\n\n    if (newChildren == null) {\n      throw new Error('An iterable object provided no iterator.');\n    }\n\n    let resultingFirstChild: Fiber | null = null;\n    let previousNewFiber: Fiber | null = null;\n\n    let oldFiber = currentFirstChild;\n    let lastPlacedIndex = 0;\n    let newIdx = 0;\n    let nextOldFiber = null;\n\n    let step = newChildren.next();\n    for (\n      ;\n      oldFiber !== null && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      const newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        const newFiber = createChild(returnFiber, step.value, lanes);\n        if (newFiber === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n      if (getIsHydrating()) {\n        const numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      const newFiber = updateFromMap(\n        existingChildren,\n        returnFiber,\n        newIdx,\n        step.value,\n        lanes,\n      );\n      if (newFiber !== null) {\n        if (shouldTrackSideEffects) {\n          if (newFiber.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(\n              newFiber.key === null ? newIdx : newFiber.key,\n            );\n          }\n        }\n        lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = newFiber;\n        } else {\n          previousNewFiber.sibling = newFiber;\n        }\n        previousNewFiber = newFiber;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(child => deleteChild(returnFiber, child));\n    }\n\n    if (getIsHydrating()) {\n      const numberOfForks = newIdx;\n      pushTreeFork(returnFiber, numberOfForks);\n    }\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    textContent: string,\n    lanes: Lanes,\n  ): Fiber {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      const existing = useFiber(currentFirstChild, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    element: ReactElement,\n    lanes: Lanes,\n  ): Fiber {\n    const key = element.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        const elementType = element.type;\n        if (elementType === REACT_FRAGMENT_TYPE) {\n          if (child.tag === Fragment) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props.children);\n            existing.return = returnFiber;\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n            return existing;\n          }\n        } else {\n          if (\n            child.elementType === elementType ||\n            // Keep this check inline so it only runs on the false path:\n            (__DEV__\n              ? isCompatibleFamilyForHotReloading(child, element)\n              : false) ||\n            // Lazy types should reconcile their resolved type.\n            // We need to do this after the Hot Reloading check above,\n            // because hot reloading has different semantics than prod because\n            // it doesn't resuspend. So we can't let the call below suspend.\n            (typeof elementType === 'object' &&\n              elementType !== null &&\n              elementType.$$typeof === REACT_LAZY_TYPE &&\n              resolveLazy(elementType) === child.type)\n          ) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props);\n            existing.ref = coerceRef(returnFiber, child, element);\n            existing.return = returnFiber;\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n            return existing;\n          }\n        }\n        // Didn't match.\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      const created = createFiberFromFragment(\n        element.props.children,\n        returnFiber.mode,\n        lanes,\n        element.key,\n      );\n      created.return = returnFiber;\n      return created;\n    } else {\n      const created = createFiberFromElement(element, returnFiber.mode, lanes);\n      created.ref = coerceRef(returnFiber, currentFirstChild, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function reconcileSinglePortal(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    portal: ReactPortal,\n    lanes: Lanes,\n  ): Fiber {\n    const key = portal.key;\n    let child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (\n          child.tag === HostPortal &&\n          child.stateNode.containerInfo === portal.containerInfo &&\n          child.stateNode.implementation === portal.implementation\n        ) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          const existing = useFiber(child, portal.children || []);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    const created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    newChild: any,\n    lanes: Lanes,\n  ): Fiber | null {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    const isUnkeyedTopLevelFragment =\n      typeof newChild === 'object' &&\n      newChild !== null &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      newChild.key === null;\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(\n            reconcileSingleElement(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              lanes,\n            ),\n          );\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(\n            reconcileSinglePortal(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              lanes,\n            ),\n          );\n        case REACT_LAZY_TYPE:\n          const payload = newChild._payload;\n          const init = newChild._init;\n          // TODO: This function is supposed to be non-recursive.\n          return reconcileChildFibers(\n            returnFiber,\n            currentFirstChild,\n            init(payload),\n            lanes,\n          );\n      }\n\n      if (isArray(newChild)) {\n        return reconcileChildrenArray(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes,\n        );\n      }\n\n      if (getIteratorFn(newChild)) {\n        return reconcileChildrenIterator(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes,\n        );\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (\n      (typeof newChild === 'string' && newChild !== '') ||\n      typeof newChild === 'number'\n    ) {\n      return placeSingleChild(\n        reconcileSingleTextNode(\n          returnFiber,\n          currentFirstChild,\n          '' + newChild,\n          lanes,\n        ),\n      );\n    }\n\n    if (__DEV__) {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nexport const reconcileChildFibers: ChildReconciler = createChildReconciler(\n  true,\n);\nexport const mountChildFibers: ChildReconciler = createChildReconciler(false);\n\nexport function cloneChildFibers(\n  current: Fiber | null,\n  workInProgress: Fiber,\n): void {\n  if (current !== null && workInProgress.child !== current.child) {\n    throw new Error('Resuming work not yet implemented.');\n  }\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n    );\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n// Reset a workInProgress child set to prepare it for a second pass.\nexport function resetChildFibers(workInProgress: Fiber, lanes: Lanes): void {\n  let child = workInProgress.child;\n  while (child !== null) {\n    resetWorkInProgress(child, lanes);\n    child = child.sibling;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}