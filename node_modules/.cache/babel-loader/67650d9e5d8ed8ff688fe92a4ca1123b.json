{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactCurrentActQueue from './ReactCurrentActQueue';\nimport queueMacrotask from 'shared/enqueueTask'; // `act` calls can be nested, so we track the depth. This represents the\n// number of `act` scopes on the stack.\n\nlet actScopeDepth = 0; // We only warn the first time you neglect to await an async `act` scope.\n\nlet didWarnNoAwaitAct = false;\nexport function act(callback) {\n  if (__DEV__) {\n    // When ReactCurrentActQueue.current is not null, it signals to React that\n    // we're currently inside an `act` scope. React will push all its tasks to\n    // this queue instead of scheduling them with platform APIs.\n    //\n    // We set this to an empty array when we first enter an `act` scope, and\n    // only unset it once we've left the outermost `act` scope — remember that\n    // `act` calls can be nested.\n    //\n    // If we're already inside an `act` scope, reuse the existing queue.\n    const prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n    const prevActQueue = ReactCurrentActQueue.current;\n    const prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n    const queue = ReactCurrentActQueue.current = prevActQueue !== null ? prevActQueue : []; // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n    // set to `true` while the given callback is executed, not for updates\n    // triggered during an async event, because this is how the legacy\n    // implementation of `act` behaved.\n\n    ReactCurrentActQueue.isBatchingLegacy = true;\n    let result; // This tracks whether the `act` call is awaited. In certain cases, not\n    // awaiting it is a mistake, so we will detect that and warn.\n\n    let didAwaitActCall = false;\n\n    try {\n      // Reset this to `false` right before entering the React work loop. The\n      // only place we ever read this fields is just below, right after running\n      // the callback. So we don't need to reset after the callback runs.\n      ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n      result = callback();\n      const didScheduleLegacyUpdate = ReactCurrentActQueue.didScheduleLegacyUpdate; // Replicate behavior of original `act` implementation in legacy mode,\n      // which flushed updates immediately after the scope function exits, even\n      // if it's an async function.\n\n      if (!prevIsBatchingLegacy && didScheduleLegacyUpdate) {\n        flushActQueue(queue);\n      } // `isBatchingLegacy` gets reset using the regular stack, not the async\n      // one used to track `act` scopes. Why, you may be wondering? Because\n      // that's how it worked before version 18. Yes, it's confusing! We should\n      // delete legacy mode!!\n\n\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n    } catch (error) {\n      // `isBatchingLegacy` gets reset using the regular stack, not the async\n      // one used to track `act` scopes. Why, you may be wondering? Because\n      // that's how it worked before version 18. Yes, it's confusing! We should\n      // delete legacy mode!!\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n      popActScope(prevActQueue, prevActScopeDepth);\n      throw error;\n    }\n\n    if (result !== null && typeof result === 'object' && // $FlowFixMe[method-unbinding]\n    typeof result.then === 'function') {\n      // A promise/thenable was returned from the callback. Wait for it to\n      // resolve before flushing the queue.\n      //\n      // If `act` were implemented as an async function, this whole block could\n      // be a single `await` call. That's really the only difference between\n      // this branch and the next one.\n      const thenable = result; // Warn if the an `act` call with an async scope is not awaited. In a\n      // future release, consider making this an error.\n\n      queueSeveralMicrotasks(() => {\n        if (!didAwaitActCall && !didWarnNoAwaitAct) {\n          didWarnNoAwaitAct = true;\n          console.error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n        }\n      });\n      return {\n        then(resolve, reject) {\n          didAwaitActCall = true;\n          thenable.then(returnValue => {\n            popActScope(prevActQueue, prevActScopeDepth);\n\n            if (prevActScopeDepth === 0) {\n              // We're exiting the outermost `act` scope. Flush the queue.\n              try {\n                flushActQueue(queue);\n                queueMacrotask(() => // Recursively flush tasks scheduled by a microtask.\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject));\n              } catch (error) {\n                // `thenable` might not be a real promise, and `flushActQueue`\n                // might throw, so we need to wrap `flushActQueue` in a\n                // try/catch.\n                reject(error);\n              }\n            } else {\n              resolve(returnValue);\n            }\n          }, error => {\n            popActScope(prevActQueue, prevActScopeDepth);\n            reject(error);\n          });\n        }\n\n      };\n    } else {\n      const returnValue = result; // The callback is not an async function. Exit the current\n      // scope immediately.\n\n      popActScope(prevActQueue, prevActScopeDepth);\n\n      if (prevActScopeDepth === 0) {\n        // We're exiting the outermost `act` scope. Flush the queue.\n        flushActQueue(queue); // If the queue is not empty, it implies that we intentionally yielded\n        // to the main thread, because something suspended. We will continue\n        // in an asynchronous task.\n        //\n        // Warn if something suspends but the `act` call is not awaited.\n        // In a future release, consider making this an error.\n\n        if (queue.length !== 0) {\n          queueSeveralMicrotasks(() => {\n            if (!didAwaitActCall && !didWarnNoAwaitAct) {\n              didWarnNoAwaitAct = true;\n              console.error('A component suspended inside an `act` scope, but the ' + '`act` call was not awaited. When testing React ' + 'components that depend on asynchronous data, you must ' + 'await the result:\\n\\n' + 'await act(() => ...)');\n            }\n          });\n        } // Like many things in this module, this is next part is confusing.\n        //\n        // We do not currently require every `act` call that is passed a\n        // callback to be awaited, through arguably we should. Since this\n        // callback was synchronous, we need to exit the current scope before\n        // returning.\n        //\n        // However, if thenable we're about to return *is* awaited, we'll\n        // immediately restore the current scope. So it shouldn't observable.\n        //\n        // This doesn't affect the case where the scope callback is async,\n        // because we always require those calls to be awaited.\n        //\n        // TODO: In a future version, consider always requiring all `act` calls\n        // to be awaited, regardless of whether the callback is sync or async.\n\n\n        ReactCurrentActQueue.current = null;\n      }\n\n      return {\n        then(resolve, reject) {\n          didAwaitActCall = true;\n\n          if (prevActScopeDepth === 0) {\n            // If the `act` call is awaited, restore the queue we were\n            // using before (see long comment above) so we can flush it.\n            ReactCurrentActQueue.current = queue;\n            queueMacrotask(() => // Recursively flush tasks scheduled by a microtask.\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject));\n          } else {\n            resolve(returnValue);\n          }\n        }\n\n      };\n    }\n  } else {\n    throw new Error('act(...) is not supported in production builds of React.');\n  }\n}\n\nfunction popActScope(prevActQueue, prevActScopeDepth) {\n  if (__DEV__) {\n    if (prevActScopeDepth !== actScopeDepth - 1) {\n      console.error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n    }\n\n    actScopeDepth = prevActScopeDepth;\n  }\n}\n\nfunction recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n  if (__DEV__) {\n    // Check if any tasks were scheduled asynchronously.\n    const queue = ReactCurrentActQueue.current;\n\n    if (queue !== null) {\n      if (queue.length !== 0) {\n        // Async tasks were scheduled, mostly likely in a microtask.\n        // Keep flushing until there are no more.\n        try {\n          flushActQueue(queue); // The work we just performed may have schedule additional async\n          // tasks. Wait a macrotask and check again.\n\n          queueMacrotask(() => recursivelyFlushAsyncActWork(returnValue, resolve, reject));\n        } catch (error) {\n          // Leave remaining tasks on the queue if something throws.\n          reject(error);\n        }\n      } else {\n        // The queue is empty. We can finish.\n        ReactCurrentActQueue.current = null;\n        resolve(returnValue);\n      }\n    } else {\n      resolve(returnValue);\n    }\n  }\n}\n\nlet isFlushing = false;\n\nfunction flushActQueue(queue) {\n  if (__DEV__) {\n    if (!isFlushing) {\n      // Prevent re-entrance.\n      isFlushing = true;\n      let i = 0;\n\n      try {\n        for (; i < queue.length; i++) {\n          let callback = queue[i];\n\n          do {\n            ReactCurrentActQueue.didUsePromise = false;\n            const continuation = callback(false);\n\n            if (continuation !== null) {\n              if (ReactCurrentActQueue.didUsePromise) {\n                // The component just suspended. Yield to the main thread in\n                // case the promise is already resolved. If so, it will ping in\n                // a microtask and we can resume without unwinding the stack.\n                queue[i] = callback;\n                queue.splice(0, i);\n                return;\n              }\n\n              callback = continuation;\n            } else {\n              break;\n            }\n          } while (true);\n        } // We flushed the entire queue.\n\n\n        queue.length = 0;\n      } catch (error) {\n        // If something throws, leave the remaining callbacks on the queue.\n        queue.splice(0, i + 1);\n        throw error;\n      } finally {\n        isFlushing = false;\n      }\n    }\n  }\n} // Some of our warnings attempt to detect if the `act` call is awaited by\n// checking in an asynchronous task. Wait a few microtasks before checking. The\n// only reason one isn't sufficient is we want to accommodate the case where an\n// `act` call is returned from an async function without first being awaited,\n// since that's a somewhat common pattern. If you do this too many times in a\n// nested sequence, you might get a warning, but you can always fix by awaiting\n// the call.\n//\n// A macrotask would also work (and is the fallback) but depending on the test\n// environment it may cause the warning to fire too late.\n\n\nconst queueSeveralMicrotasks = typeof queueMicrotask === 'function' ? callback => {\n  queueMicrotask(() => queueMicrotask(callback));\n} : queueMacrotask;","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react/src/ReactAct.js"],"names":["ReactCurrentActQueue","queueMacrotask","actScopeDepth","didWarnNoAwaitAct","act","callback","__DEV__","prevIsBatchingLegacy","isBatchingLegacy","prevActQueue","current","prevActScopeDepth","queue","result","didAwaitActCall","didScheduleLegacyUpdate","flushActQueue","error","popActScope","then","thenable","queueSeveralMicrotasks","console","resolve","reject","returnValue","recursivelyFlushAsyncActWork","length","Error","isFlushing","i","didUsePromise","continuation","splice","queueMicrotask"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Thenable} from 'shared/ReactTypes';\nimport type {RendererTask} from './ReactCurrentActQueue';\nimport ReactCurrentActQueue from './ReactCurrentActQueue';\nimport queueMacrotask from 'shared/enqueueTask';\n\n// `act` calls can be nested, so we track the depth. This represents the\n// number of `act` scopes on the stack.\nlet actScopeDepth = 0;\n\n// We only warn the first time you neglect to await an async `act` scope.\nlet didWarnNoAwaitAct = false;\n\nexport function act<T>(callback: () => T | Thenable<T>): Thenable<T> {\n  if (__DEV__) {\n    // When ReactCurrentActQueue.current is not null, it signals to React that\n    // we're currently inside an `act` scope. React will push all its tasks to\n    // this queue instead of scheduling them with platform APIs.\n    //\n    // We set this to an empty array when we first enter an `act` scope, and\n    // only unset it once we've left the outermost `act` scope — remember that\n    // `act` calls can be nested.\n    //\n    // If we're already inside an `act` scope, reuse the existing queue.\n    const prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n    const prevActQueue = ReactCurrentActQueue.current;\n    const prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n    const queue = (ReactCurrentActQueue.current =\n      prevActQueue !== null ? prevActQueue : []);\n    // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n    // set to `true` while the given callback is executed, not for updates\n    // triggered during an async event, because this is how the legacy\n    // implementation of `act` behaved.\n    ReactCurrentActQueue.isBatchingLegacy = true;\n\n    let result;\n    // This tracks whether the `act` call is awaited. In certain cases, not\n    // awaiting it is a mistake, so we will detect that and warn.\n    let didAwaitActCall = false;\n    try {\n      // Reset this to `false` right before entering the React work loop. The\n      // only place we ever read this fields is just below, right after running\n      // the callback. So we don't need to reset after the callback runs.\n      ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n      result = callback();\n      const didScheduleLegacyUpdate =\n        ReactCurrentActQueue.didScheduleLegacyUpdate;\n\n      // Replicate behavior of original `act` implementation in legacy mode,\n      // which flushed updates immediately after the scope function exits, even\n      // if it's an async function.\n      if (!prevIsBatchingLegacy && didScheduleLegacyUpdate) {\n        flushActQueue(queue);\n      }\n      // `isBatchingLegacy` gets reset using the regular stack, not the async\n      // one used to track `act` scopes. Why, you may be wondering? Because\n      // that's how it worked before version 18. Yes, it's confusing! We should\n      // delete legacy mode!!\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n    } catch (error) {\n      // `isBatchingLegacy` gets reset using the regular stack, not the async\n      // one used to track `act` scopes. Why, you may be wondering? Because\n      // that's how it worked before version 18. Yes, it's confusing! We should\n      // delete legacy mode!!\n      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n      popActScope(prevActQueue, prevActScopeDepth);\n      throw error;\n    }\n\n    if (\n      result !== null &&\n      typeof result === 'object' &&\n      // $FlowFixMe[method-unbinding]\n      typeof result.then === 'function'\n    ) {\n      // A promise/thenable was returned from the callback. Wait for it to\n      // resolve before flushing the queue.\n      //\n      // If `act` were implemented as an async function, this whole block could\n      // be a single `await` call. That's really the only difference between\n      // this branch and the next one.\n      const thenable = ((result: any): Thenable<T>);\n\n      // Warn if the an `act` call with an async scope is not awaited. In a\n      // future release, consider making this an error.\n      queueSeveralMicrotasks(() => {\n        if (!didAwaitActCall && !didWarnNoAwaitAct) {\n          didWarnNoAwaitAct = true;\n          console.error(\n            'You called act(async () => ...) without await. ' +\n              'This could lead to unexpected testing behaviour, ' +\n              'interleaving multiple act calls and mixing their ' +\n              'scopes. ' +\n              'You should - await act(async () => ...);',\n          );\n        }\n      });\n\n      return {\n        then(resolve, reject) {\n          didAwaitActCall = true;\n          thenable.then(\n            returnValue => {\n              popActScope(prevActQueue, prevActScopeDepth);\n              if (prevActScopeDepth === 0) {\n                // We're exiting the outermost `act` scope. Flush the queue.\n                try {\n                  flushActQueue(queue);\n                  queueMacrotask(() =>\n                    // Recursively flush tasks scheduled by a microtask.\n                    recursivelyFlushAsyncActWork(returnValue, resolve, reject),\n                  );\n                } catch (error) {\n                  // `thenable` might not be a real promise, and `flushActQueue`\n                  // might throw, so we need to wrap `flushActQueue` in a\n                  // try/catch.\n                  reject(error);\n                }\n              } else {\n                resolve(returnValue);\n              }\n            },\n            error => {\n              popActScope(prevActQueue, prevActScopeDepth);\n              reject(error);\n            },\n          );\n        },\n      };\n    } else {\n      const returnValue: T = (result: any);\n      // The callback is not an async function. Exit the current\n      // scope immediately.\n      popActScope(prevActQueue, prevActScopeDepth);\n      if (prevActScopeDepth === 0) {\n        // We're exiting the outermost `act` scope. Flush the queue.\n        flushActQueue(queue);\n\n        // If the queue is not empty, it implies that we intentionally yielded\n        // to the main thread, because something suspended. We will continue\n        // in an asynchronous task.\n        //\n        // Warn if something suspends but the `act` call is not awaited.\n        // In a future release, consider making this an error.\n        if (queue.length !== 0) {\n          queueSeveralMicrotasks(() => {\n            if (!didAwaitActCall && !didWarnNoAwaitAct) {\n              didWarnNoAwaitAct = true;\n              console.error(\n                'A component suspended inside an `act` scope, but the ' +\n                  '`act` call was not awaited. When testing React ' +\n                  'components that depend on asynchronous data, you must ' +\n                  'await the result:\\n\\n' +\n                  'await act(() => ...)',\n              );\n            }\n          });\n        }\n\n        // Like many things in this module, this is next part is confusing.\n        //\n        // We do not currently require every `act` call that is passed a\n        // callback to be awaited, through arguably we should. Since this\n        // callback was synchronous, we need to exit the current scope before\n        // returning.\n        //\n        // However, if thenable we're about to return *is* awaited, we'll\n        // immediately restore the current scope. So it shouldn't observable.\n        //\n        // This doesn't affect the case where the scope callback is async,\n        // because we always require those calls to be awaited.\n        //\n        // TODO: In a future version, consider always requiring all `act` calls\n        // to be awaited, regardless of whether the callback is sync or async.\n        ReactCurrentActQueue.current = null;\n      }\n      return {\n        then(resolve, reject) {\n          didAwaitActCall = true;\n          if (prevActScopeDepth === 0) {\n            // If the `act` call is awaited, restore the queue we were\n            // using before (see long comment above) so we can flush it.\n            ReactCurrentActQueue.current = queue;\n            queueMacrotask(() =>\n              // Recursively flush tasks scheduled by a microtask.\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject),\n            );\n          } else {\n            resolve(returnValue);\n          }\n        },\n      };\n    }\n  } else {\n    throw new Error('act(...) is not supported in production builds of React.');\n  }\n}\n\nfunction popActScope(prevActQueue, prevActScopeDepth) {\n  if (__DEV__) {\n    if (prevActScopeDepth !== actScopeDepth - 1) {\n      console.error(\n        'You seem to have overlapping act() calls, this is not supported. ' +\n          'Be sure to await previous act() calls before making a new one. ',\n      );\n    }\n    actScopeDepth = prevActScopeDepth;\n  }\n}\n\nfunction recursivelyFlushAsyncActWork<T>(\n  returnValue: T,\n  resolve: T => mixed,\n  reject: mixed => mixed,\n) {\n  if (__DEV__) {\n    // Check if any tasks were scheduled asynchronously.\n    const queue = ReactCurrentActQueue.current;\n    if (queue !== null) {\n      if (queue.length !== 0) {\n        // Async tasks were scheduled, mostly likely in a microtask.\n        // Keep flushing until there are no more.\n        try {\n          flushActQueue(queue);\n          // The work we just performed may have schedule additional async\n          // tasks. Wait a macrotask and check again.\n          queueMacrotask(() =>\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject),\n          );\n        } catch (error) {\n          // Leave remaining tasks on the queue if something throws.\n          reject(error);\n        }\n      } else {\n        // The queue is empty. We can finish.\n        ReactCurrentActQueue.current = null;\n        resolve(returnValue);\n      }\n    } else {\n      resolve(returnValue);\n    }\n  }\n}\n\nlet isFlushing = false;\nfunction flushActQueue(queue) {\n  if (__DEV__) {\n    if (!isFlushing) {\n      // Prevent re-entrance.\n      isFlushing = true;\n      let i = 0;\n      try {\n        for (; i < queue.length; i++) {\n          let callback: RendererTask = queue[i];\n          do {\n            ReactCurrentActQueue.didUsePromise = false;\n            const continuation = callback(false);\n            if (continuation !== null) {\n              if (ReactCurrentActQueue.didUsePromise) {\n                // The component just suspended. Yield to the main thread in\n                // case the promise is already resolved. If so, it will ping in\n                // a microtask and we can resume without unwinding the stack.\n                queue[i] = callback;\n                queue.splice(0, i);\n                return;\n              }\n              callback = continuation;\n            } else {\n              break;\n            }\n          } while (true);\n        }\n        // We flushed the entire queue.\n        queue.length = 0;\n      } catch (error) {\n        // If something throws, leave the remaining callbacks on the queue.\n        queue.splice(0, i + 1);\n        throw error;\n      } finally {\n        isFlushing = false;\n      }\n    }\n  }\n}\n\n// Some of our warnings attempt to detect if the `act` call is awaited by\n// checking in an asynchronous task. Wait a few microtasks before checking. The\n// only reason one isn't sufficient is we want to accommodate the case where an\n// `act` call is returned from an async function without first being awaited,\n// since that's a somewhat common pattern. If you do this too many times in a\n// nested sequence, you might get a warning, but you can always fix by awaiting\n// the call.\n//\n// A macrotask would also work (and is the fallback) but depending on the test\n// environment it may cause the warning to fire too late.\nconst queueSeveralMicrotasks =\n  typeof queueMicrotask === 'function'\n    ? callback => {\n        queueMicrotask(() => queueMicrotask(callback));\n      }\n    : queueMacrotask;\n"]},"metadata":{},"sourceType":"module"}