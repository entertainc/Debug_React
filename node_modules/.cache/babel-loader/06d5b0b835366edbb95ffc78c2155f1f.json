{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { REACT_STRICT_MODE_TYPE } from 'shared/ReactSymbols';\nimport { warnAboutDeprecatedLifecycles, replayFailedUnitOfWorkWithInvokeGuardedCallback, enableCreateEventHandleAPI, enableProfilerTimer, enableProfilerCommitHooks, enableProfilerNestedUpdatePhase, enableProfilerNestedUpdateScheduledHook, deferRenderPhaseUpdateToNextBatch, enableDebugTracing, enableSchedulingProfiler, disableSchedulerTimeoutInWorkLoop, skipUnmountedBoundaries, enableUpdaterTracking, enableCache, enableTransitionTracing, useModernStrictMode } from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport is from 'shared/objectIs';\nimport { // Aliased because `act` will override and push to an internal queue\nscheduleCallback as Scheduler_scheduleCallback, cancelCallback as Scheduler_cancelCallback, shouldYield, requestPaint, now, ImmediatePriority as ImmediateSchedulerPriority, UserBlockingPriority as UserBlockingSchedulerPriority, NormalPriority as NormalSchedulerPriority, IdlePriority as IdleSchedulerPriority } from './Scheduler';\nimport { flushSyncCallbacks, flushSyncCallbacksOnlyInLegacyMode, scheduleSyncCallback, scheduleLegacySyncCallback } from './ReactFiberSyncTaskQueue';\nimport { logCommitStarted, logCommitStopped, logLayoutEffectsStarted, logLayoutEffectsStopped, logPassiveEffectsStarted, logPassiveEffectsStopped, logRenderStarted, logRenderStopped } from './DebugTracing';\nimport { resetAfterCommit, scheduleTimeout, cancelTimeout, noTimeout, afterActiveInstanceBlur, getCurrentEventPriority, supportsMicrotasks, errorHydratingContainer, scheduleMicrotask, prepareRendererToRender, resetRendererAfterRender } from './ReactFiberHostConfig';\nimport { createWorkInProgress, assignFiberPropertiesInDEV, resetWorkInProgress } from './ReactFiber';\nimport { isRootDehydrated } from './ReactFiberShellHydration';\nimport { didSuspendOrErrorWhileHydratingDEV } from './ReactFiberHydrationContext';\nimport { NoMode, ProfileMode, ConcurrentMode, StrictLegacyMode, StrictEffectsMode } from './ReactTypeOfMode';\nimport { HostRoot, IndeterminateComponent, ClassComponent, SuspenseComponent, SuspenseListComponent, OffscreenComponent, FunctionComponent, ForwardRef, MemoComponent, SimpleMemoComponent, Profiler } from './ReactWorkTags';\nimport { ConcurrentRoot, LegacyRoot } from './ReactRootTags';\nimport { NoFlags, Incomplete, StoreConsistency, HostEffectMask, ForceClientRender, BeforeMutationMask, MutationMask, LayoutMask, PassiveMask, PlacementDEV, Visibility, MountPassiveDev, MountLayoutDev } from './ReactFiberFlags';\nimport { NoLanes, NoLane, SyncLane, NoTimestamp, claimNextTransitionLane, claimNextRetryLane, includesSyncLane, isSubsetOfLanes, mergeLanes, removeLanes, pickArbitraryLane, includesNonIdleWork, includesOnlyRetries, includesOnlyTransitions, includesBlockingLane, includesExpiredLane, getNextLanes, markStarvedLanesAsExpired, getLanesToRetrySynchronouslyOnError, getMostRecentEventTime, markRootUpdated, markRootSuspended as markRootSuspended_dontCallThisOneDirectly, markRootPinged, markRootEntangled, markRootFinished, getHighestPriorityLane, addFiberToLanesMap, movePendingFibersToMemoized, addTransitionToLanesMap, getTransitionsForLanes } from './ReactFiberLane';\nimport { DiscreteEventPriority, ContinuousEventPriority, DefaultEventPriority, IdleEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority, lowerEventPriority, lanesToEventPriority } from './ReactEventPriorities';\nimport { requestCurrentTransition, NoTransition } from './ReactFiberTransition';\nimport { SelectiveHydrationException, beginWork as originalBeginWork, replayFunctionComponent } from './ReactFiberBeginWork';\nimport { completeWork } from './ReactFiberCompleteWork';\nimport { unwindWork, unwindInterruptedWork } from './ReactFiberUnwindWork';\nimport { throwException, createRootErrorUpdate, createClassErrorUpdate } from './ReactFiberThrow';\nimport { commitBeforeMutationEffects, commitLayoutEffects, commitMutationEffects, commitPassiveEffectDurations, commitPassiveMountEffects, commitPassiveUnmountEffects, disappearLayoutEffects, reconnectPassiveEffects, reappearLayoutEffects, disconnectPassiveEffect, reportUncaughtErrorInDEV, invokeLayoutEffectMountInDEV, invokePassiveEffectMountInDEV, invokeLayoutEffectUnmountInDEV, invokePassiveEffectUnmountInDEV } from './ReactFiberCommitWork';\nimport { enqueueUpdate } from './ReactFiberClassUpdateQueue';\nimport { resetContextDependencies } from './ReactFiberNewContext';\nimport { resetHooksAfterThrow, resetHooksOnUnwind, ContextOnlyDispatcher } from './ReactFiberHooks';\nimport { DefaultCacheDispatcher } from './ReactFiberCache';\nimport { createCapturedValueAtFiber } from './ReactCapturedValue';\nimport { enqueueConcurrentRenderForLane, finishQueueingConcurrentUpdates, getConcurrentlyUpdatedLanes } from './ReactFiberConcurrentUpdates';\nimport { markNestedUpdateScheduled, recordCommitTime, resetNestedUpdateFlag, startProfilerTimer, stopProfilerTimerIfRunningAndRecordDelta, syncNestedUpdateFlag } from './ReactProfilerTimer'; // DEV stuff\n\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport { isRendering as ReactCurrentDebugFiberIsRenderingInDEV, current as ReactCurrentFiberCurrent, resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV } from './ReactCurrentFiber';\nimport { invokeGuardedCallback, hasCaughtError, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { isDevToolsPresent, markCommitStarted, markCommitStopped, markComponentRenderStopped, markComponentSuspended, markComponentErrored, markLayoutEffectsStarted, markLayoutEffectsStopped, markPassiveEffectsStarted, markPassiveEffectsStopped, markRenderStarted, markRenderYielded, markRenderStopped, onCommitRoot as onCommitRootDevTools, onPostCommitRoot as onPostCommitRootDevTools } from './ReactFiberDevToolsHook';\nimport { onCommitRoot as onCommitRootTestSelector } from './ReactTestSelectors';\nimport { releaseCache } from './ReactFiberCacheComponent';\nimport { isLegacyActEnvironment, isConcurrentActEnvironment } from './ReactFiberAct';\nimport { processTransitionCallbacks } from './ReactFiberTracingMarkerComponent';\nimport { SuspenseException, getSuspendedThenable, isThenableResolved } from './ReactFiberThenable';\nimport { schedulePostPaintCallback } from './ReactPostPaintCallback';\nimport { getSuspenseHandler, isBadSuspenseFallback } from './ReactFiberSuspenseContext';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent';\nconst ceil = Math.ceil;\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentCache,\n  ReactCurrentOwner,\n  ReactCurrentBatchConfig,\n  ReactCurrentActQueue\n} = ReactSharedInternals;\nexport const NoContext =\n/*             */\n0b000;\nconst BatchedContext =\n/*               */\n0b001;\nexport const RenderContext =\n/*         */\n0b010;\nexport const CommitContext =\n/*         */\n0b100;\nconst RootInProgress = 0;\nconst RootFatalErrored = 1;\nconst RootErrored = 2;\nconst RootSuspended = 3;\nconst RootSuspendedWithDelay = 4;\nconst RootCompleted = 5;\nconst RootDidNotComplete = 6; // Describes where we are in the React execution stack\n\nlet executionContext = NoContext; // The root we're working on\n\nlet workInProgressRoot = null; // The fiber we're working on\n\nlet workInProgress = null; // The lanes we're rendering\n\nlet workInProgressRootRenderLanes = NoLanes;\nconst NotSuspended = 0;\nconst SuspendedOnError = 1;\nconst SuspendedOnData = 2;\nconst SuspendedOnImmediate = 3;\nconst SuspendedOnDeprecatedThrowPromise = 4;\nconst SuspendedAndReadyToUnwind = 5;\nconst SuspendedOnHydration = 6; // When this is true, the work-in-progress fiber just suspended (or errored) and\n// we've yet to unwind the stack. In some cases, we may yield to the main thread\n// after this happens. If the fiber is pinged before we resume, we can retry\n// immediately instead of unwinding the stack.\n\nlet workInProgressSuspendedReason = NotSuspended;\nlet workInProgressThrownValue = null; // Whether a ping listener was attached during this render. This is slightly\n// different that whether something suspended, because we don't add multiple\n// listeners to a promise we've already seen (per root and lane).\n\nlet workInProgressRootDidAttachPingListener = false; // A contextual version of workInProgressRootRenderLanes. It is a superset of\n// the lanes that we started working on at the root. When we enter a subtree\n// that is currently hidden, we add the lanes that would have committed if\n// the hidden tree hadn't been deferred. This is modified by the\n// HiddenContext module.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with renderLanes.\n\nexport let renderLanes = NoLanes; // Whether to root completed, errored, suspended, etc.\n\nlet workInProgressRootExitStatus = RootInProgress; // A fatal error, if one is thrown\n\nlet workInProgressRootFatalError = null; // The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\n\nlet workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n\nlet workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n\nlet workInProgressRootRenderPhaseUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.\n\nlet workInProgressRootPingedLanes = NoLanes; // Errors that are thrown during the render phase.\n\nlet workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\n\nlet workInProgressRootRecoverableErrors = null; // The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\n\nlet globalMostRecentFallbackTime = 0;\nconst FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\n\nlet workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\n\nconst RENDER_TIMEOUT_MS = 500;\nlet workInProgressTransitions = null;\nexport function getWorkInProgressTransitions() {\n  return workInProgressTransitions;\n}\nlet currentPendingTransitionCallbacks = null;\nlet currentEndTime = null;\nexport function addTransitionStartCallbackToPendingTransition(transition) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: [],\n        transitionProgress: null,\n        transitionComplete: null,\n        markerProgress: null,\n        markerIncomplete: null,\n        markerComplete: null\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.transitionStart === null) {\n      currentPendingTransitionCallbacks.transitionStart = [];\n    }\n\n    currentPendingTransitionCallbacks.transitionStart.push(transition);\n  }\n}\nexport function addMarkerProgressCallbackToPendingTransition(markerName, transitions, pendingBoundaries) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: null,\n        transitionProgress: null,\n        transitionComplete: null,\n        markerProgress: new Map(),\n        markerIncomplete: null,\n        markerComplete: null\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.markerProgress === null) {\n      currentPendingTransitionCallbacks.markerProgress = new Map();\n    }\n\n    currentPendingTransitionCallbacks.markerProgress.set(markerName, {\n      pendingBoundaries,\n      transitions\n    });\n  }\n}\nexport function addMarkerIncompleteCallbackToPendingTransition(markerName, transitions, aborts) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: null,\n        transitionProgress: null,\n        transitionComplete: null,\n        markerProgress: null,\n        markerIncomplete: new Map(),\n        markerComplete: null\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.markerIncomplete === null) {\n      currentPendingTransitionCallbacks.markerIncomplete = new Map();\n    }\n\n    currentPendingTransitionCallbacks.markerIncomplete.set(markerName, {\n      transitions,\n      aborts\n    });\n  }\n}\nexport function addMarkerCompleteCallbackToPendingTransition(markerName, transitions) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: null,\n        transitionProgress: null,\n        transitionComplete: null,\n        markerProgress: null,\n        markerIncomplete: null,\n        markerComplete: new Map()\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.markerComplete === null) {\n      currentPendingTransitionCallbacks.markerComplete = new Map();\n    }\n\n    currentPendingTransitionCallbacks.markerComplete.set(markerName, transitions);\n  }\n}\nexport function addTransitionProgressCallbackToPendingTransition(transition, boundaries) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: null,\n        transitionProgress: new Map(),\n        transitionComplete: null,\n        markerProgress: null,\n        markerIncomplete: null,\n        markerComplete: null\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.transitionProgress === null) {\n      currentPendingTransitionCallbacks.transitionProgress = new Map();\n    }\n\n    currentPendingTransitionCallbacks.transitionProgress.set(transition, boundaries);\n  }\n}\nexport function addTransitionCompleteCallbackToPendingTransition(transition) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: null,\n        transitionProgress: null,\n        transitionComplete: [],\n        markerProgress: null,\n        markerIncomplete: null,\n        markerComplete: null\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.transitionComplete === null) {\n      currentPendingTransitionCallbacks.transitionComplete = [];\n    }\n\n    currentPendingTransitionCallbacks.transitionComplete.push(transition);\n  }\n}\n\nfunction resetRenderTimer() {\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n}\n\nexport function getRenderTargetTime() {\n  return workInProgressRootRenderTargetTime;\n}\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;\n// to track which root is currently committing layout effects.\n\nlet rootCommittingMutationOrLayoutEffects = null;\nlet rootDoesHavePassiveEffects = false;\nlet rootWithPendingPassiveEffects = null;\nlet pendingPassiveEffectsLanes = NoLanes;\nlet pendingPassiveProfilerEffects = [];\nlet pendingPassiveEffectsRemainingLanes = NoLanes;\nlet pendingPassiveTransitions = null; // Use these to prevent an infinite loop of nested updates\n\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount = 0;\nlet rootWithNestedUpdates = null;\nlet isFlushingPassiveEffects = false;\nlet didScheduleUpdateDuringPassiveEffects = false;\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount = 0;\nlet rootWithPassiveNestedUpdates = null; // If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\n\nlet currentEventTime = NoTimestamp;\nlet currentEventTransitionLane = NoLanes;\nlet isRunningInsertionEffect = false;\nexport function getWorkInProgressRoot() {\n  return workInProgressRoot;\n}\nexport function getWorkInProgressRootRenderLanes() {\n  return workInProgressRootRenderLanes;\n}\nexport function requestEventTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return now();\n  } // We're not inside React, so we may be in the middle of a browser event.\n\n\n  if (currentEventTime !== NoTimestamp) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  } // This is the first update since React yielded. Compute a new start time.\n\n\n  currentEventTime = now();\n  return currentEventTime;\n}\nexport function getCurrentTime() {\n  return now();\n}\nexport function requestUpdateLane(fiber) {\n  // Special cases\n  const mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  } else if (!deferRenderPhaseUpdateToNextBatch && (executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n    // This is a render phase update. These are not officially supported. The\n    // old behavior is to give this the same \"thread\" (lanes) as\n    // whatever is currently rendering. So if you call `setState` on a component\n    // that happens later in the same render, it will flush. Ideally, we want to\n    // remove the special case and treat them as if they came from an\n    // interleaved event. Regardless, this pattern is not officially supported.\n    // This behavior is only a fallback. The flag only exists until we can roll\n    // out the setState warning, since existing code might accidentally rely on\n    // the current behavior.\n    return pickArbitraryLane(workInProgressRootRenderLanes);\n  }\n\n  const isTransition = requestCurrentTransition() !== NoTransition;\n\n  if (isTransition) {\n    if (__DEV__ && ReactCurrentBatchConfig.transition !== null) {\n      const transition = ReactCurrentBatchConfig.transition;\n\n      if (!transition._updatedFibers) {\n        transition._updatedFibers = new Set();\n      }\n\n      transition._updatedFibers.add(fiber);\n    } // The algorithm for assigning an update to a lane should be stable for all\n    // updates at the same priority within the same event. To do this, the\n    // inputs to the algorithm must be the same.\n    //\n    // The trick we use is to cache the first of each of these inputs within an\n    // event. Then reset the cached values once we can be sure the event is\n    // over. Our heuristic for that is whenever we enter a concurrent work loop.\n\n\n    if (currentEventTransitionLane === NoLane) {\n      // All transitions within the same event are assigned the same lane.\n      currentEventTransitionLane = claimNextTransitionLane();\n    }\n\n    return currentEventTransitionLane;\n  } // Updates originating inside certain React methods, like flushSync, have\n  // their priority set by tracking it with a context variable.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  const updateLane = getCurrentUpdatePriority();\n\n  if (updateLane !== NoLane) {\n    return updateLane;\n  } // This update originated outside React. Ask the host environment for an\n  // appropriate priority, based on the type of event.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  const eventLane = getCurrentEventPriority();\n  return eventLane;\n}\n\nfunction requestRetryLane(fiber) {\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\n  // from its placeholder state to its primary/resolved state.\n  // Special cases\n  const mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  }\n\n  return claimNextRetryLane();\n}\n\nexport function scheduleUpdateOnFiber(root, fiber, lane, eventTime) {\n  if (__DEV__) {\n    if (isRunningInsertionEffect) {\n      console.error('useInsertionEffect must not schedule updates.');\n    }\n  }\n\n  if (__DEV__) {\n    if (isFlushingPassiveEffects) {\n      didScheduleUpdateDuringPassiveEffects = true;\n    }\n  } // Check if the work loop is currently suspended and waiting for data to\n  // finish loading.\n\n\n  if (workInProgressSuspendedReason === SuspendedOnData && root === workInProgressRoot) {\n    // The incoming update might unblock the current render. Interrupt the\n    // current attempt and restart from the top.\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended(root, workInProgressRootRenderLanes);\n  } // Mark that the root has a pending update.\n\n\n  markRootUpdated(root, lane, eventTime);\n\n  if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n    // This update was dispatched during the render phase. This is a mistake\n    // if the update originates from user space (with the exception of local\n    // hook updates, which are handled differently and don't reach this\n    // function), but there are some internal React features that use this as\n    // an implementation detail, like selective hydration.\n    warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n\n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(workInProgressRootRenderPhaseUpdatedLanes, lane);\n  } else {\n    // This is a normal update, scheduled from outside the render phase. For\n    // example, during an input event.\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        addFiberToLanesMap(root, fiber, lane);\n      }\n    }\n\n    warnIfUpdatesNotWrappedWithActDEV(fiber);\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      if ((executionContext & CommitContext) !== NoContext && root === rootCommittingMutationOrLayoutEffects) {\n        if (fiber.mode & ProfileMode) {\n          let current = fiber;\n\n          while (current !== null) {\n            if (current.tag === Profiler) {\n              const {\n                id,\n                onNestedUpdateScheduled\n              } = current.memoizedProps;\n\n              if (typeof onNestedUpdateScheduled === 'function') {\n                onNestedUpdateScheduled(id);\n              }\n            }\n\n            current = current.return;\n          }\n        }\n      }\n    }\n\n    if (enableTransitionTracing) {\n      const transition = ReactCurrentBatchConfig.transition;\n\n      if (transition !== null && transition.name != null) {\n        if (transition.startTime === -1) {\n          transition.startTime = now();\n        }\n\n        addTransitionToLanesMap(root, transition, lane);\n      }\n    }\n\n    if (root === workInProgressRoot) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that there was an interleaved update work on this root. Unless the\n      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n      // phase update. In that case, we don't treat render phase updates as if\n      // they were interleaved, for backwards compat reasons.\n      if (deferRenderPhaseUpdateToNextBatch || (executionContext & RenderContext) === NoContext) {\n        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n      }\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended(root, workInProgressRootRenderLanes);\n      }\n    }\n\n    ensureRootIsScheduled(root, eventTime);\n\n    if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)) {\n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\nexport function scheduleInitialHydrationOnRoot(root, lane, eventTime) {\n  // This is a special fork of scheduleUpdateOnFiber that is only used to\n  // schedule the initial hydration of a root that has just been created. Most\n  // of the stuff in scheduleUpdateOnFiber can be skipped.\n  //\n  // The main reason for this separate path, though, is to distinguish the\n  // initial children from subsequent updates. In fully client-rendered roots\n  // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n  // updates, but hydration roots are special because the initial render must\n  // match what was rendered on the server.\n  const current = root.current;\n  current.lanes = lane;\n  markRootUpdated(root, lane, eventTime);\n  ensureRootIsScheduled(root, eventTime);\n}\nexport function isUnsafeClassRenderPhaseUpdate(fiber) {\n  // Check if this is a render phase update. Only called by class components,\n  // which special (deprecated) behavior for UNSAFE_componentWillReceive props.\n  return (// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n    // decided not to enable it.\n    (!deferRenderPhaseUpdateToNextBatch || (fiber.mode & ConcurrentMode) === NoMode) && (executionContext & RenderContext) !== NoContext\n  );\n} // Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\n\nfunction ensureRootIsScheduled(root, currentTime) {\n  const existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\n  // expired so we know to work on those next.\n\n  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n\n  const nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback(existingCallbackNode);\n    }\n\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  } // We use the highest priority lane to represent the priority of the callback.\n\n\n  const newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.\n\n  const existingCallbackPriority = root.callbackPriority;\n\n  if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n  // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n  // on the `act` queue.\n  !(__DEV__ && ReactCurrentActQueue.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n    if (__DEV__) {\n      // If we're going to re-use an existing task, it needs to exist.\n      // Assume that discrete update microtasks are non-cancellable and null.\n      // TODO: Temporary until we confirm this warning is not fired.\n      if (existingCallbackNode == null && !includesSyncLane(existingCallbackPriority)) {\n        console.error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } // The priority hasn't changed. We can reuse the existing task. Exit.\n\n\n    return;\n  }\n\n  if (existingCallbackNode != null) {\n    // Cancel the existing callback. We'll schedule a new one below.\n    cancelCallback(existingCallbackNode);\n  } // Schedule a new callback.\n\n\n  let newCallbackNode;\n\n  if (includesSyncLane(newCallbackPriority)) {\n    // Special case: Sync React callbacks are scheduled on a special\n    // internal queue\n    if (root.tag === LegacyRoot) {\n      if (__DEV__ && ReactCurrentActQueue.isBatchingLegacy !== null) {\n        ReactCurrentActQueue.didScheduleLegacyUpdate = true;\n      }\n\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n    } else {\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }\n\n    if (supportsMicrotasks) {\n      // Flush the queue in a microtask.\n      if (__DEV__ && ReactCurrentActQueue.current !== null) {\n        // Inside `act`, use our internal `act` queue so that these get flushed\n        // at the end of the current scope even when using the sync version\n        // of `act`.\n        ReactCurrentActQueue.current.push(flushSyncCallbacks);\n      } else {\n        scheduleMicrotask(() => {\n          // In Safari, appending an iframe forces microtasks to run.\n          // https://github.com/facebook/react/issues/22459\n          // We don't support running callbacks in the middle of render\n          // or commit so we need to check against that.\n          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n            // Note that this would still prematurely flush the callbacks\n            // if this happens outside render or commit phase (e.g. in an event).\n            flushSyncCallbacks();\n          }\n        });\n      }\n    } else {\n      // Flush the queue in an Immediate task.\n      scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);\n    }\n\n    newCallbackNode = null;\n  } else {\n    let schedulerPriorityLevel;\n\n    switch (lanesToEventPriority(nextLanes)) {\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\n        break;\n\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\n        break;\n\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority;\n        break;\n\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n    }\n\n    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n  }\n\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n} // This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\n\n\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n    resetNestedUpdateFlag();\n  } // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n\n\n  currentEventTime = NoTimestamp;\n  currentEventTransitionLane = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  } // Flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n\n\n  const originalCallbackNode = root.callbackNode;\n  const didFlushPassiveEffects = flushPassiveEffects();\n\n  if (didFlushPassiveEffects) {\n    // Something in the passive effect phase may have canceled the current task.\n    // Check if the task node for this root was changed.\n    if (root.callbackNode !== originalCallbackNode) {\n      // The current task was canceled. Exit. We don't need to call\n      // `ensureRootIsScheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    } else {// Current task was not canceled. Continue.\n    }\n  } // Determine the next lanes to work on, using the fields stored\n  // on the root.\n\n\n  let lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (lanes === NoLanes) {\n    // Defensive coding. This is never expected to happen.\n    return null;\n  } // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n  // bug we're still investigating. Once the bug in Scheduler is fixed,\n  // we can remove this, since we track expiration ourselves.\n\n\n  const shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && (disableSchedulerTimeoutInWorkLoop || !didTimeout);\n  let exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n\n  if (exitStatus !== RootInProgress) {\n    if (exitStatus === RootErrored) {\n      // If something threw an error, try rendering one more time. We'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. If it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      const originallyAttemptedLanes = lanes;\n      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes);\n\n      if (errorRetryLanes !== NoLanes) {\n        lanes = errorRetryLanes;\n        exitStatus = recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes);\n      }\n    }\n\n    if (exitStatus === RootFatalErrored) {\n      const fatalError = workInProgressRootFatalError;\n      prepareFreshStack(root, NoLanes);\n      markRootSuspended(root, lanes);\n      ensureRootIsScheduled(root, now());\n      throw fatalError;\n    }\n\n    if (exitStatus === RootDidNotComplete) {\n      // The render unwound without completing the tree. This happens in special\n      // cases where need to exit the current render without producing a\n      // consistent tree or committing.\n      markRootSuspended(root, lanes);\n    } else {\n      // The render completed.\n      // Check if this render may have yielded to a concurrent event, and if so,\n      // confirm that any newly rendered stores are consistent.\n      // TODO: It's possible that even a concurrent render may never have yielded\n      // to the main thread, if it was fast enough, or if it expired. We could\n      // skip the consistency check in that case, too.\n      const renderWasConcurrent = !includesBlockingLane(root, lanes);\n      const finishedWork = root.current.alternate;\n\n      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n        // A store was mutated in an interleaved event. Render again,\n        // synchronously, to block further mutations.\n        exitStatus = renderRootSync(root, lanes); // We need to check again if something threw\n\n        if (exitStatus === RootErrored) {\n          const originallyAttemptedLanes = lanes;\n          const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes);\n\n          if (errorRetryLanes !== NoLanes) {\n            lanes = errorRetryLanes;\n            exitStatus = recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any\n            // concurrent events.\n          }\n        }\n\n        if (exitStatus === RootFatalErrored) {\n          const fatalError = workInProgressRootFatalError;\n          prepareFreshStack(root, NoLanes);\n          markRootSuspended(root, lanes);\n          ensureRootIsScheduled(root, now());\n          throw fatalError;\n        } // FIXME: Need to check for RootDidNotComplete again. The factoring here\n        // isn't ideal.\n\n      } // We now have a consistent tree. The next step is either to commit it,\n      // or, if something suspended, wait to commit it after a timeout.\n\n\n      root.finishedWork = finishedWork;\n      root.finishedLanes = lanes;\n      finishConcurrentRender(root, exitStatus, lanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, now());\n\n  if (root.callbackNode === originalCallbackNode) {\n    // The task node scheduled for this root is the same one that's\n    // currently executed. Need to return a continuation.\n    if (workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root) {\n      // Special case: The work loop is currently suspended and waiting for\n      // data to resolve. Unschedule the current task.\n      //\n      // TODO: The factoring is a little weird. Arguably this should be checked\n      // in ensureRootIsScheduled instead. I went back and forth, not totally\n      // sure yet.\n      root.callbackPriority = NoLane;\n      root.callbackNode = null;\n      return null;\n    }\n\n    return performConcurrentWorkOnRoot.bind(null, root);\n  }\n\n  return null;\n}\n\nfunction recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes) {\n  // If an error occurred during hydration, discard server response and fall\n  // back to client side render.\n  // Before rendering again, save the errors from the previous attempt.\n  const errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n  const wasRootDehydrated = isRootDehydrated(root);\n\n  if (wasRootDehydrated) {\n    // The shell failed to hydrate. Set a flag to force a client rendering\n    // during the next attempt. To do this, we call prepareFreshStack now\n    // to create the root work-in-progress fiber. This is a bit weird in terms\n    // of factoring, because it relies on renderRootSync not calling\n    // prepareFreshStack again in the call below, which happens because the\n    // root and lanes haven't changed.\n    //\n    // TODO: I think what we should do is set ForceClientRender inside\n    // throwException, like we do for nested Suspense boundaries. The reason\n    // it's here instead is so we can switch to the synchronous work loop, too.\n    // Something to consider for a future refactor.\n    const rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n    rootWorkInProgress.flags |= ForceClientRender;\n\n    if (__DEV__) {\n      errorHydratingContainer(root.containerInfo);\n    }\n  }\n\n  const exitStatus = renderRootSync(root, errorRetryLanes);\n\n  if (exitStatus !== RootErrored) {\n    // Successfully finished rendering on retry\n    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n      // During the synchronous render, we attached additional ping listeners.\n      // This is highly suggestive of an uncached promise (though it's not the\n      // only reason this would happen). If it was an uncached promise, then\n      // it may have masked a downstream error from ocurring without actually\n      // fixing it. Example:\n      //\n      //    use(Promise.resolve('uncached'))\n      //    throw new Error('Oops!')\n      //\n      // When this happens, there's a conflict between blocking potential\n      // concurrent data races and unwrapping uncached promise values. We\n      // have to choose one or the other. Because the data race recovery is\n      // a last ditch effort, we'll disable it.\n      root.errorRecoveryDisabledLanes = mergeLanes(root.errorRecoveryDisabledLanes, originallyAttemptedLanes); // Mark the current render as suspended and force it to restart. Once\n      // these lanes finish successfully, we'll re-enable the error recovery\n      // mechanism for subsequent updates.\n\n      workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes;\n      return RootSuspendedWithDelay;\n    } // The errors from the failed first attempt have been recovered. Add\n    // them to the collection of recoverable errors. We'll log them in the\n    // commit phase.\n\n\n    const errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n    workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n    // from the first attempt, to preserve the causal sequence.\n\n    if (errorsFromSecondAttempt !== null) {\n      queueRecoverableErrors(errorsFromSecondAttempt);\n    }\n  } else {// The UI failed to recover.\n  }\n\n  return exitStatus;\n}\n\nexport function queueRecoverableErrors(errors) {\n  if (workInProgressRootRecoverableErrors === null) {\n    workInProgressRootRecoverableErrors = errors;\n  } else {\n    // $FlowFixMe[method-unbinding]\n    workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n  }\n}\n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    case RootInProgress:\n    case RootFatalErrored:\n      {\n        throw new Error('Root did not complete. This is a bug in React.');\n      }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n\n    case RootErrored:\n      {\n        // We should have already attempted to retry this tree. If we reached\n        // this point, it errored again. Commit it.\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootSuspended:\n      {\n        markRootSuspended(root, lanes); // We have an acceptable loading state. We need to figure out if we\n        // should immediately commit it or wait a bit.\n\n        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n        !shouldForceFlushFallbacksInDEV()) {\n          // This render only included retries, no updates. Throttle committing\n          // retries so that we don't show too many loading states too quickly.\n          const msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            const nextLanes = getNextLanes(root, NoLanes);\n\n            if (nextLanes !== NoLanes) {\n              // There's additional work on this root.\n              break;\n            }\n\n            const suspendedLanes = root.suspendedLanes;\n\n            if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n              // We should prefer to render the fallback of at the last\n              // suspended level. Ping the last suspended level to try\n              // rendering it again.\n              // FIXME: What if the suspended lanes are Idle? Should not restart.\n              const eventTime = requestEventTime();\n              markRootPinged(root, suspendedLanes, eventTime);\n              break;\n            } // The render is suspended, it hasn't timed out, and there's no\n            // lower priority work to do. Instead of committing the fallback\n            // immediately, wait for more data to arrive.\n\n\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);\n            break;\n          }\n        } // The work expired. Commit immediately.\n\n\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootSuspendedWithDelay:\n      {\n        markRootSuspended(root, lanes);\n\n        if (includesOnlyTransitions(lanes)) {\n          // This is a transition, so we should exit without committing a\n          // placeholder and without scheduling a timeout. Delay indefinitely\n          // until we receive more data.\n          break;\n        }\n\n        if (!shouldForceFlushFallbacksInDEV()) {\n          // This is not a transition, but we did trigger an avoided state.\n          // Schedule a placeholder to display after a short delay, using the Just\n          // Noticeable Difference.\n          // TODO: Is the JND optimization worth the added complexity? If this is\n          // the only reason we track the event time, then probably not.\n          // Consider removing.\n          const mostRecentEventTime = getMostRecentEventTime(root, lanes);\n          const eventTimeMs = mostRecentEventTime;\n          const timeElapsedMs = now() - eventTimeMs;\n          const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            // Instead of committing the fallback immediately, wait for more data\n            // to arrive.\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);\n            break;\n          }\n        } // Commit the placeholder.\n\n\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    case RootCompleted:\n      {\n        // The work completed. Ready to commit.\n        commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        break;\n      }\n\n    default:\n      {\n        throw new Error('Unknown root exit status.');\n      }\n  }\n}\n\nfunction isRenderConsistentWithExternalStores(finishedWork) {\n  // Search the rendered tree for external store reads, and check whether the\n  // stores were mutated in a concurrent event. Intentionally using an iterative\n  // loop instead of recursion so we can exit early.\n  let node = finishedWork;\n\n  while (true) {\n    if (node.flags & StoreConsistency) {\n      const updateQueue = node.updateQueue;\n\n      if (updateQueue !== null) {\n        const checks = updateQueue.stores;\n\n        if (checks !== null) {\n          for (let i = 0; i < checks.length; i++) {\n            const check = checks[i];\n            const getSnapshot = check.getSnapshot;\n            const renderedValue = check.value;\n\n            try {\n              if (!is(getSnapshot(), renderedValue)) {\n                // Found an inconsistent store.\n                return false;\n              }\n            } catch (error) {\n              // If `getSnapshot` throws, return `false`. This will schedule\n              // a re-render, and the error will be rethrown during render.\n              return false;\n            }\n          }\n        }\n      }\n    }\n\n    const child = node.child;\n\n    if (node.subtreeFlags & StoreConsistency && child !== null) {\n      child.return = node;\n      node = child;\n      continue;\n    }\n\n    if (node === finishedWork) {\n      return true;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return true;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  } // Flow doesn't know this is unreachable, but eslint does\n  // eslint-disable-next-line no-unreachable\n\n\n  return true;\n}\n\nfunction markRootSuspended(root, suspendedLanes) {\n  // When suspending, we should always exclude lanes that were pinged or (more\n  // rarely, since we try to avoid it) updated during the render phase.\n  // TODO: Lol maybe there's a better way to factor this besides this\n  // obnoxiously named function :)\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes); // $FlowFixMe[incompatible-call] found when upgrading Flow\n\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\n} // This is the entry point for synchronous tasks that don't go\n// through Scheduler\n\n\nfunction performSyncWorkOnRoot(root) {\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n    syncNestedUpdateFlag();\n  }\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  flushPassiveEffects();\n  let lanes = getNextLanes(root, NoLanes);\n\n  if (!includesSyncLane(lanes)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n\n  let exitStatus = renderRootSync(root, lanes);\n\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. If it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    const originallyAttemptedLanes = lanes;\n    const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes);\n\n    if (errorRetryLanes !== NoLanes) {\n      lanes = errorRetryLanes;\n      exitStatus = recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes);\n    }\n  }\n\n  if (exitStatus === RootFatalErrored) {\n    const fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended(root, lanes);\n    ensureRootIsScheduled(root, now());\n    throw fatalError;\n  }\n\n  if (exitStatus === RootDidNotComplete) {\n    // The render unwound without completing the tree. This happens in special\n    // cases where need to exit the current render without producing a\n    // consistent tree or committing.\n    markRootSuspended(root, lanes);\n    ensureRootIsScheduled(root, now());\n    return null;\n  } // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n\n\n  const finishedWork = root.current.alternate;\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions); // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n\n  ensureRootIsScheduled(root, now());\n  return null;\n}\n\nexport function flushRoot(root, lanes) {\n  if (lanes !== NoLanes) {\n    markRootEntangled(root, mergeLanes(lanes, SyncLane));\n    ensureRootIsScheduled(root, now());\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nexport function getExecutionContext() {\n  return executionContext;\n}\nexport function deferredUpdates(fn) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DefaultEventPriority);\n    return fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\nexport function batchedUpdates(fn, a) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer\n    // most batchedUpdates-like method.\n\n    if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)) {\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\nexport function discreteUpdates(fn, a, b, c, d) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    return fn(a, b, c, d);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    if (executionContext === NoContext) {\n      resetRenderTimer();\n    }\n  }\n} // Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-unused-vars\n\n// eslint-disable-next-line no-redeclare\nexport function flushSync(fn) {\n  // In legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n    flushPassiveEffects();\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      flushSyncCallbacks();\n    }\n  }\n}\nexport function isAlreadyRendering() {\n  // Used by the renderer to print a warning if certain APIs are called from\n  // the wrong context.\n  return __DEV__ && (executionContext & (RenderContext | CommitContext)) !== NoContext;\n}\nexport function isInvalidExecutionContextForEventFunction() {\n  // Used to throw if certain APIs are called from the wrong context.\n  return (executionContext & RenderContext) !== NoContext;\n}\nexport function flushControlled(fn) {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n} // This is called by the HiddenContext module when we enter or leave a\n// hidden subtree. The stack logic is managed there because that's the only\n// place that ever modifies it. Which module it lives in doesn't matter for\n// performance because this function will get inlined regardless\n\nexport function setRenderLanes(subtreeRenderLanes) {\n  renderLanes = subtreeRenderLanes;\n}\nexport function getRenderLanes() {\n  return renderLanes;\n}\n\nfunction resetWorkInProgressStack() {\n  if (workInProgress === null) return;\n  let interruptedWork;\n\n  if (workInProgressSuspendedReason === NotSuspended) {\n    // Normal case. Work-in-progress hasn't started yet. Unwind all\n    // its parents.\n    interruptedWork = workInProgress.return;\n  } else {\n    // Work-in-progress is in suspended state. Reset the work loop and unwind\n    // both the suspended fiber and all its parents.\n    resetSuspendedWorkLoopOnUnwind();\n    interruptedWork = workInProgress;\n  }\n\n  while (interruptedWork !== null) {\n    const current = interruptedWork.alternate;\n    unwindInterruptedWork(current, interruptedWork, workInProgressRootRenderLanes);\n    interruptedWork = interruptedWork.return;\n  }\n\n  workInProgress = null;\n}\n\nfunction prepareFreshStack(root, lanes) {\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n  const timeoutHandle = root.timeoutHandle;\n\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n    cancelTimeout(timeoutHandle);\n  }\n\n  resetWorkInProgressStack();\n  workInProgressRoot = root;\n  const rootWorkInProgress = createWorkInProgress(root.current, null);\n  workInProgress = rootWorkInProgress;\n  workInProgressRootRenderLanes = renderLanes = lanes;\n  workInProgressSuspendedReason = NotSuspended;\n  workInProgressThrownValue = null;\n  workInProgressRootDidAttachPingListener = false;\n  workInProgressRootExitStatus = RootInProgress;\n  workInProgressRootFatalError = null;\n  workInProgressRootSkippedLanes = NoLanes;\n  workInProgressRootInterleavedUpdatedLanes = NoLanes;\n  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;\n  workInProgressRootPingedLanes = NoLanes;\n  workInProgressRootConcurrentErrors = null;\n  workInProgressRootRecoverableErrors = null;\n  finishQueueingConcurrentUpdates();\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n\n  return rootWorkInProgress;\n}\n\nfunction resetSuspendedWorkLoopOnUnwind() {\n  // Reset module-level state that was set during the render phase.\n  resetContextDependencies();\n  resetHooksOnUnwind();\n}\n\nfunction handleThrow(root, thrownValue) {\n  // A component threw an exception. Usually this is because it suspended, but\n  // it also includes regular program errors.\n  //\n  // We're either going to unwind the stack to show a Suspense or error\n  // boundary, or we're going to replay the component again. Like after a\n  // promise resolves.\n  //\n  // Until we decide whether we're going to unwind or replay, we should preserve\n  // the current state of the work loop without resetting anything.\n  //\n  // If we do decide to unwind the stack, module-level variables will be reset\n  // in resetSuspendedWorkLoopOnUnwind.\n  // These should be reset immediately because they're only supposed to be set\n  // when React is executing user code.\n  resetHooksAfterThrow();\n  resetCurrentDebugFiberInDEV();\n  ReactCurrentOwner.current = null;\n\n  if (thrownValue === SuspenseException) {\n    // This is a special type of exception used for Suspense. For historical\n    // reasons, the rest of the Suspense implementation expects the thrown value\n    // to be a thenable, because before `use` existed that was the (unstable)\n    // API for suspending. This implementation detail can change later, once we\n    // deprecate the old API in favor of `use`.\n    thrownValue = getSuspendedThenable();\n    workInProgressSuspendedReason = shouldAttemptToSuspendUntilDataResolves() ? SuspendedOnData : SuspendedOnImmediate;\n  } else if (thrownValue === SelectiveHydrationException) {\n    // An update flowed into a dehydrated boundary. Before we can apply the\n    // update, we need to finish hydrating. Interrupt the work-in-progress\n    // render so we can restart at the hydration lane.\n    //\n    // The ideal implementation would be able to switch contexts without\n    // unwinding the current stack.\n    //\n    // We could name this something more general but as of now it's the only\n    // case where we think this should happen.\n    workInProgressSuspendedReason = SuspendedOnHydration;\n  } else {\n    // This is a regular error.\n    const isWakeable = thrownValue !== null && typeof thrownValue === 'object' && // $FlowFixMe[method-unbinding]\n    typeof thrownValue.then === 'function';\n    workInProgressSuspendedReason = isWakeable ? // A wakeable object was thrown by a legacy Suspense implementation.\n    // This has slightly different behavior than suspending with `use`.\n    SuspendedOnDeprecatedThrowPromise : // This is a regular error. If something earlier in the component already\n    // suspended, we must clear the thenable state to unblock the work loop.\n    SuspendedOnError;\n  }\n\n  workInProgressThrownValue = thrownValue;\n  const erroredWork = workInProgress;\n\n  if (erroredWork === null) {\n    // This is a fatal error\n    workInProgressRootExitStatus = RootFatalErrored;\n    workInProgressRootFatalError = thrownValue;\n    return;\n  }\n\n  if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n    // Record the time spent rendering before an error was thrown. This\n    // avoids inaccurate Profiler durations in the case of a\n    // suspended render.\n    stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n\n    if (workInProgressSuspendedReason !== SuspendedOnError) {\n      const wakeable = thrownValue;\n      markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n    } else {\n      markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n    }\n  }\n}\n\nfunction shouldAttemptToSuspendUntilDataResolves() {\n  // TODO: We should be able to move the\n  // renderDidSuspend/renderDidSuspendDelayIfPossible logic into this function,\n  // instead of repeating it in the complete phase. Or something to that effect.\n  if (includesOnlyRetries(workInProgressRootRenderLanes)) {\n    // We can always wait during a retry.\n    return true;\n  } // Check if there are other pending updates that might possibly unblock this\n  // component from suspending. This mirrors the check in\n  // renderDidSuspendDelayIfPossible. We should attempt to unify them somehow.\n\n\n  if (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes)) {\n    // Suspend normally. renderDidSuspendDelayIfPossible will handle\n    // interrupting the work loop.\n    return false;\n  } // TODO: We should be able to remove the equivalent check in\n  // finishConcurrentRender, and rely just on this one.\n\n\n  if (includesOnlyTransitions(workInProgressRootRenderLanes)) {\n    const suspenseHandler = getSuspenseHandler();\n\n    if (suspenseHandler !== null && suspenseHandler.tag === SuspenseComponent) {\n      const currentSuspenseHandler = suspenseHandler.alternate;\n      const nextProps = suspenseHandler.memoizedProps;\n\n      if (isBadSuspenseFallback(currentSuspenseHandler, nextProps)) {\n        // The nearest Suspense boundary is already showing content. We should\n        // avoid replacing it with a fallback, and instead wait until the\n        // data finishes loading.\n        return true;\n      } else {\n        // This is not a bad fallback condition. We should show a fallback\n        // immediately instead of waiting for the data to resolve. This includes\n        // when suspending inside new trees.\n        return false;\n      }\n    } // During a transition, if there is no Suspense boundary (i.e. suspending in\n    // the \"shell\" of an application), or if we're inside a hidden tree, then\n    // we should wait until the data finishes loading.\n\n\n    return true;\n  } // For all other Lanes besides Transitions and Retries, we should not wait\n  // for the data to load.\n  // TODO: We should wait during Offscreen prerendering, too.\n\n\n  return false;\n}\n\nfunction pushDispatcher(container) {\n  prepareRendererToRender(container);\n  const prevDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  resetRendererAfterRender();\n  ReactCurrentDispatcher.current = prevDispatcher;\n}\n\nfunction pushCacheDispatcher() {\n  if (enableCache) {\n    const prevCacheDispatcher = ReactCurrentCache.current;\n    ReactCurrentCache.current = DefaultCacheDispatcher;\n    return prevCacheDispatcher;\n  } else {\n    return null;\n  }\n}\n\nfunction popCacheDispatcher(prevCacheDispatcher) {\n  if (enableCache) {\n    ReactCurrentCache.current = prevCacheDispatcher;\n  }\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\nexport function markSkippedUpdateLanes(lane) {\n  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n}\nexport function renderDidSuspend() {\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\nexport function renderDidSuspendDelayIfPossible() {\n  workInProgressRootExitStatus = RootSuspendedWithDelay; // Check if there are updates that we skipped tree that might have unblocked\n  // this render.\n\n  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n    // Mark the current render as suspended so that we switch to working on\n    // the updates that were skipped. Usually we only suspend at the end of\n    // the render phase.\n    // TODO: We should probably always mark the root as suspended immediately\n    // (inside this function), since by suspending at the end of the render\n    // phase introduces a potential mistake where we suspend lanes that were\n    // pinged or updated while we were rendering.\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\n  }\n}\nexport function renderDidError(error) {\n  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n\n  if (workInProgressRootConcurrentErrors === null) {\n    workInProgressRootConcurrentErrors = [error];\n  } else {\n    workInProgressRootConcurrentErrors.push(error);\n  }\n} // Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\n\nexport function renderHasNotSuspendedYet() {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootInProgress;\n} // TODO: Over time, this function and renderRootConcurrent have become more\n// and more similar. Not sure it makes sense to maintain forked paths. Consider\n// unifying them again.\n\nfunction renderRootSync(root, lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher(root.containerInfo);\n  const prevCacheDispatcher = pushCacheDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        const memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    workInProgressTransitions = getTransitionsForLanes(root, lanes);\n    prepareFreshStack(root, lanes);\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStarted(lanes);\n  }\n\n  outer: do {\n    try {\n      if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {\n        // The work loop is suspended. During a synchronous render, we don't\n        // yield to the main thread. Immediately unwind the stack. This will\n        // trigger either a fallback or an error boundary.\n        // TODO: For discrete and \"default\" updates (anything that's not\n        // flushSync), we want to wait for the microtasks the flush before\n        // unwinding. Will probably implement this using renderRootConcurrent,\n        // or merge renderRootSync and renderRootConcurrent into the same\n        // function and fork the behavior some other way.\n        const unitOfWork = workInProgress;\n        const thrownValue = workInProgressThrownValue;\n\n        switch (workInProgressSuspendedReason) {\n          case SuspendedOnHydration:\n            {\n              // Selective hydration. An update flowed into a dehydrated tree.\n              // Interrupt the current render so the work loop can switch to the\n              // hydration lane.\n              resetWorkInProgressStack();\n              workInProgressRootExitStatus = RootDidNotComplete;\n              break outer;\n            }\n\n          default:\n            {\n              // Continue with the normal work loop.\n              workInProgressSuspendedReason = NotSuspended;\n              workInProgressThrownValue = null;\n              unwindSuspendedUnitOfWork(unitOfWork, thrownValue);\n              break;\n            }\n        }\n      }\n\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleThrow(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n  popCacheDispatcher(prevCacheDispatcher);\n\n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStopped();\n  } // Set this to null to indicate there's no in-progress render.\n\n\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes; // It's safe to process the queue now that the render phase is complete.\n\n  finishQueueingConcurrentUpdates();\n  return workInProgressRootExitStatus;\n} // The work loop is an extremely hot path. Tell Closure not to inline it.\n\n/** @noinline */\n\n\nfunction workLoopSync() {\n  // Perform work without checking if we need to yield between fiber.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction renderRootConcurrent(root, lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher(root.containerInfo);\n  const prevCacheDispatcher = pushCacheDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        const memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    workInProgressTransitions = getTransitionsForLanes(root, lanes);\n    resetRenderTimer();\n    prepareFreshStack(root, lanes);\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStarted(lanes);\n  }\n\n  outer: do {\n    try {\n      if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {\n        // The work loop is suspended. We need to either unwind the stack or\n        // replay the suspended component.\n        const unitOfWork = workInProgress;\n        const thrownValue = workInProgressThrownValue;\n\n        switch (workInProgressSuspendedReason) {\n          case SuspendedOnError:\n            {\n              // Unwind then continue with the normal work loop.\n              workInProgressSuspendedReason = NotSuspended;\n              workInProgressThrownValue = null;\n              unwindSuspendedUnitOfWork(unitOfWork, thrownValue);\n              break;\n            }\n\n          case SuspendedOnData:\n            {\n              const thenable = thrownValue;\n\n              if (isThenableResolved(thenable)) {\n                // The data resolved. Try rendering the component again.\n                workInProgressSuspendedReason = NotSuspended;\n                workInProgressThrownValue = null;\n                replaySuspendedUnitOfWork(unitOfWork);\n                break;\n              } // The work loop is suspended on data. We should wait for it to\n              // resolve before continuing to render.\n\n\n              const onResolution = () => {\n                ensureRootIsScheduled(root, now());\n              };\n\n              thenable.then(onResolution, onResolution);\n              break outer;\n            }\n\n          case SuspendedOnImmediate:\n            {\n              // If this fiber just suspended, it's possible the data is already\n              // cached. Yield to the main thread to give it a chance to ping. If\n              // it does, we can retry immediately without unwinding the stack.\n              workInProgressSuspendedReason = SuspendedAndReadyToUnwind;\n              break outer;\n            }\n\n          case SuspendedAndReadyToUnwind:\n            {\n              const thenable = thrownValue;\n\n              if (isThenableResolved(thenable)) {\n                // The data resolved. Try rendering the component again.\n                workInProgressSuspendedReason = NotSuspended;\n                workInProgressThrownValue = null;\n                replaySuspendedUnitOfWork(unitOfWork);\n              } else {\n                // Otherwise, unwind then continue with the normal work loop.\n                workInProgressSuspendedReason = NotSuspended;\n                workInProgressThrownValue = null;\n                unwindSuspendedUnitOfWork(unitOfWork, thrownValue);\n              }\n\n              break;\n            }\n\n          case SuspendedOnDeprecatedThrowPromise:\n            {\n              // Suspended by an old implementation that uses the `throw promise`\n              // pattern. The newer replaying behavior can cause subtle issues\n              // like infinite ping loops. So we maintain the old behavior and\n              // always unwind.\n              workInProgressSuspendedReason = NotSuspended;\n              workInProgressThrownValue = null;\n              unwindSuspendedUnitOfWork(unitOfWork, thrownValue);\n              break;\n            }\n\n          case SuspendedOnHydration:\n            {\n              // Selective hydration. An update flowed into a dehydrated tree.\n              // Interrupt the current render so the work loop can switch to the\n              // hydration lane.\n              resetWorkInProgressStack();\n              workInProgressRootExitStatus = RootDidNotComplete;\n              break outer;\n            }\n\n          default:\n            {\n              throw new Error('Unexpected SuspendedReason. This is a bug in React.');\n            }\n        }\n      }\n\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleThrow(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  popDispatcher(prevDispatcher);\n  popCacheDispatcher(prevCacheDispatcher);\n  executionContext = prevExecutionContext;\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  } // Check if the tree has completed.\n\n\n  if (workInProgress !== null) {\n    // Still work remaining.\n    if (enableSchedulingProfiler) {\n      markRenderYielded();\n    }\n\n    return RootInProgress;\n  } else {\n    // Completed the tree.\n    if (enableSchedulingProfiler) {\n      markRenderStopped();\n    } // Set this to null to indicate there's no in-progress render.\n\n\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes; // It's safe to process the queue now that the render phase is complete.\n\n    finishQueueingConcurrentUpdates(); // Return the final exit status.\n\n    return workInProgressRootExitStatus;\n  }\n}\n/** @noinline */\n\n\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    // $FlowFixMe[incompatible-call] found when upgrading Flow\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork) {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n  setCurrentDebugFiberInDEV(unitOfWork);\n  let next;\n\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderLanes);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, renderLanes);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n\nfunction replaySuspendedUnitOfWork(unitOfWork) {\n  // This is a fork of performUnitOfWork specifcally for replaying a fiber that\n  // just suspended.\n  //\n  const current = unitOfWork.alternate;\n  setCurrentDebugFiberInDEV(unitOfWork);\n  let next;\n  setCurrentDebugFiberInDEV(unitOfWork);\n  const isProfilingMode = enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode;\n\n  if (isProfilingMode) {\n    startProfilerTimer(unitOfWork);\n  }\n\n  switch (unitOfWork.tag) {\n    case IndeterminateComponent:\n      {\n        // Because it suspended with `use`, we can assume it's a\n        // function component.\n        unitOfWork.tag = FunctionComponent; // Fallthrough to the next branch.\n      }\n    // eslint-disable-next-line no-fallthrough\n\n    case FunctionComponent:\n    case ForwardRef:\n      {\n        // Resolve `defaultProps`. This logic is copied from `beginWork`.\n        // TODO: Consider moving this switch statement into that module. Also,\n        // could maybe use this as an opportunity to say `use` doesn't work with\n        // `defaultProps` :)\n        const Component = unitOfWork.type;\n        const unresolvedProps = unitOfWork.pendingProps;\n        const resolvedProps = unitOfWork.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        next = replayFunctionComponent(current, unitOfWork, resolvedProps, Component, workInProgressRootRenderLanes);\n        break;\n      }\n\n    case SimpleMemoComponent:\n      {\n        const Component = unitOfWork.type;\n        const nextProps = unitOfWork.pendingProps;\n        next = replayFunctionComponent(current, unitOfWork, nextProps, Component, workInProgressRootRenderLanes);\n        break;\n      }\n\n    default:\n      {\n        if (__DEV__) {\n          console.error('Unexpected type of work: %s, Currently only function ' + 'components are replayed after suspending. This is a bug in React.', unitOfWork.tag);\n        }\n\n        resetSuspendedWorkLoopOnUnwind();\n        unwindInterruptedWork(current, unitOfWork, workInProgressRootRenderLanes);\n        unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, renderLanes);\n        next = beginWork(current, unitOfWork, renderLanes);\n        break;\n      }\n  }\n\n  if (isProfilingMode) {\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } // The begin phase finished successfully without suspending. Return to the\n  // normal work loop.\n\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n\nfunction unwindSuspendedUnitOfWork(unitOfWork, thrownValue) {\n  // This is a fork of performUnitOfWork specifcally for unwinding a fiber\n  // that threw an exception.\n  //\n  // Return to the normal work loop. This will unwind the stack, and potentially\n  // result in showing a fallback.\n  resetSuspendedWorkLoopOnUnwind();\n  const returnFiber = unitOfWork.return;\n\n  if (returnFiber === null || workInProgressRoot === null) {\n    // Expected to be working on a non-root fiber. This is a fatal error\n    // because there's no ancestor that can handle it; the root is\n    // supposed to capture all errors that weren't caught by an error\n    // boundary.\n    workInProgressRootExitStatus = RootFatalErrored;\n    workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n    // sibling, or the parent if there are no siblings. But since the root\n    // has no siblings nor a parent, we set it to null. Usually this is\n    // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n    // intentionally not calling those, we need set it here.\n    // TODO: Consider calling `unwindWork` to pop the contexts.\n\n    workInProgress = null;\n    return;\n  }\n\n  try {\n    // Find and mark the nearest Suspense or error boundary that can handle\n    // this \"exception\".\n    throwException(workInProgressRoot, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes);\n  } catch (error) {\n    // We had trouble processing the error. An example of this happening is\n    // when accessing the `componentDidCatch` property of an error boundary\n    // throws an error. A weird edge case. There's a regression test for this.\n    // To prevent an infinite loop, bubble the error up to the next parent.\n    workInProgress = returnFiber;\n    throw error;\n  } // Return to the normal work loop.\n\n\n  completeUnitOfWork(unitOfWork);\n}\n\nfunction completeUnitOfWork(unitOfWork) {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  let completedWork = unitOfWork;\n\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = completedWork.alternate;\n    const returnFiber = completedWork.return; // Check if the work completed or if something threw.\n\n    if ((completedWork.flags & Incomplete) === NoFlags) {\n      setCurrentDebugFiberInDEV(completedWork);\n      let next;\n\n      if (!enableProfilerTimer || (completedWork.mode & ProfileMode) === NoMode) {\n        next = completeWork(current, completedWork, renderLanes);\n      } else {\n        startProfilerTimer(completedWork);\n        next = completeWork(current, completedWork, renderLanes); // Update render duration assuming we didn't error.\n\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n      }\n\n      resetCurrentDebugFiberInDEV();\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        workInProgress = next;\n        return;\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(current, completedWork, renderLanes); // Because this fiber did not complete, don't reset its lanes.\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        next.flags &= HostEffectMask;\n        workInProgress = next;\n        return;\n      }\n\n      if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\n\n        let actualDuration = completedWork.actualDuration;\n        let child = completedWork.child;\n\n        while (child !== null) {\n          // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n\n        completedWork.actualDuration = actualDuration;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its subtree flags.\n        returnFiber.flags |= Incomplete;\n        returnFiber.subtreeFlags = NoFlags;\n        returnFiber.deletions = null;\n      } else {\n        // We've unwound all the way to the root.\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n        return;\n      }\n    }\n\n    const siblingFiber = completedWork.sibling;\n\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      workInProgress = siblingFiber;\n      return;\n    } // Otherwise, return to the parent\n    // $FlowFixMe[incompatible-type] we bail out when we get a null\n\n\n    completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n\n    workInProgress = completedWork;\n  } while (completedWork !== null); // We've reached the root.\n\n\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}\n\nfunction commitRoot(root, recoverableErrors, transitions) {\n  // TODO: This no longer makes any sense. We already wrap the mutation and\n  // layout phases. Should be able to remove.\n  const previousUpdateLanePriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition;\n    setCurrentUpdatePriority(previousUpdateLanePriority);\n  }\n\n  return null;\n}\n\nfunction commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\n    // flush synchronous work at the end, to avoid factoring hazards like this.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  const finishedWork = root.finishedWork;\n  const lanes = root.finishedLanes;\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logCommitStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markCommitStarted(lanes);\n  }\n\n  if (finishedWork === null) {\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logCommitStopped();\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markCommitStopped();\n    }\n\n    return null;\n  } else {\n    if (__DEV__) {\n      if (lanes === NoLanes) {\n        console.error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n      }\n    }\n  }\n\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n\n  if (finishedWork === root.current) {\n    throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n  } // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n\n\n  root.callbackNode = null;\n  root.callbackPriority = NoLane; // Check which lanes no longer have any work scheduled on them, and mark\n  // those as finished.\n\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes); // Make sure to account for lanes that were updated by a concurrent event\n  // during the render phase; don't mark them as finished.\n\n  const concurrentlyUpdatedLanes = getConcurrentlyUpdatedLanes();\n  remainingLanes = mergeLanes(remainingLanes, concurrentlyUpdatedLanes);\n  markRootFinished(root, remainingLanes);\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    workInProgressRootRenderLanes = NoLanes;\n  } else {// This indicates that the last root we worked on is not the same one that\n    // we're committing now. This most commonly happens when a suspended root\n    // times out.\n  } // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. (See #16714.)\n  // TODO: Delete all other places that schedule the passive effect callback\n  // They're redundant.\n\n\n  if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      pendingPassiveEffectsRemainingLanes = remainingLanes; // workInProgressTransitions might be overwritten, so we want\n      // to store it in pendingPassiveTransitions until they get processed\n      // We need to pass this through as an argument to commitRoot\n      // because workInProgressTransitions might have changed between\n      // the previous render and commit if we throttle the commit\n      // with setTimeout\n\n      pendingPassiveTransitions = transitions;\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n        // *after* passive effects fire to avoid freeing a cache pool that may\n        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n\n        return null;\n      });\n    }\n  } // Check if there are any effects in the whole tree.\n  // TODO: This is left over from the effect list implementation, where we had\n  // to check for the existence of `firstEffect` to satisfy Flow. I think the\n  // only other reason this optimization exists is because it affects profiling.\n  // Reconsider whether this is necessary.\n\n\n  const subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n  const rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n\n  if (subtreeHasEffects || rootHasEffect) {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = null;\n    const previousPriority = getCurrentUpdatePriority();\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    const prevExecutionContext = executionContext;\n    executionContext |= CommitContext; // Reset this to null before calling lifecycles\n\n    ReactCurrentOwner.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n\n    const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      // Track the root here, rather than in commitLayoutEffects(), because of ref setters.\n      // Updates scheduled during ref detachment should also be flagged.\n      rootCommittingMutationOrLayoutEffects = root;\n    } // The next phase is the mutation phase, where we mutate the host tree.\n\n\n    commitMutationEffects(root, finishedWork, lanes);\n\n    if (enableCreateEventHandleAPI) {\n      if (shouldFireAfterActiveInstanceBlur) {\n        afterActiveInstanceBlur();\n      }\n    }\n\n    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n\n    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logLayoutEffectsStarted(lanes);\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markLayoutEffectsStarted(lanes);\n    }\n\n    commitLayoutEffects(finishedWork, root, lanes);\n\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logLayoutEffectsStopped();\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markLayoutEffectsStopped();\n    }\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      rootCommittingMutationOrLayoutEffects = null;\n    } // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n\n\n    requestPaint();\n    executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  } else {\n    // No effects.\n    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n  }\n\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsLanes = lanes;\n  } else {\n    // There were no passive effects, so we can immediately release the cache\n    // pool for this render.\n    releaseRootPooledCache(root, remainingLanes);\n\n    if (__DEV__) {\n      nestedPassiveUpdateCount = 0;\n      rootWithPassiveNestedUpdates = null;\n    }\n  } // Read this again, since an effect might have updated it\n\n\n  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n  // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n  // is to detect whether something might have called setState inside\n  // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n  // inside `componentDidCatch` is itself flawed — that's why we recommend\n  // `getDerivedStateFromError` instead. However, it could be improved by\n  // checking if remainingLanes includes Sync work, instead of whether there's\n  // any work remaining at all (which would also include stuff like Suspense\n  // retries or transitions). It's been like this for a while, though, so fixing\n  // it probably isn't that urgent.\n\n  if (remainingLanes === NoLanes) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (__DEV__) {\n    if (!rootDidHavePassiveEffects) {\n      commitDoubleInvokeEffectsInDEV(root, false);\n    }\n  }\n\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\n\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      root.memoizedUpdaters.clear();\n    }\n  }\n\n  if (__DEV__) {\n    onCommitRootTestSelector();\n  } // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n\n\n  ensureRootIsScheduled(root, now());\n\n  if (recoverableErrors !== null) {\n    // There were errors during this render, but recovered from them without\n    // needing to surface it to the UI. We log them here.\n    const onRecoverableError = root.onRecoverableError;\n\n    for (let i = 0; i < recoverableErrors.length; i++) {\n      const recoverableError = recoverableErrors[i];\n      const errorInfo = makeErrorInfo(recoverableError.digest, recoverableError.stack);\n      onRecoverableError(recoverableError.value, errorInfo);\n    }\n  }\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  } // If the passive effects are the result of a discrete render, flush them\n  // synchronously at the end of the current task so that the result is\n  // immediately observable. Otherwise, we assume that they are not\n  // order-dependent and do not need to be observed by external systems, so we\n  // can wait until after paint.\n  // TODO: We can optimize this by not scheduling the callback earlier. Since we\n  // currently schedule the callback in multiple places, will wait until those\n  // are consolidated.\n\n\n  if (includesSyncLane(pendingPassiveEffectsLanes) && root.tag !== LegacyRoot) {\n    flushPassiveEffects();\n  } // Read this again, since a passive effect might have updated it\n\n\n  remainingLanes = root.pendingLanes;\n\n  if (includesSyncLane(remainingLanes)) {\n    if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n      markNestedUpdateScheduled();\n    } // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n\n\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  } // If layout work was scheduled, flush it now.\n\n\n  flushSyncCallbacks();\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logCommitStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markCommitStopped();\n  }\n\n  if (enableTransitionTracing) {\n    // We process transitions during passive effects. However, passive effects can be\n    // processed synchronously during the commit phase as well as asynchronously after\n    // paint. At the end of the commit phase, we schedule a callback that will be called\n    // after the next paint. If the transitions have already been processed (passive\n    // effect phase happened synchronously), we will schedule a callback to process\n    // the transitions. However, if we don't have any pending transition callbacks, this\n    // means that the transitions have yet to be processed (passive effects processed after paint)\n    // so we will store the end time of paint so that we can process the transitions\n    // and then call the callback via the correct end time.\n    const prevRootTransitionCallbacks = root.transitionCallbacks;\n\n    if (prevRootTransitionCallbacks !== null) {\n      schedulePostPaintCallback(endTime => {\n        const prevPendingTransitionCallbacks = currentPendingTransitionCallbacks;\n\n        if (prevPendingTransitionCallbacks !== null) {\n          currentPendingTransitionCallbacks = null;\n          scheduleCallback(IdleSchedulerPriority, () => {\n            processTransitionCallbacks(prevPendingTransitionCallbacks, endTime, prevRootTransitionCallbacks);\n          });\n        } else {\n          currentEndTime = endTime;\n        }\n      });\n    }\n  }\n\n  return null;\n}\n\nfunction makeErrorInfo(digest, componentStack) {\n  if (__DEV__) {\n    const errorInfo = {\n      componentStack,\n      digest\n    };\n    Object.defineProperty(errorInfo, 'digest', {\n      configurable: false,\n      enumerable: true,\n\n      get() {\n        console.error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError.' + ' This property is deprecated and will be removed in a future version of React.' + ' To access the digest of an Error look for this property on the Error instance itself.');\n        return digest;\n      }\n\n    });\n    return errorInfo;\n  } else {\n    return {\n      digest,\n      componentStack\n    };\n  }\n}\n\nfunction releaseRootPooledCache(root, remainingLanes) {\n  if (enableCache) {\n    const pooledCacheLanes = root.pooledCacheLanes &= remainingLanes;\n\n    if (pooledCacheLanes === NoLanes) {\n      // None of the remaining work relies on the cache pool. Clear it so\n      // subsequent requests get a new cache\n      const pooledCache = root.pooledCache;\n\n      if (pooledCache != null) {\n        root.pooledCache = null;\n        releaseCache(pooledCache);\n      }\n    }\n  }\n}\n\nexport function flushPassiveEffects() {\n  // Returns whether passive effects were flushed.\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n  // probably just combine the two functions. I believe they were only separate\n  // in the first place because we used to wrap it with\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n  // priority within React itself, so we can mutate the variable directly.\n  if (rootWithPendingPassiveEffects !== null) {\n    // Cache the root since rootWithPendingPassiveEffects is cleared in\n    // flushPassiveEffectsImpl\n    const root = rootWithPendingPassiveEffects; // Cache and clear the remaining lanes flag; it must be reset since this\n    // method can be called from various places, not always from commitRoot\n    // where the remaining lanes are known\n\n    const remainingLanes = pendingPassiveEffectsRemainingLanes;\n    pendingPassiveEffectsRemainingLanes = NoLanes;\n    const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n    const priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    const previousPriority = getCurrentUpdatePriority();\n\n    try {\n      ReactCurrentBatchConfig.transition = null;\n      setCurrentUpdatePriority(priority);\n      return flushPassiveEffectsImpl();\n    } finally {\n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig.transition = prevTransition; // Once passive effects have run for the tree - giving components a\n      // chance to retain cache instances they use - release the pooled\n      // cache at the root (if there is one)\n\n      releaseRootPooledCache(root, remainingLanes);\n    }\n  }\n\n  return false;\n}\nexport function enqueuePendingPassiveProfilerEffect(fiber) {\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    pendingPassiveProfilerEffects.push(fiber);\n\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  } // Cache and clear the transitions flag\n\n\n  const transitions = pendingPassiveTransitions;\n  pendingPassiveTransitions = null;\n  const root = rootWithPendingPassiveEffects;\n  const lanes = pendingPassiveEffectsLanes;\n  rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n  // Figure out why and fix it. It's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n\n  pendingPassiveEffectsLanes = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Cannot flush passive effects while already rendering.');\n  }\n\n  if (__DEV__) {\n    isFlushingPassiveEffects = true;\n    didScheduleUpdateDuringPassiveEffects = false;\n\n    if (enableDebugTracing) {\n      logPassiveEffectsStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markPassiveEffectsStarted(lanes);\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  commitPassiveUnmountEffects(root.current);\n  commitPassiveMountEffects(root, root.current, lanes, transitions); // TODO: Move to commitPassiveMountEffects\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    const profilerEffects = pendingPassiveProfilerEffects;\n    pendingPassiveProfilerEffects = [];\n\n    for (let i = 0; i < profilerEffects.length; i++) {\n      const fiber = profilerEffects[i];\n      commitPassiveEffectDurations(root, fiber);\n    }\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logPassiveEffectsStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markPassiveEffectsStopped();\n  }\n\n  if (__DEV__) {\n    commitDoubleInvokeEffectsInDEV(root, true);\n  }\n\n  executionContext = prevExecutionContext;\n  flushSyncCallbacks();\n\n  if (enableTransitionTracing) {\n    const prevPendingTransitionCallbacks = currentPendingTransitionCallbacks;\n    const prevRootTransitionCallbacks = root.transitionCallbacks;\n    const prevEndTime = currentEndTime;\n\n    if (prevPendingTransitionCallbacks !== null && prevRootTransitionCallbacks !== null && prevEndTime !== null) {\n      currentPendingTransitionCallbacks = null;\n      currentEndTime = null;\n      scheduleCallback(IdleSchedulerPriority, () => {\n        processTransitionCallbacks(prevPendingTransitionCallbacks, prevEndTime, prevRootTransitionCallbacks);\n      });\n    }\n  }\n\n  if (__DEV__) {\n    // If additional passive effects were scheduled, increment a counter. If this\n    // exceeds the limit, we'll fire a warning.\n    if (didScheduleUpdateDuringPassiveEffects) {\n      if (root === rootWithPassiveNestedUpdates) {\n        nestedPassiveUpdateCount++;\n      } else {\n        nestedPassiveUpdateCount = 0;\n        rootWithPassiveNestedUpdates = root;\n      }\n    } else {\n      nestedPassiveUpdateCount = 0;\n    }\n\n    isFlushingPassiveEffects = false;\n    didScheduleUpdateDuringPassiveEffects = false;\n  } // TODO: Move to commitPassiveMountEffects\n\n\n  onPostCommitRootDevTools(root);\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    const stateNode = root.current.stateNode;\n    stateNode.effectDuration = 0;\n    stateNode.passiveEffectDuration = 0;\n  }\n\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\nexport function markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\n\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  const errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n  const root = enqueueUpdate(rootFiber, update, SyncLane);\n  const eventTime = requestEventTime();\n\n  if (root !== null) {\n    markRootUpdated(root, SyncLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nexport function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n  if (__DEV__) {\n    reportUncaughtErrorInDEV(error);\n    setIsRunningInsertionEffect(false);\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = null;\n\n  if (skipUnmountedBoundaries) {\n    fiber = nearestMountedAncestor;\n  } else {\n    fiber = sourceFiber.return;\n  }\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n\n      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n        const errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n        const update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n        const root = enqueueUpdate(fiber, update, SyncLane);\n        const eventTime = requestEventTime();\n\n        if (root !== null) {\n          markRootUpdated(root, SyncLane, eventTime);\n          ensureRootIsScheduled(root, eventTime);\n        }\n\n        return;\n      }\n    }\n\n    fiber = fiber.return;\n  }\n\n  if (__DEV__) {\n    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n    // will fire for errors that are thrown by destroy functions inside deleted\n    // trees. What it should instead do is propagate the error to the parent of\n    // the deleted tree. In the meantime, do not add this warning to the\n    // allowlist; this is only for our internal use.\n    console.error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Likely ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error);\n  }\n}\nexport function attachPingListener(root, wakeable, lanes) {\n  // Attach a ping listener\n  //\n  // The data might resolve before we have a chance to commit the fallback. Or,\n  // in the case of a refresh, we'll never commit a fallback. So we need to\n  // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n  // try rendering the tree again.\n  //\n  // Only attach a listener if one does not already exist for the lanes\n  // we're currently rendering (which acts like a \"thread ID\" here).\n  //\n  // We only need to do this in concurrent mode. Legacy Suspense always\n  // commits fallbacks synchronously, so there are no pings.\n  let pingCache = root.pingCache;\n  let threadIDs;\n\n  if (pingCache === null) {\n    pingCache = root.pingCache = new PossiblyWeakMap();\n    threadIDs = new Set();\n    pingCache.set(wakeable, threadIDs);\n  } else {\n    threadIDs = pingCache.get(wakeable);\n\n    if (threadIDs === undefined) {\n      threadIDs = new Set();\n      pingCache.set(wakeable, threadIDs);\n    }\n  }\n\n  if (!threadIDs.has(lanes)) {\n    workInProgressRootDidAttachPingListener = true; // Memoize using the thread ID to prevent redundant listeners.\n\n    threadIDs.add(lanes);\n    const ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        // If we have pending work still, restore the original updaters\n        restorePendingUpdaters(root, lanes);\n      }\n    }\n\n    wakeable.then(ping, ping);\n  }\n}\n\nfunction pingSuspendedRoot(root, wakeable, pingedLanes) {\n  const pingCache = root.pingCache;\n\n  if (pingCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(wakeable);\n  }\n\n  const eventTime = requestEventTime();\n  markRootPinged(root, pingedLanes, eventTime);\n  warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n\n  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\n    // so we can always restart.\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n      // Force a restart from the root by unwinding the stack. Unless this is\n      // being called from the render phase, because that would cause a crash.\n      if ((executionContext & RenderContext) === NoContext) {\n        prepareFreshStack(root, NoLanes);\n      } else {// TODO: If this does happen during the render phase, we should throw\n        // the special internal exception that we use to interrupt the stack for\n        // selective hydration. That was temporarily reverted but we once we add\n        // it back we can use it here.\n      }\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, eventTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber, retryLane) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new lanes.\n  if (retryLane === NoLane) {\n    // TODO: Assign this to `suspenseState.retryLane`? to avoid\n    // unnecessary entanglement?\n    retryLane = requestRetryLane(boundaryFiber);\n  } // TODO: Special case idle priority?\n\n\n  const eventTime = requestEventTime();\n  const root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n\n  if (root !== null) {\n    markRootUpdated(root, retryLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber) {\n  const suspenseState = boundaryFiber.memoizedState;\n  let retryLane = NoLane;\n\n  if (suspenseState !== null) {\n    retryLane = suspenseState.retryLane;\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nexport function resolveRetryWakeable(boundaryFiber, wakeable) {\n  let retryLane = NoLane; // Default\n\n  let retryCache;\n\n  switch (boundaryFiber.tag) {\n    case SuspenseComponent:\n      retryCache = boundaryFiber.stateNode;\n      const suspenseState = boundaryFiber.memoizedState;\n\n      if (suspenseState !== null) {\n        retryLane = suspenseState.retryLane;\n      }\n\n      break;\n\n    case SuspenseListComponent:\n      retryCache = boundaryFiber.stateNode;\n      break;\n\n    case OffscreenComponent:\n      {\n        const instance = boundaryFiber.stateNode; // $FlowFixMe[incompatible-type] found when upgrading Flow\n\n        retryCache = instance._retryCache;\n        break;\n      }\n\n    default:\n      throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n  }\n\n  if (retryCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(wakeable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n} // Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\n\nfunction jnd(timeElapsed) {\n  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n}\n\nexport function throwIfInfiniteUpdateLoopDetected() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    nestedPassiveUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    rootWithPassiveNestedUpdates = null;\n    throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      rootWithPassiveNestedUpdates = null;\n      console.error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, parentFiber, isInStrictMode) {\n  if ((parentFiber.subtreeFlags & (PlacementDEV | Visibility)) === NoFlags) {\n    // Parent's descendants have already had effects double invoked.\n    // Early exit to avoid unnecessary tree traversal.\n    return;\n  }\n\n  let child = parentFiber.child;\n\n  while (child !== null) {\n    doubleInvokeEffectsInDEVIfNecessary(root, child, isInStrictMode);\n    child = child.sibling;\n  }\n} // Unconditionally disconnects and connects passive and layout effects.\n\n\nfunction doubleInvokeEffectsOnFiber(root, fiber) {\n  disappearLayoutEffects(fiber);\n  disconnectPassiveEffect(fiber);\n  reappearLayoutEffects(root, fiber.alternate, fiber, false);\n  reconnectPassiveEffects(root, fiber, NoLanes, null, false);\n}\n\nfunction doubleInvokeEffectsInDEVIfNecessary(root, fiber, parentIsInStrictMode) {\n  const isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n  const isInStrictMode = parentIsInStrictMode || isStrictModeFiber; // First case: the fiber **is not** of type OffscreenComponent. No\n  // special rules apply to double invoking effects.\n\n  if (fiber.tag !== OffscreenComponent) {\n    if (fiber.flags & PlacementDEV) {\n      setCurrentDebugFiberInDEV(fiber);\n\n      if (isInStrictMode) {\n        doubleInvokeEffectsOnFiber(root, fiber);\n      }\n\n      resetCurrentDebugFiberInDEV();\n    } else {\n      recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isInStrictMode);\n    }\n\n    return;\n  } // Second case: the fiber **is** of type OffscreenComponent.\n  // This branch contains cases specific to Offscreen.\n\n\n  if (fiber.memoizedState === null) {\n    // Only consider Offscreen that is visible.\n    // TODO (Offscreen) Handle manual mode.\n    setCurrentDebugFiberInDEV(fiber);\n\n    if (isInStrictMode && fiber.flags & Visibility) {\n      // Double invoke effects on Offscreen's subtree only\n      // if it is visible and its visibility has changed.\n      doubleInvokeEffectsOnFiber(root, fiber);\n    } else if (fiber.subtreeFlags & PlacementDEV) {\n      // Something in the subtree could have been suspended.\n      // We need to continue traversal and find newly inserted fibers.\n      recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isInStrictMode);\n    }\n\n    resetCurrentDebugFiberInDEV();\n  }\n}\n\nfunction commitDoubleInvokeEffectsInDEV(root, hasPassiveEffects) {\n  if (__DEV__) {\n    if (useModernStrictMode) {\n      let doubleInvokeEffects = true;\n\n      if (root.tag === LegacyRoot && !(root.current.mode & StrictLegacyMode)) {\n        doubleInvokeEffects = false;\n      }\n\n      if (root.tag === ConcurrentRoot && !(root.current.mode & (StrictLegacyMode | StrictEffectsMode))) {\n        doubleInvokeEffects = false;\n      }\n\n      recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n    } else {\n      legacyCommitDoubleInvokeEffectsInDEV(root.current, hasPassiveEffects);\n    }\n  }\n}\n\nfunction legacyCommitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n  // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n  // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n  // Maybe not a big deal since this is DEV only behavior.\n  setCurrentDebugFiberInDEV(fiber);\n  invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n\n  if (hasPassiveEffects) {\n    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n  }\n\n  invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n\n  if (hasPassiveEffects) {\n    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n  }\n\n  resetCurrentDebugFiberInDEV();\n}\n\nfunction invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n  let current = firstChild;\n  let subtreeRoot = null;\n\n  while (current != null) {\n    const primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n\n    if (current !== subtreeRoot && current.child != null && primarySubtreeFlag !== NoFlags) {\n      current = current.child;\n    } else {\n      if ((current.flags & fiberFlags) !== NoFlags) {\n        invokeEffectFn(current);\n      }\n\n      if (current.sibling !== null) {\n        current = current.sibling;\n      } else {\n        current = subtreeRoot = current.return;\n      }\n    }\n  }\n}\n\nlet didWarnStateUpdateForNotYetMountedComponent = null;\nexport function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n  if (__DEV__) {\n    if ((executionContext & RenderContext) !== NoContext) {\n      // We let the other warning about render phase updates deal with this one.\n      return;\n    }\n\n    if (!(fiber.mode & ConcurrentMode)) {\n      return;\n    }\n\n    const tag = fiber.tag;\n\n    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    } // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n\n\n    const componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n        return;\n      } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\n    }\n\n    const previousFiber = ReactCurrentFiberCurrent;\n\n    try {\n      setCurrentDebugFiberInDEV(fiber);\n      console.error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n    } finally {\n      if (previousFiber) {\n        setCurrentDebugFiberInDEV(fiber);\n      } else {\n        resetCurrentDebugFiberInDEV();\n      }\n    }\n  }\n}\nlet beginWork;\n\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  const dummyFiber = null;\n\n  beginWork = (current, unitOfWork, lanes) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n\n    try {\n      return originalBeginWork(current, unitOfWork, lanes);\n    } catch (originalError) {\n      if (didSuspendOrErrorWhileHydratingDEV() || originalError === SuspenseException || originalError === SelectiveHydrationException || originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\n        // Don't replay promises.\n        // Don't replay errors if we are hydrating and have already suspended or handled an error\n        throw originalError;\n      } // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n      // Unwind the failed stack frame\n\n\n      resetSuspendedWorkLoopOnUnwind();\n      unwindInterruptedWork(current, unitOfWork, workInProgressRootRenderLanes); // Restore the original properties of the fiber.\n\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      } // Run beginWork again.\n\n\n      invokeGuardedCallback(null, originalBeginWork, null, current, unitOfWork, lanes);\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError();\n\n        if (typeof replayError === 'object' && replayError !== null && replayError._suppressLogging && typeof originalError === 'object' && originalError !== null && !originalError._suppressLogging) {\n          // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n          originalError._suppressLogging = true;\n        }\n      } // We always throw the original error in case the second render pass is not idempotent.\n      // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n\n\n      throw originalError;\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInRenderForAnotherComponent;\n\nif (__DEV__) {\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n}\n\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n  if (__DEV__) {\n    if (ReactCurrentDebugFiberIsRenderingInDEV) {\n      switch (fiber.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent:\n          {\n            const renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n\n            const dedupeKey = renderingComponentName;\n\n            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n              const setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n              console.error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n            }\n\n            break;\n          }\n\n        case ClassComponent:\n          {\n            if (!didWarnAboutUpdateInRender) {\n              console.error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n              didWarnAboutUpdateInRender = true;\n            }\n\n            break;\n          }\n      }\n    }\n  }\n}\n\nexport function restorePendingUpdaters(root, lanes) {\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      const memoizedUpdaters = root.memoizedUpdaters;\n      memoizedUpdaters.forEach(schedulingFiber => {\n        addFiberToLanesMap(root, schedulingFiber, lanes);\n      }); // This function intentionally does not clear memoized updaters.\n      // Those may still be relevant to the current commit\n      // and a future one (e.g. Suspense).\n    }\n  }\n}\nconst fakeActCallbackNode = {};\n\nfunction scheduleCallback(priorityLevel, callback) {\n  if (__DEV__) {\n    // If we're currently inside an `act` scope, bypass Scheduler and push to\n    // the `act` queue instead.\n    const actQueue = ReactCurrentActQueue.current;\n\n    if (actQueue !== null) {\n      actQueue.push(callback);\n      return fakeActCallbackNode;\n    } else {\n      return Scheduler_scheduleCallback(priorityLevel, callback);\n    }\n  } else {\n    // In production, always call Scheduler. This function will be stripped out.\n    return Scheduler_scheduleCallback(priorityLevel, callback);\n  }\n}\n\nfunction cancelCallback(callbackNode) {\n  if (__DEV__ && callbackNode === fakeActCallbackNode) {\n    return;\n  } // In production, always call Scheduler. This function will be stripped out.\n\n\n  return Scheduler_cancelCallback(callbackNode);\n}\n\nfunction shouldForceFlushFallbacksInDEV() {\n  // Never force flush in production. This function should get stripped out.\n  return __DEV__ && ReactCurrentActQueue.current !== null;\n}\n\nfunction warnIfUpdatesNotWrappedWithActDEV(fiber) {\n  if (__DEV__) {\n    if (fiber.mode & ConcurrentMode) {\n      if (!isConcurrentActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n    } else {\n      // Legacy mode has additional cases where we suppress a warning.\n      if (!isLegacyActEnvironment(fiber)) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n\n      if (executionContext !== NoContext) {\n        // Legacy mode doesn't warn if the update is batched, i.e.\n        // batchedUpdates or flushSync.\n        return;\n      }\n\n      if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n        // For backwards compatibility with pre-hooks code, legacy mode only\n        // warns for updates that originate from a hook.\n        return;\n      }\n    }\n\n    if (ReactCurrentActQueue.current === null) {\n      const previousFiber = ReactCurrentFiberCurrent;\n\n      try {\n        setCurrentDebugFiberInDEV(fiber);\n        console.error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n      } finally {\n        if (previousFiber) {\n          setCurrentDebugFiberInDEV(fiber);\n        } else {\n          resetCurrentDebugFiberInDEV();\n        }\n      }\n    }\n  }\n}\n\nfunction warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n  if (__DEV__) {\n    if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue.current === null) {\n      console.error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act');\n    }\n  }\n}\n\nexport function setIsRunningInsertionEffect(isRunning) {\n  if (__DEV__) {\n    isRunningInsertionEffect = isRunning;\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberWorkLoop.js"],"names":["REACT_STRICT_MODE_TYPE","warnAboutDeprecatedLifecycles","replayFailedUnitOfWorkWithInvokeGuardedCallback","enableCreateEventHandleAPI","enableProfilerTimer","enableProfilerCommitHooks","enableProfilerNestedUpdatePhase","enableProfilerNestedUpdateScheduledHook","deferRenderPhaseUpdateToNextBatch","enableDebugTracing","enableSchedulingProfiler","disableSchedulerTimeoutInWorkLoop","skipUnmountedBoundaries","enableUpdaterTracking","enableCache","enableTransitionTracing","useModernStrictMode","ReactSharedInternals","is","scheduleCallback","Scheduler_scheduleCallback","cancelCallback","Scheduler_cancelCallback","shouldYield","requestPaint","now","ImmediatePriority","ImmediateSchedulerPriority","UserBlockingPriority","UserBlockingSchedulerPriority","NormalPriority","NormalSchedulerPriority","IdlePriority","IdleSchedulerPriority","flushSyncCallbacks","flushSyncCallbacksOnlyInLegacyMode","scheduleSyncCallback","scheduleLegacySyncCallback","logCommitStarted","logCommitStopped","logLayoutEffectsStarted","logLayoutEffectsStopped","logPassiveEffectsStarted","logPassiveEffectsStopped","logRenderStarted","logRenderStopped","resetAfterCommit","scheduleTimeout","cancelTimeout","noTimeout","afterActiveInstanceBlur","getCurrentEventPriority","supportsMicrotasks","errorHydratingContainer","scheduleMicrotask","prepareRendererToRender","resetRendererAfterRender","createWorkInProgress","assignFiberPropertiesInDEV","resetWorkInProgress","isRootDehydrated","didSuspendOrErrorWhileHydratingDEV","NoMode","ProfileMode","ConcurrentMode","StrictLegacyMode","StrictEffectsMode","HostRoot","IndeterminateComponent","ClassComponent","SuspenseComponent","SuspenseListComponent","OffscreenComponent","FunctionComponent","ForwardRef","MemoComponent","SimpleMemoComponent","Profiler","ConcurrentRoot","LegacyRoot","NoFlags","Incomplete","StoreConsistency","HostEffectMask","ForceClientRender","BeforeMutationMask","MutationMask","LayoutMask","PassiveMask","PlacementDEV","Visibility","MountPassiveDev","MountLayoutDev","NoLanes","NoLane","SyncLane","NoTimestamp","claimNextTransitionLane","claimNextRetryLane","includesSyncLane","isSubsetOfLanes","mergeLanes","removeLanes","pickArbitraryLane","includesNonIdleWork","includesOnlyRetries","includesOnlyTransitions","includesBlockingLane","includesExpiredLane","getNextLanes","markStarvedLanesAsExpired","getLanesToRetrySynchronouslyOnError","getMostRecentEventTime","markRootUpdated","markRootSuspended","markRootSuspended_dontCallThisOneDirectly","markRootPinged","markRootEntangled","markRootFinished","getHighestPriorityLane","addFiberToLanesMap","movePendingFibersToMemoized","addTransitionToLanesMap","getTransitionsForLanes","DiscreteEventPriority","ContinuousEventPriority","DefaultEventPriority","IdleEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","lowerEventPriority","lanesToEventPriority","requestCurrentTransition","NoTransition","SelectiveHydrationException","beginWork","originalBeginWork","replayFunctionComponent","completeWork","unwindWork","unwindInterruptedWork","throwException","createRootErrorUpdate","createClassErrorUpdate","commitBeforeMutationEffects","commitLayoutEffects","commitMutationEffects","commitPassiveEffectDurations","commitPassiveMountEffects","commitPassiveUnmountEffects","disappearLayoutEffects","reconnectPassiveEffects","reappearLayoutEffects","disconnectPassiveEffect","reportUncaughtErrorInDEV","invokeLayoutEffectMountInDEV","invokePassiveEffectMountInDEV","invokeLayoutEffectUnmountInDEV","invokePassiveEffectUnmountInDEV","enqueueUpdate","resetContextDependencies","resetHooksAfterThrow","resetHooksOnUnwind","ContextOnlyDispatcher","DefaultCacheDispatcher","createCapturedValueAtFiber","enqueueConcurrentRenderForLane","finishQueueingConcurrentUpdates","getConcurrentlyUpdatedLanes","markNestedUpdateScheduled","recordCommitTime","resetNestedUpdateFlag","startProfilerTimer","stopProfilerTimerIfRunningAndRecordDelta","syncNestedUpdateFlag","getComponentNameFromFiber","ReactStrictModeWarnings","isRendering","ReactCurrentDebugFiberIsRenderingInDEV","current","ReactCurrentFiberCurrent","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","invokeGuardedCallback","hasCaughtError","clearCaughtError","isDevToolsPresent","markCommitStarted","markCommitStopped","markComponentRenderStopped","markComponentSuspended","markComponentErrored","markLayoutEffectsStarted","markLayoutEffectsStopped","markPassiveEffectsStarted","markPassiveEffectsStopped","markRenderStarted","markRenderYielded","markRenderStopped","onCommitRoot","onCommitRootDevTools","onPostCommitRoot","onPostCommitRootDevTools","onCommitRootTestSelector","releaseCache","isLegacyActEnvironment","isConcurrentActEnvironment","processTransitionCallbacks","SuspenseException","getSuspendedThenable","isThenableResolved","schedulePostPaintCallback","getSuspenseHandler","isBadSuspenseFallback","resolveDefaultProps","ceil","Math","PossiblyWeakMap","WeakMap","Map","ReactCurrentDispatcher","ReactCurrentCache","ReactCurrentOwner","ReactCurrentBatchConfig","ReactCurrentActQueue","NoContext","BatchedContext","RenderContext","CommitContext","RootInProgress","RootFatalErrored","RootErrored","RootSuspended","RootSuspendedWithDelay","RootCompleted","RootDidNotComplete","executionContext","workInProgressRoot","workInProgress","workInProgressRootRenderLanes","NotSuspended","SuspendedOnError","SuspendedOnData","SuspendedOnImmediate","SuspendedOnDeprecatedThrowPromise","SuspendedAndReadyToUnwind","SuspendedOnHydration","workInProgressSuspendedReason","workInProgressThrownValue","workInProgressRootDidAttachPingListener","renderLanes","workInProgressRootExitStatus","workInProgressRootFatalError","workInProgressRootSkippedLanes","workInProgressRootInterleavedUpdatedLanes","workInProgressRootRenderPhaseUpdatedLanes","workInProgressRootPingedLanes","workInProgressRootConcurrentErrors","workInProgressRootRecoverableErrors","globalMostRecentFallbackTime","FALLBACK_THROTTLE_MS","workInProgressRootRenderTargetTime","Infinity","RENDER_TIMEOUT_MS","workInProgressTransitions","getWorkInProgressTransitions","currentPendingTransitionCallbacks","currentEndTime","addTransitionStartCallbackToPendingTransition","transition","transitionStart","transitionProgress","transitionComplete","markerProgress","markerIncomplete","markerComplete","push","addMarkerProgressCallbackToPendingTransition","markerName","transitions","pendingBoundaries","set","addMarkerIncompleteCallbackToPendingTransition","aborts","addMarkerCompleteCallbackToPendingTransition","addTransitionProgressCallbackToPendingTransition","boundaries","addTransitionCompleteCallbackToPendingTransition","resetRenderTimer","getRenderTargetTime","hasUncaughtError","firstUncaughtError","legacyErrorBoundariesThatAlreadyFailed","rootCommittingMutationOrLayoutEffects","rootDoesHavePassiveEffects","rootWithPendingPassiveEffects","pendingPassiveEffectsLanes","pendingPassiveProfilerEffects","pendingPassiveEffectsRemainingLanes","pendingPassiveTransitions","NESTED_UPDATE_LIMIT","nestedUpdateCount","rootWithNestedUpdates","isFlushingPassiveEffects","didScheduleUpdateDuringPassiveEffects","NESTED_PASSIVE_UPDATE_LIMIT","nestedPassiveUpdateCount","rootWithPassiveNestedUpdates","currentEventTime","currentEventTransitionLane","isRunningInsertionEffect","getWorkInProgressRoot","getWorkInProgressRootRenderLanes","requestEventTime","getCurrentTime","requestUpdateLane","fiber","mode","isTransition","__DEV__","_updatedFibers","Set","add","updateLane","eventLane","requestRetryLane","scheduleUpdateOnFiber","root","lane","eventTime","console","error","prepareFreshStack","warnAboutRenderPhaseUpdatesInDEV","warnIfUpdatesNotWrappedWithActDEV","tag","id","onNestedUpdateScheduled","memoizedProps","return","name","startTime","ensureRootIsScheduled","isBatchingLegacy","scheduleInitialHydrationOnRoot","lanes","isUnsafeClassRenderPhaseUpdate","currentTime","existingCallbackNode","callbackNode","nextLanes","callbackPriority","newCallbackPriority","existingCallbackPriority","fakeActCallbackNode","newCallbackNode","didScheduleLegacyUpdate","performSyncWorkOnRoot","bind","schedulerPriorityLevel","performConcurrentWorkOnRoot","didTimeout","Error","originalCallbackNode","didFlushPassiveEffects","flushPassiveEffects","shouldTimeSlice","exitStatus","renderRootConcurrent","renderRootSync","originallyAttemptedLanes","errorRetryLanes","recoverFromConcurrentError","fatalError","renderWasConcurrent","finishedWork","alternate","isRenderConsistentWithExternalStores","finishedLanes","finishConcurrentRender","errorsFromFirstAttempt","wasRootDehydrated","rootWorkInProgress","flags","containerInfo","errorRecoveryDisabledLanes","errorsFromSecondAttempt","queueRecoverableErrors","errors","apply","commitRoot","shouldForceFlushFallbacksInDEV","msUntilTimeout","suspendedLanes","timeoutHandle","mostRecentEventTime","eventTimeMs","timeElapsedMs","jnd","node","updateQueue","checks","stores","i","length","check","getSnapshot","renderedValue","value","child","subtreeFlags","sibling","flushRoot","getExecutionContext","deferredUpdates","fn","previousPriority","prevTransition","batchedUpdates","a","prevExecutionContext","discreteUpdates","b","c","d","flushSync","undefined","isAlreadyRendering","isInvalidExecutionContextForEventFunction","flushControlled","setRenderLanes","subtreeRenderLanes","getRenderLanes","resetWorkInProgressStack","interruptedWork","resetSuspendedWorkLoopOnUnwind","discardPendingWarnings","handleThrow","thrownValue","shouldAttemptToSuspendUntilDataResolves","isWakeable","then","erroredWork","wakeable","suspenseHandler","currentSuspenseHandler","nextProps","pushDispatcher","container","prevDispatcher","popDispatcher","pushCacheDispatcher","prevCacheDispatcher","popCacheDispatcher","markCommitTimeOfFallback","markSkippedUpdateLanes","renderDidSuspend","renderDidSuspendDelayIfPossible","renderDidError","renderHasNotSuspendedYet","memoizedUpdaters","size","restorePendingUpdaters","clear","outer","unitOfWork","unwindSuspendedUnitOfWork","workLoopSync","performUnitOfWork","thenable","replaySuspendedUnitOfWork","onResolution","workLoopConcurrent","next","pendingProps","completeUnitOfWork","isProfilingMode","Component","type","unresolvedProps","resolvedProps","elementType","returnFiber","completedWork","actualDuration","deletions","siblingFiber","recoverableErrors","previousUpdateLanePriority","commitRootImpl","renderPriorityLevel","flushRenderPhaseStrictModeWarningsInDEV","remainingLanes","childLanes","concurrentlyUpdatedLanes","subtreeHasEffects","rootHasEffect","shouldFireAfterActiveInstanceBlur","rootDidHavePassiveEffects","releaseRootPooledCache","pendingLanes","commitDoubleInvokeEffectsInDEV","stateNode","onRecoverableError","recoverableError","errorInfo","makeErrorInfo","digest","stack","prevRootTransitionCallbacks","transitionCallbacks","endTime","prevPendingTransitionCallbacks","componentStack","Object","defineProperty","configurable","enumerable","get","pooledCacheLanes","pooledCache","renderPriority","priority","flushPassiveEffectsImpl","enqueuePendingPassiveProfilerEffect","profilerEffects","prevEndTime","effectDuration","passiveEffectDuration","isAlreadyFailedLegacyErrorBoundary","instance","has","markLegacyErrorBoundaryAsFailed","prepareToThrowUncaughtError","onUncaughtError","captureCommitPhaseErrorOnRoot","rootFiber","sourceFiber","update","captureCommitPhaseError","nearestMountedAncestor","setIsRunningInsertionEffect","ctor","getDerivedStateFromError","componentDidCatch","attachPingListener","pingCache","threadIDs","ping","pingSuspendedRoot","pingedLanes","delete","warnIfSuspenseResolutionNotWrappedWithActDEV","retryTimedOutBoundary","boundaryFiber","retryLane","retryDehydratedSuspenseBoundary","suspenseState","memoizedState","resolveRetryWakeable","retryCache","_retryCache","timeElapsed","throwIfInfiniteUpdateLoopDetected","flushLegacyContextWarning","flushPendingUnsafeLifecycleWarnings","recursivelyTraverseAndDoubleInvokeEffectsInDEV","parentFiber","isInStrictMode","doubleInvokeEffectsInDEVIfNecessary","doubleInvokeEffectsOnFiber","parentIsInStrictMode","isStrictModeFiber","hasPassiveEffects","doubleInvokeEffects","legacyCommitDoubleInvokeEffectsInDEV","invokeEffectsInDev","firstChild","fiberFlags","invokeEffectFn","subtreeRoot","primarySubtreeFlag","didWarnStateUpdateForNotYetMountedComponent","warnAboutUpdateOnNotYetMountedFiberInDEV","componentName","previousFiber","dummyFiber","originalWorkInProgressCopy","originalError","replayError","_suppressLogging","didWarnAboutUpdateInRender","didWarnAboutUpdateInRenderForAnotherComponent","renderingComponentName","dedupeKey","setStateComponentName","forEach","schedulingFiber","priorityLevel","callback","actQueue","isRunning"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {REACT_STRICT_MODE_TYPE} from 'shared/ReactSymbols';\n\nimport type {Wakeable, Thenable} from 'shared/ReactTypes';\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Lanes, Lane} from './ReactFiberLane';\nimport type {SuspenseProps, SuspenseState} from './ReactFiberSuspenseComponent';\nimport type {FunctionComponentUpdateQueue} from './ReactFiberHooks';\nimport type {EventPriority} from './ReactEventPriorities';\nimport type {\n  PendingTransitionCallbacks,\n  PendingBoundaries,\n  Transition,\n  TransitionAbort,\n} from './ReactFiberTracingMarkerComponent';\nimport type {OffscreenInstance} from './ReactFiberOffscreenComponent';\n\nimport {\n  warnAboutDeprecatedLifecycles,\n  replayFailedUnitOfWorkWithInvokeGuardedCallback,\n  enableCreateEventHandleAPI,\n  enableProfilerTimer,\n  enableProfilerCommitHooks,\n  enableProfilerNestedUpdatePhase,\n  enableProfilerNestedUpdateScheduledHook,\n  deferRenderPhaseUpdateToNextBatch,\n  enableDebugTracing,\n  enableSchedulingProfiler,\n  disableSchedulerTimeoutInWorkLoop,\n  skipUnmountedBoundaries,\n  enableUpdaterTracking,\n  enableCache,\n  enableTransitionTracing,\n  useModernStrictMode,\n} from 'shared/ReactFeatureFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport is from 'shared/objectIs';\n\nimport {\n  // Aliased because `act` will override and push to an internal queue\n  scheduleCallback as Scheduler_scheduleCallback,\n  cancelCallback as Scheduler_cancelCallback,\n  shouldYield,\n  requestPaint,\n  now,\n  ImmediatePriority as ImmediateSchedulerPriority,\n  UserBlockingPriority as UserBlockingSchedulerPriority,\n  NormalPriority as NormalSchedulerPriority,\n  IdlePriority as IdleSchedulerPriority,\n} from './Scheduler';\nimport {\n  flushSyncCallbacks,\n  flushSyncCallbacksOnlyInLegacyMode,\n  scheduleSyncCallback,\n  scheduleLegacySyncCallback,\n} from './ReactFiberSyncTaskQueue';\nimport {\n  logCommitStarted,\n  logCommitStopped,\n  logLayoutEffectsStarted,\n  logLayoutEffectsStopped,\n  logPassiveEffectsStarted,\n  logPassiveEffectsStopped,\n  logRenderStarted,\n  logRenderStopped,\n} from './DebugTracing';\n\nimport {\n  resetAfterCommit,\n  scheduleTimeout,\n  cancelTimeout,\n  noTimeout,\n  afterActiveInstanceBlur,\n  getCurrentEventPriority,\n  supportsMicrotasks,\n  errorHydratingContainer,\n  scheduleMicrotask,\n  prepareRendererToRender,\n  resetRendererAfterRender,\n} from './ReactFiberHostConfig';\n\nimport {\n  createWorkInProgress,\n  assignFiberPropertiesInDEV,\n  resetWorkInProgress,\n} from './ReactFiber';\nimport {isRootDehydrated} from './ReactFiberShellHydration';\nimport {didSuspendOrErrorWhileHydratingDEV} from './ReactFiberHydrationContext';\nimport {\n  NoMode,\n  ProfileMode,\n  ConcurrentMode,\n  StrictLegacyMode,\n  StrictEffectsMode,\n} from './ReactTypeOfMode';\nimport {\n  HostRoot,\n  IndeterminateComponent,\n  ClassComponent,\n  SuspenseComponent,\n  SuspenseListComponent,\n  OffscreenComponent,\n  FunctionComponent,\n  ForwardRef,\n  MemoComponent,\n  SimpleMemoComponent,\n  Profiler,\n} from './ReactWorkTags';\nimport {ConcurrentRoot, LegacyRoot} from './ReactRootTags';\nimport type {Flags} from './ReactFiberFlags';\nimport {\n  NoFlags,\n  Incomplete,\n  StoreConsistency,\n  HostEffectMask,\n  ForceClientRender,\n  BeforeMutationMask,\n  MutationMask,\n  LayoutMask,\n  PassiveMask,\n  PlacementDEV,\n  Visibility,\n  MountPassiveDev,\n  MountLayoutDev,\n} from './ReactFiberFlags';\nimport {\n  NoLanes,\n  NoLane,\n  SyncLane,\n  NoTimestamp,\n  claimNextTransitionLane,\n  claimNextRetryLane,\n  includesSyncLane,\n  isSubsetOfLanes,\n  mergeLanes,\n  removeLanes,\n  pickArbitraryLane,\n  includesNonIdleWork,\n  includesOnlyRetries,\n  includesOnlyTransitions,\n  includesBlockingLane,\n  includesExpiredLane,\n  getNextLanes,\n  markStarvedLanesAsExpired,\n  getLanesToRetrySynchronouslyOnError,\n  getMostRecentEventTime,\n  markRootUpdated,\n  markRootSuspended as markRootSuspended_dontCallThisOneDirectly,\n  markRootPinged,\n  markRootEntangled,\n  markRootFinished,\n  getHighestPriorityLane,\n  addFiberToLanesMap,\n  movePendingFibersToMemoized,\n  addTransitionToLanesMap,\n  getTransitionsForLanes,\n} from './ReactFiberLane';\nimport {\n  DiscreteEventPriority,\n  ContinuousEventPriority,\n  DefaultEventPriority,\n  IdleEventPriority,\n  getCurrentUpdatePriority,\n  setCurrentUpdatePriority,\n  lowerEventPriority,\n  lanesToEventPriority,\n} from './ReactEventPriorities';\nimport {requestCurrentTransition, NoTransition} from './ReactFiberTransition';\nimport {\n  SelectiveHydrationException,\n  beginWork as originalBeginWork,\n  replayFunctionComponent,\n} from './ReactFiberBeginWork';\nimport {completeWork} from './ReactFiberCompleteWork';\nimport {unwindWork, unwindInterruptedWork} from './ReactFiberUnwindWork';\nimport {\n  throwException,\n  createRootErrorUpdate,\n  createClassErrorUpdate,\n} from './ReactFiberThrow';\nimport {\n  commitBeforeMutationEffects,\n  commitLayoutEffects,\n  commitMutationEffects,\n  commitPassiveEffectDurations,\n  commitPassiveMountEffects,\n  commitPassiveUnmountEffects,\n  disappearLayoutEffects,\n  reconnectPassiveEffects,\n  reappearLayoutEffects,\n  disconnectPassiveEffect,\n  reportUncaughtErrorInDEV,\n  invokeLayoutEffectMountInDEV,\n  invokePassiveEffectMountInDEV,\n  invokeLayoutEffectUnmountInDEV,\n  invokePassiveEffectUnmountInDEV,\n} from './ReactFiberCommitWork';\nimport {enqueueUpdate} from './ReactFiberClassUpdateQueue';\nimport {resetContextDependencies} from './ReactFiberNewContext';\nimport {\n  resetHooksAfterThrow,\n  resetHooksOnUnwind,\n  ContextOnlyDispatcher,\n} from './ReactFiberHooks';\nimport {DefaultCacheDispatcher} from './ReactFiberCache';\nimport {\n  createCapturedValueAtFiber,\n  type CapturedValue,\n} from './ReactCapturedValue';\nimport {\n  enqueueConcurrentRenderForLane,\n  finishQueueingConcurrentUpdates,\n  getConcurrentlyUpdatedLanes,\n} from './ReactFiberConcurrentUpdates';\n\nimport {\n  markNestedUpdateScheduled,\n  recordCommitTime,\n  resetNestedUpdateFlag,\n  startProfilerTimer,\n  stopProfilerTimerIfRunningAndRecordDelta,\n  syncNestedUpdateFlag,\n} from './ReactProfilerTimer';\n\n// DEV stuff\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {\n  isRendering as ReactCurrentDebugFiberIsRenderingInDEV,\n  current as ReactCurrentFiberCurrent,\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\n  setCurrentFiber as setCurrentDebugFiberInDEV,\n} from './ReactCurrentFiber';\nimport {\n  invokeGuardedCallback,\n  hasCaughtError,\n  clearCaughtError,\n} from 'shared/ReactErrorUtils';\nimport {\n  isDevToolsPresent,\n  markCommitStarted,\n  markCommitStopped,\n  markComponentRenderStopped,\n  markComponentSuspended,\n  markComponentErrored,\n  markLayoutEffectsStarted,\n  markLayoutEffectsStopped,\n  markPassiveEffectsStarted,\n  markPassiveEffectsStopped,\n  markRenderStarted,\n  markRenderYielded,\n  markRenderStopped,\n  onCommitRoot as onCommitRootDevTools,\n  onPostCommitRoot as onPostCommitRootDevTools,\n} from './ReactFiberDevToolsHook';\nimport {onCommitRoot as onCommitRootTestSelector} from './ReactTestSelectors';\nimport {releaseCache} from './ReactFiberCacheComponent';\nimport {\n  isLegacyActEnvironment,\n  isConcurrentActEnvironment,\n} from './ReactFiberAct';\nimport {processTransitionCallbacks} from './ReactFiberTracingMarkerComponent';\nimport {\n  SuspenseException,\n  getSuspendedThenable,\n  isThenableResolved,\n} from './ReactFiberThenable';\nimport {schedulePostPaintCallback} from './ReactPostPaintCallback';\nimport {\n  getSuspenseHandler,\n  isBadSuspenseFallback,\n} from './ReactFiberSuspenseContext';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent';\n\nconst ceil = Math.ceil;\n\nconst PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\nconst {\n  ReactCurrentDispatcher,\n  ReactCurrentCache,\n  ReactCurrentOwner,\n  ReactCurrentBatchConfig,\n  ReactCurrentActQueue,\n} = ReactSharedInternals;\n\ntype ExecutionContext = number;\n\nexport const NoContext = /*             */ 0b000;\nconst BatchedContext = /*               */ 0b001;\nexport const RenderContext = /*         */ 0b010;\nexport const CommitContext = /*         */ 0b100;\n\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5 | 6;\nconst RootInProgress = 0;\nconst RootFatalErrored = 1;\nconst RootErrored = 2;\nconst RootSuspended = 3;\nconst RootSuspendedWithDelay = 4;\nconst RootCompleted = 5;\nconst RootDidNotComplete = 6;\n\n// Describes where we are in the React execution stack\nlet executionContext: ExecutionContext = NoContext;\n// The root we're working on\nlet workInProgressRoot: FiberRoot | null = null;\n// The fiber we're working on\nlet workInProgress: Fiber | null = null;\n// The lanes we're rendering\nlet workInProgressRootRenderLanes: Lanes = NoLanes;\n\nopaque type SuspendedReason = 0 | 1 | 2 | 3 | 4 | 5 | 6;\nconst NotSuspended: SuspendedReason = 0;\nconst SuspendedOnError: SuspendedReason = 1;\nconst SuspendedOnData: SuspendedReason = 2;\nconst SuspendedOnImmediate: SuspendedReason = 3;\nconst SuspendedOnDeprecatedThrowPromise: SuspendedReason = 4;\nconst SuspendedAndReadyToUnwind: SuspendedReason = 5;\nconst SuspendedOnHydration: SuspendedReason = 6;\n\n// When this is true, the work-in-progress fiber just suspended (or errored) and\n// we've yet to unwind the stack. In some cases, we may yield to the main thread\n// after this happens. If the fiber is pinged before we resume, we can retry\n// immediately instead of unwinding the stack.\nlet workInProgressSuspendedReason: SuspendedReason = NotSuspended;\nlet workInProgressThrownValue: mixed = null;\n\n// Whether a ping listener was attached during this render. This is slightly\n// different that whether something suspended, because we don't add multiple\n// listeners to a promise we've already seen (per root and lane).\nlet workInProgressRootDidAttachPingListener: boolean = false;\n\n// A contextual version of workInProgressRootRenderLanes. It is a superset of\n// the lanes that we started working on at the root. When we enter a subtree\n// that is currently hidden, we add the lanes that would have committed if\n// the hidden tree hadn't been deferred. This is modified by the\n// HiddenContext module.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with renderLanes.\nexport let renderLanes: Lanes = NoLanes;\n\n// Whether to root completed, errored, suspended, etc.\nlet workInProgressRootExitStatus: RootExitStatus = RootInProgress;\n// A fatal error, if one is thrown\nlet workInProgressRootFatalError: mixed = null;\n// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nlet workInProgressRootSkippedLanes: Lanes = NoLanes;\n// Lanes that were updated (in an interleaved event) during this render.\nlet workInProgressRootInterleavedUpdatedLanes: Lanes = NoLanes;\n// Lanes that were updated during the render phase (*not* an interleaved event).\nlet workInProgressRootRenderPhaseUpdatedLanes: Lanes = NoLanes;\n// Lanes that were pinged (in an interleaved event) during this render.\nlet workInProgressRootPingedLanes: Lanes = NoLanes;\n// Errors that are thrown during the render phase.\nlet workInProgressRootConcurrentErrors: Array<\n  CapturedValue<mixed>,\n> | null = null;\n// These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\nlet workInProgressRootRecoverableErrors: Array<\n  CapturedValue<mixed>,\n> | null = null;\n\n// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nlet globalMostRecentFallbackTime: number = 0;\nconst FALLBACK_THROTTLE_MS: number = 500;\n\n// The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\nlet workInProgressRootRenderTargetTime: number = Infinity;\n// How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\nconst RENDER_TIMEOUT_MS = 500;\n\nlet workInProgressTransitions: Array<Transition> | null = null;\nexport function getWorkInProgressTransitions(): null | Array<Transition> {\n  return workInProgressTransitions;\n}\n\nlet currentPendingTransitionCallbacks: PendingTransitionCallbacks | null = null;\nlet currentEndTime: number | null = null;\n\nexport function addTransitionStartCallbackToPendingTransition(\n  transition: Transition,\n) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: [],\n        transitionProgress: null,\n        transitionComplete: null,\n        markerProgress: null,\n        markerIncomplete: null,\n        markerComplete: null,\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.transitionStart === null) {\n      currentPendingTransitionCallbacks.transitionStart = [];\n    }\n\n    currentPendingTransitionCallbacks.transitionStart.push(transition);\n  }\n}\n\nexport function addMarkerProgressCallbackToPendingTransition(\n  markerName: string,\n  transitions: Set<Transition>,\n  pendingBoundaries: PendingBoundaries,\n) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = ({\n        transitionStart: null,\n        transitionProgress: null,\n        transitionComplete: null,\n        markerProgress: new Map(),\n        markerIncomplete: null,\n        markerComplete: null,\n      }: PendingTransitionCallbacks);\n    }\n\n    if (currentPendingTransitionCallbacks.markerProgress === null) {\n      currentPendingTransitionCallbacks.markerProgress = new Map();\n    }\n\n    currentPendingTransitionCallbacks.markerProgress.set(markerName, {\n      pendingBoundaries,\n      transitions,\n    });\n  }\n}\n\nexport function addMarkerIncompleteCallbackToPendingTransition(\n  markerName: string,\n  transitions: Set<Transition>,\n  aborts: Array<TransitionAbort>,\n) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: null,\n        transitionProgress: null,\n        transitionComplete: null,\n        markerProgress: null,\n        markerIncomplete: new Map(),\n        markerComplete: null,\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.markerIncomplete === null) {\n      currentPendingTransitionCallbacks.markerIncomplete = new Map();\n    }\n\n    currentPendingTransitionCallbacks.markerIncomplete.set(markerName, {\n      transitions,\n      aborts,\n    });\n  }\n}\n\nexport function addMarkerCompleteCallbackToPendingTransition(\n  markerName: string,\n  transitions: Set<Transition>,\n) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: null,\n        transitionProgress: null,\n        transitionComplete: null,\n        markerProgress: null,\n        markerIncomplete: null,\n        markerComplete: new Map(),\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.markerComplete === null) {\n      currentPendingTransitionCallbacks.markerComplete = new Map();\n    }\n\n    currentPendingTransitionCallbacks.markerComplete.set(\n      markerName,\n      transitions,\n    );\n  }\n}\n\nexport function addTransitionProgressCallbackToPendingTransition(\n  transition: Transition,\n  boundaries: PendingBoundaries,\n) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: null,\n        transitionProgress: new Map(),\n        transitionComplete: null,\n        markerProgress: null,\n        markerIncomplete: null,\n        markerComplete: null,\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.transitionProgress === null) {\n      currentPendingTransitionCallbacks.transitionProgress = new Map();\n    }\n\n    currentPendingTransitionCallbacks.transitionProgress.set(\n      transition,\n      boundaries,\n    );\n  }\n}\n\nexport function addTransitionCompleteCallbackToPendingTransition(\n  transition: Transition,\n) {\n  if (enableTransitionTracing) {\n    if (currentPendingTransitionCallbacks === null) {\n      currentPendingTransitionCallbacks = {\n        transitionStart: null,\n        transitionProgress: null,\n        transitionComplete: [],\n        markerProgress: null,\n        markerIncomplete: null,\n        markerComplete: null,\n      };\n    }\n\n    if (currentPendingTransitionCallbacks.transitionComplete === null) {\n      currentPendingTransitionCallbacks.transitionComplete = [];\n    }\n\n    currentPendingTransitionCallbacks.transitionComplete.push(transition);\n  }\n}\n\nfunction resetRenderTimer() {\n  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n}\n\nexport function getRenderTargetTime(): number {\n  return workInProgressRootRenderTargetTime;\n}\n\nlet hasUncaughtError = false;\nlet firstUncaughtError = null;\nlet legacyErrorBoundariesThatAlreadyFailed: Set<mixed> | null = null;\n\n// Only used when enableProfilerNestedUpdateScheduledHook is true;\n// to track which root is currently committing layout effects.\nlet rootCommittingMutationOrLayoutEffects: FiberRoot | null = null;\n\nlet rootDoesHavePassiveEffects: boolean = false;\nlet rootWithPendingPassiveEffects: FiberRoot | null = null;\nlet pendingPassiveEffectsLanes: Lanes = NoLanes;\nlet pendingPassiveProfilerEffects: Array<Fiber> = [];\nlet pendingPassiveEffectsRemainingLanes: Lanes = NoLanes;\nlet pendingPassiveTransitions: Array<Transition> | null = null;\n\n// Use these to prevent an infinite loop of nested updates\nconst NESTED_UPDATE_LIMIT = 50;\nlet nestedUpdateCount: number = 0;\nlet rootWithNestedUpdates: FiberRoot | null = null;\nlet isFlushingPassiveEffects = false;\nlet didScheduleUpdateDuringPassiveEffects = false;\n\nconst NESTED_PASSIVE_UPDATE_LIMIT = 50;\nlet nestedPassiveUpdateCount: number = 0;\nlet rootWithPassiveNestedUpdates: FiberRoot | null = null;\n\n// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nlet currentEventTime: number = NoTimestamp;\nlet currentEventTransitionLane: Lanes = NoLanes;\n\nlet isRunningInsertionEffect = false;\n\nexport function getWorkInProgressRoot(): FiberRoot | null {\n  return workInProgressRoot;\n}\n\nexport function getWorkInProgressRootRenderLanes(): Lanes {\n  return workInProgressRootRenderLanes;\n}\n\nexport function requestEventTime(): number {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return now();\n  }\n  // We're not inside React, so we may be in the middle of a browser event.\n  if (currentEventTime !== NoTimestamp) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  }\n  // This is the first update since React yielded. Compute a new start time.\n  currentEventTime = now();\n  return currentEventTime;\n}\n\nexport function getCurrentTime(): number {\n  return now();\n}\n\nexport function requestUpdateLane(fiber: Fiber): Lane {\n  // Special cases\n  const mode = fiber.mode;\n  if ((mode & ConcurrentMode) === NoMode) {\n    return (SyncLane: Lane);\n  } else if (\n    !deferRenderPhaseUpdateToNextBatch &&\n    (executionContext & RenderContext) !== NoContext &&\n    workInProgressRootRenderLanes !== NoLanes\n  ) {\n    // This is a render phase update. These are not officially supported. The\n    // old behavior is to give this the same \"thread\" (lanes) as\n    // whatever is currently rendering. So if you call `setState` on a component\n    // that happens later in the same render, it will flush. Ideally, we want to\n    // remove the special case and treat them as if they came from an\n    // interleaved event. Regardless, this pattern is not officially supported.\n    // This behavior is only a fallback. The flag only exists until we can roll\n    // out the setState warning, since existing code might accidentally rely on\n    // the current behavior.\n    return pickArbitraryLane(workInProgressRootRenderLanes);\n  }\n\n  const isTransition = requestCurrentTransition() !== NoTransition;\n  if (isTransition) {\n    if (__DEV__ && ReactCurrentBatchConfig.transition !== null) {\n      const transition = ReactCurrentBatchConfig.transition;\n      if (!transition._updatedFibers) {\n        transition._updatedFibers = new Set();\n      }\n\n      transition._updatedFibers.add(fiber);\n    }\n    // The algorithm for assigning an update to a lane should be stable for all\n    // updates at the same priority within the same event. To do this, the\n    // inputs to the algorithm must be the same.\n    //\n    // The trick we use is to cache the first of each of these inputs within an\n    // event. Then reset the cached values once we can be sure the event is\n    // over. Our heuristic for that is whenever we enter a concurrent work loop.\n    if (currentEventTransitionLane === NoLane) {\n      // All transitions within the same event are assigned the same lane.\n      currentEventTransitionLane = claimNextTransitionLane();\n    }\n    return currentEventTransitionLane;\n  }\n\n  // Updates originating inside certain React methods, like flushSync, have\n  // their priority set by tracking it with a context variable.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n  const updateLane: Lane = (getCurrentUpdatePriority(): any);\n  if (updateLane !== NoLane) {\n    return updateLane;\n  }\n\n  // This update originated outside React. Ask the host environment for an\n  // appropriate priority, based on the type of event.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n  const eventLane: Lane = (getCurrentEventPriority(): any);\n  return eventLane;\n}\n\nfunction requestRetryLane(fiber: Fiber) {\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\n  // \"retries\" — a special update that attempts to flip a Suspense boundary\n  // from its placeholder state to its primary/resolved state.\n\n  // Special cases\n  const mode = fiber.mode;\n  if ((mode & ConcurrentMode) === NoMode) {\n    return (SyncLane: Lane);\n  }\n\n  return claimNextRetryLane();\n}\n\nexport function scheduleUpdateOnFiber(\n  root: FiberRoot,\n  fiber: Fiber,\n  lane: Lane,\n  eventTime: number,\n) {\n  if (__DEV__) {\n    if (isRunningInsertionEffect) {\n      console.error('useInsertionEffect must not schedule updates.');\n    }\n  }\n\n  if (__DEV__) {\n    if (isFlushingPassiveEffects) {\n      didScheduleUpdateDuringPassiveEffects = true;\n    }\n  }\n\n  // Check if the work loop is currently suspended and waiting for data to\n  // finish loading.\n  if (\n    workInProgressSuspendedReason === SuspendedOnData &&\n    root === workInProgressRoot\n  ) {\n    // The incoming update might unblock the current render. Interrupt the\n    // current attempt and restart from the top.\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended(root, workInProgressRootRenderLanes);\n  }\n\n  // Mark that the root has a pending update.\n  markRootUpdated(root, lane, eventTime);\n\n  if (\n    (executionContext & RenderContext) !== NoLanes &&\n    root === workInProgressRoot\n  ) {\n    // This update was dispatched during the render phase. This is a mistake\n    // if the update originates from user space (with the exception of local\n    // hook updates, which are handled differently and don't reach this\n    // function), but there are some internal React features that use this as\n    // an implementation detail, like selective hydration.\n    warnAboutRenderPhaseUpdatesInDEV(fiber);\n\n    // Track lanes that were updated during the render phase\n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(\n      workInProgressRootRenderPhaseUpdatedLanes,\n      lane,\n    );\n  } else {\n    // This is a normal update, scheduled from outside the render phase. For\n    // example, during an input event.\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        addFiberToLanesMap(root, fiber, lane);\n      }\n    }\n\n    warnIfUpdatesNotWrappedWithActDEV(fiber);\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      if (\n        (executionContext & CommitContext) !== NoContext &&\n        root === rootCommittingMutationOrLayoutEffects\n      ) {\n        if (fiber.mode & ProfileMode) {\n          let current: null | Fiber = fiber;\n          while (current !== null) {\n            if (current.tag === Profiler) {\n              const {id, onNestedUpdateScheduled} = current.memoizedProps;\n              if (typeof onNestedUpdateScheduled === 'function') {\n                onNestedUpdateScheduled(id);\n              }\n            }\n            current = current.return;\n          }\n        }\n      }\n    }\n\n    if (enableTransitionTracing) {\n      const transition = ReactCurrentBatchConfig.transition;\n      if (transition !== null && transition.name != null) {\n        if (transition.startTime === -1) {\n          transition.startTime = now();\n        }\n\n        addTransitionToLanesMap(root, transition, lane);\n      }\n    }\n\n    if (root === workInProgressRoot) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that there was an interleaved update work on this root. Unless the\n      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n      // phase update. In that case, we don't treat render phase updates as if\n      // they were interleaved, for backwards compat reasons.\n      if (\n        deferRenderPhaseUpdateToNextBatch ||\n        (executionContext & RenderContext) === NoContext\n      ) {\n        workInProgressRootInterleavedUpdatedLanes = mergeLanes(\n          workInProgressRootInterleavedUpdatedLanes,\n          lane,\n        );\n      }\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended(root, workInProgressRootRenderLanes);\n      }\n    }\n\n    ensureRootIsScheduled(root, eventTime);\n    if (\n      lane === SyncLane &&\n      executionContext === NoContext &&\n      (fiber.mode & ConcurrentMode) === NoMode &&\n      // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)\n    ) {\n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\n\nexport function scheduleInitialHydrationOnRoot(\n  root: FiberRoot,\n  lane: Lane,\n  eventTime: number,\n) {\n  // This is a special fork of scheduleUpdateOnFiber that is only used to\n  // schedule the initial hydration of a root that has just been created. Most\n  // of the stuff in scheduleUpdateOnFiber can be skipped.\n  //\n  // The main reason for this separate path, though, is to distinguish the\n  // initial children from subsequent updates. In fully client-rendered roots\n  // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n  // updates, but hydration roots are special because the initial render must\n  // match what was rendered on the server.\n  const current = root.current;\n  current.lanes = lane;\n  markRootUpdated(root, lane, eventTime);\n  ensureRootIsScheduled(root, eventTime);\n}\n\nexport function isUnsafeClassRenderPhaseUpdate(fiber: Fiber): boolean {\n  // Check if this is a render phase update. Only called by class components,\n  // which special (deprecated) behavior for UNSAFE_componentWillReceive props.\n  return (\n    // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n    // decided not to enable it.\n    (!deferRenderPhaseUpdateToNextBatch ||\n      (fiber.mode & ConcurrentMode) === NoMode) &&\n    (executionContext & RenderContext) !== NoContext\n  );\n}\n\n// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\n  const existingCallbackNode = root.callbackNode;\n\n  // Check if any lanes are being starved by other work. If so, mark them as\n  // expired so we know to work on those next.\n  markStarvedLanesAsExpired(root, currentTime);\n\n  // Determine the next lanes to work on, and their priority.\n  const nextLanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback(existingCallbackNode);\n    }\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  }\n\n  // We use the highest priority lane to represent the priority of the callback.\n  const newCallbackPriority = getHighestPriorityLane(nextLanes);\n\n  // Check if there's an existing task. We may be able to reuse it.\n  const existingCallbackPriority = root.callbackPriority;\n  if (\n    existingCallbackPriority === newCallbackPriority &&\n    // Special case related to `act`. If the currently scheduled task is a\n    // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n    // on the `act` queue.\n    !(\n      __DEV__ &&\n      ReactCurrentActQueue.current !== null &&\n      existingCallbackNode !== fakeActCallbackNode\n    )\n  ) {\n    if (__DEV__) {\n      // If we're going to re-use an existing task, it needs to exist.\n      // Assume that discrete update microtasks are non-cancellable and null.\n      // TODO: Temporary until we confirm this warning is not fired.\n      if (\n        existingCallbackNode == null &&\n        !includesSyncLane(existingCallbackPriority)\n      ) {\n        console.error(\n          'Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    }\n    // The priority hasn't changed. We can reuse the existing task. Exit.\n    return;\n  }\n\n  if (existingCallbackNode != null) {\n    // Cancel the existing callback. We'll schedule a new one below.\n    cancelCallback(existingCallbackNode);\n  }\n\n  // Schedule a new callback.\n  let newCallbackNode;\n  if (includesSyncLane(newCallbackPriority)) {\n    // Special case: Sync React callbacks are scheduled on a special\n    // internal queue\n    if (root.tag === LegacyRoot) {\n      if (__DEV__ && ReactCurrentActQueue.isBatchingLegacy !== null) {\n        ReactCurrentActQueue.didScheduleLegacyUpdate = true;\n      }\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n    } else {\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }\n    if (supportsMicrotasks) {\n      // Flush the queue in a microtask.\n      if (__DEV__ && ReactCurrentActQueue.current !== null) {\n        // Inside `act`, use our internal `act` queue so that these get flushed\n        // at the end of the current scope even when using the sync version\n        // of `act`.\n        ReactCurrentActQueue.current.push(flushSyncCallbacks);\n      } else {\n        scheduleMicrotask(() => {\n          // In Safari, appending an iframe forces microtasks to run.\n          // https://github.com/facebook/react/issues/22459\n          // We don't support running callbacks in the middle of render\n          // or commit so we need to check against that.\n          if (\n            (executionContext & (RenderContext | CommitContext)) ===\n            NoContext\n          ) {\n            // Note that this would still prematurely flush the callbacks\n            // if this happens outside render or commit phase (e.g. in an event).\n            flushSyncCallbacks();\n          }\n        });\n      }\n    } else {\n      // Flush the queue in an Immediate task.\n      scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);\n    }\n    newCallbackNode = null;\n  } else {\n    let schedulerPriorityLevel;\n    switch (lanesToEventPriority(nextLanes)) {\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\n        break;\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\n        break;\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority;\n        break;\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n    }\n    newCallbackNode = scheduleCallback(\n      schedulerPriorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  }\n\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n}\n\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n    resetNestedUpdateFlag();\n  }\n\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoTimestamp;\n  currentEventTransitionLane = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  // Flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n  const originalCallbackNode = root.callbackNode;\n  const didFlushPassiveEffects = flushPassiveEffects();\n  if (didFlushPassiveEffects) {\n    // Something in the passive effect phase may have canceled the current task.\n    // Check if the task node for this root was changed.\n    if (root.callbackNode !== originalCallbackNode) {\n      // The current task was canceled. Exit. We don't need to call\n      // `ensureRootIsScheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    } else {\n      // Current task was not canceled. Continue.\n    }\n  }\n\n  // Determine the next lanes to work on, using the fields stored\n  // on the root.\n  let lanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n  if (lanes === NoLanes) {\n    // Defensive coding. This is never expected to happen.\n    return null;\n  }\n\n  // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n  // bug we're still investigating. Once the bug in Scheduler is fixed,\n  // we can remove this, since we track expiration ourselves.\n  const shouldTimeSlice =\n    !includesBlockingLane(root, lanes) &&\n    !includesExpiredLane(root, lanes) &&\n    (disableSchedulerTimeoutInWorkLoop || !didTimeout);\n  let exitStatus = shouldTimeSlice\n    ? renderRootConcurrent(root, lanes)\n    : renderRootSync(root, lanes);\n  if (exitStatus !== RootInProgress) {\n    if (exitStatus === RootErrored) {\n      // If something threw an error, try rendering one more time. We'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. If it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      const originallyAttemptedLanes = lanes;\n      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(\n        root,\n        originallyAttemptedLanes,\n      );\n      if (errorRetryLanes !== NoLanes) {\n        lanes = errorRetryLanes;\n        exitStatus = recoverFromConcurrentError(\n          root,\n          originallyAttemptedLanes,\n          errorRetryLanes,\n        );\n      }\n    }\n    if (exitStatus === RootFatalErrored) {\n      const fatalError = workInProgressRootFatalError;\n      prepareFreshStack(root, NoLanes);\n      markRootSuspended(root, lanes);\n      ensureRootIsScheduled(root, now());\n      throw fatalError;\n    }\n\n    if (exitStatus === RootDidNotComplete) {\n      // The render unwound without completing the tree. This happens in special\n      // cases where need to exit the current render without producing a\n      // consistent tree or committing.\n      markRootSuspended(root, lanes);\n    } else {\n      // The render completed.\n\n      // Check if this render may have yielded to a concurrent event, and if so,\n      // confirm that any newly rendered stores are consistent.\n      // TODO: It's possible that even a concurrent render may never have yielded\n      // to the main thread, if it was fast enough, or if it expired. We could\n      // skip the consistency check in that case, too.\n      const renderWasConcurrent = !includesBlockingLane(root, lanes);\n      const finishedWork: Fiber = (root.current.alternate: any);\n      if (\n        renderWasConcurrent &&\n        !isRenderConsistentWithExternalStores(finishedWork)\n      ) {\n        // A store was mutated in an interleaved event. Render again,\n        // synchronously, to block further mutations.\n        exitStatus = renderRootSync(root, lanes);\n\n        // We need to check again if something threw\n        if (exitStatus === RootErrored) {\n          const originallyAttemptedLanes = lanes;\n          const errorRetryLanes = getLanesToRetrySynchronouslyOnError(\n            root,\n            originallyAttemptedLanes,\n          );\n          if (errorRetryLanes !== NoLanes) {\n            lanes = errorRetryLanes;\n            exitStatus = recoverFromConcurrentError(\n              root,\n              originallyAttemptedLanes,\n              errorRetryLanes,\n            );\n            // We assume the tree is now consistent because we didn't yield to any\n            // concurrent events.\n          }\n        }\n        if (exitStatus === RootFatalErrored) {\n          const fatalError = workInProgressRootFatalError;\n          prepareFreshStack(root, NoLanes);\n          markRootSuspended(root, lanes);\n          ensureRootIsScheduled(root, now());\n          throw fatalError;\n        }\n\n        // FIXME: Need to check for RootDidNotComplete again. The factoring here\n        // isn't ideal.\n      }\n\n      // We now have a consistent tree. The next step is either to commit it,\n      // or, if something suspended, wait to commit it after a timeout.\n      root.finishedWork = finishedWork;\n      root.finishedLanes = lanes;\n      finishConcurrentRender(root, exitStatus, lanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, now());\n  if (root.callbackNode === originalCallbackNode) {\n    // The task node scheduled for this root is the same one that's\n    // currently executed. Need to return a continuation.\n    if (\n      workInProgressSuspendedReason === SuspendedOnData &&\n      workInProgressRoot === root\n    ) {\n      // Special case: The work loop is currently suspended and waiting for\n      // data to resolve. Unschedule the current task.\n      //\n      // TODO: The factoring is a little weird. Arguably this should be checked\n      // in ensureRootIsScheduled instead. I went back and forth, not totally\n      // sure yet.\n      root.callbackPriority = NoLane;\n      root.callbackNode = null;\n      return null;\n    }\n    return performConcurrentWorkOnRoot.bind(null, root);\n  }\n  return null;\n}\n\nfunction recoverFromConcurrentError(\n  root,\n  originallyAttemptedLanes,\n  errorRetryLanes,\n) {\n  // If an error occurred during hydration, discard server response and fall\n  // back to client side render.\n\n  // Before rendering again, save the errors from the previous attempt.\n  const errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n\n  const wasRootDehydrated = isRootDehydrated(root);\n  if (wasRootDehydrated) {\n    // The shell failed to hydrate. Set a flag to force a client rendering\n    // during the next attempt. To do this, we call prepareFreshStack now\n    // to create the root work-in-progress fiber. This is a bit weird in terms\n    // of factoring, because it relies on renderRootSync not calling\n    // prepareFreshStack again in the call below, which happens because the\n    // root and lanes haven't changed.\n    //\n    // TODO: I think what we should do is set ForceClientRender inside\n    // throwException, like we do for nested Suspense boundaries. The reason\n    // it's here instead is so we can switch to the synchronous work loop, too.\n    // Something to consider for a future refactor.\n    const rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n    rootWorkInProgress.flags |= ForceClientRender;\n    if (__DEV__) {\n      errorHydratingContainer(root.containerInfo);\n    }\n  }\n\n  const exitStatus = renderRootSync(root, errorRetryLanes);\n  if (exitStatus !== RootErrored) {\n    // Successfully finished rendering on retry\n\n    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n      // During the synchronous render, we attached additional ping listeners.\n      // This is highly suggestive of an uncached promise (though it's not the\n      // only reason this would happen). If it was an uncached promise, then\n      // it may have masked a downstream error from ocurring without actually\n      // fixing it. Example:\n      //\n      //    use(Promise.resolve('uncached'))\n      //    throw new Error('Oops!')\n      //\n      // When this happens, there's a conflict between blocking potential\n      // concurrent data races and unwrapping uncached promise values. We\n      // have to choose one or the other. Because the data race recovery is\n      // a last ditch effort, we'll disable it.\n      root.errorRecoveryDisabledLanes = mergeLanes(\n        root.errorRecoveryDisabledLanes,\n        originallyAttemptedLanes,\n      );\n\n      // Mark the current render as suspended and force it to restart. Once\n      // these lanes finish successfully, we'll re-enable the error recovery\n      // mechanism for subsequent updates.\n      workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes;\n      return RootSuspendedWithDelay;\n    }\n\n    // The errors from the failed first attempt have been recovered. Add\n    // them to the collection of recoverable errors. We'll log them in the\n    // commit phase.\n    const errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;\n    // The errors from the second attempt should be queued after the errors\n    // from the first attempt, to preserve the causal sequence.\n    if (errorsFromSecondAttempt !== null) {\n      queueRecoverableErrors(errorsFromSecondAttempt);\n    }\n  } else {\n    // The UI failed to recover.\n  }\n  return exitStatus;\n}\n\nexport function queueRecoverableErrors(errors: Array<CapturedValue<mixed>>) {\n  if (workInProgressRootRecoverableErrors === null) {\n    workInProgressRootRecoverableErrors = errors;\n  } else {\n    // $FlowFixMe[method-unbinding]\n    workInProgressRootRecoverableErrors.push.apply(\n      workInProgressRootRecoverableErrors,\n      errors,\n    );\n  }\n}\n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    case RootInProgress:\n    case RootFatalErrored: {\n      throw new Error('Root did not complete. This is a bug in React.');\n    }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n    case RootErrored: {\n      // We should have already attempted to retry this tree. If we reached\n      // this point, it errored again. Commit it.\n      commitRoot(\n        root,\n        workInProgressRootRecoverableErrors,\n        workInProgressTransitions,\n      );\n      break;\n    }\n    case RootSuspended: {\n      markRootSuspended(root, lanes);\n\n      // We have an acceptable loading state. We need to figure out if we\n      // should immediately commit it or wait a bit.\n\n      if (\n        includesOnlyRetries(lanes) &&\n        // do not delay if we're inside an act() scope\n        !shouldForceFlushFallbacksInDEV()\n      ) {\n        // This render only included retries, no updates. Throttle committing\n        // retries so that we don't show too many loading states too quickly.\n        const msUntilTimeout =\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          const nextLanes = getNextLanes(root, NoLanes);\n          if (nextLanes !== NoLanes) {\n            // There's additional work on this root.\n            break;\n          }\n          const suspendedLanes = root.suspendedLanes;\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n            // We should prefer to render the fallback of at the last\n            // suspended level. Ping the last suspended level to try\n            // rendering it again.\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\n            const eventTime = requestEventTime();\n            markRootPinged(root, suspendedLanes, eventTime);\n            break;\n          }\n\n          // The render is suspended, it hasn't timed out, and there's no\n          // lower priority work to do. Instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(\n              null,\n              root,\n              workInProgressRootRecoverableErrors,\n              workInProgressTransitions,\n            ),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      // The work expired. Commit immediately.\n      commitRoot(\n        root,\n        workInProgressRootRecoverableErrors,\n        workInProgressTransitions,\n      );\n      break;\n    }\n    case RootSuspendedWithDelay: {\n      markRootSuspended(root, lanes);\n\n      if (includesOnlyTransitions(lanes)) {\n        // This is a transition, so we should exit without committing a\n        // placeholder and without scheduling a timeout. Delay indefinitely\n        // until we receive more data.\n        break;\n      }\n\n      if (!shouldForceFlushFallbacksInDEV()) {\n        // This is not a transition, but we did trigger an avoided state.\n        // Schedule a placeholder to display after a short delay, using the Just\n        // Noticeable Difference.\n        // TODO: Is the JND optimization worth the added complexity? If this is\n        // the only reason we track the event time, then probably not.\n        // Consider removing.\n\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\n        const eventTimeMs = mostRecentEventTime;\n        const timeElapsedMs = now() - eventTimeMs;\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\n\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          // Instead of committing the fallback immediately, wait for more data\n          // to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(\n              null,\n              root,\n              workInProgressRootRecoverableErrors,\n              workInProgressTransitions,\n            ),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n\n      // Commit the placeholder.\n      commitRoot(\n        root,\n        workInProgressRootRecoverableErrors,\n        workInProgressTransitions,\n      );\n      break;\n    }\n    case RootCompleted: {\n      // The work completed. Ready to commit.\n      commitRoot(\n        root,\n        workInProgressRootRecoverableErrors,\n        workInProgressTransitions,\n      );\n      break;\n    }\n    default: {\n      throw new Error('Unknown root exit status.');\n    }\n  }\n}\n\nfunction isRenderConsistentWithExternalStores(finishedWork: Fiber): boolean {\n  // Search the rendered tree for external store reads, and check whether the\n  // stores were mutated in a concurrent event. Intentionally using an iterative\n  // loop instead of recursion so we can exit early.\n  let node: Fiber = finishedWork;\n  while (true) {\n    if (node.flags & StoreConsistency) {\n      const updateQueue: FunctionComponentUpdateQueue | null = (node.updateQueue: any);\n      if (updateQueue !== null) {\n        const checks = updateQueue.stores;\n        if (checks !== null) {\n          for (let i = 0; i < checks.length; i++) {\n            const check = checks[i];\n            const getSnapshot = check.getSnapshot;\n            const renderedValue = check.value;\n            try {\n              if (!is(getSnapshot(), renderedValue)) {\n                // Found an inconsistent store.\n                return false;\n              }\n            } catch (error) {\n              // If `getSnapshot` throws, return `false`. This will schedule\n              // a re-render, and the error will be rethrown during render.\n              return false;\n            }\n          }\n        }\n      }\n    }\n    const child = node.child;\n    if (node.subtreeFlags & StoreConsistency && child !== null) {\n      child.return = node;\n      node = child;\n      continue;\n    }\n    if (node === finishedWork) {\n      return true;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return true;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow doesn't know this is unreachable, but eslint does\n  // eslint-disable-next-line no-unreachable\n  return true;\n}\n\nfunction markRootSuspended(root, suspendedLanes) {\n  // When suspending, we should always exclude lanes that were pinged or (more\n  // rarely, since we try to avoid it) updated during the render phase.\n  // TODO: Lol maybe there's a better way to factor this besides this\n  // obnoxiously named function :)\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n  suspendedLanes = removeLanes(\n    suspendedLanes,\n    workInProgressRootInterleavedUpdatedLanes,\n  );\n  // $FlowFixMe[incompatible-call] found when upgrading Flow\n  markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes);\n}\n\n// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root) {\n  if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n    syncNestedUpdateFlag();\n  }\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  flushPassiveEffects();\n\n  let lanes = getNextLanes(root, NoLanes);\n  if (!includesSyncLane(lanes)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n\n  let exitStatus = renderRootSync(root, lanes);\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. If it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    const originallyAttemptedLanes = lanes;\n    const errorRetryLanes = getLanesToRetrySynchronouslyOnError(\n      root,\n      originallyAttemptedLanes,\n    );\n    if (errorRetryLanes !== NoLanes) {\n      lanes = errorRetryLanes;\n      exitStatus = recoverFromConcurrentError(\n        root,\n        originallyAttemptedLanes,\n        errorRetryLanes,\n      );\n    }\n  }\n\n  if (exitStatus === RootFatalErrored) {\n    const fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended(root, lanes);\n    ensureRootIsScheduled(root, now());\n    throw fatalError;\n  }\n\n  if (exitStatus === RootDidNotComplete) {\n    // The render unwound without completing the tree. This happens in special\n    // cases where need to exit the current render without producing a\n    // consistent tree or committing.\n    markRootSuspended(root, lanes);\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n\n  // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n  const finishedWork: Fiber = (root.current.alternate: any);\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  commitRoot(\n    root,\n    workInProgressRootRecoverableErrors,\n    workInProgressTransitions,\n  );\n\n  // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  ensureRootIsScheduled(root, now());\n\n  return null;\n}\n\nexport function flushRoot(root: FiberRoot, lanes: Lanes) {\n  if (lanes !== NoLanes) {\n    markRootEntangled(root, mergeLanes(lanes, SyncLane));\n    ensureRootIsScheduled(root, now());\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\n\nexport function getExecutionContext(): ExecutionContext {\n  return executionContext;\n}\n\nexport function deferredUpdates<A>(fn: () => A): A {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DefaultEventPriority);\n    return fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nexport function batchedUpdates<A, R>(fn: A => R, a: A): R {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext;\n    // If there were legacy sync updates, flush them at the end of the outer\n    // most batchedUpdates-like method.\n    if (\n      executionContext === NoContext &&\n      // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)\n    ) {\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\n\nexport function discreteUpdates<A, B, C, D, R>(\n  fn: (A, B, C, D) => R,\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n): R {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    return fn(a, b, c, d);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    if (executionContext === NoContext) {\n      resetRenderTimer();\n    }\n  }\n}\n\n// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-unused-vars\ndeclare function flushSync<R>(fn: () => R): R;\n// eslint-disable-next-line no-redeclare\ndeclare function flushSync(void): void;\n// eslint-disable-next-line no-redeclare\nexport function flushSync<R>(fn: (() => R) | void): R | void {\n  // In legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  if (\n    rootWithPendingPassiveEffects !== null &&\n    rootWithPendingPassiveEffects.tag === LegacyRoot &&\n    (executionContext & (RenderContext | CommitContext)) === NoContext\n  ) {\n    flushPassiveEffects();\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    executionContext = prevExecutionContext;\n    // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      flushSyncCallbacks();\n    }\n  }\n}\n\nexport function isAlreadyRendering(): boolean {\n  // Used by the renderer to print a warning if certain APIs are called from\n  // the wrong context.\n  return (\n    __DEV__ &&\n    (executionContext & (RenderContext | CommitContext)) !== NoContext\n  );\n}\n\nexport function isInvalidExecutionContextForEventFunction(): boolean {\n  // Used to throw if certain APIs are called from the wrong context.\n  return (executionContext & RenderContext) !== NoContext;\n}\n\nexport function flushControlled(fn: () => mixed): void {\n  const prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\n\n// This is called by the HiddenContext module when we enter or leave a\n// hidden subtree. The stack logic is managed there because that's the only\n// place that ever modifies it. Which module it lives in doesn't matter for\n// performance because this function will get inlined regardless\nexport function setRenderLanes(subtreeRenderLanes: Lanes) {\n  renderLanes = subtreeRenderLanes;\n}\n\nexport function getRenderLanes(): Lanes {\n  return renderLanes;\n}\n\nfunction resetWorkInProgressStack() {\n  if (workInProgress === null) return;\n  let interruptedWork;\n  if (workInProgressSuspendedReason === NotSuspended) {\n    // Normal case. Work-in-progress hasn't started yet. Unwind all\n    // its parents.\n    interruptedWork = workInProgress.return;\n  } else {\n    // Work-in-progress is in suspended state. Reset the work loop and unwind\n    // both the suspended fiber and all its parents.\n    resetSuspendedWorkLoopOnUnwind();\n    interruptedWork = workInProgress;\n  }\n  while (interruptedWork !== null) {\n    const current = interruptedWork.alternate;\n    unwindInterruptedWork(\n      current,\n      interruptedWork,\n      workInProgressRootRenderLanes,\n    );\n    interruptedWork = interruptedWork.return;\n  }\n  workInProgress = null;\n}\n\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes): Fiber {\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n\n  const timeoutHandle = root.timeoutHandle;\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout;\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n    cancelTimeout(timeoutHandle);\n  }\n\n  resetWorkInProgressStack();\n  workInProgressRoot = root;\n  const rootWorkInProgress = createWorkInProgress(root.current, null);\n  workInProgress = rootWorkInProgress;\n  workInProgressRootRenderLanes = renderLanes = lanes;\n  workInProgressSuspendedReason = NotSuspended;\n  workInProgressThrownValue = null;\n  workInProgressRootDidAttachPingListener = false;\n  workInProgressRootExitStatus = RootInProgress;\n  workInProgressRootFatalError = null;\n  workInProgressRootSkippedLanes = NoLanes;\n  workInProgressRootInterleavedUpdatedLanes = NoLanes;\n  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;\n  workInProgressRootPingedLanes = NoLanes;\n  workInProgressRootConcurrentErrors = null;\n  workInProgressRootRecoverableErrors = null;\n\n  finishQueueingConcurrentUpdates();\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n\n  return rootWorkInProgress;\n}\n\nfunction resetSuspendedWorkLoopOnUnwind() {\n  // Reset module-level state that was set during the render phase.\n  resetContextDependencies();\n  resetHooksOnUnwind();\n}\n\nfunction handleThrow(root, thrownValue): void {\n  // A component threw an exception. Usually this is because it suspended, but\n  // it also includes regular program errors.\n  //\n  // We're either going to unwind the stack to show a Suspense or error\n  // boundary, or we're going to replay the component again. Like after a\n  // promise resolves.\n  //\n  // Until we decide whether we're going to unwind or replay, we should preserve\n  // the current state of the work loop without resetting anything.\n  //\n  // If we do decide to unwind the stack, module-level variables will be reset\n  // in resetSuspendedWorkLoopOnUnwind.\n\n  // These should be reset immediately because they're only supposed to be set\n  // when React is executing user code.\n  resetHooksAfterThrow();\n  resetCurrentDebugFiberInDEV();\n  ReactCurrentOwner.current = null;\n\n  if (thrownValue === SuspenseException) {\n    // This is a special type of exception used for Suspense. For historical\n    // reasons, the rest of the Suspense implementation expects the thrown value\n    // to be a thenable, because before `use` existed that was the (unstable)\n    // API for suspending. This implementation detail can change later, once we\n    // deprecate the old API in favor of `use`.\n    thrownValue = getSuspendedThenable();\n    workInProgressSuspendedReason = shouldAttemptToSuspendUntilDataResolves()\n      ? SuspendedOnData\n      : SuspendedOnImmediate;\n  } else if (thrownValue === SelectiveHydrationException) {\n    // An update flowed into a dehydrated boundary. Before we can apply the\n    // update, we need to finish hydrating. Interrupt the work-in-progress\n    // render so we can restart at the hydration lane.\n    //\n    // The ideal implementation would be able to switch contexts without\n    // unwinding the current stack.\n    //\n    // We could name this something more general but as of now it's the only\n    // case where we think this should happen.\n    workInProgressSuspendedReason = SuspendedOnHydration;\n  } else {\n    // This is a regular error.\n    const isWakeable =\n      thrownValue !== null &&\n      typeof thrownValue === 'object' &&\n      // $FlowFixMe[method-unbinding]\n      typeof thrownValue.then === 'function';\n\n    workInProgressSuspendedReason = isWakeable\n      ? // A wakeable object was thrown by a legacy Suspense implementation.\n        // This has slightly different behavior than suspending with `use`.\n        SuspendedOnDeprecatedThrowPromise\n      : // This is a regular error. If something earlier in the component already\n        // suspended, we must clear the thenable state to unblock the work loop.\n        SuspendedOnError;\n  }\n\n  workInProgressThrownValue = thrownValue;\n\n  const erroredWork = workInProgress;\n  if (erroredWork === null) {\n    // This is a fatal error\n    workInProgressRootExitStatus = RootFatalErrored;\n    workInProgressRootFatalError = thrownValue;\n    return;\n  }\n\n  if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n    // Record the time spent rendering before an error was thrown. This\n    // avoids inaccurate Profiler durations in the case of a\n    // suspended render.\n    stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n    if (workInProgressSuspendedReason !== SuspendedOnError) {\n      const wakeable: Wakeable = (thrownValue: any);\n      markComponentSuspended(\n        erroredWork,\n        wakeable,\n        workInProgressRootRenderLanes,\n      );\n    } else {\n      markComponentErrored(\n        erroredWork,\n        thrownValue,\n        workInProgressRootRenderLanes,\n      );\n    }\n  }\n}\n\nfunction shouldAttemptToSuspendUntilDataResolves() {\n  // TODO: We should be able to move the\n  // renderDidSuspend/renderDidSuspendDelayIfPossible logic into this function,\n  // instead of repeating it in the complete phase. Or something to that effect.\n\n  if (includesOnlyRetries(workInProgressRootRenderLanes)) {\n    // We can always wait during a retry.\n    return true;\n  }\n\n  // Check if there are other pending updates that might possibly unblock this\n  // component from suspending. This mirrors the check in\n  // renderDidSuspendDelayIfPossible. We should attempt to unify them somehow.\n  if (\n    includesNonIdleWork(workInProgressRootSkippedLanes) ||\n    includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes)\n  ) {\n    // Suspend normally. renderDidSuspendDelayIfPossible will handle\n    // interrupting the work loop.\n    return false;\n  }\n\n  // TODO: We should be able to remove the equivalent check in\n  // finishConcurrentRender, and rely just on this one.\n  if (includesOnlyTransitions(workInProgressRootRenderLanes)) {\n    const suspenseHandler = getSuspenseHandler();\n    if (suspenseHandler !== null && suspenseHandler.tag === SuspenseComponent) {\n      const currentSuspenseHandler = suspenseHandler.alternate;\n      const nextProps: SuspenseProps = suspenseHandler.memoizedProps;\n      if (isBadSuspenseFallback(currentSuspenseHandler, nextProps)) {\n        // The nearest Suspense boundary is already showing content. We should\n        // avoid replacing it with a fallback, and instead wait until the\n        // data finishes loading.\n        return true;\n      } else {\n        // This is not a bad fallback condition. We should show a fallback\n        // immediately instead of waiting for the data to resolve. This includes\n        // when suspending inside new trees.\n        return false;\n      }\n    }\n\n    // During a transition, if there is no Suspense boundary (i.e. suspending in\n    // the \"shell\" of an application), or if we're inside a hidden tree, then\n    // we should wait until the data finishes loading.\n    return true;\n  }\n\n  // For all other Lanes besides Transitions and Retries, we should not wait\n  // for the data to load.\n  // TODO: We should wait during Offscreen prerendering, too.\n  return false;\n}\n\nfunction pushDispatcher(container) {\n  prepareRendererToRender(container);\n  const prevDispatcher = ReactCurrentDispatcher.current;\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  resetRendererAfterRender();\n  ReactCurrentDispatcher.current = prevDispatcher;\n}\n\nfunction pushCacheDispatcher() {\n  if (enableCache) {\n    const prevCacheDispatcher = ReactCurrentCache.current;\n    ReactCurrentCache.current = DefaultCacheDispatcher;\n    return prevCacheDispatcher;\n  } else {\n    return null;\n  }\n}\n\nfunction popCacheDispatcher(prevCacheDispatcher) {\n  if (enableCache) {\n    ReactCurrentCache.current = prevCacheDispatcher;\n  }\n}\n\nexport function markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now();\n}\n\nexport function markSkippedUpdateLanes(lane: Lane | Lanes): void {\n  workInProgressRootSkippedLanes = mergeLanes(\n    lane,\n    workInProgressRootSkippedLanes,\n  );\n}\n\nexport function renderDidSuspend(): void {\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\n\nexport function renderDidSuspendDelayIfPossible(): void {\n  workInProgressRootExitStatus = RootSuspendedWithDelay;\n\n  // Check if there are updates that we skipped tree that might have unblocked\n  // this render.\n  if (\n    workInProgressRoot !== null &&\n    (includesNonIdleWork(workInProgressRootSkippedLanes) ||\n      includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))\n  ) {\n    // Mark the current render as suspended so that we switch to working on\n    // the updates that were skipped. Usually we only suspend at the end of\n    // the render phase.\n    // TODO: We should probably always mark the root as suspended immediately\n    // (inside this function), since by suspending at the end of the render\n    // phase introduces a potential mistake where we suspend lanes that were\n    // pinged or updated while we were rendering.\n    markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes);\n  }\n}\n\nexport function renderDidError(error: CapturedValue<mixed>) {\n  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n  if (workInProgressRootConcurrentErrors === null) {\n    workInProgressRootConcurrentErrors = [error];\n  } else {\n    workInProgressRootConcurrentErrors.push(error);\n  }\n}\n\n// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nexport function renderHasNotSuspendedYet(): boolean {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootInProgress;\n}\n\n// TODO: Over time, this function and renderRootConcurrent have become more\n// and more similar. Not sure it makes sense to maintain forked paths. Consider\n// unifying them again.\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher(root.containerInfo);\n  const prevCacheDispatcher = pushCacheDispatcher();\n\n  // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        const memoizedUpdaters = root.memoizedUpdaters;\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        }\n\n        // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    workInProgressTransitions = getTransitionsForLanes(root, lanes);\n    prepareFreshStack(root, lanes);\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStarted(lanes);\n  }\n\n  outer: do {\n    try {\n      if (\n        workInProgressSuspendedReason !== NotSuspended &&\n        workInProgress !== null\n      ) {\n        // The work loop is suspended. During a synchronous render, we don't\n        // yield to the main thread. Immediately unwind the stack. This will\n        // trigger either a fallback or an error boundary.\n        // TODO: For discrete and \"default\" updates (anything that's not\n        // flushSync), we want to wait for the microtasks the flush before\n        // unwinding. Will probably implement this using renderRootConcurrent,\n        // or merge renderRootSync and renderRootConcurrent into the same\n        // function and fork the behavior some other way.\n        const unitOfWork = workInProgress;\n        const thrownValue = workInProgressThrownValue;\n        switch (workInProgressSuspendedReason) {\n          case SuspendedOnHydration: {\n            // Selective hydration. An update flowed into a dehydrated tree.\n            // Interrupt the current render so the work loop can switch to the\n            // hydration lane.\n            resetWorkInProgressStack();\n            workInProgressRootExitStatus = RootDidNotComplete;\n            break outer;\n          }\n          default: {\n            // Continue with the normal work loop.\n            workInProgressSuspendedReason = NotSuspended;\n            workInProgressThrownValue = null;\n            unwindSuspendedUnitOfWork(unitOfWork, thrownValue);\n            break;\n          }\n        }\n      }\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleThrow(root, thrownValue);\n    }\n  } while (true);\n  resetContextDependencies();\n\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n  popCacheDispatcher(prevCacheDispatcher);\n\n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    throw new Error(\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\n        'bug in React. Please file an issue.',\n    );\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStopped();\n  }\n\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n\n  // It's safe to process the queue now that the render phase is complete.\n  finishQueueingConcurrentUpdates();\n\n  return workInProgressRootExitStatus;\n}\n\n// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Perform work without checking if we need to yield between fiber.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher(root.containerInfo);\n  const prevCacheDispatcher = pushCacheDispatcher();\n\n  // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        const memoizedUpdaters = root.memoizedUpdaters;\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        }\n\n        // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n\n    workInProgressTransitions = getTransitionsForLanes(root, lanes);\n    resetRenderTimer();\n    prepareFreshStack(root, lanes);\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markRenderStarted(lanes);\n  }\n\n  outer: do {\n    try {\n      if (\n        workInProgressSuspendedReason !== NotSuspended &&\n        workInProgress !== null\n      ) {\n        // The work loop is suspended. We need to either unwind the stack or\n        // replay the suspended component.\n        const unitOfWork = workInProgress;\n        const thrownValue = workInProgressThrownValue;\n        switch (workInProgressSuspendedReason) {\n          case SuspendedOnError: {\n            // Unwind then continue with the normal work loop.\n            workInProgressSuspendedReason = NotSuspended;\n            workInProgressThrownValue = null;\n            unwindSuspendedUnitOfWork(unitOfWork, thrownValue);\n            break;\n          }\n          case SuspendedOnData: {\n            const thenable: Thenable<mixed> = (thrownValue: any);\n            if (isThenableResolved(thenable)) {\n              // The data resolved. Try rendering the component again.\n              workInProgressSuspendedReason = NotSuspended;\n              workInProgressThrownValue = null;\n              replaySuspendedUnitOfWork(unitOfWork);\n              break;\n            }\n            // The work loop is suspended on data. We should wait for it to\n            // resolve before continuing to render.\n            const onResolution = () => {\n              ensureRootIsScheduled(root, now());\n            };\n            thenable.then(onResolution, onResolution);\n            break outer;\n          }\n          case SuspendedOnImmediate: {\n            // If this fiber just suspended, it's possible the data is already\n            // cached. Yield to the main thread to give it a chance to ping. If\n            // it does, we can retry immediately without unwinding the stack.\n            workInProgressSuspendedReason = SuspendedAndReadyToUnwind;\n            break outer;\n          }\n          case SuspendedAndReadyToUnwind: {\n            const thenable: Thenable<mixed> = (thrownValue: any);\n            if (isThenableResolved(thenable)) {\n              // The data resolved. Try rendering the component again.\n              workInProgressSuspendedReason = NotSuspended;\n              workInProgressThrownValue = null;\n              replaySuspendedUnitOfWork(unitOfWork);\n            } else {\n              // Otherwise, unwind then continue with the normal work loop.\n              workInProgressSuspendedReason = NotSuspended;\n              workInProgressThrownValue = null;\n              unwindSuspendedUnitOfWork(unitOfWork, thrownValue);\n            }\n            break;\n          }\n          case SuspendedOnDeprecatedThrowPromise: {\n            // Suspended by an old implementation that uses the `throw promise`\n            // pattern. The newer replaying behavior can cause subtle issues\n            // like infinite ping loops. So we maintain the old behavior and\n            // always unwind.\n            workInProgressSuspendedReason = NotSuspended;\n            workInProgressThrownValue = null;\n            unwindSuspendedUnitOfWork(unitOfWork, thrownValue);\n            break;\n          }\n          case SuspendedOnHydration: {\n            // Selective hydration. An update flowed into a dehydrated tree.\n            // Interrupt the current render so the work loop can switch to the\n            // hydration lane.\n            resetWorkInProgressStack();\n            workInProgressRootExitStatus = RootDidNotComplete;\n            break outer;\n          }\n          default: {\n            throw new Error(\n              'Unexpected SuspendedReason. This is a bug in React.',\n            );\n          }\n        }\n      }\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleThrow(root, thrownValue);\n    }\n  } while (true);\n  resetContextDependencies();\n\n  popDispatcher(prevDispatcher);\n  popCacheDispatcher(prevCacheDispatcher);\n  executionContext = prevExecutionContext;\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  }\n\n  // Check if the tree has completed.\n  if (workInProgress !== null) {\n    // Still work remaining.\n    if (enableSchedulingProfiler) {\n      markRenderYielded();\n    }\n    return RootInProgress;\n  } else {\n    // Completed the tree.\n    if (enableSchedulingProfiler) {\n      markRenderStopped();\n    }\n\n    // Set this to null to indicate there's no in-progress render.\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes;\n\n    // It's safe to process the queue now that the render phase is complete.\n    finishQueueingConcurrentUpdates();\n\n    // Return the final exit status.\n    return workInProgressRootExitStatus;\n  }\n}\n\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    // $FlowFixMe[incompatible-call] found when upgrading Flow\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n  setCurrentDebugFiberInDEV(unitOfWork);\n\n  let next;\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderLanes);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, renderLanes);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n\nfunction replaySuspendedUnitOfWork(unitOfWork: Fiber): void {\n  // This is a fork of performUnitOfWork specifcally for replaying a fiber that\n  // just suspended.\n  //\n  const current = unitOfWork.alternate;\n  setCurrentDebugFiberInDEV(unitOfWork);\n\n  let next;\n  setCurrentDebugFiberInDEV(unitOfWork);\n  const isProfilingMode =\n    enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode;\n  if (isProfilingMode) {\n    startProfilerTimer(unitOfWork);\n  }\n  switch (unitOfWork.tag) {\n    case IndeterminateComponent: {\n      // Because it suspended with `use`, we can assume it's a\n      // function component.\n      unitOfWork.tag = FunctionComponent;\n      // Fallthrough to the next branch.\n    }\n    // eslint-disable-next-line no-fallthrough\n    case FunctionComponent:\n    case ForwardRef: {\n      // Resolve `defaultProps`. This logic is copied from `beginWork`.\n      // TODO: Consider moving this switch statement into that module. Also,\n      // could maybe use this as an opportunity to say `use` doesn't work with\n      // `defaultProps` :)\n      const Component = unitOfWork.type;\n      const unresolvedProps = unitOfWork.pendingProps;\n      const resolvedProps =\n        unitOfWork.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      next = replayFunctionComponent(\n        current,\n        unitOfWork,\n        resolvedProps,\n        Component,\n        workInProgressRootRenderLanes,\n      );\n      break;\n    }\n    case SimpleMemoComponent: {\n      const Component = unitOfWork.type;\n      const nextProps = unitOfWork.pendingProps;\n      next = replayFunctionComponent(\n        current,\n        unitOfWork,\n        nextProps,\n        Component,\n        workInProgressRootRenderLanes,\n      );\n      break;\n    }\n    default: {\n      if (__DEV__) {\n        console.error(\n          'Unexpected type of work: %s, Currently only function ' +\n            'components are replayed after suspending. This is a bug in React.',\n          unitOfWork.tag,\n        );\n      }\n      resetSuspendedWorkLoopOnUnwind();\n      unwindInterruptedWork(current, unitOfWork, workInProgressRootRenderLanes);\n      unitOfWork = workInProgress = resetWorkInProgress(\n        unitOfWork,\n        renderLanes,\n      );\n      next = beginWork(current, unitOfWork, renderLanes);\n      break;\n    }\n  }\n  if (isProfilingMode) {\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  }\n\n  // The begin phase finished successfully without suspending. Return to the\n  // normal work loop.\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n\nfunction unwindSuspendedUnitOfWork(unitOfWork: Fiber, thrownValue: mixed) {\n  // This is a fork of performUnitOfWork specifcally for unwinding a fiber\n  // that threw an exception.\n  //\n  // Return to the normal work loop. This will unwind the stack, and potentially\n  // result in showing a fallback.\n  resetSuspendedWorkLoopOnUnwind();\n\n  const returnFiber = unitOfWork.return;\n  if (returnFiber === null || workInProgressRoot === null) {\n    // Expected to be working on a non-root fiber. This is a fatal error\n    // because there's no ancestor that can handle it; the root is\n    // supposed to capture all errors that weren't caught by an error\n    // boundary.\n    workInProgressRootExitStatus = RootFatalErrored;\n    workInProgressRootFatalError = thrownValue;\n    // Set `workInProgress` to null. This represents advancing to the next\n    // sibling, or the parent if there are no siblings. But since the root\n    // has no siblings nor a parent, we set it to null. Usually this is\n    // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n    // intentionally not calling those, we need set it here.\n    // TODO: Consider calling `unwindWork` to pop the contexts.\n    workInProgress = null;\n    return;\n  }\n\n  try {\n    // Find and mark the nearest Suspense or error boundary that can handle\n    // this \"exception\".\n    throwException(\n      workInProgressRoot,\n      returnFiber,\n      unitOfWork,\n      thrownValue,\n      workInProgressRootRenderLanes,\n    );\n  } catch (error) {\n    // We had trouble processing the error. An example of this happening is\n    // when accessing the `componentDidCatch` property of an error boundary\n    // throws an error. A weird edge case. There's a regression test for this.\n    // To prevent an infinite loop, bubble the error up to the next parent.\n    workInProgress = returnFiber;\n    throw error;\n  }\n\n  // Return to the normal work loop.\n  completeUnitOfWork(unitOfWork);\n}\n\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  let completedWork: Fiber = unitOfWork;\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = completedWork.alternate;\n    const returnFiber = completedWork.return;\n\n    // Check if the work completed or if something threw.\n    if ((completedWork.flags & Incomplete) === NoFlags) {\n      setCurrentDebugFiberInDEV(completedWork);\n      let next;\n      if (\n        !enableProfilerTimer ||\n        (completedWork.mode & ProfileMode) === NoMode\n      ) {\n        next = completeWork(current, completedWork, renderLanes);\n      } else {\n        startProfilerTimer(completedWork);\n        next = completeWork(current, completedWork, renderLanes);\n        // Update render duration assuming we didn't error.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n      }\n      resetCurrentDebugFiberInDEV();\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        workInProgress = next;\n        return;\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(current, completedWork, renderLanes);\n\n      // Because this fiber did not complete, don't reset its lanes.\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        next.flags &= HostEffectMask;\n        workInProgress = next;\n        return;\n      }\n\n      if (\n        enableProfilerTimer &&\n        (completedWork.mode & ProfileMode) !== NoMode\n      ) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n\n        // Include the time spent working on failed children before continuing.\n        let actualDuration = completedWork.actualDuration;\n        let child = completedWork.child;\n        while (child !== null) {\n          // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n        completedWork.actualDuration = actualDuration;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its subtree flags.\n        returnFiber.flags |= Incomplete;\n        returnFiber.subtreeFlags = NoFlags;\n        returnFiber.deletions = null;\n      } else {\n        // We've unwound all the way to the root.\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n        return;\n      }\n    }\n\n    const siblingFiber = completedWork.sibling;\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      workInProgress = siblingFiber;\n      return;\n    }\n    // Otherwise, return to the parent\n    // $FlowFixMe[incompatible-type] we bail out when we get a null\n    completedWork = returnFiber;\n    // Update the next thing we're working on in case something throws.\n    workInProgress = completedWork;\n  } while (completedWork !== null);\n\n  // We've reached the root.\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}\n\nfunction commitRoot(\n  root: FiberRoot,\n  recoverableErrors: null | Array<CapturedValue<mixed>>,\n  transitions: Array<Transition> | null,\n) {\n  // TODO: This no longer makes any sense. We already wrap the mutation and\n  // layout phases. Should be able to remove.\n  const previousUpdateLanePriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n\n  try {\n    ReactCurrentBatchConfig.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    commitRootImpl(\n      root,\n      recoverableErrors,\n      transitions,\n      previousUpdateLanePriority,\n    );\n  } finally {\n    ReactCurrentBatchConfig.transition = prevTransition;\n    setCurrentUpdatePriority(previousUpdateLanePriority);\n  }\n\n  return null;\n}\n\nfunction commitRootImpl(\n  root: FiberRoot,\n  recoverableErrors: null | Array<CapturedValue<mixed>>,\n  transitions: Array<Transition> | null,\n  renderPriorityLevel: EventPriority,\n) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\n    // flush synchronous work at the end, to avoid factoring hazards like this.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  const finishedWork = root.finishedWork;\n  const lanes = root.finishedLanes;\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logCommitStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markCommitStarted(lanes);\n  }\n\n  if (finishedWork === null) {\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logCommitStopped();\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markCommitStopped();\n    }\n\n    return null;\n  } else {\n    if (__DEV__) {\n      if (lanes === NoLanes) {\n        console.error(\n          'root.finishedLanes should not be empty during a commit. This is a ' +\n            'bug in React.',\n        );\n      }\n    }\n  }\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n\n  if (finishedWork === root.current) {\n    throw new Error(\n      'Cannot commit the same tree as before. This error is likely caused by ' +\n        'a bug in React. Please file an issue.',\n    );\n  }\n\n  // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n  root.callbackNode = null;\n  root.callbackPriority = NoLane;\n\n  // Check which lanes no longer have any work scheduled on them, and mark\n  // those as finished.\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n\n  // Make sure to account for lanes that were updated by a concurrent event\n  // during the render phase; don't mark them as finished.\n  const concurrentlyUpdatedLanes = getConcurrentlyUpdatedLanes();\n  remainingLanes = mergeLanes(remainingLanes, concurrentlyUpdatedLanes);\n\n  markRootFinished(root, remainingLanes);\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    workInProgressRootRenderLanes = NoLanes;\n  } else {\n    // This indicates that the last root we worked on is not the same one that\n    // we're committing now. This most commonly happens when a suspended root\n    // times out.\n  }\n\n  // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. (See #16714.)\n  // TODO: Delete all other places that schedule the passive effect callback\n  // They're redundant.\n  if (\n    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||\n    (finishedWork.flags & PassiveMask) !== NoFlags\n  ) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      pendingPassiveEffectsRemainingLanes = remainingLanes;\n      // workInProgressTransitions might be overwritten, so we want\n      // to store it in pendingPassiveTransitions until they get processed\n      // We need to pass this through as an argument to commitRoot\n      // because workInProgressTransitions might have changed between\n      // the previous render and commit if we throttle the commit\n      // with setTimeout\n      pendingPassiveTransitions = transitions;\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects();\n        // This render triggered passive effects: release the root cache pool\n        // *after* passive effects fire to avoid freeing a cache pool that may\n        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n        return null;\n      });\n    }\n  }\n\n  // Check if there are any effects in the whole tree.\n  // TODO: This is left over from the effect list implementation, where we had\n  // to check for the existence of `firstEffect` to satisfy Flow. I think the\n  // only other reason this optimization exists is because it affects profiling.\n  // Reconsider whether this is necessary.\n  const subtreeHasEffects =\n    (finishedWork.subtreeFlags &\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n    NoFlags;\n  const rootHasEffect =\n    (finishedWork.flags &\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n    NoFlags;\n\n  if (subtreeHasEffects || rootHasEffect) {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = null;\n    const previousPriority = getCurrentUpdatePriority();\n    setCurrentUpdatePriority(DiscreteEventPriority);\n\n    const prevExecutionContext = executionContext;\n    executionContext |= CommitContext;\n\n    // Reset this to null before calling lifecycles\n    ReactCurrentOwner.current = null;\n\n    // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n    const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(\n      root,\n      finishedWork,\n    );\n\n    if (enableProfilerTimer) {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      // Track the root here, rather than in commitLayoutEffects(), because of ref setters.\n      // Updates scheduled during ref detachment should also be flagged.\n      rootCommittingMutationOrLayoutEffects = root;\n    }\n\n    // The next phase is the mutation phase, where we mutate the host tree.\n    commitMutationEffects(root, finishedWork, lanes);\n\n    if (enableCreateEventHandleAPI) {\n      if (shouldFireAfterActiveInstanceBlur) {\n        afterActiveInstanceBlur();\n      }\n    }\n    resetAfterCommit(root.containerInfo);\n\n    // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n    root.current = finishedWork;\n\n    // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logLayoutEffectsStarted(lanes);\n      }\n    }\n    if (enableSchedulingProfiler) {\n      markLayoutEffectsStarted(lanes);\n    }\n    commitLayoutEffects(finishedWork, root, lanes);\n    if (__DEV__) {\n      if (enableDebugTracing) {\n        logLayoutEffectsStopped();\n      }\n    }\n\n    if (enableSchedulingProfiler) {\n      markLayoutEffectsStopped();\n    }\n\n    if (enableProfilerTimer && enableProfilerNestedUpdateScheduledHook) {\n      rootCommittingMutationOrLayoutEffects = null;\n    }\n\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n    requestPaint();\n\n    executionContext = prevExecutionContext;\n\n    // Reset the priority to the previous non-sync value.\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  } else {\n    // No effects.\n    root.current = finishedWork;\n    // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n    if (enableProfilerTimer) {\n      recordCommitTime();\n    }\n  }\n\n  const rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsLanes = lanes;\n  } else {\n    // There were no passive effects, so we can immediately release the cache\n    // pool for this render.\n    releaseRootPooledCache(root, remainingLanes);\n    if (__DEV__) {\n      nestedPassiveUpdateCount = 0;\n      rootWithPassiveNestedUpdates = null;\n    }\n  }\n\n  // Read this again, since an effect might have updated it\n  remainingLanes = root.pendingLanes;\n\n  // Check if there's remaining work on this root\n  // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n  // is to detect whether something might have called setState inside\n  // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n  // inside `componentDidCatch` is itself flawed — that's why we recommend\n  // `getDerivedStateFromError` instead. However, it could be improved by\n  // checking if remainingLanes includes Sync work, instead of whether there's\n  // any work remaining at all (which would also include stuff like Suspense\n  // retries or transitions). It's been like this for a while, though, so fixing\n  // it probably isn't that urgent.\n  if (remainingLanes === NoLanes) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  if (__DEV__) {\n    if (!rootDidHavePassiveEffects) {\n      commitDoubleInvokeEffectsInDEV(root, false);\n    }\n  }\n\n  onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel);\n\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      root.memoizedUpdaters.clear();\n    }\n  }\n\n  if (__DEV__) {\n    onCommitRootTestSelector();\n  }\n\n  // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n  ensureRootIsScheduled(root, now());\n\n  if (recoverableErrors !== null) {\n    // There were errors during this render, but recovered from them without\n    // needing to surface it to the UI. We log them here.\n    const onRecoverableError = root.onRecoverableError;\n    for (let i = 0; i < recoverableErrors.length; i++) {\n      const recoverableError = recoverableErrors[i];\n      const errorInfo = makeErrorInfo(\n        recoverableError.digest,\n        recoverableError.stack,\n      );\n      onRecoverableError(recoverableError.value, errorInfo);\n    }\n  }\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    const error = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error;\n  }\n\n  // If the passive effects are the result of a discrete render, flush them\n  // synchronously at the end of the current task so that the result is\n  // immediately observable. Otherwise, we assume that they are not\n  // order-dependent and do not need to be observed by external systems, so we\n  // can wait until after paint.\n  // TODO: We can optimize this by not scheduling the callback earlier. Since we\n  // currently schedule the callback in multiple places, will wait until those\n  // are consolidated.\n  if (includesSyncLane(pendingPassiveEffectsLanes) && root.tag !== LegacyRoot) {\n    flushPassiveEffects();\n  }\n\n  // Read this again, since a passive effect might have updated it\n  remainingLanes = root.pendingLanes;\n  if (includesSyncLane(remainingLanes)) {\n    if (enableProfilerTimer && enableProfilerNestedUpdatePhase) {\n      markNestedUpdateScheduled();\n    }\n\n    // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  }\n\n  // If layout work was scheduled, flush it now.\n  flushSyncCallbacks();\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logCommitStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markCommitStopped();\n  }\n\n  if (enableTransitionTracing) {\n    // We process transitions during passive effects. However, passive effects can be\n    // processed synchronously during the commit phase as well as asynchronously after\n    // paint. At the end of the commit phase, we schedule a callback that will be called\n    // after the next paint. If the transitions have already been processed (passive\n    // effect phase happened synchronously), we will schedule a callback to process\n    // the transitions. However, if we don't have any pending transition callbacks, this\n    // means that the transitions have yet to be processed (passive effects processed after paint)\n    // so we will store the end time of paint so that we can process the transitions\n    // and then call the callback via the correct end time.\n    const prevRootTransitionCallbacks = root.transitionCallbacks;\n    if (prevRootTransitionCallbacks !== null) {\n      schedulePostPaintCallback(endTime => {\n        const prevPendingTransitionCallbacks = currentPendingTransitionCallbacks;\n        if (prevPendingTransitionCallbacks !== null) {\n          currentPendingTransitionCallbacks = null;\n          scheduleCallback(IdleSchedulerPriority, () => {\n            processTransitionCallbacks(\n              prevPendingTransitionCallbacks,\n              endTime,\n              prevRootTransitionCallbacks,\n            );\n          });\n        } else {\n          currentEndTime = endTime;\n        }\n      });\n    }\n  }\n\n  return null;\n}\n\nfunction makeErrorInfo(digest: ?string, componentStack: ?string) {\n  if (__DEV__) {\n    const errorInfo = {\n      componentStack,\n      digest,\n    };\n    Object.defineProperty(errorInfo, 'digest', {\n      configurable: false,\n      enumerable: true,\n      get() {\n        console.error(\n          'You are accessing \"digest\" from the errorInfo object passed to onRecoverableError.' +\n            ' This property is deprecated and will be removed in a future version of React.' +\n            ' To access the digest of an Error look for this property on the Error instance itself.',\n        );\n        return digest;\n      },\n    });\n    return errorInfo;\n  } else {\n    return {\n      digest,\n      componentStack,\n    };\n  }\n}\n\nfunction releaseRootPooledCache(root: FiberRoot, remainingLanes: Lanes) {\n  if (enableCache) {\n    const pooledCacheLanes = (root.pooledCacheLanes &= remainingLanes);\n    if (pooledCacheLanes === NoLanes) {\n      // None of the remaining work relies on the cache pool. Clear it so\n      // subsequent requests get a new cache\n      const pooledCache = root.pooledCache;\n      if (pooledCache != null) {\n        root.pooledCache = null;\n        releaseCache(pooledCache);\n      }\n    }\n  }\n}\n\nexport function flushPassiveEffects(): boolean {\n  // Returns whether passive effects were flushed.\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n  // probably just combine the two functions. I believe they were only separate\n  // in the first place because we used to wrap it with\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n  // priority within React itself, so we can mutate the variable directly.\n  if (rootWithPendingPassiveEffects !== null) {\n    // Cache the root since rootWithPendingPassiveEffects is cleared in\n    // flushPassiveEffectsImpl\n    const root = rootWithPendingPassiveEffects;\n    // Cache and clear the remaining lanes flag; it must be reset since this\n    // method can be called from various places, not always from commitRoot\n    // where the remaining lanes are known\n    const remainingLanes = pendingPassiveEffectsRemainingLanes;\n    pendingPassiveEffectsRemainingLanes = NoLanes;\n\n    const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n    const priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    const previousPriority = getCurrentUpdatePriority();\n\n    try {\n      ReactCurrentBatchConfig.transition = null;\n      setCurrentUpdatePriority(priority);\n      return flushPassiveEffectsImpl();\n    } finally {\n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig.transition = prevTransition;\n\n      // Once passive effects have run for the tree - giving components a\n      // chance to retain cache instances they use - release the pooled\n      // cache at the root (if there is one)\n      releaseRootPooledCache(root, remainingLanes);\n    }\n  }\n  return false;\n}\n\nexport function enqueuePendingPassiveProfilerEffect(fiber: Fiber): void {\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    pendingPassiveProfilerEffects.push(fiber);\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n\n  // Cache and clear the transitions flag\n  const transitions = pendingPassiveTransitions;\n  pendingPassiveTransitions = null;\n\n  const root = rootWithPendingPassiveEffects;\n  const lanes = pendingPassiveEffectsLanes;\n  rootWithPendingPassiveEffects = null;\n  // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n  // Figure out why and fix it. It's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n  pendingPassiveEffectsLanes = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Cannot flush passive effects while already rendering.');\n  }\n\n  if (__DEV__) {\n    isFlushingPassiveEffects = true;\n    didScheduleUpdateDuringPassiveEffects = false;\n\n    if (enableDebugTracing) {\n      logPassiveEffectsStarted(lanes);\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markPassiveEffectsStarted(lanes);\n  }\n\n  const prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n\n  commitPassiveUnmountEffects(root.current);\n  commitPassiveMountEffects(root, root.current, lanes, transitions);\n\n  // TODO: Move to commitPassiveMountEffects\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    const profilerEffects = pendingPassiveProfilerEffects;\n    pendingPassiveProfilerEffects = [];\n    for (let i = 0; i < profilerEffects.length; i++) {\n      const fiber = ((profilerEffects[i]: any): Fiber);\n      commitPassiveEffectDurations(root, fiber);\n    }\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logPassiveEffectsStopped();\n    }\n  }\n\n  if (enableSchedulingProfiler) {\n    markPassiveEffectsStopped();\n  }\n\n  if (__DEV__) {\n    commitDoubleInvokeEffectsInDEV(root, true);\n  }\n\n  executionContext = prevExecutionContext;\n\n  flushSyncCallbacks();\n\n  if (enableTransitionTracing) {\n    const prevPendingTransitionCallbacks = currentPendingTransitionCallbacks;\n    const prevRootTransitionCallbacks = root.transitionCallbacks;\n    const prevEndTime = currentEndTime;\n    if (\n      prevPendingTransitionCallbacks !== null &&\n      prevRootTransitionCallbacks !== null &&\n      prevEndTime !== null\n    ) {\n      currentPendingTransitionCallbacks = null;\n      currentEndTime = null;\n      scheduleCallback(IdleSchedulerPriority, () => {\n        processTransitionCallbacks(\n          prevPendingTransitionCallbacks,\n          prevEndTime,\n          prevRootTransitionCallbacks,\n        );\n      });\n    }\n  }\n\n  if (__DEV__) {\n    // If additional passive effects were scheduled, increment a counter. If this\n    // exceeds the limit, we'll fire a warning.\n    if (didScheduleUpdateDuringPassiveEffects) {\n      if (root === rootWithPassiveNestedUpdates) {\n        nestedPassiveUpdateCount++;\n      } else {\n        nestedPassiveUpdateCount = 0;\n        rootWithPassiveNestedUpdates = root;\n      }\n    } else {\n      nestedPassiveUpdateCount = 0;\n    }\n    isFlushingPassiveEffects = false;\n    didScheduleUpdateDuringPassiveEffects = false;\n  }\n\n  // TODO: Move to commitPassiveMountEffects\n  onPostCommitRootDevTools(root);\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    const stateNode = root.current.stateNode;\n    stateNode.effectDuration = 0;\n    stateNode.passiveEffectDuration = 0;\n  }\n\n  return true;\n}\n\nexport function isAlreadyFailedLegacyErrorBoundary(instance: mixed): boolean {\n  return (\n    legacyErrorBoundariesThatAlreadyFailed !== null &&\n    legacyErrorBoundariesThatAlreadyFailed.has(instance)\n  );\n}\n\nexport function markLegacyErrorBoundaryAsFailed(instance: mixed) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error: mixed) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\nexport const onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(\n  rootFiber: Fiber,\n  sourceFiber: Fiber,\n  error: mixed,\n) {\n  const errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n  const update = createRootErrorUpdate(rootFiber, errorInfo, (SyncLane: Lane));\n  const root = enqueueUpdate(rootFiber, update, (SyncLane: Lane));\n  const eventTime = requestEventTime();\n  if (root !== null) {\n    markRootUpdated(root, SyncLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nexport function captureCommitPhaseError(\n  sourceFiber: Fiber,\n  nearestMountedAncestor: Fiber | null,\n  error: mixed,\n) {\n  if (__DEV__) {\n    reportUncaughtErrorInDEV(error);\n    setIsRunningInsertionEffect(false);\n  }\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n    return;\n  }\n\n  let fiber = null;\n  if (skipUnmountedBoundaries) {\n    fiber = nearestMountedAncestor;\n  } else {\n    fiber = sourceFiber.return;\n  }\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      const ctor = fiber.type;\n      const instance = fiber.stateNode;\n      if (\n        typeof ctor.getDerivedStateFromError === 'function' ||\n        (typeof instance.componentDidCatch === 'function' &&\n          !isAlreadyFailedLegacyErrorBoundary(instance))\n      ) {\n        const errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n        const update = createClassErrorUpdate(\n          fiber,\n          errorInfo,\n          (SyncLane: Lane),\n        );\n        const root = enqueueUpdate(fiber, update, (SyncLane: Lane));\n        const eventTime = requestEventTime();\n        if (root !== null) {\n          markRootUpdated(root, SyncLane, eventTime);\n          ensureRootIsScheduled(root, eventTime);\n        }\n        return;\n      }\n    }\n    fiber = fiber.return;\n  }\n\n  if (__DEV__) {\n    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n    // will fire for errors that are thrown by destroy functions inside deleted\n    // trees. What it should instead do is propagate the error to the parent of\n    // the deleted tree. In the meantime, do not add this warning to the\n    // allowlist; this is only for our internal use.\n    console.error(\n      'Internal React error: Attempted to capture a commit phase error ' +\n        'inside a detached tree. This indicates a bug in React. Likely ' +\n        'causes include deleting the same fiber more than once, committing an ' +\n        'already-finished tree, or an inconsistent return pointer.\\n\\n' +\n        'Error message:\\n\\n%s',\n      error,\n    );\n  }\n}\n\nexport function attachPingListener(\n  root: FiberRoot,\n  wakeable: Wakeable,\n  lanes: Lanes,\n) {\n  // Attach a ping listener\n  //\n  // The data might resolve before we have a chance to commit the fallback. Or,\n  // in the case of a refresh, we'll never commit a fallback. So we need to\n  // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n  // try rendering the tree again.\n  //\n  // Only attach a listener if one does not already exist for the lanes\n  // we're currently rendering (which acts like a \"thread ID\" here).\n  //\n  // We only need to do this in concurrent mode. Legacy Suspense always\n  // commits fallbacks synchronously, so there are no pings.\n  let pingCache = root.pingCache;\n  let threadIDs;\n  if (pingCache === null) {\n    pingCache = root.pingCache = new PossiblyWeakMap();\n    threadIDs = new Set();\n    pingCache.set(wakeable, threadIDs);\n  } else {\n    threadIDs = pingCache.get(wakeable);\n    if (threadIDs === undefined) {\n      threadIDs = new Set();\n      pingCache.set(wakeable, threadIDs);\n    }\n  }\n  if (!threadIDs.has(lanes)) {\n    workInProgressRootDidAttachPingListener = true;\n\n    // Memoize using the thread ID to prevent redundant listeners.\n    threadIDs.add(lanes);\n    const ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n    if (enableUpdaterTracking) {\n      if (isDevToolsPresent) {\n        // If we have pending work still, restore the original updaters\n        restorePendingUpdaters(root, lanes);\n      }\n    }\n    wakeable.then(ping, ping);\n  }\n}\n\nfunction pingSuspendedRoot(\n  root: FiberRoot,\n  wakeable: Wakeable,\n  pingedLanes: Lanes,\n) {\n  const pingCache = root.pingCache;\n  if (pingCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(wakeable);\n  }\n\n  const eventTime = requestEventTime();\n  markRootPinged(root, pingedLanes, eventTime);\n\n  warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n\n  if (\n    workInProgressRoot === root &&\n    isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)\n  ) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\n    // so we can always restart.\n    if (\n      workInProgressRootExitStatus === RootSuspendedWithDelay ||\n      (workInProgressRootExitStatus === RootSuspended &&\n        includesOnlyRetries(workInProgressRootRenderLanes) &&\n        now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)\n    ) {\n      // Force a restart from the root by unwinding the stack. Unless this is\n      // being called from the render phase, because that would cause a crash.\n      if ((executionContext & RenderContext) === NoContext) {\n        prepareFreshStack(root, NoLanes);\n      } else {\n        // TODO: If this does happen during the render phase, we should throw\n        // the special internal exception that we use to interrupt the stack for\n        // selective hydration. That was temporarily reverted but we once we add\n        // it back we can use it here.\n      }\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootPingedLanes = mergeLanes(\n        workInProgressRootPingedLanes,\n        pingedLanes,\n      );\n    }\n  }\n\n  ensureRootIsScheduled(root, eventTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new lanes.\n  if (retryLane === NoLane) {\n    // TODO: Assign this to `suspenseState.retryLane`? to avoid\n    // unnecessary entanglement?\n    retryLane = requestRetryLane(boundaryFiber);\n  }\n  // TODO: Special case idle priority?\n  const eventTime = requestEventTime();\n  const root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n  if (root !== null) {\n    markRootUpdated(root, retryLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nexport function retryDehydratedSuspenseBoundary(boundaryFiber: Fiber) {\n  const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\n  let retryLane = NoLane;\n  if (suspenseState !== null) {\n    retryLane = suspenseState.retryLane;\n  }\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\n\nexport function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable) {\n  let retryLane = NoLane; // Default\n  let retryCache: WeakSet<Wakeable> | Set<Wakeable> | null;\n  switch (boundaryFiber.tag) {\n    case SuspenseComponent:\n      retryCache = boundaryFiber.stateNode;\n      const suspenseState: null | SuspenseState = boundaryFiber.memoizedState;\n      if (suspenseState !== null) {\n        retryLane = suspenseState.retryLane;\n      }\n      break;\n    case SuspenseListComponent:\n      retryCache = boundaryFiber.stateNode;\n      break;\n    case OffscreenComponent: {\n      const instance: OffscreenInstance = boundaryFiber.stateNode;\n      // $FlowFixMe[incompatible-type] found when upgrading Flow\n      retryCache = instance._retryCache;\n      break;\n    }\n    default:\n      throw new Error(\n        'Pinged unknown suspense boundary type. ' +\n          'This is probably a bug in React.',\n      );\n  }\n\n  if (retryCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(wakeable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\n\n// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed: number) {\n  return timeElapsed < 120\n    ? 120\n    : timeElapsed < 480\n    ? 480\n    : timeElapsed < 1080\n    ? 1080\n    : timeElapsed < 1920\n    ? 1920\n    : timeElapsed < 3000\n    ? 3000\n    : timeElapsed < 4320\n    ? 4320\n    : ceil(timeElapsed / 1960) * 1960;\n}\n\nexport function throwIfInfiniteUpdateLoopDetected() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    nestedPassiveUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    rootWithPassiveNestedUpdates = null;\n\n    throw new Error(\n      'Maximum update depth exceeded. This can happen when a component ' +\n        'repeatedly calls setState inside componentWillUpdate or ' +\n        'componentDidUpdate. React limits the number of nested updates to ' +\n        'prevent infinite loops.',\n    );\n  }\n\n  if (__DEV__) {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n      rootWithPassiveNestedUpdates = null;\n\n      console.error(\n        'Maximum update depth exceeded. This can happen when a component ' +\n          \"calls setState inside useEffect, but useEffect either doesn't \" +\n          'have a dependency array, or one of the dependencies changes on ' +\n          'every render.',\n      );\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  if (__DEV__) {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction recursivelyTraverseAndDoubleInvokeEffectsInDEV(\n  root: FiberRoot,\n  parentFiber: Fiber,\n  isInStrictMode: boolean,\n) {\n  if ((parentFiber.subtreeFlags & (PlacementDEV | Visibility)) === NoFlags) {\n    // Parent's descendants have already had effects double invoked.\n    // Early exit to avoid unnecessary tree traversal.\n    return;\n  }\n  let child = parentFiber.child;\n  while (child !== null) {\n    doubleInvokeEffectsInDEVIfNecessary(root, child, isInStrictMode);\n    child = child.sibling;\n  }\n}\n\n// Unconditionally disconnects and connects passive and layout effects.\nfunction doubleInvokeEffectsOnFiber(root: FiberRoot, fiber: Fiber) {\n  disappearLayoutEffects(fiber);\n  disconnectPassiveEffect(fiber);\n  reappearLayoutEffects(root, fiber.alternate, fiber, false);\n  reconnectPassiveEffects(root, fiber, NoLanes, null, false);\n}\n\nfunction doubleInvokeEffectsInDEVIfNecessary(\n  root: FiberRoot,\n  fiber: Fiber,\n  parentIsInStrictMode: boolean,\n) {\n  const isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n  const isInStrictMode = parentIsInStrictMode || isStrictModeFiber;\n\n  // First case: the fiber **is not** of type OffscreenComponent. No\n  // special rules apply to double invoking effects.\n  if (fiber.tag !== OffscreenComponent) {\n    if (fiber.flags & PlacementDEV) {\n      setCurrentDebugFiberInDEV(fiber);\n      if (isInStrictMode) {\n        doubleInvokeEffectsOnFiber(root, fiber);\n      }\n      resetCurrentDebugFiberInDEV();\n    } else {\n      recursivelyTraverseAndDoubleInvokeEffectsInDEV(\n        root,\n        fiber,\n        isInStrictMode,\n      );\n    }\n    return;\n  }\n\n  // Second case: the fiber **is** of type OffscreenComponent.\n  // This branch contains cases specific to Offscreen.\n  if (fiber.memoizedState === null) {\n    // Only consider Offscreen that is visible.\n    // TODO (Offscreen) Handle manual mode.\n    setCurrentDebugFiberInDEV(fiber);\n    if (isInStrictMode && fiber.flags & Visibility) {\n      // Double invoke effects on Offscreen's subtree only\n      // if it is visible and its visibility has changed.\n      doubleInvokeEffectsOnFiber(root, fiber);\n    } else if (fiber.subtreeFlags & PlacementDEV) {\n      // Something in the subtree could have been suspended.\n      // We need to continue traversal and find newly inserted fibers.\n      recursivelyTraverseAndDoubleInvokeEffectsInDEV(\n        root,\n        fiber,\n        isInStrictMode,\n      );\n    }\n    resetCurrentDebugFiberInDEV();\n  }\n}\n\nfunction commitDoubleInvokeEffectsInDEV(\n  root: FiberRoot,\n  hasPassiveEffects: boolean,\n) {\n  if (__DEV__) {\n    if (useModernStrictMode) {\n      let doubleInvokeEffects = true;\n\n      if (root.tag === LegacyRoot && !(root.current.mode & StrictLegacyMode)) {\n        doubleInvokeEffects = false;\n      }\n      if (\n        root.tag === ConcurrentRoot &&\n        !(root.current.mode & (StrictLegacyMode | StrictEffectsMode))\n      ) {\n        doubleInvokeEffects = false;\n      }\n      recursivelyTraverseAndDoubleInvokeEffectsInDEV(\n        root,\n        root.current,\n        doubleInvokeEffects,\n      );\n    } else {\n      legacyCommitDoubleInvokeEffectsInDEV(root.current, hasPassiveEffects);\n    }\n  }\n}\n\nfunction legacyCommitDoubleInvokeEffectsInDEV(\n  fiber: Fiber,\n  hasPassiveEffects: boolean,\n) {\n  // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n  // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n  // Maybe not a big deal since this is DEV only behavior.\n\n  setCurrentDebugFiberInDEV(fiber);\n  invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n  if (hasPassiveEffects) {\n    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n  }\n\n  invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n  if (hasPassiveEffects) {\n    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n  }\n  resetCurrentDebugFiberInDEV();\n}\n\nfunction invokeEffectsInDev(\n  firstChild: Fiber,\n  fiberFlags: Flags,\n  invokeEffectFn: (fiber: Fiber) => void,\n) {\n  let current: null | Fiber = firstChild;\n  let subtreeRoot = null;\n  while (current != null) {\n    const primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n    if (\n      current !== subtreeRoot &&\n      current.child != null &&\n      primarySubtreeFlag !== NoFlags\n    ) {\n      current = current.child;\n    } else {\n      if ((current.flags & fiberFlags) !== NoFlags) {\n        invokeEffectFn(current);\n      }\n\n      if (current.sibling !== null) {\n        current = current.sibling;\n      } else {\n        current = subtreeRoot = current.return;\n      }\n    }\n  }\n}\n\nlet didWarnStateUpdateForNotYetMountedComponent: Set<string> | null = null;\nexport function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber: Fiber) {\n  if (__DEV__) {\n    if ((executionContext & RenderContext) !== NoContext) {\n      // We let the other warning about render phase updates deal with this one.\n      return;\n    }\n\n    if (!(fiber.mode & ConcurrentMode)) {\n      return;\n    }\n\n    const tag = fiber.tag;\n    if (\n      tag !== IndeterminateComponent &&\n      tag !== HostRoot &&\n      tag !== ClassComponent &&\n      tag !== FunctionComponent &&\n      tag !== ForwardRef &&\n      tag !== MemoComponent &&\n      tag !== SimpleMemoComponent\n    ) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    }\n\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    const componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n        return;\n      }\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\n    }\n\n    const previousFiber = ReactCurrentFiberCurrent;\n    try {\n      setCurrentDebugFiberInDEV(fiber);\n      console.error(\n        \"Can't perform a React state update on a component that hasn't mounted yet. \" +\n          'This indicates that you have a side-effect in your render function that ' +\n          'asynchronously later calls tries to update the component. Move this work to ' +\n          'useEffect instead.',\n      );\n    } finally {\n      if (previousFiber) {\n        setCurrentDebugFiberInDEV(fiber);\n      } else {\n        resetCurrentDebugFiberInDEV();\n      }\n    }\n  }\n}\n\nlet beginWork;\nif (__DEV__ && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  const dummyFiber = null;\n  beginWork = (current, unitOfWork, lanes) => {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    const originalWorkInProgressCopy = assignFiberPropertiesInDEV(\n      dummyFiber,\n      unitOfWork,\n    );\n    try {\n      return originalBeginWork(current, unitOfWork, lanes);\n    } catch (originalError) {\n      if (\n        didSuspendOrErrorWhileHydratingDEV() ||\n        originalError === SuspenseException ||\n        originalError === SelectiveHydrationException ||\n        (originalError !== null &&\n          typeof originalError === 'object' &&\n          typeof originalError.then === 'function')\n      ) {\n        // Don't replay promises.\n        // Don't replay errors if we are hydrating and have already suspended or handled an error\n        throw originalError;\n      }\n\n      // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n\n      // Unwind the failed stack frame\n      resetSuspendedWorkLoopOnUnwind();\n      unwindInterruptedWork(current, unitOfWork, workInProgressRootRenderLanes);\n\n      // Restore the original properties of the fiber.\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if (enableProfilerTimer && unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      }\n\n      // Run beginWork again.\n      invokeGuardedCallback(\n        null,\n        originalBeginWork,\n        null,\n        current,\n        unitOfWork,\n        lanes,\n      );\n\n      if (hasCaughtError()) {\n        const replayError = clearCaughtError();\n        if (\n          typeof replayError === 'object' &&\n          replayError !== null &&\n          replayError._suppressLogging &&\n          typeof originalError === 'object' &&\n          originalError !== null &&\n          !originalError._suppressLogging\n        ) {\n          // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n          originalError._suppressLogging = true;\n        }\n      }\n      // We always throw the original error in case the second render pass is not idempotent.\n      // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n      throw originalError;\n    }\n  };\n} else {\n  beginWork = originalBeginWork;\n}\n\nlet didWarnAboutUpdateInRender = false;\nlet didWarnAboutUpdateInRenderForAnotherComponent;\nif (__DEV__) {\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n}\n\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n  if (__DEV__) {\n    if (ReactCurrentDebugFiberIsRenderingInDEV) {\n      switch (fiber.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent: {\n          const renderingComponentName =\n            (workInProgress && getComponentNameFromFiber(workInProgress)) ||\n            'Unknown';\n          // Dedupe by the rendering component because it's the one that needs to be fixed.\n          const dedupeKey = renderingComponentName;\n          if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n            didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n            const setStateComponentName =\n              getComponentNameFromFiber(fiber) || 'Unknown';\n            console.error(\n              'Cannot update a component (`%s`) while rendering a ' +\n                'different component (`%s`). To locate the bad setState() call inside `%s`, ' +\n                'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',\n              setStateComponentName,\n              renderingComponentName,\n              renderingComponentName,\n            );\n          }\n          break;\n        }\n        case ClassComponent: {\n          if (!didWarnAboutUpdateInRender) {\n            console.error(\n              'Cannot update during an existing state transition (such as ' +\n                'within `render`). Render methods should be a pure ' +\n                'function of props and state.',\n            );\n            didWarnAboutUpdateInRender = true;\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n\nexport function restorePendingUpdaters(root: FiberRoot, lanes: Lanes): void {\n  if (enableUpdaterTracking) {\n    if (isDevToolsPresent) {\n      const memoizedUpdaters = root.memoizedUpdaters;\n      memoizedUpdaters.forEach(schedulingFiber => {\n        addFiberToLanesMap(root, schedulingFiber, lanes);\n      });\n\n      // This function intentionally does not clear memoized updaters.\n      // Those may still be relevant to the current commit\n      // and a future one (e.g. Suspense).\n    }\n  }\n}\n\nconst fakeActCallbackNode = {};\nfunction scheduleCallback(priorityLevel, callback) {\n  if (__DEV__) {\n    // If we're currently inside an `act` scope, bypass Scheduler and push to\n    // the `act` queue instead.\n    const actQueue = ReactCurrentActQueue.current;\n    if (actQueue !== null) {\n      actQueue.push(callback);\n      return fakeActCallbackNode;\n    } else {\n      return Scheduler_scheduleCallback(priorityLevel, callback);\n    }\n  } else {\n    // In production, always call Scheduler. This function will be stripped out.\n    return Scheduler_scheduleCallback(priorityLevel, callback);\n  }\n}\n\nfunction cancelCallback(callbackNode) {\n  if (__DEV__ && callbackNode === fakeActCallbackNode) {\n    return;\n  }\n  // In production, always call Scheduler. This function will be stripped out.\n  return Scheduler_cancelCallback(callbackNode);\n}\n\nfunction shouldForceFlushFallbacksInDEV() {\n  // Never force flush in production. This function should get stripped out.\n  return __DEV__ && ReactCurrentActQueue.current !== null;\n}\n\nfunction warnIfUpdatesNotWrappedWithActDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    if (fiber.mode & ConcurrentMode) {\n      if (!isConcurrentActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n    } else {\n      // Legacy mode has additional cases where we suppress a warning.\n      if (!isLegacyActEnvironment(fiber)) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n      if (executionContext !== NoContext) {\n        // Legacy mode doesn't warn if the update is batched, i.e.\n        // batchedUpdates or flushSync.\n        return;\n      }\n      if (\n        fiber.tag !== FunctionComponent &&\n        fiber.tag !== ForwardRef &&\n        fiber.tag !== SimpleMemoComponent\n      ) {\n        // For backwards compatibility with pre-hooks code, legacy mode only\n        // warns for updates that originate from a hook.\n        return;\n      }\n    }\n\n    if (ReactCurrentActQueue.current === null) {\n      const previousFiber = ReactCurrentFiberCurrent;\n      try {\n        setCurrentDebugFiberInDEV(fiber);\n        console.error(\n          'An update to %s inside a test was not wrapped in act(...).\\n\\n' +\n            'When testing, code that causes React state updates should be ' +\n            'wrapped into act(...):\\n\\n' +\n            'act(() => {\\n' +\n            '  /* fire events that update state */\\n' +\n            '});\\n' +\n            '/* assert on the output */\\n\\n' +\n            \"This ensures that you're testing the behavior the user would see \" +\n            'in the browser.' +\n            ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\n          getComponentNameFromFiber(fiber),\n        );\n      } finally {\n        if (previousFiber) {\n          setCurrentDebugFiberInDEV(fiber);\n        } else {\n          resetCurrentDebugFiberInDEV();\n        }\n      }\n    }\n  }\n}\n\nfunction warnIfSuspenseResolutionNotWrappedWithActDEV(root: FiberRoot): void {\n  if (__DEV__) {\n    if (\n      root.tag !== LegacyRoot &&\n      isConcurrentActEnvironment() &&\n      ReactCurrentActQueue.current === null\n    ) {\n      console.error(\n        'A suspended resource finished loading inside a test, but the event ' +\n          'was not wrapped in act(...).\\n\\n' +\n          'When testing, code that resolves suspended data should be wrapped ' +\n          'into act(...):\\n\\n' +\n          'act(() => {\\n' +\n          '  /* finish loading suspended data */\\n' +\n          '});\\n' +\n          '/* assert on the output */\\n\\n' +\n          \"This ensures that you're testing the behavior the user would see \" +\n          'in the browser.' +\n          ' Learn more at https://reactjs.org/link/wrap-tests-with-act',\n      );\n    }\n  }\n}\n\nexport function setIsRunningInsertionEffect(isRunning: boolean): void {\n  if (__DEV__) {\n    isRunningInsertionEffect = isRunning;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}