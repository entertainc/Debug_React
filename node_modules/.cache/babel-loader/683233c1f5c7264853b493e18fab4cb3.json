{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { isOffscreenManual } from './ReactFiberOffscreenComponent';\nimport { enableLegacyHidden, enableHostSingletons, enableSuspenseCallback, enableScopeAPI, enableProfilerTimer, enableCache, enableTransitionTracing, enableFloat } from 'shared/ReactFeatureFlags';\nimport { resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions } from './ReactMutableSource';\nimport { now } from './Scheduler';\nimport { IndeterminateComponent, FunctionComponent, ClassComponent, HostRoot, HostComponent, HostResource, HostSingleton, HostText, HostPortal, ContextProvider, ContextConsumer, ForwardRef, Fragment, Mode, Profiler, SuspenseComponent, SuspenseListComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, ScopeComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent, TracingMarkerComponent } from './ReactWorkTags';\nimport { NoMode, ConcurrentMode, ProfileMode } from './ReactTypeOfMode';\nimport { Ref, RefStatic, Placement, Update, Visibility, NoFlags, DidCapture, Snapshot, ChildDeletion, StaticMask, MutationMask, Passive, Incomplete, ShouldCapture, ForceClientRender } from './ReactFiberFlags';\nimport { createInstance, createTextInstance, resolveSingletonInstance, appendInitialChild, finalizeInitialChildren, prepareUpdate, supportsMutation, supportsPersistence, supportsResources, supportsSingletons, cloneInstance, cloneHiddenInstance, cloneHiddenTextInstance, createContainerChildSet, appendChildToContainerChildSet, finalizeContainerChildren, preparePortalMount, prepareScopeUpdate } from './ReactFiberHostConfig';\nimport { getRootHostContainer, popHostContext, getHostContext, popHostContainer } from './ReactFiberHostContext';\nimport { suspenseStackCursor, popSuspenseListContext, popSuspenseHandler, pushSuspenseListContext, setShallowSuspenseListContext, ForceSuspenseFallback, setDefaultShallowSuspenseListContext, isBadSuspenseFallback } from './ReactFiberSuspenseContext';\nimport { popHiddenContext } from './ReactFiberHiddenContext';\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent';\nimport { isContextProvider as isLegacyContextProvider, popContext as popLegacyContext, popTopLevelContextObject as popTopLevelLegacyContextObject } from './ReactFiberContext';\nimport { popProvider } from './ReactFiberNewContext';\nimport { prepareToHydrateHostInstance, prepareToHydrateHostTextInstance, prepareToHydrateHostSuspenseInstance, warnIfUnhydratedTailNodes, popHydrationState, resetHydrationState, getIsHydrating, hasUnhydratedTailNodes, upgradeHydrationErrorsToRecoverable } from './ReactFiberHydrationContext';\nimport { renderDidSuspend, renderDidSuspendDelayIfPossible, renderHasNotSuspendedYet, getRenderTargetTime, getWorkInProgressTransitions } from './ReactFiberWorkLoop';\nimport { OffscreenLane, SomeRetryLane, NoLanes, includesSomeLane, mergeLanes } from './ReactFiberLane';\nimport { resetChildFibers } from './ReactChildFiber';\nimport { createScopeInstance } from './ReactFiberScope';\nimport { transferActualDuration } from './ReactProfilerTimer';\nimport { popCacheProvider } from './ReactFiberCacheComponent';\nimport { popTreeContext } from './ReactFiberTreeContext';\nimport { popRootTransition, popTransition } from './ReactFiberTransition';\nimport { popMarkerInstance, popRootMarkerInstance } from './ReactFiberTracingMarkerComponent';\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.flags |= Update;\n}\n\nfunction markRef(workInProgress) {\n  workInProgress.flags |= Ref | RefStatic;\n}\n\nfunction hadNoMutationsEffects(current, completedWork) {\n  const didBailout = current !== null && current.child === completedWork.child;\n\n  if (didBailout) {\n    return true;\n  }\n\n  if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n    return false;\n  } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n  // then we only have to check the `completedWork.subtreeFlags`.\n\n\n  let child = completedWork.child;\n\n  while (child !== null) {\n    if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {\n      return false;\n    }\n\n    child = child.sibling;\n  }\n\n  return true;\n}\n\nlet appendAllChildren;\nlet updateHostContainer;\nlet updateHostComponent;\nlet updateHostText;\n\nif (supportsMutation) {\n  // Mutation mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal || (enableHostSingletons && supportsSingletons ? node.tag === HostSingleton : false)) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n        // If we have a HostSingleton it will be placed independently\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === workInProgress) {\n        return;\n      } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n      while (node.sibling === null) {\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    const oldProps = current.memoizedProps;\n\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    } // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n\n\n    const instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n\n    const updatePayload = prepareUpdate(instance, type, oldProps, newProps, currentHostContext); // TODO: Type this specific to this type of component.\n\n    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        const child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        appendAllChildren(parent, node, true, true);\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n      while (node.sibling === null) {\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n\n  const appendAllChildrenToContainer = function (containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostPortal) {// If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        const child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        } // If Offscreen is not in manual mode, detached tree is hidden from user space.\n\n\n        const _needsVisibilityToggle = !isOffscreenManual(node);\n\n        appendAllChildrenToContainer(containerChildSet, node, _needsVisibilityToggle, true);\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n      while (node.sibling === null) {\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {\n    const portalOrRoot = workInProgress.stateNode;\n    const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged) {// No changes, just reuse the existing instance.\n    } else {\n      const container = portalOrRoot.containerInfo;\n      const newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps) {\n    const currentInstance = current.stateNode;\n    const oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n\n    const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    const recyclableInstance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    let updatePayload = null;\n\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, currentHostContext);\n    }\n\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    const newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n    if (finalizeInitialChildren(newInstance, type, newProps, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n\n    workInProgress.stateNode = newInstance;\n\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      const rootContainerInstance = getRootHostContainer();\n      const currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n\n      markUpdate(workInProgress);\n    } else {\n      workInProgress.stateNode = current.stateNode;\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps) {// Noop\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {// Noop\n  };\n}\n\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  if (getIsHydrating()) {\n    // If we're hydrating, we should consume as many items as we can\n    // so we don't leave any behind.\n    return;\n  }\n\n  switch (renderState.tailMode) {\n    case 'hidden':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        let tailNode = renderState.tail;\n        let lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          renderState.tail = null;\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n\n    case 'collapsed':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        let tailNode = renderState.tail;\n        let lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          if (!hasRenderedATailFallback && renderState.tail !== null) {\n            // We suspended during the head. We want to show at least one\n            // row at the tail. So we'll keep on and cut off the rest.\n            renderState.tail.sibling = null;\n          } else {\n            renderState.tail = null;\n          }\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n  }\n}\n\nfunction bubbleProperties(completedWork) {\n  const didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n  let newChildLanes = NoLanes;\n  let subtreeFlags = NoFlags;\n\n  if (!didBailout) {\n    // Bubble up the earliest expiration time.\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      let actualDuration = completedWork.actualDuration;\n      let treeBaseDuration = completedWork.selfBaseDuration;\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n        // When work is done, it should bubble to the parent's actualDuration. If\n        // the fiber has not been cloned though, (meaning no work was done), then\n        // this value will reflect the amount of time spent working on a previous\n        // render. In that case it should not bubble. We determine whether it was\n        // cloned by comparing the child pointer.\n        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n\n        actualDuration += child.actualDuration; // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.actualDuration = actualDuration;\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        child.return = completedWork;\n        child = child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  } else {\n    // Bubble up the earliest expiration time.\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      let treeBaseDuration = completedWork.selfBaseDuration;\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= child.subtreeFlags & StaticMask;\n        subtreeFlags |= child.flags & StaticMask; // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      let child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= child.subtreeFlags & StaticMask;\n        subtreeFlags |= child.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        child.return = completedWork;\n        child = child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  }\n\n  completedWork.childLanes = newChildLanes;\n  return didBailout;\n}\n\nfunction completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {\n  if (hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {\n    warnIfUnhydratedTailNodes(workInProgress);\n    resetHydrationState();\n    workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\n    return false;\n  }\n\n  const wasHydrated = popHydrationState(workInProgress);\n\n  if (nextState !== null && nextState.dehydrated !== null) {\n    // We might be inside a hydration state the first time we're picking up this\n    // Suspense boundary, and also after we've reentered it for further hydration.\n    if (current === null) {\n      if (!wasHydrated) {\n        throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n      }\n\n      prepareToHydrateHostSuspenseInstance(workInProgress);\n      bubbleProperties(workInProgress);\n\n      if (enableProfilerTimer) {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          const isTimedOutSuspense = nextState !== null;\n\n          if (isTimedOutSuspense) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            const primaryChildFragment = workInProgress.child;\n\n            if (primaryChildFragment !== null) {\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n              workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n            }\n          }\n        }\n      }\n\n      return false;\n    } else {\n      // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n      // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n      resetHydrationState();\n\n      if ((workInProgress.flags & DidCapture) === NoFlags) {\n        // This boundary did not suspend so it's now hydrated and unsuspended.\n        workInProgress.memoizedState = null;\n      } // If nothing suspended, we need to schedule an effect to mark this boundary\n      // as having hydrated so events know that they're free to be invoked.\n      // It's also a signal to replay events and the suspense callback.\n      // If something suspended, schedule an effect to attach retry listeners.\n      // So we might as well always mark this.\n\n\n      workInProgress.flags |= Update;\n      bubbleProperties(workInProgress);\n\n      if (enableProfilerTimer) {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          const isTimedOutSuspense = nextState !== null;\n\n          if (isTimedOutSuspense) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            const primaryChildFragment = workInProgress.child;\n\n            if (primaryChildFragment !== null) {\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n              workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n  } else {\n    // Successfully completed this tree. If this was a forced client render,\n    // there may have been recoverable errors during first hydration\n    // attempt. If so, add them to a queue so we can log them in the\n    // commit phase.\n    upgradeHydrationErrorsToRecoverable(); // Fall through to normal Suspense path\n\n    return true;\n  }\n}\n\nfunction completeWork(current, workInProgress, renderLanes) {\n  const newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n\n  popTreeContext(workInProgress);\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostRoot:\n      {\n        const fiberRoot = workInProgress.stateNode;\n\n        if (enableTransitionTracing) {\n          const transitions = getWorkInProgressTransitions(); // We set the Passive flag here because if there are new transitions,\n          // we will need to schedule callbacks and process the transitions,\n          // which we do in the passive phase\n\n          if (transitions !== null) {\n            workInProgress.flags |= Passive;\n          }\n        }\n\n        if (enableCache) {\n          let previousCache = null;\n\n          if (current !== null) {\n            previousCache = current.memoizedState.cache;\n          }\n\n          const cache = workInProgress.memoizedState.cache;\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            workInProgress.flags |= Passive;\n          }\n\n          popCacheProvider(workInProgress, cache);\n        }\n\n        if (enableTransitionTracing) {\n          popRootMarkerInstance(workInProgress);\n        }\n\n        popRootTransition(workInProgress, fiberRoot, renderLanes);\n        popHostContainer(workInProgress);\n        popTopLevelLegacyContextObject(workInProgress);\n        resetMutableSourceWorkInProgressVersions();\n\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          const wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // If we hydrated, then we'll need to schedule an update for\n            // the commit side-effects on the root.\n            markUpdate(workInProgress);\n          } else {\n            if (current !== null) {\n              const prevState = current.memoizedState;\n\n              if ( // Check if this is a client root\n              !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n              (workInProgress.flags & ForceClientRender) !== NoFlags) {\n                // Schedule an effect to clear this container at the start of the\n                // next commit. This handles the case of React rendering into a\n                // container with previous children. It's also safe to do for\n                // updates too, because current.child would only be null if the\n                // previous render was null (so the container would already\n                // be empty).\n                workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                // recoverable errors during first hydration attempt. If so, add\n                // them to a queue so we can log them in the commit phase.\n\n                upgradeHydrationErrorsToRecoverable();\n              }\n            }\n          }\n        }\n\n        updateHostContainer(current, workInProgress);\n        bubbleProperties(workInProgress);\n\n        if (enableTransitionTracing) {\n          if ((workInProgress.subtreeFlags & Visibility) !== NoFlags) {\n            // If any of our suspense children toggle visibility, this means that\n            // the pending boundaries array needs to be updated, which we only\n            // do in the passive phase.\n            workInProgress.flags |= Passive;\n          }\n        }\n\n        return null;\n      }\n\n    case HostResource:\n      {\n        if (enableFloat && supportsResources) {\n          popHostContext(workInProgress);\n          const currentRef = current ? current.ref : null;\n\n          if (currentRef !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n\n          if (current === null || current.memoizedState !== workInProgress.memoizedState) {\n            // The workInProgress resource is different than the current one or the current\n            // one does not exist\n            markUpdate(workInProgress);\n          }\n\n          bubbleProperties(workInProgress);\n          return null;\n        }\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    case HostSingleton:\n      {\n        if (enableHostSingletons && supportsSingletons) {\n          popHostContext(workInProgress);\n          const rootContainerInstance = getRootHostContainer();\n          const type = workInProgress.type;\n\n          if (current !== null && workInProgress.stateNode != null) {\n            updateHostComponent(current, workInProgress, type, newProps);\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          } else {\n            if (!newProps) {\n              if (workInProgress.stateNode === null) {\n                throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n              } // This can happen when we abort work.\n\n\n              bubbleProperties(workInProgress);\n              return null;\n            }\n\n            const currentHostContext = getHostContext();\n            const wasHydrated = popHydrationState(workInProgress);\n\n            if (wasHydrated) {\n              // We ignore the boolean indicating there is an updateQueue because\n              // it is used only to set text children and HostSingletons do not\n              // use them.\n              prepareToHydrateHostInstance(workInProgress, currentHostContext);\n            } else {\n              workInProgress.stateNode = resolveSingletonInstance(type, newProps, rootContainerInstance, currentHostContext, true);\n              markUpdate(workInProgress);\n            }\n\n            if (workInProgress.ref !== null) {\n              // If there is a ref on a host node we need to schedule a callback\n              markRef(workInProgress);\n            }\n          }\n\n          bubbleProperties(workInProgress);\n          return null;\n        }\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        const type = workInProgress.type;\n\n        if (current !== null && workInProgress.stateNode != null) {\n          updateHostComponent(current, workInProgress, type, newProps);\n\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n\n            bubbleProperties(workInProgress);\n            return null;\n          }\n\n          const currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on whether we want to add them top->down or\n          // bottom->up. Top->down is faster in IE11.\n\n          const wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (prepareToHydrateHostInstance(workInProgress, currentHostContext)) {\n              // If changes to the hydrated node need to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            const rootContainerInstance = getRootHostContainer();\n            const instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n            appendAllChildren(instance, workInProgress, false, false);\n            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n\n            if (finalizeInitialChildren(instance, type, newProps, currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostText:\n      {\n        const newText = newProps;\n\n        if (current && workInProgress.stateNode != null) {\n          const oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n\n          updateHostText(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n          }\n\n          const rootContainerInstance = getRootHostContainer();\n          const currentHostContext = getHostContext();\n          const wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseHandler(workInProgress);\n        const nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this\n        // to its own fiber type so that we can add other kinds of hydration\n        // boundaries that aren't associated with a Suspense tree. In anticipation\n        // of such a refactor, all the hydration logic is contained in\n        // this branch.\n\n        if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {\n          const fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);\n\n          if (!fallthroughToNormalSuspensePath) {\n            if (workInProgress.flags & ShouldCapture) {\n              // Special case. There were remaining unhydrated nodes. We treat\n              // this as a mismatch. Revert to client rendering.\n              return workInProgress;\n            } else {\n              // Did not finish hydrating, either because this is the initial\n              // render or because something suspended.\n              return null;\n            }\n          } // Continue with the normal Suspense path.\n\n        }\n\n        if ((workInProgress.flags & DidCapture) !== NoFlags) {\n          // Something suspended. Re-render with the fallback children.\n          workInProgress.lanes = renderLanes; // Do not reset the effect list.\n\n          if (enableProfilerTimer && (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          } // Don't bubble properties in this case.\n\n\n          return workInProgress;\n        }\n\n        const nextDidTimeout = nextState !== null;\n        const prevDidTimeout = current !== null && current.memoizedState !== null;\n\n        if (enableCache && nextDidTimeout) {\n          const offscreenFiber = workInProgress.child;\n          let previousCache = null;\n\n          if (offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null && offscreenFiber.alternate.memoizedState.cachePool !== null) {\n            previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;\n          }\n\n          let cache = null;\n\n          if (offscreenFiber.memoizedState !== null && offscreenFiber.memoizedState.cachePool !== null) {\n            cache = offscreenFiber.memoizedState.cachePool.pool;\n          }\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            offscreenFiber.flags |= Passive;\n          }\n        } // If the suspended state of the boundary changes, we need to schedule\n        // a passive effect, which is when we process the transitions\n\n\n        if (nextDidTimeout !== prevDidTimeout) {\n          if (enableTransitionTracing) {\n            const offscreenFiber = workInProgress.child;\n            offscreenFiber.flags |= Passive;\n          } // If the suspended state of the boundary changes, we need to schedule\n          // an effect to toggle the subtree's visibility. When we switch from\n          // fallback -> primary, the inner Offscreen fiber schedules this effect\n          // as part of its normal complete phase. But when we switch from\n          // primary -> fallback, the inner Offscreen fiber does not have a complete\n          // phase. So we need to schedule its effect here.\n          //\n          // We also use this flag to connect/disconnect the effects, but the same\n          // logic applies: when re-connecting, the Offscreen fiber's complete\n          // phase will handle scheduling the effect. It's only when the fallback\n          // is active that we have to do anything special.\n\n\n          if (nextDidTimeout) {\n            const offscreenFiber = workInProgress.child;\n            offscreenFiber.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything\n            // in the concurrent tree already suspended during this render.\n            // This is a known bug.\n\n            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n              // TODO: Move this back to throwException because this is too late\n              // if this is a large tree which is common for initial loads. We\n              // don't know if we should restart a render or not until we get\n              // this marker, and this is too late.\n              // If this render already had a ping or lower pri updates,\n              // and this is the first time we know we're going to suspend we\n              // should be able to immediately restart from within throwException.\n              if (isBadSuspenseFallback(current, newProps)) {\n                renderDidSuspendDelayIfPossible();\n              } else {\n                renderDidSuspend();\n              }\n            }\n          }\n        }\n\n        const wakeables = workInProgress.updateQueue;\n\n        if (wakeables !== null) {\n          // Schedule an effect to attach a retry listener to the promise.\n          // TODO: Move to passive phase\n          workInProgress.flags |= Update;\n        }\n\n        if (enableSuspenseCallback && workInProgress.updateQueue !== null && workInProgress.memoizedProps.suspenseCallback != null) {\n          // Always notify the callback\n          // TODO: Move to passive phase\n          workInProgress.flags |= Update;\n        }\n\n        bubbleProperties(workInProgress);\n\n        if (enableProfilerTimer) {\n          if ((workInProgress.mode & ProfileMode) !== NoMode) {\n            if (nextDidTimeout) {\n              // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n              const primaryChildFragment = workInProgress.child;\n\n              if (primaryChildFragment !== null) {\n                // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(current, workInProgress);\n\n      if (current === null) {\n        preparePortalMount(workInProgress.stateNode.containerInfo);\n      }\n\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ContextProvider:\n      // Pop provider fiber\n      const context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n\n    case IncompleteClassComponent:\n      {\n        // Same as class component case. I put it down here so that the tags are\n        // sequential to ensure this switch is compiled to a jump table.\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          popLegacyContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseListContext(workInProgress);\n        const renderState = workInProgress.memoizedState;\n\n        if (renderState === null) {\n          // We're running in the default, \"independent\" mode.\n          // We don't do anything in this mode.\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        let didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n        const renderedTail = renderState.rendering;\n\n        if (renderedTail === null) {\n          // We just rendered the head.\n          if (!didSuspendAlready) {\n            // This is the first pass. We need to figure out if anything is still\n            // suspended in the rendered set.\n            // If new content unsuspended, but there's still some content that\n            // didn't. Then we need to do a second pass that forces everything\n            // to keep showing their fallbacks.\n            // We might be suspended if something in this render pass suspended, or\n            // something in the previous committed pass suspended. Otherwise,\n            // there's no chance so we can skip the expensive call to\n            // findFirstSuspended.\n            const cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\n\n            if (!cannotBeSuspended) {\n              let row = workInProgress.child;\n\n              while (row !== null) {\n                const suspended = findFirstSuspended(row);\n\n                if (suspended !== null) {\n                  didSuspendAlready = true;\n                  workInProgress.flags |= DidCapture;\n                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                  // part of the second pass. In that case nothing will subscribe to\n                  // its thenables. Instead, we'll transfer its thenables to the\n                  // SuspenseList so that it can retry if they resolve.\n                  // There might be multiple of these in the list but since we're\n                  // going to wait for all of them anyway, it doesn't really matter\n                  // which ones gets to ping. In theory we could get clever and keep\n                  // track of how many dependencies remain but it gets tricky because\n                  // in the meantime, we can add/remove/change items and dependencies.\n                  // We might bail out of the loop before finding any but that\n                  // doesn't matter since that means that the other boundaries that\n                  // we did find already has their listeners attached.\n\n                  const newThenables = suspended.updateQueue;\n\n                  if (newThenables !== null) {\n                    workInProgress.updateQueue = newThenables;\n                    workInProgress.flags |= Update;\n                  } // Rerender the whole list, but this time, we'll force fallbacks\n                  // to stay in place.\n                  // Reset the effect flags before doing the second pass since that's now invalid.\n                  // Reset the child fibers to their original state.\n\n\n                  workInProgress.subtreeFlags = NoFlags;\n                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense List Context to force suspense and\n                  // immediately rerender the children.\n\n                  pushSuspenseListContext(workInProgress, setShallowSuspenseListContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n\n                  return workInProgress.child;\n                }\n\n                row = row.sibling;\n              }\n            }\n\n            if (renderState.tail !== null && now() > getRenderTargetTime()) {\n              // We have already passed our CPU deadline but we still have rows\n              // left in the tail. We'll just give up further attempts to render\n              // the main content and only render fallbacks.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          } else {\n            cutOffTailIfNeeded(renderState, false);\n          } // Next we're going to render the tail.\n\n        } else {\n          // Append the rendered row to the child list.\n          if (!didSuspendAlready) {\n            const suspended = findFirstSuspended(renderedTail);\n\n            if (suspended !== null) {\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n              // get lost if this row ends up dropped during a second pass.\n\n              const newThenables = suspended.updateQueue;\n\n              if (newThenables !== null) {\n                workInProgress.updateQueue = newThenables;\n                workInProgress.flags |= Update;\n              }\n\n              cutOffTailIfNeeded(renderState, true); // This might have been modified.\n\n              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n              ) {\n                // We're done.\n                bubbleProperties(workInProgress);\n                return null;\n              }\n            } else if ( // The time it took to render last row is greater than the remaining\n            // time we have to render. So rendering one more row would likely\n            // exceed it.\n            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n              // We have now passed our CPU deadline and we'll just give up further\n              // attempts to render the main content and only render fallbacks.\n              // The assumption is that this is usually faster.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          }\n\n          if (renderState.isBackwards) {\n            // The effect list of the backwards tail will have been added\n            // to the end. This breaks the guarantee that life-cycles fire in\n            // sibling order but that isn't a strong guarantee promised by React.\n            // Especially since these might also just pop in during future commits.\n            // Append to the beginning of the list.\n            renderedTail.sibling = workInProgress.child;\n            workInProgress.child = renderedTail;\n          } else {\n            const previousSibling = renderState.last;\n\n            if (previousSibling !== null) {\n              previousSibling.sibling = renderedTail;\n            } else {\n              workInProgress.child = renderedTail;\n            }\n\n            renderState.last = renderedTail;\n          }\n        }\n\n        if (renderState.tail !== null) {\n          // We still have tail rows to render.\n          // Pop a row.\n          const next = renderState.tail;\n          renderState.rendering = next;\n          renderState.tail = next.sibling;\n          renderState.renderingStartTime = now();\n          next.sibling = null; // Restore the context.\n          // TODO: We can probably just avoid popping it instead and only\n          // setting it the first time we go from not suspended to suspended.\n\n          let suspenseContext = suspenseStackCursor.current;\n\n          if (didSuspendAlready) {\n            suspenseContext = setShallowSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n          } else {\n            suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n          }\n\n          pushSuspenseListContext(workInProgress, suspenseContext); // Do a pass over the next row.\n          // Don't bubble properties in this case.\n\n          return next;\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          if (current === null) {\n            const scopeInstance = createScopeInstance();\n            workInProgress.stateNode = scopeInstance;\n            prepareScopeUpdate(scopeInstance, workInProgress);\n\n            if (workInProgress.ref !== null) {\n              markRef(workInProgress);\n              markUpdate(workInProgress);\n            }\n          } else {\n            if (workInProgress.ref !== null) {\n              markUpdate(workInProgress);\n            }\n\n            if (current.ref !== workInProgress.ref) {\n              markRef(workInProgress);\n            }\n          }\n\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        popSuspenseHandler(workInProgress);\n        popHiddenContext(workInProgress);\n        const nextState = workInProgress.memoizedState;\n        const nextIsHidden = nextState !== null; // Schedule a Visibility effect if the visibility has changed\n\n        if (enableLegacyHidden && workInProgress.tag === LegacyHiddenComponent) {// LegacyHidden doesn't do any hiding — it only pre-renders.\n        } else {\n          if (current !== null) {\n            const prevState = current.memoizedState;\n            const prevIsHidden = prevState !== null;\n\n            if (prevIsHidden !== nextIsHidden) {\n              workInProgress.flags |= Visibility;\n            }\n          } else {\n            // On initial mount, we only need a Visibility effect if the tree\n            // is hidden.\n            if (nextIsHidden) {\n              workInProgress.flags |= Visibility;\n            }\n          }\n        }\n\n        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n          bubbleProperties(workInProgress);\n        } else {\n          // Don't bubble properties for hidden children unless we're rendering\n          // at offscreen priority.\n          if (includesSomeLane(renderLanes, OffscreenLane) && // Also don't bubble if the tree suspended\n          (workInProgress.flags & DidCapture) === NoLanes) {\n            bubbleProperties(workInProgress); // Check if there was an insertion or update in the hidden subtree.\n            // If so, we need to hide those nodes in the commit phase, so\n            // schedule a visibility effect.\n\n            if ((!enableLegacyHidden || workInProgress.tag !== LegacyHiddenComponent) && workInProgress.subtreeFlags & (Placement | Update)) {\n              workInProgress.flags |= Visibility;\n            }\n          }\n        }\n\n        if (workInProgress.updateQueue !== null) {\n          // Schedule an effect to attach Suspense retry listeners\n          // TODO: Move to passive phase\n          workInProgress.flags |= Update;\n        }\n\n        if (enableCache) {\n          let previousCache = null;\n\n          if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n            previousCache = current.memoizedState.cachePool.pool;\n          }\n\n          let cache = null;\n\n          if (workInProgress.memoizedState !== null && workInProgress.memoizedState.cachePool !== null) {\n            cache = workInProgress.memoizedState.cachePool.pool;\n          }\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            workInProgress.flags |= Passive;\n          }\n        }\n\n        popTransition(workInProgress, current);\n        return null;\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          let previousCache = null;\n\n          if (current !== null) {\n            previousCache = current.memoizedState.cache;\n          }\n\n          const cache = workInProgress.memoizedState.cache;\n\n          if (cache !== previousCache) {\n            // Run passive effects to retain/release the cache.\n            workInProgress.flags |= Passive;\n          }\n\n          popCacheProvider(workInProgress, cache);\n          bubbleProperties(workInProgress);\n        }\n\n        return null;\n      }\n\n    case TracingMarkerComponent:\n      {\n        if (enableTransitionTracing) {\n          const instance = workInProgress.stateNode;\n\n          if (instance !== null) {\n            popMarkerInstance(workInProgress);\n          }\n\n          bubbleProperties(workInProgress);\n        }\n\n        return null;\n      }\n  }\n\n  throw new Error(`Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` + 'React. Please file an issue.');\n}\n\nexport { completeWork };","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberCompleteWork.js"],"names":["isOffscreenManual","enableLegacyHidden","enableHostSingletons","enableSuspenseCallback","enableScopeAPI","enableProfilerTimer","enableCache","enableTransitionTracing","enableFloat","resetWorkInProgressVersions","resetMutableSourceWorkInProgressVersions","now","IndeterminateComponent","FunctionComponent","ClassComponent","HostRoot","HostComponent","HostResource","HostSingleton","HostText","HostPortal","ContextProvider","ContextConsumer","ForwardRef","Fragment","Mode","Profiler","SuspenseComponent","SuspenseListComponent","MemoComponent","SimpleMemoComponent","LazyComponent","IncompleteClassComponent","ScopeComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","TracingMarkerComponent","NoMode","ConcurrentMode","ProfileMode","Ref","RefStatic","Placement","Update","Visibility","NoFlags","DidCapture","Snapshot","ChildDeletion","StaticMask","MutationMask","Passive","Incomplete","ShouldCapture","ForceClientRender","createInstance","createTextInstance","resolveSingletonInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","supportsMutation","supportsPersistence","supportsResources","supportsSingletons","cloneInstance","cloneHiddenInstance","cloneHiddenTextInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","preparePortalMount","prepareScopeUpdate","getRootHostContainer","popHostContext","getHostContext","popHostContainer","suspenseStackCursor","popSuspenseListContext","popSuspenseHandler","pushSuspenseListContext","setShallowSuspenseListContext","ForceSuspenseFallback","setDefaultShallowSuspenseListContext","isBadSuspenseFallback","popHiddenContext","findFirstSuspended","isContextProvider","isLegacyContextProvider","popContext","popLegacyContext","popTopLevelContextObject","popTopLevelLegacyContextObject","popProvider","prepareToHydrateHostInstance","prepareToHydrateHostTextInstance","prepareToHydrateHostSuspenseInstance","warnIfUnhydratedTailNodes","popHydrationState","resetHydrationState","getIsHydrating","hasUnhydratedTailNodes","upgradeHydrationErrorsToRecoverable","renderDidSuspend","renderDidSuspendDelayIfPossible","renderHasNotSuspendedYet","getRenderTargetTime","getWorkInProgressTransitions","OffscreenLane","SomeRetryLane","NoLanes","includesSomeLane","mergeLanes","resetChildFibers","createScopeInstance","transferActualDuration","popCacheProvider","popTreeContext","popRootTransition","popTransition","popMarkerInstance","popRootMarkerInstance","markUpdate","workInProgress","flags","markRef","hadNoMutationsEffects","current","completedWork","didBailout","child","subtreeFlags","sibling","appendAllChildren","updateHostContainer","updateHostComponent","updateHostText","parent","needsVisibilityToggle","isHidden","node","tag","stateNode","return","type","newProps","oldProps","memoizedProps","instance","currentHostContext","updatePayload","updateQueue","oldText","newText","branches","props","text","memoizedState","appendAllChildrenToContainer","containerChildSet","_needsVisibilityToggle","portalOrRoot","childrenUnchanged","container","containerInfo","newChildSet","pendingChildren","currentInstance","recyclableInstance","newInstance","rootContainerInstance","cutOffTailIfNeeded","renderState","hasRenderedATailFallback","tailMode","tailNode","tail","lastTailNode","alternate","bubbleProperties","newChildLanes","mode","actualDuration","treeBaseDuration","selfBaseDuration","lanes","childLanes","completeDehydratedSuspenseBoundary","nextState","wasHydrated","dehydrated","Error","isTimedOutSuspense","primaryChildFragment","completeWork","renderLanes","pendingProps","Component","fiberRoot","transitions","previousCache","cache","pendingContext","context","prevState","isDehydrated","currentRef","ref","fallthroughToNormalSuspensePath","nextDidTimeout","prevDidTimeout","offscreenFiber","cachePool","pool","wakeables","suspenseCallback","_context","didSuspendAlready","renderedTail","rendering","cannotBeSuspended","row","suspended","newThenables","renderingStartTime","isBackwards","previousSibling","last","next","suspenseContext","scopeInstance","nextIsHidden","prevIsHidden"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {RootState} from './ReactFiberRoot';\nimport type {Lanes, Lane} from './ReactFiberLane';\nimport type {\n  ReactScopeInstance,\n  ReactContext,\n  Wakeable,\n} from 'shared/ReactTypes';\nimport type {\n  Instance,\n  Type,\n  Props,\n  Container,\n  ChildSet,\n} from './ReactFiberHostConfig';\nimport type {\n  SuspenseState,\n  SuspenseListRenderState,\n} from './ReactFiberSuspenseComponent';\nimport {isOffscreenManual} from './ReactFiberOffscreenComponent';\nimport type {OffscreenState} from './ReactFiberOffscreenComponent';\nimport type {TracingMarkerInstance} from './ReactFiberTracingMarkerComponent';\nimport type {Cache} from './ReactFiberCacheComponent';\nimport {\n  enableLegacyHidden,\n  enableHostSingletons,\n  enableSuspenseCallback,\n  enableScopeAPI,\n  enableProfilerTimer,\n  enableCache,\n  enableTransitionTracing,\n  enableFloat,\n} from 'shared/ReactFeatureFlags';\n\nimport {resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions} from './ReactMutableSource';\n\nimport {now} from './Scheduler';\n\nimport {\n  IndeterminateComponent,\n  FunctionComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostResource,\n  HostSingleton,\n  HostText,\n  HostPortal,\n  ContextProvider,\n  ContextConsumer,\n  ForwardRef,\n  Fragment,\n  Mode,\n  Profiler,\n  SuspenseComponent,\n  SuspenseListComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  LazyComponent,\n  IncompleteClassComponent,\n  ScopeComponent,\n  OffscreenComponent,\n  LegacyHiddenComponent,\n  CacheComponent,\n  TracingMarkerComponent,\n} from './ReactWorkTags';\nimport {NoMode, ConcurrentMode, ProfileMode} from './ReactTypeOfMode';\nimport {\n  Ref,\n  RefStatic,\n  Placement,\n  Update,\n  Visibility,\n  NoFlags,\n  DidCapture,\n  Snapshot,\n  ChildDeletion,\n  StaticMask,\n  MutationMask,\n  Passive,\n  Incomplete,\n  ShouldCapture,\n  ForceClientRender,\n} from './ReactFiberFlags';\n\nimport {\n  createInstance,\n  createTextInstance,\n  resolveSingletonInstance,\n  appendInitialChild,\n  finalizeInitialChildren,\n  prepareUpdate,\n  supportsMutation,\n  supportsPersistence,\n  supportsResources,\n  supportsSingletons,\n  cloneInstance,\n  cloneHiddenInstance,\n  cloneHiddenTextInstance,\n  createContainerChildSet,\n  appendChildToContainerChildSet,\n  finalizeContainerChildren,\n  preparePortalMount,\n  prepareScopeUpdate,\n} from './ReactFiberHostConfig';\nimport {\n  getRootHostContainer,\n  popHostContext,\n  getHostContext,\n  popHostContainer,\n} from './ReactFiberHostContext';\nimport {\n  suspenseStackCursor,\n  popSuspenseListContext,\n  popSuspenseHandler,\n  pushSuspenseListContext,\n  setShallowSuspenseListContext,\n  ForceSuspenseFallback,\n  setDefaultShallowSuspenseListContext,\n  isBadSuspenseFallback,\n} from './ReactFiberSuspenseContext';\nimport {popHiddenContext} from './ReactFiberHiddenContext';\nimport {findFirstSuspended} from './ReactFiberSuspenseComponent';\nimport {\n  isContextProvider as isLegacyContextProvider,\n  popContext as popLegacyContext,\n  popTopLevelContextObject as popTopLevelLegacyContextObject,\n} from './ReactFiberContext';\nimport {popProvider} from './ReactFiberNewContext';\nimport {\n  prepareToHydrateHostInstance,\n  prepareToHydrateHostTextInstance,\n  prepareToHydrateHostSuspenseInstance,\n  warnIfUnhydratedTailNodes,\n  popHydrationState,\n  resetHydrationState,\n  getIsHydrating,\n  hasUnhydratedTailNodes,\n  upgradeHydrationErrorsToRecoverable,\n} from './ReactFiberHydrationContext';\nimport {\n  renderDidSuspend,\n  renderDidSuspendDelayIfPossible,\n  renderHasNotSuspendedYet,\n  getRenderTargetTime,\n  getWorkInProgressTransitions,\n} from './ReactFiberWorkLoop';\nimport {\n  OffscreenLane,\n  SomeRetryLane,\n  NoLanes,\n  includesSomeLane,\n  mergeLanes,\n} from './ReactFiberLane';\nimport {resetChildFibers} from './ReactChildFiber';\nimport {createScopeInstance} from './ReactFiberScope';\nimport {transferActualDuration} from './ReactProfilerTimer';\nimport {popCacheProvider} from './ReactFiberCacheComponent';\nimport {popTreeContext} from './ReactFiberTreeContext';\nimport {popRootTransition, popTransition} from './ReactFiberTransition';\nimport {\n  popMarkerInstance,\n  popRootMarkerInstance,\n} from './ReactFiberTracingMarkerComponent';\n\nfunction markUpdate(workInProgress: Fiber) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.flags |= Update;\n}\n\nfunction markRef(workInProgress: Fiber) {\n  workInProgress.flags |= Ref | RefStatic;\n}\n\nfunction hadNoMutationsEffects(current: null | Fiber, completedWork: Fiber) {\n  const didBailout = current !== null && current.child === completedWork.child;\n  if (didBailout) {\n    return true;\n  }\n\n  if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n    return false;\n  }\n\n  // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n  // then we only have to check the `completedWork.subtreeFlags`.\n  let child = completedWork.child;\n  while (child !== null) {\n    if (\n      (child.flags & MutationMask) !== NoFlags ||\n      (child.subtreeFlags & MutationMask) !== NoFlags\n    ) {\n      return false;\n    }\n    child = child.sibling;\n  }\n  return true;\n}\n\nlet appendAllChildren;\nlet updateHostContainer;\nlet updateHostComponent;\nlet updateHostText;\nif (supportsMutation) {\n  // Mutation mode\n\n  appendAllChildren = function(\n    parent: Instance,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (\n        node.tag === HostPortal ||\n        (enableHostSingletons && supportsSingletons\n          ? node.tag === HostSingleton\n          : false)\n      ) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n        // If we have a HostSingleton it will be placed independently\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      while (node.sibling === null) {\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function(current: null | Fiber, workInProgress: Fiber) {\n    // Noop\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n  ) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    const oldProps = current.memoizedProps;\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    }\n\n    // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n    const instance: Instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n    const updatePayload = prepareUpdate(\n      instance,\n      type,\n      oldProps,\n      newProps,\n      currentHostContext,\n    );\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = (updatePayload: any);\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n\n  appendAllChildren = function(\n    parent: Instance,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (\n        node.tag === OffscreenComponent &&\n        node.memoizedState !== null\n      ) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        const child = node.child;\n        if (child !== null) {\n          child.return = node;\n        }\n        appendAllChildren(parent, node, true, true);\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      node = (node: Fiber);\n      if (node === workInProgress) {\n        return;\n      }\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      while (node.sibling === null) {\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\n  const appendAllChildrenToContainer = function(\n    containerChildSet: ChildSet,\n    workInProgress: Fiber,\n    needsVisibilityToggle: boolean,\n    isHidden: boolean,\n  ) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    let node = workInProgress.child;\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n      branches: if (node.tag === HostComponent) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const props = node.memoizedProps;\n          const type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        let instance = node.stateNode;\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          const text = node.memoizedProps;\n          instance = cloneHiddenTextInstance(instance, text, node);\n        }\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (\n        node.tag === OffscreenComponent &&\n        node.memoizedState !== null\n      ) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        const child = node.child;\n        if (child !== null) {\n          child.return = node;\n        }\n        // If Offscreen is not in manual mode, detached tree is hidden from user space.\n        const _needsVisibilityToggle = !isOffscreenManual(node);\n        appendAllChildrenToContainer(\n          containerChildSet,\n          node,\n          _needsVisibilityToggle,\n          true,\n        );\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      node = (node: Fiber);\n      if (node === workInProgress) {\n        return;\n      }\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      while (node.sibling === null) {\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n  updateHostContainer = function(current: null | Fiber, workInProgress: Fiber) {\n    const portalOrRoot: {\n      containerInfo: Container,\n      pendingChildren: ChildSet,\n      ...\n    } = workInProgress.stateNode;\n    const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n    if (childrenUnchanged) {\n      // No changes, just reuse the existing instance.\n    } else {\n      const container = portalOrRoot.containerInfo;\n      const newChildSet = createContainerChildSet(container);\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet;\n      // Schedule an update on the container to swap out the container.\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n  ) {\n    const currentInstance = current.stateNode;\n    const oldProps = current.memoizedProps;\n    // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n    const childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    const recyclableInstance: Instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    let updatePayload = null;\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(\n        recyclableInstance,\n        type,\n        oldProps,\n        newProps,\n        currentHostContext,\n      );\n    }\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    const newInstance = cloneInstance(\n      currentInstance,\n      updatePayload,\n      type,\n      oldProps,\n      newProps,\n      workInProgress,\n      childrenUnchanged,\n      recyclableInstance,\n    );\n    if (\n      finalizeInitialChildren(newInstance, type, newProps, currentHostContext)\n    ) {\n      markUpdate(workInProgress);\n    }\n    workInProgress.stateNode = newInstance;\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      const rootContainerInstance = getRootHostContainer();\n      const currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(\n        newText,\n        rootContainerInstance,\n        currentHostContext,\n        workInProgress,\n      );\n      // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n      markUpdate(workInProgress);\n    } else {\n      workInProgress.stateNode = current.stateNode;\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function(current: null | Fiber, workInProgress: Fiber) {\n    // Noop\n  };\n  updateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n  ) {\n    // Noop\n  };\n  updateHostText = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    oldText: string,\n    newText: string,\n  ) {\n    // Noop\n  };\n}\n\nfunction cutOffTailIfNeeded(\n  renderState: SuspenseListRenderState,\n  hasRenderedATailFallback: boolean,\n) {\n  if (getIsHydrating()) {\n    // If we're hydrating, we should consume as many items as we can\n    // so we don't leave any behind.\n    return;\n  }\n  switch (renderState.tailMode) {\n    case 'hidden': {\n      // Any insertions at the end of the tail list after this point\n      // should be invisible. If there are already mounted boundaries\n      // anything before them are not considered for collapsing.\n      // Therefore we need to go through the whole tail to find if\n      // there are any.\n      let tailNode = renderState.tail;\n      let lastTailNode = null;\n      while (tailNode !== null) {\n        if (tailNode.alternate !== null) {\n          lastTailNode = tailNode;\n        }\n        tailNode = tailNode.sibling;\n      }\n      // Next we're simply going to delete all insertions after the\n      // last rendered item.\n      if (lastTailNode === null) {\n        // All remaining items in the tail are insertions.\n        renderState.tail = null;\n      } else {\n        // Detach the insertion after the last node that was already\n        // inserted.\n        lastTailNode.sibling = null;\n      }\n      break;\n    }\n    case 'collapsed': {\n      // Any insertions at the end of the tail list after this point\n      // should be invisible. If there are already mounted boundaries\n      // anything before them are not considered for collapsing.\n      // Therefore we need to go through the whole tail to find if\n      // there are any.\n      let tailNode = renderState.tail;\n      let lastTailNode = null;\n      while (tailNode !== null) {\n        if (tailNode.alternate !== null) {\n          lastTailNode = tailNode;\n        }\n        tailNode = tailNode.sibling;\n      }\n      // Next we're simply going to delete all insertions after the\n      // last rendered item.\n      if (lastTailNode === null) {\n        // All remaining items in the tail are insertions.\n        if (!hasRenderedATailFallback && renderState.tail !== null) {\n          // We suspended during the head. We want to show at least one\n          // row at the tail. So we'll keep on and cut off the rest.\n          renderState.tail.sibling = null;\n        } else {\n          renderState.tail = null;\n        }\n      } else {\n        // Detach the insertion after the last node that was already\n        // inserted.\n        lastTailNode.sibling = null;\n      }\n      break;\n    }\n  }\n}\n\nfunction bubbleProperties(completedWork: Fiber) {\n  const didBailout =\n    completedWork.alternate !== null &&\n    completedWork.alternate.child === completedWork.child;\n\n  let newChildLanes = NoLanes;\n  let subtreeFlags = NoFlags;\n\n  if (!didBailout) {\n    // Bubble up the earliest expiration time.\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      let actualDuration = completedWork.actualDuration;\n      let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\n\n      let child = completedWork.child;\n      while (child !== null) {\n        newChildLanes = mergeLanes(\n          newChildLanes,\n          mergeLanes(child.lanes, child.childLanes),\n        );\n\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags;\n\n        // When a fiber is cloned, its actualDuration is reset to 0. This value will\n        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n        // When work is done, it should bubble to the parent's actualDuration. If\n        // the fiber has not been cloned though, (meaning no work was done), then\n        // this value will reflect the amount of time spent working on a previous\n        // render. In that case it should not bubble. We determine whether it was\n        // cloned by comparing the child pointer.\n        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n        actualDuration += child.actualDuration;\n\n        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.actualDuration = actualDuration;\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      let child = completedWork.child;\n      while (child !== null) {\n        newChildLanes = mergeLanes(\n          newChildLanes,\n          mergeLanes(child.lanes, child.childLanes),\n        );\n\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags;\n\n        // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n        child.return = completedWork;\n\n        child = child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  } else {\n    // Bubble up the earliest expiration time.\n    if (enableProfilerTimer && (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      let treeBaseDuration = ((completedWork.selfBaseDuration: any): number);\n\n      let child = completedWork.child;\n      while (child !== null) {\n        newChildLanes = mergeLanes(\n          newChildLanes,\n          mergeLanes(child.lanes, child.childLanes),\n        );\n\n        // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n        subtreeFlags |= child.subtreeFlags & StaticMask;\n        subtreeFlags |= child.flags & StaticMask;\n\n        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      let child = completedWork.child;\n      while (child !== null) {\n        newChildLanes = mergeLanes(\n          newChildLanes,\n          mergeLanes(child.lanes, child.childLanes),\n        );\n\n        // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n        subtreeFlags |= child.subtreeFlags & StaticMask;\n        subtreeFlags |= child.flags & StaticMask;\n\n        // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n        child.return = completedWork;\n\n        child = child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  }\n\n  completedWork.childLanes = newChildLanes;\n\n  return didBailout;\n}\n\nfunction completeDehydratedSuspenseBoundary(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextState: SuspenseState | null,\n): boolean {\n  if (\n    hasUnhydratedTailNodes() &&\n    (workInProgress.mode & ConcurrentMode) !== NoMode &&\n    (workInProgress.flags & DidCapture) === NoFlags\n  ) {\n    warnIfUnhydratedTailNodes(workInProgress);\n    resetHydrationState();\n    workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\n\n    return false;\n  }\n\n  const wasHydrated = popHydrationState(workInProgress);\n\n  if (nextState !== null && nextState.dehydrated !== null) {\n    // We might be inside a hydration state the first time we're picking up this\n    // Suspense boundary, and also after we've reentered it for further hydration.\n    if (current === null) {\n      if (!wasHydrated) {\n        throw new Error(\n          'A dehydrated suspense component was completed without a hydrated node. ' +\n            'This is probably a bug in React.',\n        );\n      }\n      prepareToHydrateHostSuspenseInstance(workInProgress);\n      bubbleProperties(workInProgress);\n      if (enableProfilerTimer) {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          const isTimedOutSuspense = nextState !== null;\n          if (isTimedOutSuspense) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            const primaryChildFragment = workInProgress.child;\n            if (primaryChildFragment !== null) {\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n              workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\n            }\n          }\n        }\n      }\n      return false;\n    } else {\n      // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n      // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n      resetHydrationState();\n      if ((workInProgress.flags & DidCapture) === NoFlags) {\n        // This boundary did not suspend so it's now hydrated and unsuspended.\n        workInProgress.memoizedState = null;\n      }\n      // If nothing suspended, we need to schedule an effect to mark this boundary\n      // as having hydrated so events know that they're free to be invoked.\n      // It's also a signal to replay events and the suspense callback.\n      // If something suspended, schedule an effect to attach retry listeners.\n      // So we might as well always mark this.\n      workInProgress.flags |= Update;\n      bubbleProperties(workInProgress);\n      if (enableProfilerTimer) {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          const isTimedOutSuspense = nextState !== null;\n          if (isTimedOutSuspense) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            const primaryChildFragment = workInProgress.child;\n            if (primaryChildFragment !== null) {\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n              workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\n            }\n          }\n        }\n      }\n      return false;\n    }\n  } else {\n    // Successfully completed this tree. If this was a forced client render,\n    // there may have been recoverable errors during first hydration\n    // attempt. If so, add them to a queue so we can log them in the\n    // commit phase.\n    upgradeHydrationErrorsToRecoverable();\n\n    // Fall through to normal Suspense path\n    return true;\n  }\n}\n\nfunction completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  const newProps = workInProgress.pendingProps;\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostRoot: {\n      const fiberRoot = (workInProgress.stateNode: FiberRoot);\n\n      if (enableTransitionTracing) {\n        const transitions = getWorkInProgressTransitions();\n        // We set the Passive flag here because if there are new transitions,\n        // we will need to schedule callbacks and process the transitions,\n        // which we do in the passive phase\n        if (transitions !== null) {\n          workInProgress.flags |= Passive;\n        }\n      }\n\n      if (enableCache) {\n        let previousCache: Cache | null = null;\n        if (current !== null) {\n          previousCache = current.memoizedState.cache;\n        }\n        const cache: Cache = workInProgress.memoizedState.cache;\n        if (cache !== previousCache) {\n          // Run passive effects to retain/release the cache.\n          workInProgress.flags |= Passive;\n        }\n        popCacheProvider(workInProgress, cache);\n      }\n\n      if (enableTransitionTracing) {\n        popRootMarkerInstance(workInProgress);\n      }\n\n      popRootTransition(workInProgress, fiberRoot, renderLanes);\n      popHostContainer(workInProgress);\n      popTopLevelLegacyContextObject(workInProgress);\n      resetMutableSourceWorkInProgressVersions();\n      if (fiberRoot.pendingContext) {\n        fiberRoot.context = fiberRoot.pendingContext;\n        fiberRoot.pendingContext = null;\n      }\n      if (current === null || current.child === null) {\n        // If we hydrated, pop so that we can delete any remaining children\n        // that weren't hydrated.\n        const wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // If we hydrated, then we'll need to schedule an update for\n          // the commit side-effects on the root.\n          markUpdate(workInProgress);\n        } else {\n          if (current !== null) {\n            const prevState: RootState = current.memoizedState;\n            if (\n              // Check if this is a client root\n              !prevState.isDehydrated ||\n              // Check if we reverted to client rendering (e.g. due to an error)\n              (workInProgress.flags & ForceClientRender) !== NoFlags\n            ) {\n              // Schedule an effect to clear this container at the start of the\n              // next commit. This handles the case of React rendering into a\n              // container with previous children. It's also safe to do for\n              // updates too, because current.child would only be null if the\n              // previous render was null (so the container would already\n              // be empty).\n              workInProgress.flags |= Snapshot;\n\n              // If this was a forced client render, there may have been\n              // recoverable errors during first hydration attempt. If so, add\n              // them to a queue so we can log them in the commit phase.\n              upgradeHydrationErrorsToRecoverable();\n            }\n          }\n        }\n      }\n      updateHostContainer(current, workInProgress);\n      bubbleProperties(workInProgress);\n      if (enableTransitionTracing) {\n        if ((workInProgress.subtreeFlags & Visibility) !== NoFlags) {\n          // If any of our suspense children toggle visibility, this means that\n          // the pending boundaries array needs to be updated, which we only\n          // do in the passive phase.\n          workInProgress.flags |= Passive;\n        }\n      }\n      return null;\n    }\n    case HostResource: {\n      if (enableFloat && supportsResources) {\n        popHostContext(workInProgress);\n        const currentRef = current ? current.ref : null;\n        if (currentRef !== workInProgress.ref) {\n          markRef(workInProgress);\n        }\n        if (\n          current === null ||\n          current.memoizedState !== workInProgress.memoizedState\n        ) {\n          // The workInProgress resource is different than the current one or the current\n          // one does not exist\n          markUpdate(workInProgress);\n        }\n        bubbleProperties(workInProgress);\n        return null;\n      }\n    }\n    // eslint-disable-next-line-no-fallthrough\n    case HostSingleton: {\n      if (enableHostSingletons && supportsSingletons) {\n        popHostContext(workInProgress);\n        const rootContainerInstance = getRootHostContainer();\n        const type = workInProgress.type;\n        if (current !== null && workInProgress.stateNode != null) {\n          updateHostComponent(current, workInProgress, type, newProps);\n\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            if (workInProgress.stateNode === null) {\n              throw new Error(\n                'We must have new props for new mounts. This error is likely ' +\n                  'caused by a bug in React. Please file an issue.',\n              );\n            }\n\n            // This can happen when we abort work.\n            bubbleProperties(workInProgress);\n            return null;\n          }\n\n          const currentHostContext = getHostContext();\n          const wasHydrated = popHydrationState(workInProgress);\n          if (wasHydrated) {\n            // We ignore the boolean indicating there is an updateQueue because\n            // it is used only to set text children and HostSingletons do not\n            // use them.\n            prepareToHydrateHostInstance(workInProgress, currentHostContext);\n          } else {\n            workInProgress.stateNode = resolveSingletonInstance(\n              type,\n              newProps,\n              rootContainerInstance,\n              currentHostContext,\n              true,\n            );\n            markUpdate(workInProgress);\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n        bubbleProperties(workInProgress);\n        return null;\n      }\n    }\n    // eslint-disable-next-line-no-fallthrough\n    case HostComponent: {\n      popHostContext(workInProgress);\n      const type = workInProgress.type;\n      if (current !== null && workInProgress.stateNode != null) {\n        updateHostComponent(current, workInProgress, type, newProps);\n\n        if (current.ref !== workInProgress.ref) {\n          markRef(workInProgress);\n        }\n      } else {\n        if (!newProps) {\n          if (workInProgress.stateNode === null) {\n            throw new Error(\n              'We must have new props for new mounts. This error is likely ' +\n                'caused by a bug in React. Please file an issue.',\n            );\n          }\n\n          // This can happen when we abort work.\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        const currentHostContext = getHostContext();\n        // TODO: Move createInstance to beginWork and keep it on a context\n        // \"stack\" as the parent. Then append children as we go in beginWork\n        // or completeWork depending on whether we want to add them top->down or\n        // bottom->up. Top->down is faster in IE11.\n        const wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          // TODO: Move this and createInstance step into the beginPhase\n          // to consolidate.\n          if (\n            prepareToHydrateHostInstance(workInProgress, currentHostContext)\n          ) {\n            // If changes to the hydrated node need to be applied at the\n            // commit-phase we mark this as such.\n            markUpdate(workInProgress);\n          }\n        } else {\n          const rootContainerInstance = getRootHostContainer();\n          const instance = createInstance(\n            type,\n            newProps,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n          appendAllChildren(instance, workInProgress, false, false);\n          workInProgress.stateNode = instance;\n\n          // Certain renderers require commit-time effects for initial mount.\n          // (eg DOM renderer supports auto-focus for certain elements).\n          // Make sure such renderers get scheduled for later work.\n          if (\n            finalizeInitialChildren(\n              instance,\n              type,\n              newProps,\n              currentHostContext,\n            )\n          ) {\n            markUpdate(workInProgress);\n          }\n        }\n\n        if (workInProgress.ref !== null) {\n          // If there is a ref on a host node we need to schedule a callback\n          markRef(workInProgress);\n        }\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostText: {\n      const newText = newProps;\n      if (current && workInProgress.stateNode != null) {\n        const oldText = current.memoizedProps;\n        // If we have an alternate, that means this is an update and we need\n        // to schedule a side-effect to do the updates.\n        updateHostText(current, workInProgress, oldText, newText);\n      } else {\n        if (typeof newText !== 'string') {\n          if (workInProgress.stateNode === null) {\n            throw new Error(\n              'We must have new props for new mounts. This error is likely ' +\n                'caused by a bug in React. Please file an issue.',\n            );\n          }\n          // This can happen when we abort work.\n        }\n        const rootContainerInstance = getRootHostContainer();\n        const currentHostContext = getHostContext();\n        const wasHydrated = popHydrationState(workInProgress);\n        if (wasHydrated) {\n          if (prepareToHydrateHostTextInstance(workInProgress)) {\n            markUpdate(workInProgress);\n          }\n        } else {\n          workInProgress.stateNode = createTextInstance(\n            newText,\n            rootContainerInstance,\n            currentHostContext,\n            workInProgress,\n          );\n        }\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case SuspenseComponent: {\n      popSuspenseHandler(workInProgress);\n      const nextState: null | SuspenseState = workInProgress.memoizedState;\n\n      // Special path for dehydrated boundaries. We may eventually move this\n      // to its own fiber type so that we can add other kinds of hydration\n      // boundaries that aren't associated with a Suspense tree. In anticipation\n      // of such a refactor, all the hydration logic is contained in\n      // this branch.\n      if (\n        current === null ||\n        (current.memoizedState !== null &&\n          current.memoizedState.dehydrated !== null)\n      ) {\n        const fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(\n          current,\n          workInProgress,\n          nextState,\n        );\n        if (!fallthroughToNormalSuspensePath) {\n          if (workInProgress.flags & ShouldCapture) {\n            // Special case. There were remaining unhydrated nodes. We treat\n            // this as a mismatch. Revert to client rendering.\n            return workInProgress;\n          } else {\n            // Did not finish hydrating, either because this is the initial\n            // render or because something suspended.\n            return null;\n          }\n        }\n\n        // Continue with the normal Suspense path.\n      }\n\n      if ((workInProgress.flags & DidCapture) !== NoFlags) {\n        // Something suspended. Re-render with the fallback children.\n        workInProgress.lanes = renderLanes;\n        // Do not reset the effect list.\n        if (\n          enableProfilerTimer &&\n          (workInProgress.mode & ProfileMode) !== NoMode\n        ) {\n          transferActualDuration(workInProgress);\n        }\n        // Don't bubble properties in this case.\n        return workInProgress;\n      }\n\n      const nextDidTimeout = nextState !== null;\n      const prevDidTimeout =\n        current !== null &&\n        (current.memoizedState: null | SuspenseState) !== null;\n\n      if (enableCache && nextDidTimeout) {\n        const offscreenFiber: Fiber = (workInProgress.child: any);\n        let previousCache: Cache | null = null;\n        if (\n          offscreenFiber.alternate !== null &&\n          offscreenFiber.alternate.memoizedState !== null &&\n          offscreenFiber.alternate.memoizedState.cachePool !== null\n        ) {\n          previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;\n        }\n        let cache: Cache | null = null;\n        if (\n          offscreenFiber.memoizedState !== null &&\n          offscreenFiber.memoizedState.cachePool !== null\n        ) {\n          cache = offscreenFiber.memoizedState.cachePool.pool;\n        }\n        if (cache !== previousCache) {\n          // Run passive effects to retain/release the cache.\n          offscreenFiber.flags |= Passive;\n        }\n      }\n\n      // If the suspended state of the boundary changes, we need to schedule\n      // a passive effect, which is when we process the transitions\n      if (nextDidTimeout !== prevDidTimeout) {\n        if (enableTransitionTracing) {\n          const offscreenFiber: Fiber = (workInProgress.child: any);\n          offscreenFiber.flags |= Passive;\n        }\n\n        // If the suspended state of the boundary changes, we need to schedule\n        // an effect to toggle the subtree's visibility. When we switch from\n        // fallback -> primary, the inner Offscreen fiber schedules this effect\n        // as part of its normal complete phase. But when we switch from\n        // primary -> fallback, the inner Offscreen fiber does not have a complete\n        // phase. So we need to schedule its effect here.\n        //\n        // We also use this flag to connect/disconnect the effects, but the same\n        // logic applies: when re-connecting, the Offscreen fiber's complete\n        // phase will handle scheduling the effect. It's only when the fallback\n        // is active that we have to do anything special.\n        if (nextDidTimeout) {\n          const offscreenFiber: Fiber = (workInProgress.child: any);\n          offscreenFiber.flags |= Visibility;\n\n          // TODO: This will still suspend a synchronous tree if anything\n          // in the concurrent tree already suspended during this render.\n          // This is a known bug.\n          if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n            // TODO: Move this back to throwException because this is too late\n            // if this is a large tree which is common for initial loads. We\n            // don't know if we should restart a render or not until we get\n            // this marker, and this is too late.\n            // If this render already had a ping or lower pri updates,\n            // and this is the first time we know we're going to suspend we\n            // should be able to immediately restart from within throwException.\n            if (isBadSuspenseFallback(current, newProps)) {\n              renderDidSuspendDelayIfPossible();\n            } else {\n              renderDidSuspend();\n            }\n          }\n        }\n      }\n\n      const wakeables: Set<Wakeable> | null = (workInProgress.updateQueue: any);\n      if (wakeables !== null) {\n        // Schedule an effect to attach a retry listener to the promise.\n        // TODO: Move to passive phase\n        workInProgress.flags |= Update;\n      }\n\n      if (\n        enableSuspenseCallback &&\n        workInProgress.updateQueue !== null &&\n        workInProgress.memoizedProps.suspenseCallback != null\n      ) {\n        // Always notify the callback\n        // TODO: Move to passive phase\n        workInProgress.flags |= Update;\n      }\n      bubbleProperties(workInProgress);\n      if (enableProfilerTimer) {\n        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n          if (nextDidTimeout) {\n            // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n            const primaryChildFragment = workInProgress.child;\n            if (primaryChildFragment !== null) {\n              // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n              workInProgress.treeBaseDuration -= ((primaryChildFragment.treeBaseDuration: any): number);\n            }\n          }\n        }\n      }\n      return null;\n    }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(current, workInProgress);\n      if (current === null) {\n        preparePortalMount(workInProgress.stateNode.containerInfo);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case ContextProvider:\n      // Pop provider fiber\n      const context: ReactContext<any> = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n    case IncompleteClassComponent: {\n      // Same as class component case. I put it down here so that the tags are\n      // sequential to ensure this switch is compiled to a jump table.\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        popLegacyContext(workInProgress);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case SuspenseListComponent: {\n      popSuspenseListContext(workInProgress);\n\n      const renderState: null | SuspenseListRenderState =\n        workInProgress.memoizedState;\n\n      if (renderState === null) {\n        // We're running in the default, \"independent\" mode.\n        // We don't do anything in this mode.\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n      let didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n\n      const renderedTail = renderState.rendering;\n      if (renderedTail === null) {\n        // We just rendered the head.\n        if (!didSuspendAlready) {\n          // This is the first pass. We need to figure out if anything is still\n          // suspended in the rendered set.\n\n          // If new content unsuspended, but there's still some content that\n          // didn't. Then we need to do a second pass that forces everything\n          // to keep showing their fallbacks.\n\n          // We might be suspended if something in this render pass suspended, or\n          // something in the previous committed pass suspended. Otherwise,\n          // there's no chance so we can skip the expensive call to\n          // findFirstSuspended.\n          const cannotBeSuspended =\n            renderHasNotSuspendedYet() &&\n            (current === null || (current.flags & DidCapture) === NoFlags);\n          if (!cannotBeSuspended) {\n            let row = workInProgress.child;\n            while (row !== null) {\n              const suspended = findFirstSuspended(row);\n              if (suspended !== null) {\n                didSuspendAlready = true;\n                workInProgress.flags |= DidCapture;\n                cutOffTailIfNeeded(renderState, false);\n\n                // If this is a newly suspended tree, it might not get committed as\n                // part of the second pass. In that case nothing will subscribe to\n                // its thenables. Instead, we'll transfer its thenables to the\n                // SuspenseList so that it can retry if they resolve.\n                // There might be multiple of these in the list but since we're\n                // going to wait for all of them anyway, it doesn't really matter\n                // which ones gets to ping. In theory we could get clever and keep\n                // track of how many dependencies remain but it gets tricky because\n                // in the meantime, we can add/remove/change items and dependencies.\n                // We might bail out of the loop before finding any but that\n                // doesn't matter since that means that the other boundaries that\n                // we did find already has their listeners attached.\n                const newThenables = suspended.updateQueue;\n                if (newThenables !== null) {\n                  workInProgress.updateQueue = newThenables;\n                  workInProgress.flags |= Update;\n                }\n\n                // Rerender the whole list, but this time, we'll force fallbacks\n                // to stay in place.\n                // Reset the effect flags before doing the second pass since that's now invalid.\n                // Reset the child fibers to their original state.\n                workInProgress.subtreeFlags = NoFlags;\n                resetChildFibers(workInProgress, renderLanes);\n\n                // Set up the Suspense List Context to force suspense and\n                // immediately rerender the children.\n                pushSuspenseListContext(\n                  workInProgress,\n                  setShallowSuspenseListContext(\n                    suspenseStackCursor.current,\n                    ForceSuspenseFallback,\n                  ),\n                );\n                // Don't bubble properties in this case.\n                return workInProgress.child;\n              }\n              row = row.sibling;\n            }\n          }\n\n          if (renderState.tail !== null && now() > getRenderTargetTime()) {\n            // We have already passed our CPU deadline but we still have rows\n            // left in the tail. We'll just give up further attempts to render\n            // the main content and only render fallbacks.\n            workInProgress.flags |= DidCapture;\n            didSuspendAlready = true;\n\n            cutOffTailIfNeeded(renderState, false);\n\n            // Since nothing actually suspended, there will nothing to ping this\n            // to get it started back up to attempt the next item. While in terms\n            // of priority this work has the same priority as this current render,\n            // it's not part of the same transition once the transition has\n            // committed. If it's sync, we still want to yield so that it can be\n            // painted. Conceptually, this is really the same as pinging.\n            // We can use any RetryLane even if it's the one currently rendering\n            // since we're leaving it behind on this node.\n            workInProgress.lanes = SomeRetryLane;\n          }\n        } else {\n          cutOffTailIfNeeded(renderState, false);\n        }\n        // Next we're going to render the tail.\n      } else {\n        // Append the rendered row to the child list.\n        if (!didSuspendAlready) {\n          const suspended = findFirstSuspended(renderedTail);\n          if (suspended !== null) {\n            workInProgress.flags |= DidCapture;\n            didSuspendAlready = true;\n\n            // Ensure we transfer the update queue to the parent so that it doesn't\n            // get lost if this row ends up dropped during a second pass.\n            const newThenables = suspended.updateQueue;\n            if (newThenables !== null) {\n              workInProgress.updateQueue = newThenables;\n              workInProgress.flags |= Update;\n            }\n\n            cutOffTailIfNeeded(renderState, true);\n            // This might have been modified.\n            if (\n              renderState.tail === null &&\n              renderState.tailMode === 'hidden' &&\n              !renderedTail.alternate &&\n              !getIsHydrating() // We don't cut it if we're hydrating.\n            ) {\n              // We're done.\n              bubbleProperties(workInProgress);\n              return null;\n            }\n          } else if (\n            // The time it took to render last row is greater than the remaining\n            // time we have to render. So rendering one more row would likely\n            // exceed it.\n            now() * 2 - renderState.renderingStartTime >\n              getRenderTargetTime() &&\n            renderLanes !== OffscreenLane\n          ) {\n            // We have now passed our CPU deadline and we'll just give up further\n            // attempts to render the main content and only render fallbacks.\n            // The assumption is that this is usually faster.\n            workInProgress.flags |= DidCapture;\n            didSuspendAlready = true;\n\n            cutOffTailIfNeeded(renderState, false);\n\n            // Since nothing actually suspended, there will nothing to ping this\n            // to get it started back up to attempt the next item. While in terms\n            // of priority this work has the same priority as this current render,\n            // it's not part of the same transition once the transition has\n            // committed. If it's sync, we still want to yield so that it can be\n            // painted. Conceptually, this is really the same as pinging.\n            // We can use any RetryLane even if it's the one currently rendering\n            // since we're leaving it behind on this node.\n            workInProgress.lanes = SomeRetryLane;\n          }\n        }\n        if (renderState.isBackwards) {\n          // The effect list of the backwards tail will have been added\n          // to the end. This breaks the guarantee that life-cycles fire in\n          // sibling order but that isn't a strong guarantee promised by React.\n          // Especially since these might also just pop in during future commits.\n          // Append to the beginning of the list.\n          renderedTail.sibling = workInProgress.child;\n          workInProgress.child = renderedTail;\n        } else {\n          const previousSibling = renderState.last;\n          if (previousSibling !== null) {\n            previousSibling.sibling = renderedTail;\n          } else {\n            workInProgress.child = renderedTail;\n          }\n          renderState.last = renderedTail;\n        }\n      }\n\n      if (renderState.tail !== null) {\n        // We still have tail rows to render.\n        // Pop a row.\n        const next = renderState.tail;\n        renderState.rendering = next;\n        renderState.tail = next.sibling;\n        renderState.renderingStartTime = now();\n        next.sibling = null;\n\n        // Restore the context.\n        // TODO: We can probably just avoid popping it instead and only\n        // setting it the first time we go from not suspended to suspended.\n        let suspenseContext = suspenseStackCursor.current;\n        if (didSuspendAlready) {\n          suspenseContext = setShallowSuspenseListContext(\n            suspenseContext,\n            ForceSuspenseFallback,\n          );\n        } else {\n          suspenseContext = setDefaultShallowSuspenseListContext(\n            suspenseContext,\n          );\n        }\n        pushSuspenseListContext(workInProgress, suspenseContext);\n        // Do a pass over the next row.\n        // Don't bubble properties in this case.\n        return next;\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        if (current === null) {\n          const scopeInstance: ReactScopeInstance = createScopeInstance();\n          workInProgress.stateNode = scopeInstance;\n          prepareScopeUpdate(scopeInstance, workInProgress);\n          if (workInProgress.ref !== null) {\n            markRef(workInProgress);\n            markUpdate(workInProgress);\n          }\n        } else {\n          if (workInProgress.ref !== null) {\n            markUpdate(workInProgress);\n          }\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        }\n        bubbleProperties(workInProgress);\n        return null;\n      }\n      break;\n    }\n    case OffscreenComponent:\n    case LegacyHiddenComponent: {\n      popSuspenseHandler(workInProgress);\n      popHiddenContext(workInProgress);\n      const nextState: OffscreenState | null = workInProgress.memoizedState;\n      const nextIsHidden = nextState !== null;\n\n      // Schedule a Visibility effect if the visibility has changed\n      if (enableLegacyHidden && workInProgress.tag === LegacyHiddenComponent) {\n        // LegacyHidden doesn't do any hiding — it only pre-renders.\n      } else {\n        if (current !== null) {\n          const prevState: OffscreenState | null = current.memoizedState;\n          const prevIsHidden = prevState !== null;\n          if (prevIsHidden !== nextIsHidden) {\n            workInProgress.flags |= Visibility;\n          }\n        } else {\n          // On initial mount, we only need a Visibility effect if the tree\n          // is hidden.\n          if (nextIsHidden) {\n            workInProgress.flags |= Visibility;\n          }\n        }\n      }\n\n      if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n        bubbleProperties(workInProgress);\n      } else {\n        // Don't bubble properties for hidden children unless we're rendering\n        // at offscreen priority.\n        if (\n          includesSomeLane(renderLanes, (OffscreenLane: Lane)) &&\n          // Also don't bubble if the tree suspended\n          (workInProgress.flags & DidCapture) === NoLanes\n        ) {\n          bubbleProperties(workInProgress);\n          // Check if there was an insertion or update in the hidden subtree.\n          // If so, we need to hide those nodes in the commit phase, so\n          // schedule a visibility effect.\n          if (\n            (!enableLegacyHidden ||\n              workInProgress.tag !== LegacyHiddenComponent) &&\n            workInProgress.subtreeFlags & (Placement | Update)\n          ) {\n            workInProgress.flags |= Visibility;\n          }\n        }\n      }\n\n      if (workInProgress.updateQueue !== null) {\n        // Schedule an effect to attach Suspense retry listeners\n        // TODO: Move to passive phase\n        workInProgress.flags |= Update;\n      }\n\n      if (enableCache) {\n        let previousCache: Cache | null = null;\n        if (\n          current !== null &&\n          current.memoizedState !== null &&\n          current.memoizedState.cachePool !== null\n        ) {\n          previousCache = current.memoizedState.cachePool.pool;\n        }\n        let cache: Cache | null = null;\n        if (\n          workInProgress.memoizedState !== null &&\n          workInProgress.memoizedState.cachePool !== null\n        ) {\n          cache = workInProgress.memoizedState.cachePool.pool;\n        }\n        if (cache !== previousCache) {\n          // Run passive effects to retain/release the cache.\n          workInProgress.flags |= Passive;\n        }\n      }\n\n      popTransition(workInProgress, current);\n\n      return null;\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        let previousCache: Cache | null = null;\n        if (current !== null) {\n          previousCache = current.memoizedState.cache;\n        }\n        const cache: Cache = workInProgress.memoizedState.cache;\n        if (cache !== previousCache) {\n          // Run passive effects to retain/release the cache.\n          workInProgress.flags |= Passive;\n        }\n        popCacheProvider(workInProgress, cache);\n        bubbleProperties(workInProgress);\n      }\n      return null;\n    }\n    case TracingMarkerComponent: {\n      if (enableTransitionTracing) {\n        const instance: TracingMarkerInstance | null = workInProgress.stateNode;\n        if (instance !== null) {\n          popMarkerInstance(workInProgress);\n        }\n        bubbleProperties(workInProgress);\n      }\n      return null;\n    }\n  }\n\n  throw new Error(\n    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +\n      'React. Please file an issue.',\n  );\n}\n\nexport {completeWork};\n"]},"metadata":{},"sourceType":"module"}