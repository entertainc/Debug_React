{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactCurrentDispatcher from './ReactCurrentDispatcher';\nimport ReactCurrentCache from './ReactCurrentCache';\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactCurrentDispatcher.current;\n\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n    }\n  } // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n\n\n  return dispatcher;\n}\n\nexport function getCacheSignal() {\n  const dispatcher = ReactCurrentCache.current;\n\n  if (!dispatcher) {\n    // If we have no cache to associate with this call, then we don't know\n    // its lifetime. We abort early since that's safer than letting it live\n    // for ever. Unlike just caching which can be a functional noop outside\n    // of React, these should generally always be associated with some React\n    // render but we're not limiting quite as much as making it a Hook.\n    // It's safer than erroring early at runtime.\n    const controller = new AbortController();\n    const reason = new Error('This CacheSignal was requested outside React which means that it is ' + 'immediately aborted.'); // $FlowFixMe Flow doesn't yet know about this argument.\n\n    controller.abort(reason);\n    return controller.signal;\n  }\n\n  return dispatcher.getCacheSignal();\n}\nexport function getCacheForType(resourceType) {\n  const dispatcher = ReactCurrentCache.current;\n\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not being cached.\n    return resourceType();\n  }\n\n  return dispatcher.getCacheForType(resourceType);\n}\nexport function useContext(Context) {\n  const dispatcher = resolveDispatcher();\n\n  if (__DEV__) {\n    // TODO: add a more generic warning for invalid values.\n    if (Context._context !== undefined) {\n      const realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n\n      if (realContext.Consumer === Context) {\n        console.error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n      } else if (realContext.Provider === Context) {\n        console.error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n      }\n    }\n  }\n\n  return dispatcher.useContext(Context);\n}\nexport function useState(initialState) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\nexport function useReducer(reducer, initialArg, init) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\nexport function useRef(initialValue) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\nexport function useEffect(create, deps) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\nexport function useInsertionEffect(create, deps) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\nexport function useLayoutEffect(create, deps) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\nexport function useCallback(callback, deps) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\nexport function useMemo(create, deps) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\nexport function useImperativeHandle(ref, create, deps) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\nexport function useDebugValue(value, formatterFn) {\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\nexport function useTransition() {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\nexport function useDeferredValue(value) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value);\n}\nexport function useId() {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\nexport function useMutableSource(source, getSnapshot, subscribe) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMutableSource(source, getSnapshot, subscribe);\n}\nexport function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n}\nexport function useCacheRefresh() {\n  const dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n\n  return dispatcher.useCacheRefresh();\n}\nexport function use(usable) {\n  const dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n\n  return dispatcher.use(usable);\n}\nexport function useMemoCache(size) {\n  const dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n\n  return dispatcher.useMemoCache(size);\n}\nexport function useEffectEvent(callback) {\n  const dispatcher = resolveDispatcher(); // $FlowFixMe This is unstable, thus optional\n\n  return dispatcher.useEffectEvent(callback);\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react/src/ReactHooks.js"],"names":["ReactCurrentDispatcher","ReactCurrentCache","resolveDispatcher","dispatcher","current","__DEV__","console","error","getCacheSignal","controller","AbortController","reason","Error","abort","signal","getCacheForType","resourceType","useContext","Context","_context","undefined","realContext","Consumer","Provider","useState","initialState","useReducer","reducer","initialArg","init","useRef","initialValue","useEffect","create","deps","useInsertionEffect","useLayoutEffect","useCallback","callback","useMemo","useImperativeHandle","ref","useDebugValue","value","formatterFn","useTransition","useDeferredValue","useId","useMutableSource","source","getSnapshot","subscribe","useSyncExternalStore","getServerSnapshot","useCacheRefresh","use","usable","useMemoCache","size","useEffectEvent"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  MutableSource,\n  MutableSourceGetSnapshotFn,\n  MutableSourceSubscribeFn,\n  ReactContext,\n  StartTransitionOptions,\n  Usable,\n} from 'shared/ReactTypes';\n\nimport ReactCurrentDispatcher from './ReactCurrentDispatcher';\nimport ReactCurrentCache from './ReactCurrentCache';\n\ntype BasicStateAction<S> = (S => S) | S;\ntype Dispatch<A> = A => void;\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactCurrentDispatcher.current;\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error(\n        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n          ' one of the following reasons:\\n' +\n          '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n          '2. You might be breaking the Rules of Hooks\\n' +\n          '3. You might have more than one copy of React in the same app\\n' +\n          'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',\n      );\n    }\n  }\n  // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n  return ((dispatcher: any): Dispatcher);\n}\n\nexport function getCacheSignal(): AbortSignal {\n  const dispatcher = ReactCurrentCache.current;\n  if (!dispatcher) {\n    // If we have no cache to associate with this call, then we don't know\n    // its lifetime. We abort early since that's safer than letting it live\n    // for ever. Unlike just caching which can be a functional noop outside\n    // of React, these should generally always be associated with some React\n    // render but we're not limiting quite as much as making it a Hook.\n    // It's safer than erroring early at runtime.\n    const controller = new AbortController();\n    const reason = new Error(\n      'This CacheSignal was requested outside React which means that it is ' +\n        'immediately aborted.',\n    );\n    // $FlowFixMe Flow doesn't yet know about this argument.\n    controller.abort(reason);\n    return controller.signal;\n  }\n  return dispatcher.getCacheSignal();\n}\n\nexport function getCacheForType<T>(resourceType: () => T): T {\n  const dispatcher = ReactCurrentCache.current;\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not being cached.\n    return resourceType();\n  }\n  return dispatcher.getCacheForType(resourceType);\n}\n\nexport function useContext<T>(Context: ReactContext<T>): T {\n  const dispatcher = resolveDispatcher();\n  if (__DEV__) {\n    // TODO: add a more generic warning for invalid values.\n    if ((Context: any)._context !== undefined) {\n      const realContext = (Context: any)._context;\n      // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n      if (realContext.Consumer === Context) {\n        console.error(\n          'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' +\n            'removed in a future major release. Did you mean to call useContext(Context) instead?',\n        );\n      } else if (realContext.Provider === Context) {\n        console.error(\n          'Calling useContext(Context.Provider) is not supported. ' +\n            'Did you mean to call useContext(Context) instead?',\n        );\n      }\n    }\n  }\n  return dispatcher.useContext(Context);\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\nexport function useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n\nexport function useRef<T>(initialValue: T): {current: T} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\nexport function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n\nexport function useInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\n\nexport function useLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\n\nexport function useCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\n\nexport function useMemo<T>(\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\n\nexport function useImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\n\nexport function useDebugValue<T>(\n  value: T,\n  formatterFn: ?(value: T) => mixed,\n): void {\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nexport function useTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\n\nexport function useDeferredValue<T>(value: T): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value);\n}\n\nexport function useId(): string {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\n\nexport function useMutableSource<Source, Snapshot>(\n  source: MutableSource<Source>,\n  getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,\n  subscribe: MutableSourceSubscribeFn<Source, Snapshot>,\n): Snapshot {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMutableSource(source, getSnapshot, subscribe);\n}\n\nexport function useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n  );\n}\n\nexport function useCacheRefresh(): <T>(?() => T, ?T) => void {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe This is unstable, thus optional\n  return dispatcher.useCacheRefresh();\n}\n\nexport function use<T>(usable: Usable<T>): T {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe This is unstable, thus optional\n  return dispatcher.use(usable);\n}\n\nexport function useMemoCache(size: number): Array<any> {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe This is unstable, thus optional\n  return dispatcher.useMemoCache(size);\n}\n\nexport function useEffectEvent<T>(callback: T): void {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe This is unstable, thus optional\n  return dispatcher.useEffectEvent(callback);\n}\n"]},"metadata":{},"sourceType":"module"}