{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { OffscreenDetached } from './ReactFiberOffscreenComponent';\nimport checkPropTypes from 'shared/checkPropTypes';\nimport { markComponentRenderStarted, markComponentRenderStopped, setIsStrictModeForDevtools } from './ReactFiberDevToolsHook';\nimport { IndeterminateComponent, FunctionComponent, ClassComponent, HostRoot, HostComponent, HostResource, HostSingleton, HostText, HostPortal, ForwardRef, Fragment, Mode, ContextProvider, ContextConsumer, Profiler, SuspenseComponent, SuspenseListComponent, MemoComponent, SimpleMemoComponent, LazyComponent, IncompleteClassComponent, ScopeComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent, TracingMarkerComponent } from './ReactWorkTags';\nimport { NoFlags, PerformedWork, Placement, Hydrating, ContentReset, DidCapture, Update, Ref, RefStatic, ChildDeletion, ForceUpdateForLegacySuspense, StaticMask, ShouldCapture, ForceClientRender, Passive } from './ReactFiberFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { debugRenderPhaseSideEffectsForStrictMode, disableLegacyContext, disableModulePatternComponents, enableProfilerCommitHooks, enableProfilerTimer, warnAboutDefaultPropsOnFunctionComponents, enableScopeAPI, enableCache, enableLazyContextPropagation, enableSchedulingProfiler, enableTransitionTracing, enableLegacyHidden, enableCPUSuspense, enableUseMutableSource, enableFloat, enableHostSingletons } from 'shared/ReactFeatureFlags';\nimport isArray from 'shared/isArray';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport { REACT_LAZY_TYPE, getIteratorFn } from 'shared/ReactSymbols';\nimport { getCurrentFiberOwnerNameInDevOrNull, setIsRendering } from './ReactCurrentFiber';\nimport { resolveFunctionForHotReloading, resolveForwardRefForHotReloading, resolveClassForHotReloading } from './ReactFiberHotReloading';\nimport { mountChildFibers, reconcileChildFibers, cloneChildFibers } from './ReactChildFiber';\nimport { processUpdateQueue, cloneUpdateQueue, initializeUpdateQueue, enqueueCapturedUpdate } from './ReactFiberClassUpdateQueue';\nimport { NoLane, NoLanes, SyncLane, OffscreenLane, DefaultHydrationLane, SomeRetryLane, NoTimestamp, includesSomeLane, laneToLanes, removeLanes, mergeLanes, getBumpedLaneForHydration, pickArbitraryLane } from './ReactFiberLane';\nimport { ConcurrentMode, NoMode, ProfileMode, StrictLegacyMode } from './ReactTypeOfMode';\nimport { shouldSetTextContent, isSuspenseInstancePending, isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry, supportsHydration, supportsResources, supportsSingletons, isPrimaryRenderer, getResource } from './ReactFiberHostConfig';\nimport { shouldError, shouldSuspend } from './ReactFiberReconciler';\nimport { pushHostContext, pushHostContainer } from './ReactFiberHostContext';\nimport { suspenseStackCursor, pushSuspenseListContext, ForceSuspenseFallback, hasSuspenseListContext, setDefaultShallowSuspenseListContext, setShallowSuspenseListContext, pushPrimaryTreeSuspenseHandler, pushFallbackTreeSuspenseHandler, pushOffscreenSuspenseHandler, reuseSuspenseHandlerOnStack, popSuspenseHandler } from './ReactFiberSuspenseContext';\nimport { pushHiddenContext, reuseHiddenContextOnStack } from './ReactFiberHiddenContext';\nimport { findFirstSuspended } from './ReactFiberSuspenseComponent';\nimport { pushProvider, propagateContextChange, lazilyPropagateParentContextChanges, propagateParentContextChangesToDeferredTree, checkIfContextChanged, readContext, prepareToReadContext, scheduleContextWorkOnParentPath } from './ReactFiberNewContext';\nimport { renderWithHooks, checkDidRenderIdHook, bailoutHooks, replaySuspendedComponentWithHooks } from './ReactFiberHooks';\nimport { stopProfilerTimerIfRunning } from './ReactProfilerTimer';\nimport { getMaskedContext, getUnmaskedContext, hasContextChanged as hasLegacyContextChanged, pushContextProvider as pushLegacyContextProvider, isContextProvider as isLegacyContextProvider, pushTopLevelContextObject, invalidateContextProvider } from './ReactFiberContext';\nimport { getIsHydrating, enterHydrationState, reenterHydrationStateFromDehydratedSuspenseInstance, resetHydrationState, claimHydratableSingleton, tryToClaimNextHydratableInstance, warnIfHydrating, queueHydrationError } from './ReactFiberHydrationContext';\nimport { adoptClassInstance, constructClassInstance, mountClassInstance, resumeMountClassInstance, updateClassInstance } from './ReactFiberClassComponent';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent';\nimport { resolveLazyComponentTag, createFiberFromTypeAndProps, createFiberFromFragment, createFiberFromOffscreen, createWorkInProgress, isSimpleFunctionComponent } from './ReactFiber';\nimport { retryDehydratedSuspenseBoundary, scheduleUpdateOnFiber, renderDidSuspendDelayIfPossible, markSkippedUpdateLanes, getWorkInProgressRoot } from './ReactFiberWorkLoop';\nimport { enqueueConcurrentRenderForLane } from './ReactFiberConcurrentUpdates';\nimport { setWorkInProgressVersion } from './ReactMutableSource';\nimport { pushCacheProvider, CacheContext } from './ReactFiberCacheComponent';\nimport { createCapturedValue, createCapturedValueAtFiber } from './ReactCapturedValue';\nimport { createClassErrorUpdate } from './ReactFiberThrow';\nimport is from 'shared/objectIs';\nimport { getForksAtLevel, isForkedChild, pushTreeId, pushMaterializedTreeId } from './ReactFiberTreeContext';\nimport { requestCacheFromPool, pushRootTransition, getSuspendedCache, pushTransition, getOffscreenDeferredCache, getPendingTransitions } from './ReactFiberTransition';\nimport { getMarkerInstances, pushMarkerInstance, pushRootMarkerInstance, TransitionTracingMarker } from './ReactFiberTracingMarkerComponent';\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner; // A special exception that's used to unwind the stack when an update flows\n// into a dehydrated boundary.\n\nexport const SelectiveHydrationException = new Error(\"This is not a real error. It's an implementation detail of React's \" + \"selective hydration feature. If this leaks into userspace, it's a bug in \" + 'React. Please file an issue.');\nlet didReceiveUpdate = false;\nlet didWarnAboutBadClass;\nlet didWarnAboutModulePatternComponent;\nlet didWarnAboutContextTypeOnFunctionComponent;\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\nlet didWarnAboutFunctionRefs;\nexport let didWarnAboutReassigningProps;\nlet didWarnAboutRevealOrder;\nlet didWarnAboutTailOptions;\nlet didWarnAboutDefaultPropsOnFunctionComponent;\n\nif (__DEV__) {\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\n}\n\nexport function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their\n  // identities match.\n\n  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n}\n\nfunction updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  const render = Component.render;\n  const ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n\n  let nextChildren;\n  let hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n    hasId = checkDidRenderIdHook();\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (current === null) {\n    const type = Component.type;\n\n    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n    Component.defaultProps === undefined) {\n      let resolvedType = type;\n\n      if (__DEV__) {\n        resolvedType = resolveFunctionForHotReloading(type);\n      } // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n\n\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n\n      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n    }\n\n    if (__DEV__) {\n      const innerPropTypes = type.propTypes;\n\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(type));\n      }\n\n      if (warnAboutDefaultPropsOnFunctionComponents && Component.defaultProps !== undefined) {\n        const componentName = getComponentNameFromType(type) || 'Unknown';\n\n        if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n          console.error('%s: Support for defaultProps will be removed from memo components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);\n          didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n        }\n      }\n    }\n\n    const child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n\n  if (__DEV__) {\n    const type = Component.type;\n    const innerPropTypes = type.propTypes;\n\n    if (innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(innerPropTypes, nextProps, // Resolved props\n      'prop', getComponentNameFromType(type));\n    }\n  }\n\n  const currentChild = current.child; // This is always exactly one child\n\n  const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n  if (!hasScheduledUpdateOrContext) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    const prevProps = currentChild.memoizedProps; // Default to shallow comparison\n\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  const newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      let outerMemoType = workInProgress.elementType;\n\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        const lazyComponent = outerMemoType;\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n\n        try {\n          outerMemoType = init(payload);\n        } catch (x) {\n          // $FlowFixMe[incompatible-type] found when upgrading Flow\n          outerMemoType = null;\n        } // Inner propTypes will be validated in the function component path.\n\n\n        const outerPropTypes = outerMemoType && outerMemoType.propTypes;\n\n        if (outerPropTypes) {\n          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n          'prop', getComponentNameFromType(outerMemoType));\n        }\n      }\n    }\n  }\n\n  if (current !== null) {\n    const prevProps = current.memoizedProps;\n\n    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && (__DEV__ ? workInProgress.type === current.type : true)) {\n      didReceiveUpdate = false; // The props are shallowly equal. Reuse the previous props object, like we\n      // would during a normal fiber bailout.\n      //\n      // We don't have strong guarantees that the props object is referentially\n      // equal during updates where we can't bail out anyway â€” like if the props\n      // are shallowly equal, but there's a local state or context update in the\n      // same batch.\n      //\n      // However, as a principle, we should aim to make the behavior consistent\n      // across different ways of memoizing a component. For example, React.memo\n      // has a different internal Fiber layout if you pass a normal function\n      // component (SimpleMemoComponent) versus if you pass a different type\n      // like forwardRef (MemoComponent). But this is an implementation detail.\n      // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n      // affect whether the props object is reused during a bailout.\n\n      workInProgress.pendingProps = nextProps = prevProps;\n\n      if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n        // The pending lanes were cleared at the beginning of beginWork. We're\n        // about to bail out, but there might be other lanes that weren't\n        // included in the current render. Usually, the priority level of the\n        // remaining updates is accumulated during the evaluation of the\n        // component (i.e. when processing the update queue). But since since\n        // we're bailing out early *without* evaluating the component, we need\n        // to account for it here, too. Reset to the value of the current fiber.\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n        // because a MemoComponent fiber does not have hooks or an update queue;\n        // rather, it wraps around an inner component, which may or may not\n        // contains hooks.\n        // TODO: Move the reset at in beginWork out of the common path so that\n        // this is no longer necessary.\n        workInProgress.lanes = current.lanes;\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      }\n    }\n  }\n\n  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n}\n\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  const nextIsDetached = (workInProgress.stateNode._pendingVisibility & OffscreenDetached) !== 0;\n  const prevState = current !== null ? current.memoizedState : null;\n  markRef(current, workInProgress);\n\n  if (nextProps.mode === 'hidden' || enableLegacyHidden && nextProps.mode === 'unstable-defer-without-hiding' || nextIsDetached) {\n    // Rendering a hidden tree.\n    const didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n\n    if (didSuspend) {\n      // Something suspended inside a hidden tree\n      // Include the base lanes from the last render\n      const nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes) : renderLanes;\n\n      if (current !== null) {\n        // Reset to the current children\n        let currentChild = workInProgress.child = current.child; // The current render suspended, but there may be other lanes with\n        // pending work. We can't read `childLanes` from the current Offscreen\n        // fiber because we reset it when it was deferred; however, we can read\n        // the pending lanes from the child fibers.\n\n        let currentChildLanes = NoLanes;\n\n        while (currentChild !== null) {\n          currentChildLanes = mergeLanes(mergeLanes(currentChildLanes, currentChild.lanes), currentChild.childLanes);\n          currentChild = currentChild.sibling;\n        }\n\n        const lanesWeJustAttempted = nextBaseLanes;\n        const remainingChildLanes = removeLanes(currentChildLanes, lanesWeJustAttempted);\n        workInProgress.childLanes = remainingChildLanes;\n      } else {\n        workInProgress.childLanes = NoLanes;\n        workInProgress.child = null;\n      }\n\n      return deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes);\n    }\n\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      // In legacy sync mode, don't defer the subtree. Render it now.\n      // TODO: Consider how Offscreen should work with transitions in the future\n      const nextState = {\n        baseLanes: NoLanes,\n        cachePool: null\n      };\n      workInProgress.memoizedState = nextState;\n\n      if (enableCache) {\n        // push the cache pool even though we're going to bail out\n        // because otherwise there'd be a context mismatch\n        if (current !== null) {\n          pushTransition(workInProgress, null, null);\n        }\n      }\n\n      reuseHiddenContextOnStack(workInProgress);\n      pushOffscreenSuspenseHandler(workInProgress);\n    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {\n      // We're hidden, and we're not rendering at Offscreen. We will bail out\n      // and resume this tree later.\n      // Schedule this fiber to re-render at Offscreen priority\n      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane); // Include the base lanes from the last render\n\n      const nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes) : renderLanes;\n      return deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes);\n    } else {\n      // This is the second render. The surrounding visible content has already\n      // committed. Now we resume rendering the hidden tree.\n      // Rendering at offscreen, so we can clear the base lanes.\n      const nextState = {\n        baseLanes: NoLanes,\n        cachePool: null\n      };\n      workInProgress.memoizedState = nextState;\n\n      if (enableCache && current !== null) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        const prevCachePool = prevState !== null ? prevState.cachePool : null; // TODO: Consider if and how Offscreen pre-rendering should\n        // be attributed to the transition that spawned it\n\n        pushTransition(workInProgress, prevCachePool, null);\n      } // Push the lanes that were skipped when we bailed out.\n\n\n      if (prevState !== null) {\n        pushHiddenContext(workInProgress, prevState);\n      } else {\n        reuseHiddenContextOnStack(workInProgress);\n      }\n\n      pushOffscreenSuspenseHandler(workInProgress);\n    }\n  } else {\n    // Rendering a visible tree.\n    if (prevState !== null) {\n      // We're going from hidden -> visible.\n      let prevCachePool = null;\n\n      if (enableCache) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        prevCachePool = prevState.cachePool;\n      }\n\n      let transitions = null;\n\n      if (enableTransitionTracing) {\n        // We have now gone from hidden to visible, so any transitions should\n        // be added to the stack to get added to any Offscreen/suspense children\n        const instance = workInProgress.stateNode;\n\n        if (instance !== null && instance._transitions != null) {\n          transitions = Array.from(instance._transitions);\n        }\n      }\n\n      pushTransition(workInProgress, prevCachePool, transitions); // Push the lanes that were skipped when we bailed out.\n\n      pushHiddenContext(workInProgress, prevState);\n      reuseSuspenseHandlerOnStack(workInProgress); // Since we're not hidden anymore, reset the state\n\n      workInProgress.memoizedState = null;\n    } else {\n      // We weren't previously hidden, and we still aren't, so there's nothing\n      // special to do. Need to push to the stack regardless, though, to avoid\n      // a push/pop misalignment.\n      if (enableCache) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        if (current !== null) {\n          pushTransition(workInProgress, null, null);\n        }\n      } // We're about to bail out, but we need to push this to the stack anyway\n      // to avoid a push/pop misalignment.\n\n\n      reuseHiddenContextOnStack(workInProgress);\n      reuseSuspenseHandlerOnStack(workInProgress);\n    }\n  }\n\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n  const nextState = {\n    baseLanes: nextBaseLanes,\n    // Save the cache pool so we can resume later.\n    cachePool: enableCache ? getOffscreenDeferredCache() : null\n  };\n  workInProgress.memoizedState = nextState;\n\n  if (enableCache) {\n    // push the cache pool even though we're going to bail out\n    // because otherwise there'd be a context mismatch\n    if (current !== null) {\n      pushTransition(workInProgress, null, null);\n    }\n  } // We're about to bail out, but we need to push this to the stack anyway\n  // to avoid a push/pop misalignment.\n\n\n  reuseHiddenContextOnStack(workInProgress);\n  pushOffscreenSuspenseHandler(workInProgress);\n\n  if (enableLazyContextPropagation && current !== null) {\n    // Since this tree will resume rendering in a separate render, we need\n    // to propagate parent contexts now so we don't lose track of which\n    // ones changed.\n    propagateParentContextChangesToDeferredTree(current, workInProgress, renderLanes);\n  }\n\n  return null;\n} // Note: These happen to have identical begin phases, for now. We shouldn't hold\n// ourselves to this constraint, though. If the behavior diverges, we should\n// fork the function.\n\n\nconst updateLegacyHiddenComponent = updateOffscreenComponent;\n\nfunction updateCacheComponent(current, workInProgress, renderLanes) {\n  if (!enableCache) {\n    return null;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const parentCache = readContext(CacheContext);\n\n  if (current === null) {\n    // Initial mount. Request a fresh cache from the pool.\n    const freshCache = requestCacheFromPool(renderLanes);\n    const initialState = {\n      parent: parentCache,\n      cache: freshCache\n    };\n    workInProgress.memoizedState = initialState;\n    initializeUpdateQueue(workInProgress);\n    pushCacheProvider(workInProgress, freshCache);\n  } else {\n    // Check for updates\n    if (includesSomeLane(current.lanes, renderLanes)) {\n      cloneUpdateQueue(current, workInProgress);\n      processUpdateQueue(workInProgress, null, null, renderLanes);\n    }\n\n    const prevState = current.memoizedState;\n    const nextState = workInProgress.memoizedState; // Compare the new parent cache to the previous to see detect there was\n    // a refresh.\n\n    if (prevState.parent !== parentCache) {\n      // Refresh in parent. Update the parent.\n      const derivedState = {\n        parent: parentCache,\n        cache: parentCache\n      }; // Copied from getDerivedStateFromProps implementation. Once the update\n      // queue is empty, persist the derived state onto the base state.\n\n      workInProgress.memoizedState = derivedState;\n\n      if (workInProgress.lanes === NoLanes) {\n        const updateQueue = workInProgress.updateQueue;\n        workInProgress.memoizedState = updateQueue.baseState = derivedState;\n      }\n\n      pushCacheProvider(workInProgress, parentCache); // No need to propagate a context change because the refreshed parent\n      // already did.\n    } else {\n      // The parent didn't refresh. Now check if this cache did.\n      const nextCache = nextState.cache;\n      pushCacheProvider(workInProgress, nextCache);\n\n      if (nextCache !== prevState.cache) {\n        // This cache refreshed. Propagate a context change.\n        propagateContextChange(workInProgress, CacheContext, renderLanes);\n      }\n    }\n  }\n\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n} // This should only be called if the name changes\n\n\nfunction updateTracingMarkerComponent(current, workInProgress, renderLanes) {\n  if (!enableTransitionTracing) {\n    return null;\n  } // TODO: (luna) Only update the tracing marker if it's newly rendered or it's name changed.\n  // A tracing marker is only associated with the transitions that rendered\n  // or updated it, so we can create a new set of transitions each time\n\n\n  if (current === null) {\n    const currentTransitions = getPendingTransitions();\n\n    if (currentTransitions !== null) {\n      const markerInstance = {\n        tag: TransitionTracingMarker,\n        transitions: new Set(currentTransitions),\n        pendingBoundaries: null,\n        name: workInProgress.pendingProps.name,\n        aborts: null\n      };\n      workInProgress.stateNode = markerInstance; // We call the marker complete callback when all child suspense boundaries resolve.\n      // We do this in the commit phase on Offscreen. If the marker has no child suspense\n      // boundaries, we need to schedule a passive effect to make sure we call the marker\n      // complete callback.\n\n      workInProgress.flags |= Passive;\n    }\n  } else {\n    if (__DEV__) {\n      if (current.memoizedProps.name !== workInProgress.pendingProps.name) {\n        console.error('Changing the name of a tracing marker after mount is not supported. ' + 'To remount the tracing marker, pass it a new key.');\n      }\n    }\n  }\n\n  const instance = workInProgress.stateNode;\n\n  if (instance !== null) {\n    pushMarkerInstance(workInProgress, instance);\n  }\n\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateFragment(current, workInProgress, renderLanes) {\n  const nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMode(current, workInProgress, renderLanes) {\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current, workInProgress, renderLanes) {\n  if (enableProfilerTimer) {\n    workInProgress.flags |= Update;\n\n    if (enableProfilerCommitHooks) {\n      // Reset effect durations for the next eventual effect phase.\n      // These are reset during render to allow the DevTools commit hook a chance to read them,\n      const stateNode = workInProgress.stateNode;\n      stateNode.effectDuration = 0;\n      stateNode.passiveEffectDuration = 0;\n    }\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markRef(current, workInProgress) {\n  const ref = workInProgress.ref;\n\n  if (current === null && ref !== null || current !== null && current.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.flags |= Ref;\n    workInProgress.flags |= RefStatic;\n  }\n}\n\nfunction updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  let nextChildren;\n  let hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nexport function replayFunctionComponent(current, workInProgress, nextProps, Component, renderLanes) {\n  // This function is used to replay a component that previously suspended,\n  // after its data resolves. It's a simplified version of\n  // updateFunctionComponent that reuses the hooks from the previous attempt.\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  const nextChildren = replaySuspendedComponentWithHooks(current, workInProgress, Component, nextProps, context);\n  const hasId = checkDidRenderIdHook();\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (__DEV__) {\n    // This is used by DevTools to force a boundary to error.\n    switch (shouldError(workInProgress)) {\n      case false:\n        {\n          const instance = workInProgress.stateNode;\n          const ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n          // Is there a better way to do this?\n\n          const tempInstance = new ctor(workInProgress.memoizedProps, instance.context);\n          const state = tempInstance.state;\n          instance.updater.enqueueSetState(instance, state, null);\n          break;\n        }\n\n      case true:\n        {\n          workInProgress.flags |= DidCapture;\n          workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n\n          const error = new Error('Simulated error coming from DevTools');\n          const lane = pickArbitraryLane(renderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n\n          const update = createClassErrorUpdate(workInProgress, createCapturedValueAtFiber(error, workInProgress), lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          break;\n        }\n    }\n\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  } // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\n  let hasContext;\n\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n\n  if (instance === null) {\n    resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress); // In the initial pass we might need to construct the instance.\n\n    constructClassInstance(workInProgress, Component, nextProps);\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  } else {\n    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n  }\n\n  const nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n\n  if (__DEV__) {\n    const inst = workInProgress.stateNode;\n\n    if (shouldUpdate && inst.props !== nextProps) {\n      if (!didWarnAboutReassigningProps) {\n        console.error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n      }\n\n      didWarnAboutReassigningProps = true;\n    }\n  }\n\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n  const didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  const instance = workInProgress.stateNode; // Rerender\n\n  ReactCurrentOwner.current = workInProgress;\n  let nextChildren;\n\n  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n    // If we captured an error, but getDerivedStateFromError is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    if (enableSchedulingProfiler) {\n      markComponentRenderStarted(workInProgress);\n    }\n\n    if (__DEV__) {\n      setIsRendering(true);\n      nextChildren = instance.render();\n\n      if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          instance.render();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      setIsRendering(false);\n    } else {\n      nextChildren = instance.render();\n    }\n\n    if (enableSchedulingProfiler) {\n      markComponentRenderStopped();\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  } // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n\n\n  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  const root = workInProgress.stateNode;\n\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderLanes) {\n  pushHostRootContext(workInProgress);\n\n  if (current === null) {\n    throw new Error('Should have a current fiber. This is a bug in React.');\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const prevState = workInProgress.memoizedState;\n  const prevChildren = prevState.element;\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  const nextState = workInProgress.memoizedState;\n  const root = workInProgress.stateNode;\n  pushRootTransition(workInProgress, root, renderLanes);\n\n  if (enableTransitionTracing) {\n    pushRootMarkerInstance(workInProgress);\n  }\n\n  if (enableCache) {\n    const nextCache = nextState.cache;\n    pushCacheProvider(workInProgress, nextCache);\n\n    if (nextCache !== prevState.cache) {\n      // The root cache refreshed.\n      propagateContextChange(workInProgress, CacheContext, renderLanes);\n    }\n  } // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n\n  const nextChildren = nextState.element;\n\n  if (supportsHydration && prevState.isDehydrated) {\n    // This is a hydration root whose shell has not yet hydrated. We should\n    // attempt to hydrate.\n    // Flip isDehydrated to false to indicate that when this render\n    // finishes, the root will no longer be dehydrated.\n    const overrideState = {\n      element: nextChildren,\n      isDehydrated: false,\n      cache: nextState.cache\n    };\n    const updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n    // have reducer functions so it doesn't need rebasing.\n\n    updateQueue.baseState = overrideState;\n    workInProgress.memoizedState = overrideState;\n\n    if (workInProgress.flags & ForceClientRender) {\n      // Something errored during a previous attempt to hydrate the shell, so we\n      // forced a client render.\n      const recoverableError = createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside ' + 'of a Suspense boundary, the entire root will switch to ' + 'client rendering.'), workInProgress);\n      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n    } else if (nextChildren !== prevChildren) {\n      const recoverableError = createCapturedValueAtFiber(new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.'), workInProgress);\n      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n    } else {\n      // The outermost shell has not hydrated yet. Start hydrating.\n      enterHydrationState(workInProgress);\n\n      if (enableUseMutableSource) {\n        const mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData;\n\n        if (mutableSourceEagerHydrationData != null) {\n          for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {\n            const mutableSource = mutableSourceEagerHydrationData[i];\n            const version = mutableSourceEagerHydrationData[i + 1];\n            setWorkInProgressVersion(mutableSource, version);\n          }\n        }\n      }\n\n      const child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n      workInProgress.child = child;\n      let node = child;\n\n      while (node) {\n        // Mark each child as hydrating. This is a fast path to know whether this\n        // tree is part of a hydrating tree. This is used to determine if a child\n        // node has fully mounted yet, and for scheduling event replaying.\n        // Conceptually this is similar to Placement in that a new subtree is\n        // inserted into the React tree here. It just happens to not need DOM\n        // mutations because it already exists.\n        node.flags = node.flags & ~Placement | Hydrating;\n        node = node.sibling;\n      }\n    }\n  } else {\n    // Root is not dehydrated. Either this is a client-only root, or it\n    // already hydrated.\n    resetHydrationState();\n\n    if (nextChildren === prevChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nfunction mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {\n  // Revert to client rendering.\n  resetHydrationState();\n  queueHydrationError(recoverableError);\n  workInProgress.flags |= ForceClientRender;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current, workInProgress, renderLanes) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n  let nextChildren = nextProps.children;\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.flags |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostResource(current, workInProgress, renderLanes) {\n  pushHostContext(workInProgress);\n  markRef(current, workInProgress);\n  const currentProps = current === null ? null : current.memoizedProps;\n  workInProgress.memoizedState = getResource(workInProgress.type, workInProgress.pendingProps, currentProps); // Resources never have reconciler managed children. It is possible for\n  // the host implementation of getResource to consider children in the\n  // resource construction but they will otherwise be discarded. In practice\n  // this precludes all but the simplest children and Host specific warnings\n  // should be implemented to warn when children are passsed when otherwise not\n  // expected\n\n  return null;\n}\n\nfunction updateHostSingleton(current, workInProgress, renderLanes) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    claimHydratableSingleton(workInProgress);\n  }\n\n  const nextChildren = workInProgress.pendingProps.children;\n\n  if (current === null && !getIsHydrating()) {\n    // Similar to Portals we append Singleton children in the commit phase. So we\n    // Track insertions even on mount.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  markRef(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  } // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n\n\n  return null;\n}\n\nfunction mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n  const props = workInProgress.pendingProps;\n  const lazyComponent = elementType;\n  const payload = lazyComponent._payload;\n  const init = lazyComponent._init;\n  let Component = init(payload); // Store the unwrapped component in the type.\n\n  workInProgress.type = Component;\n  const resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n  const resolvedProps = resolveDefaultProps(Component, props);\n  let child;\n\n  switch (resolvedTag) {\n    case FunctionComponent:\n      {\n        if (__DEV__) {\n          validateFunctionComponentInDev(workInProgress, Component);\n          workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n        }\n\n        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ClassComponent:\n      {\n        if (__DEV__) {\n          workInProgress.type = Component = resolveClassForHotReloading(Component);\n        }\n\n        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ForwardRef:\n      {\n        if (__DEV__) {\n          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n        }\n\n        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case MemoComponent:\n      {\n        if (__DEV__) {\n          if (workInProgress.type !== workInProgress.elementType) {\n            const outerPropTypes = Component.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentNameFromType(Component));\n            }\n          }\n        }\n\n        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        renderLanes);\n        return child;\n      }\n  }\n\n  let hint = '';\n\n  if (__DEV__) {\n    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n      hint = ' Did you wrap a component in React.lazy() more than once?';\n    }\n  } // This message intentionally doesn't mention ForwardRef or MemoComponent\n  // because the fact that it's a separate type of work is an\n  // implementation detail.\n\n\n  throw new Error(`Element type is invalid. Received a promise that resolves to: ${Component}. ` + `Lazy element type must resolve to a class or function.${hint}`);\n}\n\nfunction mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress); // Promote the fiber to a class and try rendering again.\n\n  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n  let hasContext;\n\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  constructClassInstance(workInProgress, Component, nextProps);\n  mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n}\n\nfunction mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n  const props = workInProgress.pendingProps;\n  let context;\n\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  let value;\n  let hasId;\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  if (__DEV__) {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    setIsRendering(true);\n    ReactCurrentOwner.current = workInProgress;\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  } else {\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  if (__DEV__) {\n    // Support for module components is deprecated and is removed behind a flag.\n    // Whether or not it would crash later, we want to show a good message in DEV first.\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', componentName, componentName, componentName);\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n  }\n\n  if ( // Run these checks in production only if the flag is off.\n  // Eventually we'll delete this branch altogether.\n  !disableModulePatternComponents && typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    if (__DEV__) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', componentName, componentName, componentName);\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    } // Proceed under the assumption that this is a class instance\n\n\n    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n\n    let hasContext = false;\n\n    if (isLegacyContextProvider(Component)) {\n      hasContext = true;\n      pushLegacyContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n    initializeUpdateQueue(workInProgress);\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderLanes);\n    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n\n    if (__DEV__) {\n      if (disableLegacyContext && Component.contextTypes) {\n        console.error('%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with React.useContext() instead.', getComponentNameFromType(Component) || 'Unknown');\n      }\n    }\n\n    if (getIsHydrating() && hasId) {\n      pushMaterializedTreeId(workInProgress);\n    }\n\n    reconcileChildren(null, workInProgress, value, renderLanes);\n\n    if (__DEV__) {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress, Component) {\n  if (__DEV__) {\n    if (Component) {\n      if (Component.childContextTypes) {\n        console.error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');\n      }\n    }\n\n    if (workInProgress.ref !== null) {\n      let info = '';\n      const ownerName = getCurrentFiberOwnerNameInDevOrNull();\n\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      let warningKey = ownerName || '';\n      const debugSource = workInProgress._debugSource;\n\n      if (debugSource) {\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n      }\n\n      if (!didWarnAboutFunctionRefs[warningKey]) {\n        didWarnAboutFunctionRefs[warningKey] = true;\n        console.error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);\n      }\n    }\n\n    if (warnAboutDefaultPropsOnFunctionComponents && Component.defaultProps !== undefined) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n        console.error('%s: Support for defaultProps will be removed from function components ' + 'in a future major release. Use JavaScript default parameters instead.', componentName);\n        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\n        console.error('%s: Function components do not support getDerivedStateFromProps.', componentName);\n        didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\n        console.error('%s: Function components do not support contextType.', componentName);\n        didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\n      }\n    }\n  }\n}\n\nconst SUSPENDED_MARKER = {\n  dehydrated: null,\n  treeContext: null,\n  retryLane: NoLane\n};\n\nfunction mountSuspenseOffscreenState(renderLanes) {\n  return {\n    baseLanes: renderLanes,\n    cachePool: getSuspendedCache()\n  };\n}\n\nfunction updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n  let cachePool = null;\n\n  if (enableCache) {\n    const prevCachePool = prevOffscreenState.cachePool;\n\n    if (prevCachePool !== null) {\n      const parentCache = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2;\n\n      if (prevCachePool.parent !== parentCache) {\n        // Detected a refresh in the parent. This overrides any previously\n        // suspended cache.\n        cachePool = {\n          parent: parentCache,\n          pool: parentCache\n        };\n      } else {\n        // We can reuse the cache from last time. The only thing that would have\n        // overridden it is a parent refresh, which we checked for above.\n        cachePool = prevCachePool;\n      }\n    } else {\n      // If there's no previous cache pool, grab the current one.\n      cachePool = getSuspendedCache();\n    }\n  }\n\n  return {\n    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n    cachePool\n  };\n} // TODO: Probably should inline this back\n\n\nfunction shouldRemainOnFallback(current, workInProgress, renderLanes) {\n  // If we're already showing a fallback, there are cases where we need to\n  // remain on that fallback regardless of whether the content has resolved.\n  // For example, SuspenseList coordinates when nested content appears.\n  if (current !== null) {\n    const suspenseState = current.memoizedState;\n\n    if (suspenseState === null) {\n      // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n      // Note: This is a factoring smell. Can't remain on a fallback if there's\n      // no fallback to remain on.\n      return false;\n    }\n  } // Not currently showing content. Consult the Suspense context.\n\n\n  const suspenseContext = suspenseStackCursor.current;\n  return hasSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n}\n\nfunction getRemainingWorkInPrimaryTree(current, renderLanes) {\n  // TODO: Should not remove render lanes that were pinged during this render\n  return removeLanes(current.childLanes, renderLanes);\n}\n\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n\n  if (__DEV__) {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.flags |= DidCapture;\n    }\n  }\n\n  let showFallback = false;\n  const didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (didSuspend || shouldRemainOnFallback(current, workInProgress, renderLanes)) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    showFallback = true;\n    workInProgress.flags &= ~DidCapture;\n  } // OK, the next part is confusing. We're about to reconcile the Suspense\n  // boundary's children. This involves some custom reconciliation logic. Two\n  // main reasons this is so complicated.\n  //\n  // First, Legacy Mode has different semantics for backwards compatibility. The\n  // primary tree will commit in an inconsistent state, so when we do the\n  // second pass to render the fallback, we do some exceedingly, uh, clever\n  // hacks to make that not totally break. Like transferring effects and\n  // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n  // because we bailout on the primary tree completely and leave it in its old\n  // state, no effects. Same as what we do for Offscreen (except that\n  // Offscreen doesn't have the first render pass).\n  //\n  // Second is hydration. During hydration, the Suspense fiber has a slightly\n  // different layout, where the child points to a dehydrated fragment, which\n  // contains the DOM rendered by the server.\n  //\n  // Third, even if you set all that aside, Suspense is like error boundaries in\n  // that we first we try to render one tree, and if that fails, we render again\n  // and switch to a different tree. Like a try/catch block. So we have to track\n  // which branch we're currently rendering. Ideally we would model this using\n  // a stack.\n\n\n  if (current === null) {\n    // Initial mount\n    // Special path for hydration\n    // If we're currently hydrating, try to hydrate this boundary.\n    if (getIsHydrating()) {\n      // We must push the suspense handler context *before* attempting to\n      // hydrate, to avoid a mismatch in case it errors.\n      if (showFallback) {\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n      } else {\n        pushFallbackTreeSuspenseHandler(workInProgress);\n      }\n\n      tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n\n      const suspenseState = workInProgress.memoizedState;\n\n      if (suspenseState !== null) {\n        const dehydrated = suspenseState.dehydrated;\n\n        if (dehydrated !== null) {\n          return mountDehydratedSuspenseComponent(workInProgress, dehydrated, renderLanes);\n        }\n      } // If hydration didn't succeed, fall through to the normal Suspense path.\n      // To avoid a stack mismatch we need to pop the Suspense handler that we\n      // pushed above. This will become less awkward when move the hydration\n      // logic to its own fiber.\n\n\n      popSuspenseHandler(workInProgress);\n    }\n\n    const nextPrimaryChildren = nextProps.children;\n    const nextFallbackChildren = nextProps.fallback;\n\n    if (showFallback) {\n      pushFallbackTreeSuspenseHandler(workInProgress);\n      const fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      const primaryChildFragment = workInProgress.child;\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n\n      if (enableTransitionTracing) {\n        const currentTransitions = getPendingTransitions();\n\n        if (currentTransitions !== null) {\n          const parentMarkerInstances = getMarkerInstances();\n          const offscreenQueue = primaryChildFragment.updateQueue;\n\n          if (offscreenQueue === null) {\n            const newOffscreenQueue = {\n              transitions: currentTransitions,\n              markerInstances: parentMarkerInstances,\n              wakeables: null\n            };\n            primaryChildFragment.updateQueue = newOffscreenQueue;\n          } else {\n            offscreenQueue.transitions = currentTransitions;\n            offscreenQueue.markerInstances = parentMarkerInstances;\n          }\n        }\n      }\n\n      return fallbackFragment;\n    } else if (enableCPUSuspense && typeof nextProps.unstable_expectedLoadTime === 'number') {\n      // This is a CPU-bound tree. Skip this tree and show a placeholder to\n      // unblock the surrounding content. Then immediately retry after the\n      // initial commit.\n      pushFallbackTreeSuspenseHandler(workInProgress);\n      const fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      const primaryChildFragment = workInProgress.child;\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER; // TODO: Transition Tracing is not yet implemented for CPU Suspense.\n      // Since nothing actually suspended, there will nothing to ping this to\n      // get it started back up to attempt the next item. While in terms of\n      // priority this work has the same priority as this current render, it's\n      // not part of the same transition once the transition has committed. If\n      // it's sync, we still want to yield so that it can be painted.\n      // Conceptually, this is really the same as pinging. We can use any\n      // RetryLane even if it's the one currently rendering since we're leaving\n      // it behind on this node.\n\n      workInProgress.lanes = SomeRetryLane;\n      return fallbackFragment;\n    } else {\n      pushPrimaryTreeSuspenseHandler(workInProgress);\n      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes);\n    }\n  } else {\n    // This is an update.\n    // Special path for hydration\n    const prevState = current.memoizedState;\n\n    if (prevState !== null) {\n      const dehydrated = prevState.dehydrated;\n\n      if (dehydrated !== null) {\n        return updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, dehydrated, prevState, renderLanes);\n      }\n    }\n\n    if (showFallback) {\n      pushFallbackTreeSuspenseHandler(workInProgress);\n      const nextFallbackChildren = nextProps.fallback;\n      const nextPrimaryChildren = nextProps.children;\n      const fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      const primaryChildFragment = workInProgress.child;\n      const prevOffscreenState = current.child.memoizedState;\n      primaryChildFragment.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n\n      if (enableTransitionTracing) {\n        const currentTransitions = getPendingTransitions();\n\n        if (currentTransitions !== null) {\n          const parentMarkerInstances = getMarkerInstances();\n          const offscreenQueue = primaryChildFragment.updateQueue;\n          const currentOffscreenQueue = current.updateQueue;\n\n          if (offscreenQueue === null) {\n            const newOffscreenQueue = {\n              transitions: currentTransitions,\n              markerInstances: parentMarkerInstances,\n              wakeables: null\n            };\n            primaryChildFragment.updateQueue = newOffscreenQueue;\n          } else if (offscreenQueue === currentOffscreenQueue) {\n            // If the work-in-progress queue is the same object as current, we\n            // can't modify it without cloning it first.\n            const newOffscreenQueue = {\n              transitions: currentTransitions,\n              markerInstances: parentMarkerInstances,\n              wakeables: currentOffscreenQueue !== null ? currentOffscreenQueue.wakeables : null\n            };\n            primaryChildFragment.updateQueue = newOffscreenQueue;\n          } else {\n            offscreenQueue.transitions = currentTransitions;\n            offscreenQueue.markerInstances = parentMarkerInstances;\n          }\n        }\n      }\n\n      primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackChildFragment;\n    } else {\n      pushPrimaryTreeSuspenseHandler(workInProgress);\n      const nextPrimaryChildren = nextProps.children;\n      const primaryChildFragment = updateSuspensePrimaryChildren(current, workInProgress, nextPrimaryChildren, renderLanes);\n      workInProgress.memoizedState = null;\n      return primaryChildFragment;\n    }\n  }\n}\n\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n  const mode = workInProgress.mode;\n  const primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  const primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode, renderLanes);\n  primaryChildFragment.return = workInProgress;\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  const mode = workInProgress.mode;\n  const progressedPrimaryFragment = workInProgress.child;\n  const primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  let primaryChildFragment;\n  let fallbackChildFragment;\n\n  if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n    // In legacy mode, we commit the primary tree as if it successfully\n    // completed, even though it's in an inconsistent state.\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = 0;\n      primaryChildFragment.treeBaseDuration = 0;\n    }\n\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  } else {\n    primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode, NoLanes);\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  }\n\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n  // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n  // this wrapper function to constrain it.\n  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n}\n\nfunction updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n  // The props argument to `createWorkInProgress` is `any` typed, so we use this\n  // wrapper function to constrain it.\n  return createWorkInProgress(current, offscreenProps);\n}\n\nfunction updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n  const currentPrimaryChildFragment = current.child;\n  const currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  const primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n    mode: 'visible',\n    children: primaryChildren\n  });\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    primaryChildFragment.lanes = renderLanes;\n  }\n\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = null;\n\n  if (currentFallbackChildFragment !== null) {\n    // Delete the fallback child fragment\n    const deletions = workInProgress.deletions;\n\n    if (deletions === null) {\n      workInProgress.deletions = [currentFallbackChildFragment];\n      workInProgress.flags |= ChildDeletion;\n    } else {\n      deletions.push(currentFallbackChildFragment);\n    }\n  }\n\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  const mode = workInProgress.mode;\n  const currentPrimaryChildFragment = current.child;\n  const currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  const primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  let primaryChildFragment;\n\n  if ( // In legacy mode, we commit the primary tree as if it successfully\n  // completed, even though it's in an inconsistent state.\n  (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n  // already cloned. In legacy mode, the only case where this isn't true is\n  // when DevTools forces us to display a fallback; we skip the first render\n  // pass entirely and go straight to rendering the fallback. (In Concurrent\n  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n  // only codepath.)\n  workInProgress.child !== currentPrimaryChildFragment) {\n    const progressedPrimaryFragment = workInProgress.child;\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n    } // The fallback fiber was added as a deletion during the first pass.\n    // However, since we're going to remain on the fallback, we no longer want\n    // to delete it.\n\n\n    workInProgress.deletions = null;\n  } else {\n    primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps); // Since we're reusing a current tree, we need to reuse the flags, too.\n    // (We don't do this in legacy mode, because in legacy mode we don't re-use\n    // the current tree; see previous branch.)\n\n    primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n  }\n\n  let fallbackChildFragment;\n\n  if (currentFallbackChildFragment !== null) {\n    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n  } else {\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n    // mounted but this is a new fiber.\n\n    fallbackChildFragment.flags |= Placement;\n  }\n\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {\n  // Falling back to client rendering. Because this has performance\n  // implications, it's considered a recoverable error, even though the user\n  // likely won't observe anything wrong with the UI.\n  //\n  // The error is passed in as an argument to enforce that every caller provide\n  // a custom message, or explicitly opt out (currently the only path that opts\n  // out is legacy mode; every concurrent path provides an error).\n  if (recoverableError !== null) {\n    queueHydrationError(recoverableError);\n  } // This will add the old fiber to the deletion list\n\n\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n\n  const nextProps = workInProgress.pendingProps;\n  const primaryChildren = nextProps.children;\n  const primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes); // Needs a placement effect because the parent (the Suspense boundary) already\n  // mounted but this is a new fiber.\n\n  primaryChildFragment.flags |= Placement;\n  workInProgress.memoizedState = null;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  const fiberMode = workInProgress.mode;\n  const primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  const primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode, NoLanes);\n  const fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n  // boundary) already mounted but this is a new fiber.\n\n  fallbackChildFragment.flags |= Placement;\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n\n  if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n    // We will have dropped the effect list which contains the\n    // deletion. We need to reconcile to delete the current child.\n    reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  }\n\n  return fallbackChildFragment;\n}\n\nfunction mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    if (__DEV__) {\n      console.error('Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOMClient.hydrateRoot(container, <App />)' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');\n    }\n\n    workInProgress.lanes = laneToLanes(SyncLane);\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    // Schedule a normal pri update to render this content.\n    workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.lanes = laneToLanes(OffscreenLane);\n  }\n\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes) {\n  if (!didSuspend) {\n    // This is the first render pass. Attempt to hydrate.\n    pushPrimaryTreeSuspenseHandler(workInProgress); // We should never be hydrating at this point because it is the first pass,\n    // but after we've already committed once.\n\n    warnIfHydrating();\n\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, null);\n    }\n\n    if (isSuspenseInstanceFallback(suspenseInstance)) {\n      // This boundary is in a permanent fallback state. In this case, we'll never\n      // get an update and we'll never be able to hydrate the final content. Let's just try the\n      // client side render instead.\n      let digest, message, stack;\n\n      if (__DEV__) {\n        ({\n          digest,\n          message,\n          stack\n        } = getSuspenseInstanceFallbackErrorDetails(suspenseInstance));\n      } else {\n        ({\n          digest\n        } = getSuspenseInstanceFallbackErrorDetails(suspenseInstance));\n      }\n\n      let error;\n\n      if (message) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        error = new Error(message);\n      } else {\n        error = new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. Switched to ' + 'client rendering.');\n      }\n\n      error.digest = digest;\n      const capturedValue = createCapturedValue(error, digest, stack);\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, capturedValue);\n    }\n\n    if (enableLazyContextPropagation && // TODO: Factoring is a little weird, since we check this right below, too.\n    // But don't want to re-arrange the if-else chain until/unless this\n    // feature lands.\n    !didReceiveUpdate) {\n      // We need to check if any children have context before we decide to bail\n      // out, so propagate the changes now.\n      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n    } // We use lanes to indicate that a child might depend on context, so if\n    // any context has changed, we need to treat is as if the input might have changed.\n\n\n    const hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n\n    if (didReceiveUpdate || hasContextChanged) {\n      // This boundary has changed since the first render. This means that we are now unable to\n      // hydrate it. We might still be able to hydrate it using a higher priority lane.\n      const root = getWorkInProgressRoot();\n\n      if (root !== null) {\n        const attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n\n        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n          // Intentionally mutating since this render will get interrupted. This\n          // is one of the very rare times where we mutate the current tree\n          // during the render phase.\n          suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render\n\n          const eventTime = NoTimestamp;\n          enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);\n          scheduleUpdateOnFiber(root, current, attemptHydrationAtLane, eventTime); // Throw a special object that signals to the work loop that it should\n          // interrupt the current render.\n          //\n          // Because we're inside a React-only execution stack, we don't\n          // strictly need to throw here â€” we could instead modify some internal\n          // work loop state. But using an exception means we don't need to\n          // check for this case on every iteration of the work loop. So doing\n          // it this way moves the check out of the fast path.\n\n          throw SelectiveHydrationException;\n        } else {// We have already tried to ping at a higher priority than we're rendering with\n          // so if we got here, we must have failed to hydrate at those levels. We must\n          // now give up. Instead, we're going to delete the whole subtree and instead inject\n          // a new real Suspense boundary to take its place, which may render content\n          // or fallback. This might suspend for a while and if it does we might still have\n          // an opportunity to hydrate before this pass commits.\n        }\n      } // If we did not selectively hydrate, we'll continue rendering without\n      // hydrating. Mark this tree as suspended to prevent it from committing\n      // outside a transition.\n      //\n      // This path should only happen if the hydration lane already suspended.\n      // Currently, it also happens during sync updates because there is no\n      // hydration lane for sync updates.\n      // TODO: We should ideally have a sync hydration lane that we can apply to do\n      // a pass where we hydrate this subtree in place using the previous Context and then\n      // reapply the update afterwards.\n\n\n      renderDidSuspendDelayIfPossible();\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, null);\n    } else if (isSuspenseInstancePending(suspenseInstance)) {\n      // This component is still pending more data from the server, so we can't hydrate its\n      // content. We treat it as if this component suspended itself. It might seem as if\n      // we could just try to render it client-side instead. However, this will perform a\n      // lot of unnecessary work and is unlikely to complete since it often will suspend\n      // on missing data anyway. Additionally, the server might be able to render more\n      // than we can on the client yet. In that case we'd end up with more fallback states\n      // on the client than if we just leave it alone. If the server times out or errors\n      // these should update this boundary to the permanent Fallback state instead.\n      // Mark it as having captured (i.e. suspended).\n      workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n\n      workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n\n      const retry = retryDehydratedSuspenseBoundary.bind(null, current);\n      registerSuspenseInstanceRetry(suspenseInstance, retry);\n      return null;\n    } else {\n      // This is the first attempt.\n      reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n      const primaryChildren = nextProps.children;\n      const primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes); // Mark the children as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n\n      primaryChildFragment.flags |= Hydrating;\n      return primaryChildFragment;\n    }\n  } else {\n    // This is the second render pass. We already attempted to hydrated, but\n    // something either suspended or errored.\n    if (workInProgress.flags & ForceClientRender) {\n      // Something errored during hydration. Try again without hydrating.\n      pushPrimaryTreeSuspenseHandler(workInProgress);\n      workInProgress.flags &= ~ForceClientRender;\n      const capturedValue = createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. ' + 'Switched to client rendering.'));\n      return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, capturedValue);\n    } else if (workInProgress.memoizedState !== null) {\n      // Something suspended and we should still be in dehydrated mode.\n      // Leave the existing child in place.\n      // Push to avoid a mismatch\n      pushFallbackTreeSuspenseHandler(workInProgress);\n      workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n      // but the normal suspense pass doesn't.\n\n      workInProgress.flags |= DidCapture;\n      return null;\n    } else {\n      // Suspended but we should no longer be in dehydrated mode.\n      // Therefore we now have to render the fallback.\n      pushFallbackTreeSuspenseHandler(workInProgress);\n      const nextPrimaryChildren = nextProps.children;\n      const nextFallbackChildren = nextProps.fallback;\n      const fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      const primaryChildFragment = workInProgress.child;\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackChildFragment;\n    }\n  }\n}\n\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n  const alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n  }\n\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n}\n\nfunction propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  let node = firstChild;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state = node.memoizedState;\n\n      if (state !== null) {\n        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === workInProgress) {\n      return;\n    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n    while (node.sibling === null) {\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n\n      node = node.return;\n    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild) {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  let row = firstChild;\n  let lastContentRow = null;\n\n  while (row !== null) {\n    const currentRow = row.alternate; // New rows can't be content rows.\n\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n\n    row = row.sibling;\n  }\n\n  return lastContentRow;\n}\n\nfunction validateRevealOrder(revealOrder) {\n  if (__DEV__) {\n    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards':\n            {\n              console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n              break;\n            }\n\n          case 'forward':\n          case 'backward':\n            {\n              console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n              break;\n            }\n\n          default:\n            console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n            break;\n        }\n      } else {\n        console.error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(tailMode, revealOrder) {\n  if (__DEV__) {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot, index) {\n  if (__DEV__) {\n    const isAnArray = isArray(childSlot);\n    const isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n\n    if (isAnArray || isIterable) {\n      const type = isAnArray ? 'array' : 'iterable';\n      console.error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateSuspenseListChildren(children, revealOrder) {\n  if (__DEV__) {\n    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n      if (isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        const iteratorFn = getIteratorFn(children);\n\n        if (typeof iteratorFn === 'function') {\n          const childrenIterator = iteratorFn.call(children);\n\n          if (childrenIterator) {\n            let step = childrenIterator.next();\n            let i = 0;\n\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, i)) {\n                return;\n              }\n\n              i++;\n            }\n          }\n        } else {\n          console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n  const renderState = workInProgress.memoizedState;\n\n  if (renderState === null) {\n    workInProgress.memoizedState = {\n      isBackwards: isBackwards,\n      rendering: null,\n      renderingStartTime: 0,\n      last: lastContentRow,\n      tail: tail,\n      tailMode: tailMode\n    };\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.renderingStartTime = 0;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailMode = tailMode;\n  }\n} // This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\n\n\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const revealOrder = nextProps.revealOrder;\n  const tailMode = nextProps.tail;\n  const newChildren = nextProps.children;\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  let suspenseContext = suspenseStackCursor.current;\n  const shouldForceFallback = hasSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n    workInProgress.flags |= DidCapture;\n  } else {\n    const didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\n\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n    }\n\n    suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n  }\n\n  pushSuspenseListContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    // In legacy mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards':\n        {\n          const lastContentRow = findLastContentRow(workInProgress.child);\n          let tail;\n\n          if (lastContentRow === null) {\n            // The whole list is part of the tail.\n            // TODO: We could fast path by just rendering the tail now.\n            tail = workInProgress.child;\n            workInProgress.child = null;\n          } else {\n            // Disconnect the tail rows after the content row.\n            // We're going to render them separately later.\n            tail = lastContentRow.sibling;\n            lastContentRow.sibling = null;\n          }\n\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          tail, lastContentRow, tailMode);\n          break;\n        }\n\n      case 'backwards':\n        {\n          // We're going to find the first row that has existing content.\n          // At the same time we're going to reverse the list of everything\n          // we pass in the meantime. That's going to be our tail in reverse\n          // order.\n          let tail = null;\n          let row = workInProgress.child;\n          workInProgress.child = null;\n\n          while (row !== null) {\n            const currentRow = row.alternate; // New rows can't be content rows.\n\n            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n              // This is the beginning of the main content.\n              workInProgress.child = row;\n              break;\n            }\n\n            const nextRow = row.sibling;\n            row.sibling = tail;\n            tail = row;\n            row = nextRow;\n          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n\n\n          initSuspenseListRenderState(workInProgress, true, // isBackwards\n          tail, null, // last\n          tailMode);\n          break;\n        }\n\n      case 'together':\n        {\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          null, // tail\n          null, // last\n          undefined);\n          break;\n        }\n\n      default:\n        {\n          // The default reveal order is the same as not having\n          // a boundary.\n          workInProgress.memoizedState = null;\n        }\n    }\n  }\n\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(current, workInProgress, renderLanes) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  const nextChildren = workInProgress.pendingProps;\n\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n\nfunction updateContextProvider(current, workInProgress, renderLanes) {\n  const providerType = workInProgress.type;\n  const context = providerType._context;\n  const newProps = workInProgress.pendingProps;\n  const oldProps = workInProgress.memoizedProps;\n  const newValue = newProps.value;\n\n  if (__DEV__) {\n    if (!('value' in newProps)) {\n      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n        console.error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n      }\n    }\n\n    const providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\n    }\n  }\n\n  pushProvider(workInProgress, context, newValue);\n\n  if (enableLazyContextPropagation) {// In the lazy propagation implementation, we don't scan for matching\n    // consumers until something bails out, because until something bails out\n    // we're going to visit those nodes, anyway. The trade-off is that it shifts\n    // responsibility to the consumer to track whether something has changed.\n  } else {\n    if (oldProps !== null) {\n      const oldValue = oldProps.value;\n\n      if (is(oldValue, newValue)) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children && !hasLegacyContextChanged()) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n      } else {\n        // The context value changed. Search for matching consumers and schedule\n        // them to update.\n        propagateContextChange(workInProgress, context, renderLanes);\n      }\n    }\n  }\n\n  const newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(current, workInProgress, renderLanes) {\n  let context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n\n  if (__DEV__) {\n    if (context._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n          console.error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n        }\n      }\n    } else {\n      context = context._context;\n    }\n  }\n\n  const newProps = workInProgress.pendingProps;\n  const render = newProps.children;\n\n  if (__DEV__) {\n    if (typeof render !== 'function') {\n      console.error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n    }\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const newValue = readContext(context);\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  let newChildren;\n\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    newChildren = render(newValue);\n    setIsRendering(false);\n  } else {\n    newChildren = render(newValue);\n  }\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateScopeComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\nexport function checkIfWorkInProgressReceivedUpdate() {\n  return didReceiveUpdate;\n}\n\nfunction resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress) {\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    if (current !== null) {\n      // A lazy component only mounts if it suspended inside a non-\n      // concurrent tree, in an inconsistent state. We want to treat it like\n      // a new mount, even though an empty version of it already committed.\n      // Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n      workInProgress.flags |= Placement;\n    }\n  }\n}\n\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n\n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    if (enableLazyContextPropagation && current !== null) {\n      // Before bailing out, check if there are any context changes in\n      // the children.\n      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n\n      if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  } // This fiber doesn't have work, but its subtree does. Clone the child\n  // fibers and continue.\n\n\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n  if (__DEV__) {\n    const returnFiber = oldWorkInProgress.return;\n\n    if (returnFiber === null) {\n      // eslint-disable-next-line react-internal/prod-error-codes\n      throw new Error('Cannot swap the root fiber.');\n    } // Disconnect from the old current.\n    // It will get deleted.\n\n\n    current.alternate = null;\n    oldWorkInProgress.alternate = null; // Connect to the new tree.\n\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      let prevSibling = returnFiber.child;\n\n      if (prevSibling === null) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        throw new Error('Expected parent to have a child.');\n      } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n        prevSibling = prevSibling.sibling;\n\n        if (prevSibling === null) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          throw new Error('Expected to find the previous sibling.');\n        }\n      } // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n\n      prevSibling.sibling = newWorkInProgress;\n    } // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n\n\n    const deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [current];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(current);\n    }\n\n    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n\n    return newWorkInProgress;\n  } else {\n    throw new Error('Did not expect this call in production. ' + 'This is a bug in React. Please file an issue.');\n  }\n}\n\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\n  // Before performing an early bailout, we must check if there are pending\n  // updates or context.\n  const updateLanes = current.lanes;\n\n  if (includesSomeLane(updateLanes, renderLanes)) {\n    return true;\n  } // No pending update, but because context is propagated lazily, we need\n  // to check for a context change before we bail out.\n\n\n  if (enableLazyContextPropagation) {\n    const dependencies = current.dependencies;\n\n    if (dependencies !== null && checkIfContextChanged(dependencies)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n  // This fiber does not have any pending work. Bailout without entering\n  // the begin phase. There's still some bookkeeping we that needs to be done\n  // in this optimized path, mostly pushing stuff onto the stack.\n  switch (workInProgress.tag) {\n    case HostRoot:\n      pushHostRootContext(workInProgress);\n      const root = workInProgress.stateNode;\n      pushRootTransition(workInProgress, root, renderLanes);\n\n      if (enableTransitionTracing) {\n        pushRootMarkerInstance(workInProgress);\n      }\n\n      if (enableCache) {\n        const cache = current.memoizedState.cache;\n        pushCacheProvider(workInProgress, cache);\n      }\n\n      resetHydrationState();\n      break;\n\n    case HostResource:\n    case HostSingleton:\n    case HostComponent:\n      pushHostContext(workInProgress);\n      break;\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n\n        if (isLegacyContextProvider(Component)) {\n          pushLegacyContextProvider(workInProgress);\n        }\n\n        break;\n      }\n\n    case HostPortal:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n\n    case ContextProvider:\n      {\n        const newValue = workInProgress.memoizedProps.value;\n        const context = workInProgress.type._context;\n        pushProvider(workInProgress, context, newValue);\n        break;\n      }\n\n    case Profiler:\n      if (enableProfilerTimer) {\n        // Profiler should only call onRender when one of its descendants actually rendered.\n        const hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (hasChildWork) {\n          workInProgress.flags |= Update;\n        }\n\n        if (enableProfilerCommitHooks) {\n          // Reset effect durations for the next eventual effect phase.\n          // These are reset during render to allow the DevTools commit hook a chance to read them,\n          const stateNode = workInProgress.stateNode;\n          stateNode.effectDuration = 0;\n          stateNode.passiveEffectDuration = 0;\n        }\n      }\n\n      break;\n\n    case SuspenseComponent:\n      {\n        const state = workInProgress.memoizedState;\n\n        if (state !== null) {\n          if (state.dehydrated !== null) {\n            // We're not going to render the children, so this is just to maintain\n            // push/pop symmetry\n            pushPrimaryTreeSuspenseHandler(workInProgress); // We know that this component will suspend again because if it has\n            // been unsuspended it has committed as a resolved Suspense component.\n            // If it needs to be retried, it should have work scheduled on it.\n\n            workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n            // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n\n            return null;\n          } // If this boundary is currently timed out, we need to decide\n          // whether to retry the primary children, or to skip over it and\n          // go straight to the fallback. Check the priority of the primary\n          // child fragment.\n\n\n          const primaryChildFragment = workInProgress.child;\n          const primaryChildLanes = primaryChildFragment.childLanes;\n\n          if (includesSomeLane(renderLanes, primaryChildLanes)) {\n            // The primary children have pending work. Use the normal path\n            // to attempt to render the primary children again.\n            return updateSuspenseComponent(current, workInProgress, renderLanes);\n          } else {\n            // The primary child fragment does not have pending work marked\n            // on it\n            pushPrimaryTreeSuspenseHandler(workInProgress); // The primary children do not have pending work with sufficient\n            // priority. Bailout.\n\n            const child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\n            if (child !== null) {\n              // The fallback children have pending work. Skip over the\n              // primary children and work on the fallback.\n              return child.sibling;\n            } else {\n              // Note: We can return `null` here because we already checked\n              // whether there were nested context consumers, via the call to\n              // `bailoutOnAlreadyFinishedWork` above.\n              return null;\n            }\n          }\n        } else {\n          pushPrimaryTreeSuspenseHandler(workInProgress);\n        }\n\n        break;\n      }\n\n    case SuspenseListComponent:\n      {\n        const didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n        let hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (enableLazyContextPropagation && !hasChildWork) {\n          // Context changes may not have been propagated yet. We need to do\n          // that now, before we can decide whether to bail out.\n          // TODO: We use `childLanes` as a heuristic for whether there is\n          // remaining work in a few places, including\n          // `bailoutOnAlreadyFinishedWork` and\n          // `updateDehydratedSuspenseComponent`. We should maybe extract this\n          // into a dedicated function.\n          lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n          hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n        }\n\n        if (didSuspendBefore) {\n          if (hasChildWork) {\n            // If something was in fallback state last time, and we have all the\n            // same children then we're still in progressive loading state.\n            // Something might get unblocked by state updates or retries in the\n            // tree which will affect the tail. So we need to use the normal\n            // path to compute the correct tail.\n            return updateSuspenseListComponent(current, workInProgress, renderLanes);\n          } // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n\n\n          workInProgress.flags |= DidCapture;\n        } // If nothing suspended before and we're rendering the same children,\n        // then the tail doesn't matter. Anything new that suspends will work\n        // in the \"together\" mode, so we can continue from the state we had.\n\n\n        const renderState = workInProgress.memoizedState;\n\n        if (renderState !== null) {\n          // Reset to the \"together\" mode in case we've started a different\n          // update in the past but didn't complete it.\n          renderState.rendering = null;\n          renderState.tail = null;\n          renderState.lastEffect = null;\n        }\n\n        pushSuspenseListContext(workInProgress, suspenseStackCursor.current);\n\n        if (hasChildWork) {\n          break;\n        } else {\n          // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n          return null;\n        }\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        // Need to check if the tree still needs to be deferred. This is\n        // almost identical to the logic used in the normal update path,\n        // so we'll just enter that. The only difference is we'll bail out\n        // at the next level instead of this one, because the child props\n        // have not changed. Which is fine.\n        // TODO: Probably should refactor `beginWork` to split the bailout\n        // path from the normal path. I'm tempted to do a labeled break here\n        // but I won't :)\n        workInProgress.lanes = NoLanes;\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          const cache = current.memoizedState.cache;\n          pushCacheProvider(workInProgress, cache);\n        }\n\n        break;\n      }\n\n    case TracingMarkerComponent:\n      {\n        if (enableTransitionTracing) {\n          const instance = workInProgress.stateNode;\n\n          if (instance !== null) {\n            pushMarkerInstance(workInProgress, instance);\n          }\n        }\n      }\n  }\n\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\n\nfunction beginWork(current, workInProgress, renderLanes) {\n  if (__DEV__) {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n    }\n  }\n\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (oldProps !== newProps || hasLegacyContextChanged() || (__DEV__ ? workInProgress.type !== current.type : false)) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n      if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n      // may not be work scheduled on `current`, so we check for this flag.\n      (workInProgress.flags & DidCapture) === NoFlags) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n      }\n\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n\n    if (getIsHydrating() && isForkedChild(workInProgress)) {\n      // Check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // In a true multi-threaded implementation, we would render children on\n      // parallel threads. This would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // We only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      const slotIndex = workInProgress.index;\n      const numberOfForks = getForksAtLevel(workInProgress);\n      pushTreeId(workInProgress, numberOfForks, slotIndex);\n    }\n  } // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n\n\n  workInProgress.lanes = NoLanes;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      {\n        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n      }\n\n    case LazyComponent:\n      {\n        const elementType = workInProgress.elementType;\n        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n      }\n\n    case FunctionComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case ClassComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateClassComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n\n    case HostResource:\n      if (enableFloat && supportsResources) {\n        return updateHostResource(current, workInProgress, renderLanes);\n      }\n\n    // eslint-disable-next-line no-fallthrough\n\n    case HostSingleton:\n      if (enableHostSingletons && supportsSingletons) {\n        return updateHostSingleton(current, workInProgress, renderLanes);\n      }\n\n    // eslint-disable-next-line no-fallthrough\n\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderLanes);\n\n    case HostText:\n      return updateHostText(current, workInProgress);\n\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n\n    case ForwardRef:\n      {\n        const type = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === type ? unresolvedProps : resolveDefaultProps(type, unresolvedProps);\n        return updateForwardRef(current, workInProgress, type, resolvedProps, renderLanes);\n      }\n\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n\n    case MemoComponent:\n      {\n        const type = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n\n        let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n\n        if (__DEV__) {\n          if (workInProgress.type !== workInProgress.elementType) {\n            const outerPropTypes = type.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentNameFromType(type));\n            }\n          }\n        }\n\n        resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n        return updateMemoComponent(current, workInProgress, type, resolvedProps, renderLanes);\n      }\n\n    case SimpleMemoComponent:\n      {\n        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n      }\n\n    case IncompleteClassComponent:\n      {\n        const Component = workInProgress.type;\n        const unresolvedProps = workInProgress.pendingProps;\n        const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return mountIncompleteClassComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case SuspenseListComponent:\n      {\n        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          return updateScopeComponent(current, workInProgress, renderLanes);\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n\n    case LegacyHiddenComponent:\n      {\n        if (enableLegacyHidden) {\n          return updateLegacyHiddenComponent(current, workInProgress, renderLanes);\n        }\n\n        break;\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          return updateCacheComponent(current, workInProgress, renderLanes);\n        }\n\n        break;\n      }\n\n    case TracingMarkerComponent:\n      {\n        if (enableTransitionTracing) {\n          return updateTracingMarkerComponent(current, workInProgress, renderLanes);\n        }\n\n        break;\n      }\n  }\n\n  throw new Error(`Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` + 'React. Please file an issue.');\n}\n\nexport { beginWork };","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberBeginWork.js"],"names":["OffscreenDetached","checkPropTypes","markComponentRenderStarted","markComponentRenderStopped","setIsStrictModeForDevtools","IndeterminateComponent","FunctionComponent","ClassComponent","HostRoot","HostComponent","HostResource","HostSingleton","HostText","HostPortal","ForwardRef","Fragment","Mode","ContextProvider","ContextConsumer","Profiler","SuspenseComponent","SuspenseListComponent","MemoComponent","SimpleMemoComponent","LazyComponent","IncompleteClassComponent","ScopeComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","TracingMarkerComponent","NoFlags","PerformedWork","Placement","Hydrating","ContentReset","DidCapture","Update","Ref","RefStatic","ChildDeletion","ForceUpdateForLegacySuspense","StaticMask","ShouldCapture","ForceClientRender","Passive","ReactSharedInternals","debugRenderPhaseSideEffectsForStrictMode","disableLegacyContext","disableModulePatternComponents","enableProfilerCommitHooks","enableProfilerTimer","warnAboutDefaultPropsOnFunctionComponents","enableScopeAPI","enableCache","enableLazyContextPropagation","enableSchedulingProfiler","enableTransitionTracing","enableLegacyHidden","enableCPUSuspense","enableUseMutableSource","enableFloat","enableHostSingletons","isArray","shallowEqual","getComponentNameFromFiber","getComponentNameFromType","ReactStrictModeWarnings","REACT_LAZY_TYPE","getIteratorFn","getCurrentFiberOwnerNameInDevOrNull","setIsRendering","resolveFunctionForHotReloading","resolveForwardRefForHotReloading","resolveClassForHotReloading","mountChildFibers","reconcileChildFibers","cloneChildFibers","processUpdateQueue","cloneUpdateQueue","initializeUpdateQueue","enqueueCapturedUpdate","NoLane","NoLanes","SyncLane","OffscreenLane","DefaultHydrationLane","SomeRetryLane","NoTimestamp","includesSomeLane","laneToLanes","removeLanes","mergeLanes","getBumpedLaneForHydration","pickArbitraryLane","ConcurrentMode","NoMode","ProfileMode","StrictLegacyMode","shouldSetTextContent","isSuspenseInstancePending","isSuspenseInstanceFallback","getSuspenseInstanceFallbackErrorDetails","registerSuspenseInstanceRetry","supportsHydration","supportsResources","supportsSingletons","isPrimaryRenderer","getResource","shouldError","shouldSuspend","pushHostContext","pushHostContainer","suspenseStackCursor","pushSuspenseListContext","ForceSuspenseFallback","hasSuspenseListContext","setDefaultShallowSuspenseListContext","setShallowSuspenseListContext","pushPrimaryTreeSuspenseHandler","pushFallbackTreeSuspenseHandler","pushOffscreenSuspenseHandler","reuseSuspenseHandlerOnStack","popSuspenseHandler","pushHiddenContext","reuseHiddenContextOnStack","findFirstSuspended","pushProvider","propagateContextChange","lazilyPropagateParentContextChanges","propagateParentContextChangesToDeferredTree","checkIfContextChanged","readContext","prepareToReadContext","scheduleContextWorkOnParentPath","renderWithHooks","checkDidRenderIdHook","bailoutHooks","replaySuspendedComponentWithHooks","stopProfilerTimerIfRunning","getMaskedContext","getUnmaskedContext","hasContextChanged","hasLegacyContextChanged","pushContextProvider","pushLegacyContextProvider","isContextProvider","isLegacyContextProvider","pushTopLevelContextObject","invalidateContextProvider","getIsHydrating","enterHydrationState","reenterHydrationStateFromDehydratedSuspenseInstance","resetHydrationState","claimHydratableSingleton","tryToClaimNextHydratableInstance","warnIfHydrating","queueHydrationError","adoptClassInstance","constructClassInstance","mountClassInstance","resumeMountClassInstance","updateClassInstance","resolveDefaultProps","resolveLazyComponentTag","createFiberFromTypeAndProps","createFiberFromFragment","createFiberFromOffscreen","createWorkInProgress","isSimpleFunctionComponent","retryDehydratedSuspenseBoundary","scheduleUpdateOnFiber","renderDidSuspendDelayIfPossible","markSkippedUpdateLanes","getWorkInProgressRoot","enqueueConcurrentRenderForLane","setWorkInProgressVersion","pushCacheProvider","CacheContext","createCapturedValue","createCapturedValueAtFiber","createClassErrorUpdate","is","getForksAtLevel","isForkedChild","pushTreeId","pushMaterializedTreeId","requestCacheFromPool","pushRootTransition","getSuspendedCache","pushTransition","getOffscreenDeferredCache","getPendingTransitions","getMarkerInstances","pushMarkerInstance","pushRootMarkerInstance","TransitionTracingMarker","ReactCurrentOwner","SelectiveHydrationException","Error","didReceiveUpdate","didWarnAboutBadClass","didWarnAboutModulePatternComponent","didWarnAboutContextTypeOnFunctionComponent","didWarnAboutGetDerivedStateOnFunctionComponent","didWarnAboutFunctionRefs","didWarnAboutReassigningProps","didWarnAboutRevealOrder","didWarnAboutTailOptions","didWarnAboutDefaultPropsOnFunctionComponent","__DEV__","reconcileChildren","current","workInProgress","nextChildren","renderLanes","child","forceUnmountCurrentAndReconcile","updateForwardRef","Component","nextProps","type","elementType","innerPropTypes","propTypes","render","ref","hasId","bailoutOnAlreadyFinishedWork","flags","updateMemoComponent","compare","defaultProps","undefined","resolvedType","tag","validateFunctionComponentInDev","updateSimpleMemoComponent","componentName","console","error","mode","return","currentChild","hasScheduledUpdateOrContext","checkScheduledUpdateOrContext","prevProps","memoizedProps","newChild","outerMemoType","$$typeof","lazyComponent","payload","_payload","init","_init","x","outerPropTypes","pendingProps","lanes","updateFunctionComponent","updateOffscreenComponent","children","nextIsDetached","stateNode","_pendingVisibility","prevState","memoizedState","markRef","didSuspend","nextBaseLanes","baseLanes","currentChildLanes","childLanes","sibling","lanesWeJustAttempted","remainingChildLanes","deferHiddenOffscreenComponent","nextState","cachePool","prevCachePool","transitions","instance","_transitions","Array","from","updateLegacyHiddenComponent","updateCacheComponent","parentCache","freshCache","initialState","parent","cache","derivedState","updateQueue","baseState","nextCache","updateTracingMarkerComponent","currentTransitions","markerInstance","Set","pendingBoundaries","name","aborts","updateFragment","updateMode","updateProfiler","effectDuration","passiveEffectDuration","context","unmaskedContext","replayFunctionComponent","updateClassComponent","ctor","tempInstance","state","updater","enqueueSetState","lane","update","hasContext","shouldUpdate","resetSuspendedCurrentOnMountInLegacyMode","nextUnitOfWork","finishClassComponent","inst","props","didCaptureError","getDerivedStateFromError","pushHostRootContext","root","pendingContext","containerInfo","updateHostRoot","prevChildren","element","isDehydrated","overrideState","recoverableError","mountHostRootWithoutHydrating","mutableSourceEagerHydrationData","i","length","mutableSource","version","node","updateHostComponent","isDirectTextChild","updateHostResource","currentProps","updateHostSingleton","updateHostText","mountLazyComponent","_current","resolvedTag","resolvedProps","hint","mountIncompleteClassComponent","mountIndeterminateComponent","value","prototype","recordLegacyContextWarning","contextTypes","childContextTypes","displayName","info","ownerName","warningKey","debugSource","_debugSource","fileName","lineNumber","getDerivedStateFromProps","contextType","SUSPENDED_MARKER","dehydrated","treeContext","retryLane","mountSuspenseOffscreenState","updateSuspenseOffscreenState","prevOffscreenState","_currentValue","_currentValue2","pool","shouldRemainOnFallback","suspenseState","suspenseContext","getRemainingWorkInPrimaryTree","updateSuspenseComponent","showFallback","mountDehydratedSuspenseComponent","nextPrimaryChildren","nextFallbackChildren","fallback","fallbackFragment","mountSuspenseFallbackChildren","primaryChildFragment","parentMarkerInstances","offscreenQueue","newOffscreenQueue","markerInstances","wakeables","unstable_expectedLoadTime","mountSuspensePrimaryChildren","updateDehydratedSuspenseComponent","fallbackChildFragment","updateSuspenseFallbackChildren","currentOffscreenQueue","updateSuspensePrimaryChildren","primaryChildren","primaryChildProps","mountWorkInProgressOffscreenFiber","fallbackChildren","progressedPrimaryFragment","actualDuration","actualStartTime","selfBaseDuration","treeBaseDuration","offscreenProps","updateWorkInProgressOffscreenFiber","currentPrimaryChildFragment","currentFallbackChildFragment","deletions","push","subtreeFlags","retrySuspenseComponentWithoutHydrating","mountSuspenseFallbackAfterRetryWithoutHydrating","fiberMode","suspenseInstance","digest","message","stack","capturedValue","attemptHydrationAtLane","eventTime","retry","bind","scheduleSuspenseWorkOnFiber","fiber","propagationRoot","alternate","propagateSuspenseContextChange","firstChild","findLastContentRow","row","lastContentRow","currentRow","validateRevealOrder","revealOrder","toLowerCase","validateTailOptions","tailMode","validateSuspenseListNestedChild","childSlot","index","isAnArray","isIterable","validateSuspenseListChildren","iteratorFn","childrenIterator","call","step","next","done","initSuspenseListRenderState","isBackwards","tail","renderState","rendering","renderingStartTime","last","updateSuspenseListComponent","newChildren","shouldForceFallback","didSuspendBefore","nextRow","updatePortalComponent","hasWarnedAboutUsingNoValuePropOnContextProvider","updateContextProvider","providerType","_context","newProps","oldProps","newValue","providerPropTypes","oldValue","hasWarnedAboutUsingContextAsConsumer","updateContextConsumer","Consumer","updateScopeComponent","markWorkInProgressReceivedUpdate","checkIfWorkInProgressReceivedUpdate","dependencies","remountFiber","oldWorkInProgress","newWorkInProgress","returnFiber","prevSibling","updateLanes","attemptEarlyBailoutIfNoScheduledUpdate","hasChildWork","primaryChildLanes","lastEffect","beginWork","_debugNeedsRemount","key","_debugOwner","slotIndex","numberOfForks","unresolvedProps"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  ReactProviderType,\n  ReactContext,\n  ReactNodeList,\n  MutableSource,\n} from 'shared/ReactTypes';\nimport type {LazyComponent as LazyComponentType} from 'react/src/ReactLazy';\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {TypeOfMode} from './ReactTypeOfMode';\nimport type {Lanes, Lane} from './ReactFiberLane';\nimport type {\n  SuspenseState,\n  SuspenseListRenderState,\n  SuspenseListTailMode,\n} from './ReactFiberSuspenseComponent';\nimport type {SuspenseContext} from './ReactFiberSuspenseContext';\nimport type {\n  OffscreenProps,\n  OffscreenState,\n  OffscreenQueue,\n  OffscreenInstance,\n} from './ReactFiberOffscreenComponent';\nimport {OffscreenDetached} from './ReactFiberOffscreenComponent';\nimport type {\n  Cache,\n  CacheComponentState,\n  SpawnedCachePool,\n} from './ReactFiberCacheComponent';\nimport type {UpdateQueue} from './ReactFiberClassUpdateQueue';\nimport type {RootState} from './ReactFiberRoot';\nimport type {TracingMarkerInstance} from './ReactFiberTracingMarkerComponent';\n\nimport checkPropTypes from 'shared/checkPropTypes';\nimport {\n  markComponentRenderStarted,\n  markComponentRenderStopped,\n  setIsStrictModeForDevtools,\n} from './ReactFiberDevToolsHook';\nimport {\n  IndeterminateComponent,\n  FunctionComponent,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostResource,\n  HostSingleton,\n  HostText,\n  HostPortal,\n  ForwardRef,\n  Fragment,\n  Mode,\n  ContextProvider,\n  ContextConsumer,\n  Profiler,\n  SuspenseComponent,\n  SuspenseListComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  LazyComponent,\n  IncompleteClassComponent,\n  ScopeComponent,\n  OffscreenComponent,\n  LegacyHiddenComponent,\n  CacheComponent,\n  TracingMarkerComponent,\n} from './ReactWorkTags';\nimport {\n  NoFlags,\n  PerformedWork,\n  Placement,\n  Hydrating,\n  ContentReset,\n  DidCapture,\n  Update,\n  Ref,\n  RefStatic,\n  ChildDeletion,\n  ForceUpdateForLegacySuspense,\n  StaticMask,\n  ShouldCapture,\n  ForceClientRender,\n  Passive,\n} from './ReactFiberFlags';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {\n  debugRenderPhaseSideEffectsForStrictMode,\n  disableLegacyContext,\n  disableModulePatternComponents,\n  enableProfilerCommitHooks,\n  enableProfilerTimer,\n  warnAboutDefaultPropsOnFunctionComponents,\n  enableScopeAPI,\n  enableCache,\n  enableLazyContextPropagation,\n  enableSchedulingProfiler,\n  enableTransitionTracing,\n  enableLegacyHidden,\n  enableCPUSuspense,\n  enableUseMutableSource,\n  enableFloat,\n  enableHostSingletons,\n} from 'shared/ReactFeatureFlags';\nimport isArray from 'shared/isArray';\nimport shallowEqual from 'shared/shallowEqual';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactStrictModeWarnings from './ReactStrictModeWarnings';\nimport {REACT_LAZY_TYPE, getIteratorFn} from 'shared/ReactSymbols';\nimport {\n  getCurrentFiberOwnerNameInDevOrNull,\n  setIsRendering,\n} from './ReactCurrentFiber';\nimport {\n  resolveFunctionForHotReloading,\n  resolveForwardRefForHotReloading,\n  resolveClassForHotReloading,\n} from './ReactFiberHotReloading';\n\nimport {\n  mountChildFibers,\n  reconcileChildFibers,\n  cloneChildFibers,\n} from './ReactChildFiber';\nimport {\n  processUpdateQueue,\n  cloneUpdateQueue,\n  initializeUpdateQueue,\n  enqueueCapturedUpdate,\n} from './ReactFiberClassUpdateQueue';\nimport {\n  NoLane,\n  NoLanes,\n  SyncLane,\n  OffscreenLane,\n  DefaultHydrationLane,\n  SomeRetryLane,\n  NoTimestamp,\n  includesSomeLane,\n  laneToLanes,\n  removeLanes,\n  mergeLanes,\n  getBumpedLaneForHydration,\n  pickArbitraryLane,\n} from './ReactFiberLane';\nimport {\n  ConcurrentMode,\n  NoMode,\n  ProfileMode,\n  StrictLegacyMode,\n} from './ReactTypeOfMode';\nimport {\n  shouldSetTextContent,\n  isSuspenseInstancePending,\n  isSuspenseInstanceFallback,\n  getSuspenseInstanceFallbackErrorDetails,\n  registerSuspenseInstanceRetry,\n  supportsHydration,\n  supportsResources,\n  supportsSingletons,\n  isPrimaryRenderer,\n  getResource,\n} from './ReactFiberHostConfig';\nimport type {SuspenseInstance} from './ReactFiberHostConfig';\nimport {shouldError, shouldSuspend} from './ReactFiberReconciler';\nimport {pushHostContext, pushHostContainer} from './ReactFiberHostContext';\nimport {\n  suspenseStackCursor,\n  pushSuspenseListContext,\n  ForceSuspenseFallback,\n  hasSuspenseListContext,\n  setDefaultShallowSuspenseListContext,\n  setShallowSuspenseListContext,\n  pushPrimaryTreeSuspenseHandler,\n  pushFallbackTreeSuspenseHandler,\n  pushOffscreenSuspenseHandler,\n  reuseSuspenseHandlerOnStack,\n  popSuspenseHandler,\n} from './ReactFiberSuspenseContext';\nimport {\n  pushHiddenContext,\n  reuseHiddenContextOnStack,\n} from './ReactFiberHiddenContext';\nimport {findFirstSuspended} from './ReactFiberSuspenseComponent';\nimport {\n  pushProvider,\n  propagateContextChange,\n  lazilyPropagateParentContextChanges,\n  propagateParentContextChangesToDeferredTree,\n  checkIfContextChanged,\n  readContext,\n  prepareToReadContext,\n  scheduleContextWorkOnParentPath,\n} from './ReactFiberNewContext';\nimport {\n  renderWithHooks,\n  checkDidRenderIdHook,\n  bailoutHooks,\n  replaySuspendedComponentWithHooks,\n} from './ReactFiberHooks';\nimport {stopProfilerTimerIfRunning} from './ReactProfilerTimer';\nimport {\n  getMaskedContext,\n  getUnmaskedContext,\n  hasContextChanged as hasLegacyContextChanged,\n  pushContextProvider as pushLegacyContextProvider,\n  isContextProvider as isLegacyContextProvider,\n  pushTopLevelContextObject,\n  invalidateContextProvider,\n} from './ReactFiberContext';\nimport {\n  getIsHydrating,\n  enterHydrationState,\n  reenterHydrationStateFromDehydratedSuspenseInstance,\n  resetHydrationState,\n  claimHydratableSingleton,\n  tryToClaimNextHydratableInstance,\n  warnIfHydrating,\n  queueHydrationError,\n} from './ReactFiberHydrationContext';\nimport {\n  adoptClassInstance,\n  constructClassInstance,\n  mountClassInstance,\n  resumeMountClassInstance,\n  updateClassInstance,\n} from './ReactFiberClassComponent';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent';\nimport {\n  resolveLazyComponentTag,\n  createFiberFromTypeAndProps,\n  createFiberFromFragment,\n  createFiberFromOffscreen,\n  createWorkInProgress,\n  isSimpleFunctionComponent,\n} from './ReactFiber';\nimport {\n  retryDehydratedSuspenseBoundary,\n  scheduleUpdateOnFiber,\n  renderDidSuspendDelayIfPossible,\n  markSkippedUpdateLanes,\n  getWorkInProgressRoot,\n} from './ReactFiberWorkLoop';\nimport {enqueueConcurrentRenderForLane} from './ReactFiberConcurrentUpdates';\nimport {setWorkInProgressVersion} from './ReactMutableSource';\nimport {pushCacheProvider, CacheContext} from './ReactFiberCacheComponent';\nimport {\n  createCapturedValue,\n  createCapturedValueAtFiber,\n  type CapturedValue,\n} from './ReactCapturedValue';\nimport {createClassErrorUpdate} from './ReactFiberThrow';\nimport is from 'shared/objectIs';\nimport {\n  getForksAtLevel,\n  isForkedChild,\n  pushTreeId,\n  pushMaterializedTreeId,\n} from './ReactFiberTreeContext';\nimport {\n  requestCacheFromPool,\n  pushRootTransition,\n  getSuspendedCache,\n  pushTransition,\n  getOffscreenDeferredCache,\n  getPendingTransitions,\n} from './ReactFiberTransition';\nimport {\n  getMarkerInstances,\n  pushMarkerInstance,\n  pushRootMarkerInstance,\n  TransitionTracingMarker,\n} from './ReactFiberTracingMarkerComponent';\n\nconst ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\n// A special exception that's used to unwind the stack when an update flows\n// into a dehydrated boundary.\nexport const SelectiveHydrationException: mixed = new Error(\n  \"This is not a real error. It's an implementation detail of React's \" +\n    \"selective hydration feature. If this leaks into userspace, it's a bug in \" +\n    'React. Please file an issue.',\n);\n\nlet didReceiveUpdate: boolean = false;\n\nlet didWarnAboutBadClass;\nlet didWarnAboutModulePatternComponent;\nlet didWarnAboutContextTypeOnFunctionComponent;\nlet didWarnAboutGetDerivedStateOnFunctionComponent;\nlet didWarnAboutFunctionRefs;\nexport let didWarnAboutReassigningProps: boolean;\nlet didWarnAboutRevealOrder;\nlet didWarnAboutTailOptions;\nlet didWarnAboutDefaultPropsOnFunctionComponent;\n\nif (__DEV__) {\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n  didWarnAboutDefaultPropsOnFunctionComponent = {};\n}\n\nexport function reconcileChildren(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderLanes: Lanes,\n) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderLanes,\n    );\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(\n  current: Fiber,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderLanes: Lanes,\n) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(\n    workInProgress,\n    current.child,\n    null,\n    renderLanes,\n  );\n  // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their\n  // identities match.\n  workInProgress.child = reconcileChildFibers(\n    workInProgress,\n    null,\n    nextChildren,\n    renderLanes,\n  );\n}\n\nfunction updateForwardRef(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentNameFromType(Component),\n        );\n      }\n    }\n  }\n\n  const render = Component.render;\n  const ref = workInProgress.ref;\n\n  // The rest is a fork of updateFunctionComponent\n  let nextChildren;\n  let hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      render,\n      nextProps,\n      ref,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      render,\n      nextProps,\n      ref,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n  }\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n): null | Fiber {\n  if (current === null) {\n    const type = Component.type;\n    if (\n      isSimpleFunctionComponent(type) &&\n      Component.compare === null &&\n      // SimpleMemoComponent codepath doesn't resolve outer props either.\n      Component.defaultProps === undefined\n    ) {\n      let resolvedType = type;\n      if (__DEV__) {\n        resolvedType = resolveFunctionForHotReloading(type);\n      }\n      // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        resolvedType,\n        nextProps,\n        renderLanes,\n      );\n    }\n    if (__DEV__) {\n      const innerPropTypes = type.propTypes;\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentNameFromType(type),\n        );\n      }\n      if (\n        warnAboutDefaultPropsOnFunctionComponents &&\n        Component.defaultProps !== undefined\n      ) {\n        const componentName = getComponentNameFromType(type) || 'Unknown';\n        if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n          console.error(\n            '%s: Support for defaultProps will be removed from memo components ' +\n              'in a future major release. Use JavaScript default parameters instead.',\n            componentName,\n          );\n          didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n        }\n      }\n    }\n    const child = createFiberFromTypeAndProps(\n      Component.type,\n      null,\n      nextProps,\n      workInProgress,\n      workInProgress.mode,\n      renderLanes,\n    );\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n  if (__DEV__) {\n    const type = Component.type;\n    const innerPropTypes = type.propTypes;\n    if (innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(\n        innerPropTypes,\n        nextProps, // Resolved props\n        'prop',\n        getComponentNameFromType(type),\n      );\n    }\n  }\n  const currentChild = ((current.child: any): Fiber); // This is always exactly one child\n  const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(\n    current,\n    renderLanes,\n  );\n  if (!hasScheduledUpdateOrContext) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    const prevProps = currentChild.memoizedProps;\n    // Default to shallow comparison\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n  }\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  const newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n): null | Fiber {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      let outerMemoType = workInProgress.elementType;\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        const lazyComponent: LazyComponentType<any, any> = outerMemoType;\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          outerMemoType = init(payload);\n        } catch (x) {\n          // $FlowFixMe[incompatible-type] found when upgrading Flow\n          outerMemoType = null;\n        }\n        // Inner propTypes will be validated in the function component path.\n        const outerPropTypes = outerMemoType && (outerMemoType: any).propTypes;\n        if (outerPropTypes) {\n          checkPropTypes(\n            outerPropTypes,\n            nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n            'prop',\n            getComponentNameFromType(outerMemoType),\n          );\n        }\n      }\n    }\n  }\n  if (current !== null) {\n    const prevProps = current.memoizedProps;\n    if (\n      shallowEqual(prevProps, nextProps) &&\n      current.ref === workInProgress.ref &&\n      // Prevent bailout if the implementation changed due to hot reload.\n      (__DEV__ ? workInProgress.type === current.type : true)\n    ) {\n      didReceiveUpdate = false;\n\n      // The props are shallowly equal. Reuse the previous props object, like we\n      // would during a normal fiber bailout.\n      //\n      // We don't have strong guarantees that the props object is referentially\n      // equal during updates where we can't bail out anyway â€” like if the props\n      // are shallowly equal, but there's a local state or context update in the\n      // same batch.\n      //\n      // However, as a principle, we should aim to make the behavior consistent\n      // across different ways of memoizing a component. For example, React.memo\n      // has a different internal Fiber layout if you pass a normal function\n      // component (SimpleMemoComponent) versus if you pass a different type\n      // like forwardRef (MemoComponent). But this is an implementation detail.\n      // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n      // affect whether the props object is reused during a bailout.\n      workInProgress.pendingProps = nextProps = prevProps;\n\n      if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n        // The pending lanes were cleared at the beginning of beginWork. We're\n        // about to bail out, but there might be other lanes that weren't\n        // included in the current render. Usually, the priority level of the\n        // remaining updates is accumulated during the evaluation of the\n        // component (i.e. when processing the update queue). But since since\n        // we're bailing out early *without* evaluating the component, we need\n        // to account for it here, too. Reset to the value of the current fiber.\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n        // because a MemoComponent fiber does not have hooks or an update queue;\n        // rather, it wraps around an inner component, which may or may not\n        // contains hooks.\n        // TODO: Move the reset at in beginWork out of the common path so that\n        // this is no longer necessary.\n        workInProgress.lanes = current.lanes;\n        return bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      }\n    }\n  }\n  return updateFunctionComponent(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    renderLanes,\n  );\n}\n\nfunction updateOffscreenComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  const nextProps: OffscreenProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  const nextIsDetached =\n    (workInProgress.stateNode._pendingVisibility & OffscreenDetached) !== 0;\n\n  const prevState: OffscreenState | null =\n    current !== null ? current.memoizedState : null;\n\n  markRef(current, workInProgress);\n\n  if (\n    nextProps.mode === 'hidden' ||\n    (enableLegacyHidden &&\n      nextProps.mode === 'unstable-defer-without-hiding') ||\n    nextIsDetached\n  ) {\n    // Rendering a hidden tree.\n\n    const didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n    if (didSuspend) {\n      // Something suspended inside a hidden tree\n\n      // Include the base lanes from the last render\n      const nextBaseLanes =\n        prevState !== null\n          ? mergeLanes(prevState.baseLanes, renderLanes)\n          : renderLanes;\n\n      if (current !== null) {\n        // Reset to the current children\n        let currentChild = (workInProgress.child = current.child);\n\n        // The current render suspended, but there may be other lanes with\n        // pending work. We can't read `childLanes` from the current Offscreen\n        // fiber because we reset it when it was deferred; however, we can read\n        // the pending lanes from the child fibers.\n        let currentChildLanes = NoLanes;\n        while (currentChild !== null) {\n          currentChildLanes = mergeLanes(\n            mergeLanes(currentChildLanes, currentChild.lanes),\n            currentChild.childLanes,\n          );\n          currentChild = currentChild.sibling;\n        }\n        const lanesWeJustAttempted = nextBaseLanes;\n        const remainingChildLanes = removeLanes(\n          currentChildLanes,\n          lanesWeJustAttempted,\n        );\n        workInProgress.childLanes = remainingChildLanes;\n      } else {\n        workInProgress.childLanes = NoLanes;\n        workInProgress.child = null;\n      }\n\n      return deferHiddenOffscreenComponent(\n        current,\n        workInProgress,\n        nextBaseLanes,\n        renderLanes,\n      );\n    }\n\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      // In legacy sync mode, don't defer the subtree. Render it now.\n      // TODO: Consider how Offscreen should work with transitions in the future\n      const nextState: OffscreenState = {\n        baseLanes: NoLanes,\n        cachePool: null,\n      };\n      workInProgress.memoizedState = nextState;\n      if (enableCache) {\n        // push the cache pool even though we're going to bail out\n        // because otherwise there'd be a context mismatch\n        if (current !== null) {\n          pushTransition(workInProgress, null, null);\n        }\n      }\n      reuseHiddenContextOnStack(workInProgress);\n      pushOffscreenSuspenseHandler(workInProgress);\n    } else if (!includesSomeLane(renderLanes, (OffscreenLane: Lane))) {\n      // We're hidden, and we're not rendering at Offscreen. We will bail out\n      // and resume this tree later.\n\n      // Schedule this fiber to re-render at Offscreen priority\n      workInProgress.lanes = workInProgress.childLanes = laneToLanes(\n        OffscreenLane,\n      );\n\n      // Include the base lanes from the last render\n      const nextBaseLanes =\n        prevState !== null\n          ? mergeLanes(prevState.baseLanes, renderLanes)\n          : renderLanes;\n\n      return deferHiddenOffscreenComponent(\n        current,\n        workInProgress,\n        nextBaseLanes,\n        renderLanes,\n      );\n    } else {\n      // This is the second render. The surrounding visible content has already\n      // committed. Now we resume rendering the hidden tree.\n\n      // Rendering at offscreen, so we can clear the base lanes.\n      const nextState: OffscreenState = {\n        baseLanes: NoLanes,\n        cachePool: null,\n      };\n      workInProgress.memoizedState = nextState;\n      if (enableCache && current !== null) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        const prevCachePool = prevState !== null ? prevState.cachePool : null;\n        // TODO: Consider if and how Offscreen pre-rendering should\n        // be attributed to the transition that spawned it\n        pushTransition(workInProgress, prevCachePool, null);\n      }\n\n      // Push the lanes that were skipped when we bailed out.\n      if (prevState !== null) {\n        pushHiddenContext(workInProgress, prevState);\n      } else {\n        reuseHiddenContextOnStack(workInProgress);\n      }\n      pushOffscreenSuspenseHandler(workInProgress);\n    }\n  } else {\n    // Rendering a visible tree.\n    if (prevState !== null) {\n      // We're going from hidden -> visible.\n      let prevCachePool = null;\n      if (enableCache) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        prevCachePool = prevState.cachePool;\n      }\n\n      let transitions = null;\n      if (enableTransitionTracing) {\n        // We have now gone from hidden to visible, so any transitions should\n        // be added to the stack to get added to any Offscreen/suspense children\n        const instance: OffscreenInstance | null = workInProgress.stateNode;\n        if (instance !== null && instance._transitions != null) {\n          transitions = Array.from(instance._transitions);\n        }\n      }\n\n      pushTransition(workInProgress, prevCachePool, transitions);\n\n      // Push the lanes that were skipped when we bailed out.\n      pushHiddenContext(workInProgress, prevState);\n      reuseSuspenseHandlerOnStack(workInProgress);\n\n      // Since we're not hidden anymore, reset the state\n      workInProgress.memoizedState = null;\n    } else {\n      // We weren't previously hidden, and we still aren't, so there's nothing\n      // special to do. Need to push to the stack regardless, though, to avoid\n      // a push/pop misalignment.\n\n      if (enableCache) {\n        // If the render that spawned this one accessed the cache pool, resume\n        // using the same cache. Unless the parent changed, since that means\n        // there was a refresh.\n        if (current !== null) {\n          pushTransition(workInProgress, null, null);\n        }\n      }\n\n      // We're about to bail out, but we need to push this to the stack anyway\n      // to avoid a push/pop misalignment.\n      reuseHiddenContextOnStack(workInProgress);\n      reuseSuspenseHandlerOnStack(workInProgress);\n    }\n  }\n\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction deferHiddenOffscreenComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextBaseLanes: Lanes,\n  renderLanes: Lanes,\n) {\n  const nextState: OffscreenState = {\n    baseLanes: nextBaseLanes,\n    // Save the cache pool so we can resume later.\n    cachePool: enableCache ? getOffscreenDeferredCache() : null,\n  };\n  workInProgress.memoizedState = nextState;\n  if (enableCache) {\n    // push the cache pool even though we're going to bail out\n    // because otherwise there'd be a context mismatch\n    if (current !== null) {\n      pushTransition(workInProgress, null, null);\n    }\n  }\n\n  // We're about to bail out, but we need to push this to the stack anyway\n  // to avoid a push/pop misalignment.\n  reuseHiddenContextOnStack(workInProgress);\n\n  pushOffscreenSuspenseHandler(workInProgress);\n\n  if (enableLazyContextPropagation && current !== null) {\n    // Since this tree will resume rendering in a separate render, we need\n    // to propagate parent contexts now so we don't lose track of which\n    // ones changed.\n    propagateParentContextChangesToDeferredTree(\n      current,\n      workInProgress,\n      renderLanes,\n    );\n  }\n\n  return null;\n}\n\n// Note: These happen to have identical begin phases, for now. We shouldn't hold\n// ourselves to this constraint, though. If the behavior diverges, we should\n// fork the function.\nconst updateLegacyHiddenComponent = updateOffscreenComponent;\n\nfunction updateCacheComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  if (!enableCache) {\n    return null;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const parentCache = readContext(CacheContext);\n\n  if (current === null) {\n    // Initial mount. Request a fresh cache from the pool.\n    const freshCache = requestCacheFromPool(renderLanes);\n    const initialState: CacheComponentState = {\n      parent: parentCache,\n      cache: freshCache,\n    };\n    workInProgress.memoizedState = initialState;\n    initializeUpdateQueue(workInProgress);\n    pushCacheProvider(workInProgress, freshCache);\n  } else {\n    // Check for updates\n    if (includesSomeLane(current.lanes, renderLanes)) {\n      cloneUpdateQueue(current, workInProgress);\n      processUpdateQueue(workInProgress, null, null, renderLanes);\n    }\n    const prevState: CacheComponentState = current.memoizedState;\n    const nextState: CacheComponentState = workInProgress.memoizedState;\n\n    // Compare the new parent cache to the previous to see detect there was\n    // a refresh.\n    if (prevState.parent !== parentCache) {\n      // Refresh in parent. Update the parent.\n      const derivedState: CacheComponentState = {\n        parent: parentCache,\n        cache: parentCache,\n      };\n\n      // Copied from getDerivedStateFromProps implementation. Once the update\n      // queue is empty, persist the derived state onto the base state.\n      workInProgress.memoizedState = derivedState;\n      if (workInProgress.lanes === NoLanes) {\n        const updateQueue: UpdateQueue<any> = (workInProgress.updateQueue: any);\n        workInProgress.memoizedState = updateQueue.baseState = derivedState;\n      }\n\n      pushCacheProvider(workInProgress, parentCache);\n      // No need to propagate a context change because the refreshed parent\n      // already did.\n    } else {\n      // The parent didn't refresh. Now check if this cache did.\n      const nextCache = nextState.cache;\n      pushCacheProvider(workInProgress, nextCache);\n      if (nextCache !== prevState.cache) {\n        // This cache refreshed. Propagate a context change.\n        propagateContextChange(workInProgress, CacheContext, renderLanes);\n      }\n    }\n  }\n\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\n// This should only be called if the name changes\nfunction updateTracingMarkerComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  if (!enableTransitionTracing) {\n    return null;\n  }\n\n  // TODO: (luna) Only update the tracing marker if it's newly rendered or it's name changed.\n  // A tracing marker is only associated with the transitions that rendered\n  // or updated it, so we can create a new set of transitions each time\n  if (current === null) {\n    const currentTransitions = getPendingTransitions();\n    if (currentTransitions !== null) {\n      const markerInstance: TracingMarkerInstance = {\n        tag: TransitionTracingMarker,\n        transitions: new Set(currentTransitions),\n        pendingBoundaries: null,\n        name: workInProgress.pendingProps.name,\n        aborts: null,\n      };\n      workInProgress.stateNode = markerInstance;\n\n      // We call the marker complete callback when all child suspense boundaries resolve.\n      // We do this in the commit phase on Offscreen. If the marker has no child suspense\n      // boundaries, we need to schedule a passive effect to make sure we call the marker\n      // complete callback.\n      workInProgress.flags |= Passive;\n    }\n  } else {\n    if (__DEV__) {\n      if (current.memoizedProps.name !== workInProgress.pendingProps.name) {\n        console.error(\n          'Changing the name of a tracing marker after mount is not supported. ' +\n            'To remount the tracing marker, pass it a new key.',\n        );\n      }\n    }\n  }\n\n  const instance: TracingMarkerInstance | null = workInProgress.stateNode;\n  if (instance !== null) {\n    pushMarkerInstance(workInProgress, instance);\n  }\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateFragment(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  const nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMode(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  const nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  if (enableProfilerTimer) {\n    workInProgress.flags |= Update;\n\n    if (enableProfilerCommitHooks) {\n      // Reset effect durations for the next eventual effect phase.\n      // These are reset during render to allow the DevTools commit hook a chance to read them,\n      const stateNode = workInProgress.stateNode;\n      stateNode.effectDuration = 0;\n      stateNode.passiveEffectDuration = 0;\n    }\n  }\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markRef(current: Fiber | null, workInProgress: Fiber) {\n  const ref = workInProgress.ref;\n  if (\n    (current === null && ref !== null) ||\n    (current !== null && current.ref !== ref)\n  ) {\n    // Schedule a Ref effect\n    workInProgress.flags |= Ref;\n    workInProgress.flags |= RefStatic;\n  }\n}\n\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps: any,\n  renderLanes,\n) {\n  if (__DEV__) {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentNameFromType(Component),\n        );\n      }\n    }\n  }\n\n  let context;\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  let nextChildren;\n  let hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      context,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  } else {\n    nextChildren = renderWithHooks(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      context,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n  }\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nexport function replayFunctionComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextProps: any,\n  Component: any,\n  renderLanes: Lanes,\n): Fiber | null {\n  // This function is used to replay a component that previously suspended,\n  // after its data resolves. It's a simplified version of\n  // updateFunctionComponent that reuses the hooks from the previous attempt.\n\n  let context;\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n  const nextChildren = replaySuspendedComponentWithHooks(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    context,\n  );\n  const hasId = checkDidRenderIdHook();\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n) {\n  if (__DEV__) {\n    // This is used by DevTools to force a boundary to error.\n    switch (shouldError(workInProgress)) {\n      case false: {\n        const instance = workInProgress.stateNode;\n        const ctor = workInProgress.type;\n        // TODO This way of resetting the error boundary state is a hack.\n        // Is there a better way to do this?\n        const tempInstance = new ctor(\n          workInProgress.memoizedProps,\n          instance.context,\n        );\n        const state = tempInstance.state;\n        instance.updater.enqueueSetState(instance, state, null);\n        break;\n      }\n      case true: {\n        workInProgress.flags |= DidCapture;\n        workInProgress.flags |= ShouldCapture;\n        // eslint-disable-next-line react-internal/prod-error-codes\n        const error = new Error('Simulated error coming from DevTools');\n        const lane = pickArbitraryLane(renderLanes);\n        workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n        // Schedule the error boundary to re-render using updated state\n        const update = createClassErrorUpdate(\n          workInProgress,\n          createCapturedValueAtFiber(error, workInProgress),\n          lane,\n        );\n        enqueueCapturedUpdate(workInProgress, update);\n        break;\n      }\n    }\n\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      const innerPropTypes = Component.propTypes;\n      if (innerPropTypes) {\n        checkPropTypes(\n          innerPropTypes,\n          nextProps, // Resolved props\n          'prop',\n          getComponentNameFromType(Component),\n        );\n      }\n    }\n  }\n\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  let hasContext;\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderLanes);\n\n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n  if (instance === null) {\n    resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);\n\n    // In the initial pass we might need to construct the instance.\n    constructClassInstance(workInProgress, Component, nextProps);\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(\n      workInProgress,\n      Component,\n      nextProps,\n      renderLanes,\n    );\n  } else {\n    shouldUpdate = updateClassInstance(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      renderLanes,\n    );\n  }\n  const nextUnitOfWork = finishClassComponent(\n    current,\n    workInProgress,\n    Component,\n    shouldUpdate,\n    hasContext,\n    renderLanes,\n  );\n  if (__DEV__) {\n    const inst = workInProgress.stateNode;\n    if (shouldUpdate && inst.props !== nextProps) {\n      if (!didWarnAboutReassigningProps) {\n        console.error(\n          'It looks like %s is reassigning its own `this.props` while rendering. ' +\n            'This is not supported and can lead to confusing bugs.',\n          getComponentNameFromFiber(workInProgress) || 'a component',\n        );\n      }\n      didWarnAboutReassigningProps = true;\n    }\n  }\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  shouldUpdate: boolean,\n  hasContext: boolean,\n  renderLanes: Lanes,\n) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current, workInProgress);\n\n  const didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  const instance = workInProgress.stateNode;\n\n  // Rerender\n  ReactCurrentOwner.current = workInProgress;\n  let nextChildren;\n  if (\n    didCaptureError &&\n    typeof Component.getDerivedStateFromError !== 'function'\n  ) {\n    // If we captured an error, but getDerivedStateFromError is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    if (enableSchedulingProfiler) {\n      markComponentRenderStarted(workInProgress);\n    }\n    if (__DEV__) {\n      setIsRendering(true);\n      nextChildren = instance.render();\n      if (\n        debugRenderPhaseSideEffectsForStrictMode &&\n        workInProgress.mode & StrictLegacyMode\n      ) {\n        setIsStrictModeForDevtools(true);\n        try {\n          instance.render();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n      setIsRendering(false);\n    } else {\n      nextChildren = instance.render();\n    }\n    if (enableSchedulingProfiler) {\n      markComponentRenderStopped();\n    }\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(\n      current,\n      workInProgress,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n  workInProgress.memoizedState = instance.state;\n\n  // The context might have changed so we need to recalculate it.\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  const root = (workInProgress.stateNode: FiberRoot);\n  if (root.pendingContext) {\n    pushTopLevelContextObject(\n      workInProgress,\n      root.pendingContext,\n      root.pendingContext !== root.context,\n    );\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderLanes) {\n  pushHostRootContext(workInProgress);\n\n  if (current === null) {\n    throw new Error('Should have a current fiber. This is a bug in React.');\n  }\n\n  const nextProps = workInProgress.pendingProps;\n  const prevState = workInProgress.memoizedState;\n  const prevChildren = prevState.element;\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n\n  const nextState: RootState = workInProgress.memoizedState;\n  const root: FiberRoot = workInProgress.stateNode;\n  pushRootTransition(workInProgress, root, renderLanes);\n\n  if (enableTransitionTracing) {\n    pushRootMarkerInstance(workInProgress);\n  }\n\n  if (enableCache) {\n    const nextCache: Cache = nextState.cache;\n    pushCacheProvider(workInProgress, nextCache);\n    if (nextCache !== prevState.cache) {\n      // The root cache refreshed.\n      propagateContextChange(workInProgress, CacheContext, renderLanes);\n    }\n  }\n\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  const nextChildren = nextState.element;\n  if (supportsHydration && prevState.isDehydrated) {\n    // This is a hydration root whose shell has not yet hydrated. We should\n    // attempt to hydrate.\n\n    // Flip isDehydrated to false to indicate that when this render\n    // finishes, the root will no longer be dehydrated.\n    const overrideState: RootState = {\n      element: nextChildren,\n      isDehydrated: false,\n      cache: nextState.cache,\n    };\n    const updateQueue: UpdateQueue<RootState> = (workInProgress.updateQueue: any);\n    // `baseState` can always be the last state because the root doesn't\n    // have reducer functions so it doesn't need rebasing.\n    updateQueue.baseState = overrideState;\n    workInProgress.memoizedState = overrideState;\n\n    if (workInProgress.flags & ForceClientRender) {\n      // Something errored during a previous attempt to hydrate the shell, so we\n      // forced a client render.\n      const recoverableError = createCapturedValueAtFiber(\n        new Error(\n          'There was an error while hydrating. Because the error happened outside ' +\n            'of a Suspense boundary, the entire root will switch to ' +\n            'client rendering.',\n        ),\n        workInProgress,\n      );\n      return mountHostRootWithoutHydrating(\n        current,\n        workInProgress,\n        nextChildren,\n        renderLanes,\n        recoverableError,\n      );\n    } else if (nextChildren !== prevChildren) {\n      const recoverableError = createCapturedValueAtFiber(\n        new Error(\n          'This root received an early update, before anything was able ' +\n            'hydrate. Switched the entire root to client rendering.',\n        ),\n        workInProgress,\n      );\n      return mountHostRootWithoutHydrating(\n        current,\n        workInProgress,\n        nextChildren,\n        renderLanes,\n        recoverableError,\n      );\n    } else {\n      // The outermost shell has not hydrated yet. Start hydrating.\n      enterHydrationState(workInProgress);\n      if (enableUseMutableSource) {\n        const mutableSourceEagerHydrationData =\n          root.mutableSourceEagerHydrationData;\n        if (mutableSourceEagerHydrationData != null) {\n          for (let i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {\n            const mutableSource = ((mutableSourceEagerHydrationData[\n              i\n            ]: any): MutableSource<any>);\n            const version = mutableSourceEagerHydrationData[i + 1];\n            setWorkInProgressVersion(mutableSource, version);\n          }\n        }\n      }\n\n      const child = mountChildFibers(\n        workInProgress,\n        null,\n        nextChildren,\n        renderLanes,\n      );\n      workInProgress.child = child;\n\n      let node = child;\n      while (node) {\n        // Mark each child as hydrating. This is a fast path to know whether this\n        // tree is part of a hydrating tree. This is used to determine if a child\n        // node has fully mounted yet, and for scheduling event replaying.\n        // Conceptually this is similar to Placement in that a new subtree is\n        // inserted into the React tree here. It just happens to not need DOM\n        // mutations because it already exists.\n        node.flags = (node.flags & ~Placement) | Hydrating;\n        node = node.sibling;\n      }\n    }\n  } else {\n    // Root is not dehydrated. Either this is a client-only root, or it\n    // already hydrated.\n    resetHydrationState();\n    if (nextChildren === prevChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n  return workInProgress.child;\n}\n\nfunction mountHostRootWithoutHydrating(\n  current: Fiber,\n  workInProgress: Fiber,\n  nextChildren: ReactNodeList,\n  renderLanes: Lanes,\n  recoverableError: CapturedValue<mixed>,\n) {\n  // Revert to client rendering.\n  resetHydrationState();\n\n  queueHydrationError(recoverableError);\n\n  workInProgress.flags |= ForceClientRender;\n\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n\n  let nextChildren = nextProps.children;\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.flags |= ContentReset;\n  }\n\n  markRef(current, workInProgress);\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostResource(current, workInProgress, renderLanes) {\n  pushHostContext(workInProgress);\n  markRef(current, workInProgress);\n  const currentProps = current === null ? null : current.memoizedProps;\n  workInProgress.memoizedState = getResource(\n    workInProgress.type,\n    workInProgress.pendingProps,\n    currentProps,\n  );\n  // Resources never have reconciler managed children. It is possible for\n  // the host implementation of getResource to consider children in the\n  // resource construction but they will otherwise be discarded. In practice\n  // this precludes all but the simplest children and Host specific warnings\n  // should be implemented to warn when children are passsed when otherwise not\n  // expected\n  return null;\n}\n\nfunction updateHostSingleton(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    claimHydratableSingleton(workInProgress);\n  }\n\n  const nextChildren = workInProgress.pendingProps.children;\n\n  if (current === null && !getIsHydrating()) {\n    // Similar to Portals we append Singleton children in the commit phase. So we\n    // Track insertions even on mount.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n  markRef(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n  // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n  return null;\n}\n\nfunction mountLazyComponent(\n  _current,\n  workInProgress,\n  elementType,\n  renderLanes,\n) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n\n  const props = workInProgress.pendingProps;\n  const lazyComponent: LazyComponentType<any, any> = elementType;\n  const payload = lazyComponent._payload;\n  const init = lazyComponent._init;\n  let Component = init(payload);\n  // Store the unwrapped component in the type.\n  workInProgress.type = Component;\n  const resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component));\n  const resolvedProps = resolveDefaultProps(Component, props);\n  let child;\n  switch (resolvedTag) {\n    case FunctionComponent: {\n      if (__DEV__) {\n        validateFunctionComponentInDev(workInProgress, Component);\n        workInProgress.type = Component = resolveFunctionForHotReloading(\n          Component,\n        );\n      }\n      child = updateFunctionComponent(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n      return child;\n    }\n    case ClassComponent: {\n      if (__DEV__) {\n        workInProgress.type = Component = resolveClassForHotReloading(\n          Component,\n        );\n      }\n      child = updateClassComponent(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n      return child;\n    }\n    case ForwardRef: {\n      if (__DEV__) {\n        workInProgress.type = Component = resolveForwardRefForHotReloading(\n          Component,\n        );\n      }\n      child = updateForwardRef(\n        null,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n      return child;\n    }\n    case MemoComponent: {\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = Component.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentNameFromType(Component),\n            );\n          }\n        }\n      }\n      child = updateMemoComponent(\n        null,\n        workInProgress,\n        Component,\n        resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        renderLanes,\n      );\n      return child;\n    }\n  }\n  let hint = '';\n  if (__DEV__) {\n    if (\n      Component !== null &&\n      typeof Component === 'object' &&\n      Component.$$typeof === REACT_LAZY_TYPE\n    ) {\n      hint = ' Did you wrap a component in React.lazy() more than once?';\n    }\n  }\n\n  // This message intentionally doesn't mention ForwardRef or MemoComponent\n  // because the fact that it's a separate type of work is an\n  // implementation detail.\n  throw new Error(\n    `Element type is invalid. Received a promise that resolves to: ${Component}. ` +\n      `Lazy element type must resolve to a class or function.${hint}`,\n  );\n}\n\nfunction mountIncompleteClassComponent(\n  _current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes,\n) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n\n  // Promote the fiber to a class and try rendering again.\n  workInProgress.tag = ClassComponent;\n\n  // The rest of this function is a fork of `updateClassComponent`\n\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  let hasContext;\n  if (isLegacyContextProvider(Component)) {\n    hasContext = true;\n    pushLegacyContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderLanes);\n\n  constructClassInstance(workInProgress, Component, nextProps);\n  mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n\n  return finishClassComponent(\n    null,\n    workInProgress,\n    Component,\n    true,\n    hasContext,\n    renderLanes,\n  );\n}\n\nfunction mountIndeterminateComponent(\n  _current,\n  workInProgress,\n  Component,\n  renderLanes,\n) {\n  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);\n\n  const props = workInProgress.pendingProps;\n  let context;\n  if (!disableLegacyContext) {\n    const unmaskedContext = getUnmaskedContext(\n      workInProgress,\n      Component,\n      false,\n    );\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  let value;\n  let hasId;\n\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n  if (__DEV__) {\n    if (\n      Component.prototype &&\n      typeof Component.prototype.render === 'function'\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        console.error(\n          \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" +\n            'This is likely to cause errors. Change %s to extend React.Component instead.',\n          componentName,\n          componentName,\n        );\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    setIsRendering(true);\n    ReactCurrentOwner.current = workInProgress;\n    value = renderWithHooks(\n      null,\n      workInProgress,\n      Component,\n      props,\n      context,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  } else {\n    value = renderWithHooks(\n      null,\n      workInProgress,\n      Component,\n      props,\n      context,\n      renderLanes,\n    );\n    hasId = checkDidRenderIdHook();\n  }\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n\n  if (__DEV__) {\n    // Support for module components is deprecated and is removed behind a flag.\n    // Whether or not it would crash later, we want to show a good message in DEV first.\n    if (\n      typeof value === 'object' &&\n      value !== null &&\n      typeof value.render === 'function' &&\n      value.$$typeof === undefined\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error(\n          'The <%s /> component appears to be a function component that returns a class instance. ' +\n            'Change %s to a class that extends React.Component instead. ' +\n            \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\n            \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\n            'cannot be called with `new` by React.',\n          componentName,\n          componentName,\n          componentName,\n        );\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n  }\n\n  if (\n    // Run these checks in production only if the flag is off.\n    // Eventually we'll delete this branch altogether.\n    !disableModulePatternComponents &&\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.render === 'function' &&\n    value.$$typeof === undefined\n  ) {\n    if (__DEV__) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n      if (!didWarnAboutModulePatternComponent[componentName]) {\n        console.error(\n          'The <%s /> component appears to be a function component that returns a class instance. ' +\n            'Change %s to a class that extends React.Component instead. ' +\n            \"If you can't use a class try assigning the prototype on the function as a workaround. \" +\n            \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" +\n            'cannot be called with `new` by React.',\n          componentName,\n          componentName,\n          componentName,\n        );\n        didWarnAboutModulePatternComponent[componentName] = true;\n      }\n    }\n\n    // Proceed under the assumption that this is a class instance\n    workInProgress.tag = ClassComponent;\n\n    // Throw out any hooks that were used.\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null;\n\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    let hasContext = false;\n    if (isLegacyContextProvider(Component)) {\n      hasContext = true;\n      pushLegacyContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState =\n      value.state !== null && value.state !== undefined ? value.state : null;\n\n    initializeUpdateQueue(workInProgress);\n\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderLanes);\n    return finishClassComponent(\n      null,\n      workInProgress,\n      Component,\n      true,\n      hasContext,\n      renderLanes,\n    );\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n    if (__DEV__) {\n      if (disableLegacyContext && Component.contextTypes) {\n        console.error(\n          '%s uses the legacy contextTypes API which is no longer supported. ' +\n            'Use React.createContext() with React.useContext() instead.',\n          getComponentNameFromType(Component) || 'Unknown',\n        );\n      }\n    }\n\n    if (getIsHydrating() && hasId) {\n      pushMaterializedTreeId(workInProgress);\n    }\n\n    reconcileChildren(null, workInProgress, value, renderLanes);\n    if (__DEV__) {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress: Fiber, Component: any) {\n  if (__DEV__) {\n    if (Component) {\n      if (Component.childContextTypes) {\n        console.error(\n          '%s(...): childContextTypes cannot be defined on a function component.',\n          Component.displayName || Component.name || 'Component',\n        );\n      }\n    }\n    if (workInProgress.ref !== null) {\n      let info = '';\n      const ownerName = getCurrentFiberOwnerNameInDevOrNull();\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      let warningKey = ownerName || '';\n      const debugSource = workInProgress._debugSource;\n      if (debugSource) {\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n      }\n      if (!didWarnAboutFunctionRefs[warningKey]) {\n        didWarnAboutFunctionRefs[warningKey] = true;\n        console.error(\n          'Function components cannot be given refs. ' +\n            'Attempts to access this ref will fail. ' +\n            'Did you mean to use React.forwardRef()?%s',\n          info,\n        );\n      }\n    }\n\n    if (\n      warnAboutDefaultPropsOnFunctionComponents &&\n      Component.defaultProps !== undefined\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Support for defaultProps will be removed from function components ' +\n            'in a future major release. Use JavaScript default parameters instead.',\n          componentName,\n        );\n        didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Function components do not support getDerivedStateFromProps.',\n          componentName,\n        );\n        didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true;\n      }\n    }\n\n    if (\n      typeof Component.contextType === 'object' &&\n      Component.contextType !== null\n    ) {\n      const componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[componentName]) {\n        console.error(\n          '%s: Function components do not support contextType.',\n          componentName,\n        );\n        didWarnAboutContextTypeOnFunctionComponent[componentName] = true;\n      }\n    }\n  }\n}\n\nconst SUSPENDED_MARKER: SuspenseState = {\n  dehydrated: null,\n  treeContext: null,\n  retryLane: NoLane,\n};\n\nfunction mountSuspenseOffscreenState(renderLanes: Lanes): OffscreenState {\n  return {\n    baseLanes: renderLanes,\n    cachePool: getSuspendedCache(),\n  };\n}\n\nfunction updateSuspenseOffscreenState(\n  prevOffscreenState: OffscreenState,\n  renderLanes: Lanes,\n): OffscreenState {\n  let cachePool: SpawnedCachePool | null = null;\n  if (enableCache) {\n    const prevCachePool: SpawnedCachePool | null = prevOffscreenState.cachePool;\n    if (prevCachePool !== null) {\n      const parentCache = isPrimaryRenderer\n        ? CacheContext._currentValue\n        : CacheContext._currentValue2;\n      if (prevCachePool.parent !== parentCache) {\n        // Detected a refresh in the parent. This overrides any previously\n        // suspended cache.\n        cachePool = {\n          parent: parentCache,\n          pool: parentCache,\n        };\n      } else {\n        // We can reuse the cache from last time. The only thing that would have\n        // overridden it is a parent refresh, which we checked for above.\n        cachePool = prevCachePool;\n      }\n    } else {\n      // If there's no previous cache pool, grab the current one.\n      cachePool = getSuspendedCache();\n    }\n  }\n  return {\n    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n    cachePool,\n  };\n}\n\n// TODO: Probably should inline this back\nfunction shouldRemainOnFallback(\n  current: null | Fiber,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  // If we're already showing a fallback, there are cases where we need to\n  // remain on that fallback regardless of whether the content has resolved.\n  // For example, SuspenseList coordinates when nested content appears.\n  if (current !== null) {\n    const suspenseState: SuspenseState = current.memoizedState;\n    if (suspenseState === null) {\n      // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n      // Note: This is a factoring smell. Can't remain on a fallback if there's\n      // no fallback to remain on.\n      return false;\n    }\n  }\n\n  // Not currently showing content. Consult the Suspense context.\n  const suspenseContext: SuspenseContext = suspenseStackCursor.current;\n  return hasSuspenseListContext(\n    suspenseContext,\n    (ForceSuspenseFallback: SuspenseContext),\n  );\n}\n\nfunction getRemainingWorkInPrimaryTree(current: Fiber, renderLanes) {\n  // TODO: Should not remove render lanes that were pinged during this render\n  return removeLanes(current.childLanes, renderLanes);\n}\n\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n\n  // This is used by DevTools to force a boundary to suspend.\n  if (__DEV__) {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.flags |= DidCapture;\n    }\n  }\n\n  let showFallback = false;\n  const didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n  if (\n    didSuspend ||\n    shouldRemainOnFallback(current, workInProgress, renderLanes)\n  ) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    showFallback = true;\n    workInProgress.flags &= ~DidCapture;\n  }\n\n  // OK, the next part is confusing. We're about to reconcile the Suspense\n  // boundary's children. This involves some custom reconciliation logic. Two\n  // main reasons this is so complicated.\n  //\n  // First, Legacy Mode has different semantics for backwards compatibility. The\n  // primary tree will commit in an inconsistent state, so when we do the\n  // second pass to render the fallback, we do some exceedingly, uh, clever\n  // hacks to make that not totally break. Like transferring effects and\n  // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n  // because we bailout on the primary tree completely and leave it in its old\n  // state, no effects. Same as what we do for Offscreen (except that\n  // Offscreen doesn't have the first render pass).\n  //\n  // Second is hydration. During hydration, the Suspense fiber has a slightly\n  // different layout, where the child points to a dehydrated fragment, which\n  // contains the DOM rendered by the server.\n  //\n  // Third, even if you set all that aside, Suspense is like error boundaries in\n  // that we first we try to render one tree, and if that fails, we render again\n  // and switch to a different tree. Like a try/catch block. So we have to track\n  // which branch we're currently rendering. Ideally we would model this using\n  // a stack.\n  if (current === null) {\n    // Initial mount\n\n    // Special path for hydration\n    // If we're currently hydrating, try to hydrate this boundary.\n    if (getIsHydrating()) {\n      // We must push the suspense handler context *before* attempting to\n      // hydrate, to avoid a mismatch in case it errors.\n      if (showFallback) {\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n      } else {\n        pushFallbackTreeSuspenseHandler(workInProgress);\n      }\n      tryToClaimNextHydratableInstance(workInProgress);\n      // This could've been a dehydrated suspense component.\n      const suspenseState: null | SuspenseState = workInProgress.memoizedState;\n      if (suspenseState !== null) {\n        const dehydrated = suspenseState.dehydrated;\n        if (dehydrated !== null) {\n          return mountDehydratedSuspenseComponent(\n            workInProgress,\n            dehydrated,\n            renderLanes,\n          );\n        }\n      }\n      // If hydration didn't succeed, fall through to the normal Suspense path.\n      // To avoid a stack mismatch we need to pop the Suspense handler that we\n      // pushed above. This will become less awkward when move the hydration\n      // logic to its own fiber.\n      popSuspenseHandler(workInProgress);\n    }\n\n    const nextPrimaryChildren = nextProps.children;\n    const nextFallbackChildren = nextProps.fallback;\n\n    if (showFallback) {\n      pushFallbackTreeSuspenseHandler(workInProgress);\n\n      const fallbackFragment = mountSuspenseFallbackChildren(\n        workInProgress,\n        nextPrimaryChildren,\n        nextFallbackChildren,\n        renderLanes,\n      );\n      const primaryChildFragment: Fiber = (workInProgress.child: any);\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\n        renderLanes,\n      );\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      if (enableTransitionTracing) {\n        const currentTransitions = getPendingTransitions();\n        if (currentTransitions !== null) {\n          const parentMarkerInstances = getMarkerInstances();\n          const offscreenQueue: OffscreenQueue | null = (primaryChildFragment.updateQueue: any);\n          if (offscreenQueue === null) {\n            const newOffscreenQueue: OffscreenQueue = {\n              transitions: currentTransitions,\n              markerInstances: parentMarkerInstances,\n              wakeables: null,\n            };\n            primaryChildFragment.updateQueue = newOffscreenQueue;\n          } else {\n            offscreenQueue.transitions = currentTransitions;\n            offscreenQueue.markerInstances = parentMarkerInstances;\n          }\n        }\n      }\n\n      return fallbackFragment;\n    } else if (\n      enableCPUSuspense &&\n      typeof nextProps.unstable_expectedLoadTime === 'number'\n    ) {\n      // This is a CPU-bound tree. Skip this tree and show a placeholder to\n      // unblock the surrounding content. Then immediately retry after the\n      // initial commit.\n      pushFallbackTreeSuspenseHandler(workInProgress);\n      const fallbackFragment = mountSuspenseFallbackChildren(\n        workInProgress,\n        nextPrimaryChildren,\n        nextFallbackChildren,\n        renderLanes,\n      );\n      const primaryChildFragment: Fiber = (workInProgress.child: any);\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\n        renderLanes,\n      );\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n\n      // TODO: Transition Tracing is not yet implemented for CPU Suspense.\n\n      // Since nothing actually suspended, there will nothing to ping this to\n      // get it started back up to attempt the next item. While in terms of\n      // priority this work has the same priority as this current render, it's\n      // not part of the same transition once the transition has committed. If\n      // it's sync, we still want to yield so that it can be painted.\n      // Conceptually, this is really the same as pinging. We can use any\n      // RetryLane even if it's the one currently rendering since we're leaving\n      // it behind on this node.\n      workInProgress.lanes = SomeRetryLane;\n      return fallbackFragment;\n    } else {\n      pushPrimaryTreeSuspenseHandler(workInProgress);\n      return mountSuspensePrimaryChildren(\n        workInProgress,\n        nextPrimaryChildren,\n        renderLanes,\n      );\n    }\n  } else {\n    // This is an update.\n\n    // Special path for hydration\n    const prevState: null | SuspenseState = current.memoizedState;\n    if (prevState !== null) {\n      const dehydrated = prevState.dehydrated;\n      if (dehydrated !== null) {\n        return updateDehydratedSuspenseComponent(\n          current,\n          workInProgress,\n          didSuspend,\n          nextProps,\n          dehydrated,\n          prevState,\n          renderLanes,\n        );\n      }\n    }\n\n    if (showFallback) {\n      pushFallbackTreeSuspenseHandler(workInProgress);\n\n      const nextFallbackChildren = nextProps.fallback;\n      const nextPrimaryChildren = nextProps.children;\n      const fallbackChildFragment = updateSuspenseFallbackChildren(\n        current,\n        workInProgress,\n        nextPrimaryChildren,\n        nextFallbackChildren,\n        renderLanes,\n      );\n      const primaryChildFragment: Fiber = (workInProgress.child: any);\n      const prevOffscreenState: OffscreenState | null = (current.child: any)\n        .memoizedState;\n      primaryChildFragment.memoizedState =\n        prevOffscreenState === null\n          ? mountSuspenseOffscreenState(renderLanes)\n          : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n      if (enableTransitionTracing) {\n        const currentTransitions = getPendingTransitions();\n        if (currentTransitions !== null) {\n          const parentMarkerInstances = getMarkerInstances();\n          const offscreenQueue: OffscreenQueue | null = (primaryChildFragment.updateQueue: any);\n          const currentOffscreenQueue: OffscreenQueue | null = (current.updateQueue: any);\n          if (offscreenQueue === null) {\n            const newOffscreenQueue: OffscreenQueue = {\n              transitions: currentTransitions,\n              markerInstances: parentMarkerInstances,\n              wakeables: null,\n            };\n            primaryChildFragment.updateQueue = newOffscreenQueue;\n          } else if (offscreenQueue === currentOffscreenQueue) {\n            // If the work-in-progress queue is the same object as current, we\n            // can't modify it without cloning it first.\n            const newOffscreenQueue: OffscreenQueue = {\n              transitions: currentTransitions,\n              markerInstances: parentMarkerInstances,\n              wakeables:\n                currentOffscreenQueue !== null\n                  ? currentOffscreenQueue.wakeables\n                  : null,\n            };\n            primaryChildFragment.updateQueue = newOffscreenQueue;\n          } else {\n            offscreenQueue.transitions = currentTransitions;\n            offscreenQueue.markerInstances = parentMarkerInstances;\n          }\n        }\n      }\n      primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(\n        current,\n        renderLanes,\n      );\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackChildFragment;\n    } else {\n      pushPrimaryTreeSuspenseHandler(workInProgress);\n\n      const nextPrimaryChildren = nextProps.children;\n      const primaryChildFragment = updateSuspensePrimaryChildren(\n        current,\n        workInProgress,\n        nextPrimaryChildren,\n        renderLanes,\n      );\n      workInProgress.memoizedState = null;\n      return primaryChildFragment;\n    }\n  }\n}\n\nfunction mountSuspensePrimaryChildren(\n  workInProgress,\n  primaryChildren,\n  renderLanes,\n) {\n  const mode = workInProgress.mode;\n  const primaryChildProps: OffscreenProps = {\n    mode: 'visible',\n    children: primaryChildren,\n  };\n  const primaryChildFragment = mountWorkInProgressOffscreenFiber(\n    primaryChildProps,\n    mode,\n    renderLanes,\n  );\n  primaryChildFragment.return = workInProgress;\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackChildren(\n  workInProgress,\n  primaryChildren,\n  fallbackChildren,\n  renderLanes,\n) {\n  const mode = workInProgress.mode;\n  const progressedPrimaryFragment: Fiber | null = workInProgress.child;\n\n  const primaryChildProps: OffscreenProps = {\n    mode: 'hidden',\n    children: primaryChildren,\n  };\n\n  let primaryChildFragment;\n  let fallbackChildFragment;\n  if (\n    (mode & ConcurrentMode) === NoMode &&\n    progressedPrimaryFragment !== null\n  ) {\n    // In legacy mode, we commit the primary tree as if it successfully\n    // completed, even though it's in an inconsistent state.\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = 0;\n      primaryChildFragment.treeBaseDuration = 0;\n    }\n\n    fallbackChildFragment = createFiberFromFragment(\n      fallbackChildren,\n      mode,\n      renderLanes,\n      null,\n    );\n  } else {\n    primaryChildFragment = mountWorkInProgressOffscreenFiber(\n      primaryChildProps,\n      mode,\n      NoLanes,\n    );\n    fallbackChildFragment = createFiberFromFragment(\n      fallbackChildren,\n      mode,\n      renderLanes,\n      null,\n    );\n  }\n\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction mountWorkInProgressOffscreenFiber(\n  offscreenProps: OffscreenProps,\n  mode: TypeOfMode,\n  renderLanes: Lanes,\n) {\n  // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n  // this wrapper function to constrain it.\n  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n}\n\nfunction updateWorkInProgressOffscreenFiber(\n  current: Fiber,\n  offscreenProps: OffscreenProps,\n) {\n  // The props argument to `createWorkInProgress` is `any` typed, so we use this\n  // wrapper function to constrain it.\n  return createWorkInProgress(current, offscreenProps);\n}\n\nfunction updateSuspensePrimaryChildren(\n  current,\n  workInProgress,\n  primaryChildren,\n  renderLanes,\n) {\n  const currentPrimaryChildFragment: Fiber = (current.child: any);\n  const currentFallbackChildFragment: Fiber | null =\n    currentPrimaryChildFragment.sibling;\n\n  const primaryChildFragment = updateWorkInProgressOffscreenFiber(\n    currentPrimaryChildFragment,\n    {\n      mode: 'visible',\n      children: primaryChildren,\n    },\n  );\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    primaryChildFragment.lanes = renderLanes;\n  }\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = null;\n  if (currentFallbackChildFragment !== null) {\n    // Delete the fallback child fragment\n    const deletions = workInProgress.deletions;\n    if (deletions === null) {\n      workInProgress.deletions = [currentFallbackChildFragment];\n      workInProgress.flags |= ChildDeletion;\n    } else {\n      deletions.push(currentFallbackChildFragment);\n    }\n  }\n\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction updateSuspenseFallbackChildren(\n  current,\n  workInProgress,\n  primaryChildren,\n  fallbackChildren,\n  renderLanes,\n) {\n  const mode = workInProgress.mode;\n  const currentPrimaryChildFragment: Fiber = (current.child: any);\n  const currentFallbackChildFragment: Fiber | null =\n    currentPrimaryChildFragment.sibling;\n\n  const primaryChildProps: OffscreenProps = {\n    mode: 'hidden',\n    children: primaryChildren,\n  };\n\n  let primaryChildFragment;\n  if (\n    // In legacy mode, we commit the primary tree as if it successfully\n    // completed, even though it's in an inconsistent state.\n    (mode & ConcurrentMode) === NoMode &&\n    // Make sure we're on the second pass, i.e. the primary child fragment was\n    // already cloned. In legacy mode, the only case where this isn't true is\n    // when DevTools forces us to display a fallback; we skip the first render\n    // pass entirely and go straight to rendering the fallback. (In Concurrent\n    // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n    // only codepath.)\n    workInProgress.child !== currentPrimaryChildFragment\n  ) {\n    const progressedPrimaryFragment: Fiber = (workInProgress.child: any);\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration =\n        currentPrimaryChildFragment.selfBaseDuration;\n      primaryChildFragment.treeBaseDuration =\n        currentPrimaryChildFragment.treeBaseDuration;\n    }\n\n    // The fallback fiber was added as a deletion during the first pass.\n    // However, since we're going to remain on the fallback, we no longer want\n    // to delete it.\n    workInProgress.deletions = null;\n  } else {\n    primaryChildFragment = updateWorkInProgressOffscreenFiber(\n      currentPrimaryChildFragment,\n      primaryChildProps,\n    );\n    // Since we're reusing a current tree, we need to reuse the flags, too.\n    // (We don't do this in legacy mode, because in legacy mode we don't re-use\n    // the current tree; see previous branch.)\n    primaryChildFragment.subtreeFlags =\n      currentPrimaryChildFragment.subtreeFlags & StaticMask;\n  }\n  let fallbackChildFragment;\n  if (currentFallbackChildFragment !== null) {\n    fallbackChildFragment = createWorkInProgress(\n      currentFallbackChildFragment,\n      fallbackChildren,\n    );\n  } else {\n    fallbackChildFragment = createFiberFromFragment(\n      fallbackChildren,\n      mode,\n      renderLanes,\n      null,\n    );\n    // Needs a placement effect because the parent (the Suspense boundary) already\n    // mounted but this is a new fiber.\n    fallbackChildFragment.flags |= Placement;\n  }\n\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n\n  return fallbackChildFragment;\n}\n\nfunction retrySuspenseComponentWithoutHydrating(\n  current: Fiber,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n  recoverableError: CapturedValue<mixed> | null,\n) {\n  // Falling back to client rendering. Because this has performance\n  // implications, it's considered a recoverable error, even though the user\n  // likely won't observe anything wrong with the UI.\n  //\n  // The error is passed in as an argument to enforce that every caller provide\n  // a custom message, or explicitly opt out (currently the only path that opts\n  // out is legacy mode; every concurrent path provides an error).\n  if (recoverableError !== null) {\n    queueHydrationError(recoverableError);\n  }\n\n  // This will add the old fiber to the deletion list\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n\n  // We're now not suspended nor dehydrated.\n  const nextProps = workInProgress.pendingProps;\n  const primaryChildren = nextProps.children;\n  const primaryChildFragment = mountSuspensePrimaryChildren(\n    workInProgress,\n    primaryChildren,\n    renderLanes,\n  );\n  // Needs a placement effect because the parent (the Suspense boundary) already\n  // mounted but this is a new fiber.\n  primaryChildFragment.flags |= Placement;\n  workInProgress.memoizedState = null;\n\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackAfterRetryWithoutHydrating(\n  current,\n  workInProgress,\n  primaryChildren,\n  fallbackChildren,\n  renderLanes,\n) {\n  const fiberMode = workInProgress.mode;\n  const primaryChildProps: OffscreenProps = {\n    mode: 'visible',\n    children: primaryChildren,\n  };\n  const primaryChildFragment = mountWorkInProgressOffscreenFiber(\n    primaryChildProps,\n    fiberMode,\n    NoLanes,\n  );\n  const fallbackChildFragment = createFiberFromFragment(\n    fallbackChildren,\n    fiberMode,\n    renderLanes,\n    null,\n  );\n  // Needs a placement effect because the parent (the Suspense\n  // boundary) already mounted but this is a new fiber.\n  fallbackChildFragment.flags |= Placement;\n\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n\n  if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n    // We will have dropped the effect list which contains the\n    // deletion. We need to reconcile to delete the current child.\n    reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  }\n\n  return fallbackChildFragment;\n}\n\nfunction mountDehydratedSuspenseComponent(\n  workInProgress: Fiber,\n  suspenseInstance: SuspenseInstance,\n  renderLanes: Lanes,\n): null | Fiber {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    if (__DEV__) {\n      console.error(\n        'Cannot hydrate Suspense in legacy mode. Switch from ' +\n          'ReactDOM.hydrate(element, container) to ' +\n          'ReactDOMClient.hydrateRoot(container, <App />)' +\n          '.render(element) or remove the Suspense components from ' +\n          'the server rendered components.',\n      );\n    }\n    workInProgress.lanes = laneToLanes(SyncLane);\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    // Schedule a normal pri update to render this content.\n    workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.lanes = laneToLanes(OffscreenLane);\n  }\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(\n  current: Fiber,\n  workInProgress: Fiber,\n  didSuspend: boolean,\n  nextProps: any,\n  suspenseInstance: SuspenseInstance,\n  suspenseState: SuspenseState,\n  renderLanes: Lanes,\n): null | Fiber {\n  if (!didSuspend) {\n    // This is the first render pass. Attempt to hydrate.\n    pushPrimaryTreeSuspenseHandler(workInProgress);\n\n    // We should never be hydrating at this point because it is the first pass,\n    // but after we've already committed once.\n    warnIfHydrating();\n\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      return retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes,\n        null,\n      );\n    }\n\n    if (isSuspenseInstanceFallback(suspenseInstance)) {\n      // This boundary is in a permanent fallback state. In this case, we'll never\n      // get an update and we'll never be able to hydrate the final content. Let's just try the\n      // client side render instead.\n      let digest, message, stack;\n      if (__DEV__) {\n        ({digest, message, stack} = getSuspenseInstanceFallbackErrorDetails(\n          suspenseInstance,\n        ));\n      } else {\n        ({digest} = getSuspenseInstanceFallbackErrorDetails(suspenseInstance));\n      }\n\n      let error;\n      if (message) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        error = new Error(message);\n      } else {\n        error = new Error(\n          'The server could not finish this Suspense boundary, likely ' +\n            'due to an error during server rendering. Switched to ' +\n            'client rendering.',\n        );\n      }\n      (error: any).digest = digest;\n      const capturedValue = createCapturedValue(error, digest, stack);\n      return retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes,\n        capturedValue,\n      );\n    }\n\n    if (\n      enableLazyContextPropagation &&\n      // TODO: Factoring is a little weird, since we check this right below, too.\n      // But don't want to re-arrange the if-else chain until/unless this\n      // feature lands.\n      !didReceiveUpdate\n    ) {\n      // We need to check if any children have context before we decide to bail\n      // out, so propagate the changes now.\n      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n    }\n\n    // We use lanes to indicate that a child might depend on context, so if\n    // any context has changed, we need to treat is as if the input might have changed.\n    const hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n    if (didReceiveUpdate || hasContextChanged) {\n      // This boundary has changed since the first render. This means that we are now unable to\n      // hydrate it. We might still be able to hydrate it using a higher priority lane.\n      const root = getWorkInProgressRoot();\n      if (root !== null) {\n        const attemptHydrationAtLane = getBumpedLaneForHydration(\n          root,\n          renderLanes,\n        );\n        if (\n          attemptHydrationAtLane !== NoLane &&\n          attemptHydrationAtLane !== suspenseState.retryLane\n        ) {\n          // Intentionally mutating since this render will get interrupted. This\n          // is one of the very rare times where we mutate the current tree\n          // during the render phase.\n          suspenseState.retryLane = attemptHydrationAtLane;\n          // TODO: Ideally this would inherit the event time of the current render\n          const eventTime = NoTimestamp;\n          enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);\n          scheduleUpdateOnFiber(\n            root,\n            current,\n            attemptHydrationAtLane,\n            eventTime,\n          );\n\n          // Throw a special object that signals to the work loop that it should\n          // interrupt the current render.\n          //\n          // Because we're inside a React-only execution stack, we don't\n          // strictly need to throw here â€” we could instead modify some internal\n          // work loop state. But using an exception means we don't need to\n          // check for this case on every iteration of the work loop. So doing\n          // it this way moves the check out of the fast path.\n          throw SelectiveHydrationException;\n        } else {\n          // We have already tried to ping at a higher priority than we're rendering with\n          // so if we got here, we must have failed to hydrate at those levels. We must\n          // now give up. Instead, we're going to delete the whole subtree and instead inject\n          // a new real Suspense boundary to take its place, which may render content\n          // or fallback. This might suspend for a while and if it does we might still have\n          // an opportunity to hydrate before this pass commits.\n        }\n      }\n\n      // If we did not selectively hydrate, we'll continue rendering without\n      // hydrating. Mark this tree as suspended to prevent it from committing\n      // outside a transition.\n      //\n      // This path should only happen if the hydration lane already suspended.\n      // Currently, it also happens during sync updates because there is no\n      // hydration lane for sync updates.\n      // TODO: We should ideally have a sync hydration lane that we can apply to do\n      // a pass where we hydrate this subtree in place using the previous Context and then\n      // reapply the update afterwards.\n      renderDidSuspendDelayIfPossible();\n      return retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes,\n        null,\n      );\n    } else if (isSuspenseInstancePending(suspenseInstance)) {\n      // This component is still pending more data from the server, so we can't hydrate its\n      // content. We treat it as if this component suspended itself. It might seem as if\n      // we could just try to render it client-side instead. However, this will perform a\n      // lot of unnecessary work and is unlikely to complete since it often will suspend\n      // on missing data anyway. Additionally, the server might be able to render more\n      // than we can on the client yet. In that case we'd end up with more fallback states\n      // on the client than if we just leave it alone. If the server times out or errors\n      // these should update this boundary to the permanent Fallback state instead.\n      // Mark it as having captured (i.e. suspended).\n      workInProgress.flags |= DidCapture;\n      // Leave the child in place. I.e. the dehydrated fragment.\n      workInProgress.child = current.child;\n      // Register a callback to retry this boundary once the server has sent the result.\n      const retry = retryDehydratedSuspenseBoundary.bind(null, current);\n      registerSuspenseInstanceRetry(suspenseInstance, retry);\n      return null;\n    } else {\n      // This is the first attempt.\n      reenterHydrationStateFromDehydratedSuspenseInstance(\n        workInProgress,\n        suspenseInstance,\n        suspenseState.treeContext,\n      );\n      const primaryChildren = nextProps.children;\n      const primaryChildFragment = mountSuspensePrimaryChildren(\n        workInProgress,\n        primaryChildren,\n        renderLanes,\n      );\n      // Mark the children as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      primaryChildFragment.flags |= Hydrating;\n      return primaryChildFragment;\n    }\n  } else {\n    // This is the second render pass. We already attempted to hydrated, but\n    // something either suspended or errored.\n\n    if (workInProgress.flags & ForceClientRender) {\n      // Something errored during hydration. Try again without hydrating.\n      pushPrimaryTreeSuspenseHandler(workInProgress);\n\n      workInProgress.flags &= ~ForceClientRender;\n      const capturedValue = createCapturedValue(\n        new Error(\n          'There was an error while hydrating this Suspense boundary. ' +\n            'Switched to client rendering.',\n        ),\n      );\n      return retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes,\n        capturedValue,\n      );\n    } else if ((workInProgress.memoizedState: null | SuspenseState) !== null) {\n      // Something suspended and we should still be in dehydrated mode.\n      // Leave the existing child in place.\n\n      // Push to avoid a mismatch\n      pushFallbackTreeSuspenseHandler(workInProgress);\n\n      workInProgress.child = current.child;\n      // The dehydrated completion pass expects this flag to be there\n      // but the normal suspense pass doesn't.\n      workInProgress.flags |= DidCapture;\n      return null;\n    } else {\n      // Suspended but we should no longer be in dehydrated mode.\n      // Therefore we now have to render the fallback.\n      pushFallbackTreeSuspenseHandler(workInProgress);\n\n      const nextPrimaryChildren = nextProps.children;\n      const nextFallbackChildren = nextProps.fallback;\n      const fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(\n        current,\n        workInProgress,\n        nextPrimaryChildren,\n        nextFallbackChildren,\n        renderLanes,\n      );\n      const primaryChildFragment: Fiber = (workInProgress.child: any);\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(\n        renderLanes,\n      );\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackChildFragment;\n    }\n  }\n}\n\nfunction scheduleSuspenseWorkOnFiber(\n  fiber: Fiber,\n  renderLanes: Lanes,\n  propagationRoot: Fiber,\n) {\n  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n  }\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n}\n\nfunction propagateSuspenseContextChange(\n  workInProgress: Fiber,\n  firstChild: null | Fiber,\n  renderLanes: Lanes,\n): void {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  let node = firstChild;\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state: SuspenseState | null = node.memoizedState;\n      if (state !== null) {\n        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === workInProgress) {\n      return;\n    }\n    // $FlowFixMe[incompatible-use] found when upgrading Flow\n    while (node.sibling === null) {\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n      node = node.return;\n    }\n    // $FlowFixMe[incompatible-use] found when upgrading Flow\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild: null | Fiber): null | Fiber {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  let row = firstChild;\n  let lastContentRow: null | Fiber = null;\n  while (row !== null) {\n    const currentRow = row.alternate;\n    // New rows can't be content rows.\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n    row = row.sibling;\n  }\n  return lastContentRow;\n}\n\ntype SuspenseListRevealOrder = 'forwards' | 'backwards' | 'together' | void;\n\nfunction validateRevealOrder(revealOrder: SuspenseListRevealOrder) {\n  if (__DEV__) {\n    if (\n      revealOrder !== undefined &&\n      revealOrder !== 'forwards' &&\n      revealOrder !== 'backwards' &&\n      revealOrder !== 'together' &&\n      !didWarnAboutRevealOrder[revealOrder]\n    ) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards': {\n            console.error(\n              '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\n                'Use lowercase \"%s\" instead.',\n              revealOrder,\n              revealOrder.toLowerCase(),\n            );\n            break;\n          }\n          case 'forward':\n          case 'backward': {\n            console.error(\n              '\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' +\n                'React uses the -s suffix in the spelling. Use \"%ss\" instead.',\n              revealOrder,\n              revealOrder.toLowerCase(),\n            );\n            break;\n          }\n          default:\n            console.error(\n              '\"%s\" is not a supported revealOrder on <SuspenseList />. ' +\n                'Did you mean \"together\", \"forwards\" or \"backwards\"?',\n              revealOrder,\n            );\n            break;\n        }\n      } else {\n        console.error(\n          '%s is not a supported value for revealOrder on <SuspenseList />. ' +\n            'Did you mean \"together\", \"forwards\" or \"backwards\"?',\n          revealOrder,\n        );\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(\n  tailMode: SuspenseListTailMode,\n  revealOrder: SuspenseListRevealOrder,\n) {\n  if (__DEV__) {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error(\n          '\"%s\" is not a supported value for tail on <SuspenseList />. ' +\n            'Did you mean \"collapsed\" or \"hidden\"?',\n          tailMode,\n        );\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n        console.error(\n          '<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' +\n            '\"forwards\" or \"backwards\". ' +\n            'Did you mean to specify revealOrder=\"forwards\"?',\n          tailMode,\n        );\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot: mixed, index: number) {\n  if (__DEV__) {\n    const isAnArray = isArray(childSlot);\n    const isIterable =\n      !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n    if (isAnArray || isIterable) {\n      const type = isAnArray ? 'array' : 'iterable';\n      console.error(\n        'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' +\n          'an additional SuspenseList to configure its revealOrder: ' +\n          '<SuspenseList revealOrder=...> ... ' +\n          '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' +\n          '</SuspenseList>',\n        type,\n        index,\n        type,\n      );\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction validateSuspenseListChildren(\n  children: mixed,\n  revealOrder: SuspenseListRevealOrder,\n) {\n  if (__DEV__) {\n    if (\n      (revealOrder === 'forwards' || revealOrder === 'backwards') &&\n      children !== undefined &&\n      children !== null &&\n      children !== false\n    ) {\n      if (isArray(children)) {\n        for (let i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        const iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          const childrenIterator = iteratorFn.call(children);\n          if (childrenIterator) {\n            let step = childrenIterator.next();\n            let i = 0;\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, i)) {\n                return;\n              }\n              i++;\n            }\n          }\n        } else {\n          console.error(\n            'A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' +\n              'This is not useful since it needs multiple rows. ' +\n              'Did you mean to pass multiple children or an array?',\n            revealOrder,\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(\n  workInProgress: Fiber,\n  isBackwards: boolean,\n  tail: null | Fiber,\n  lastContentRow: null | Fiber,\n  tailMode: SuspenseListTailMode,\n): void {\n  const renderState: null | SuspenseListRenderState =\n    workInProgress.memoizedState;\n  if (renderState === null) {\n    workInProgress.memoizedState = ({\n      isBackwards: isBackwards,\n      rendering: null,\n      renderingStartTime: 0,\n      last: lastContentRow,\n      tail: tail,\n      tailMode: tailMode,\n    }: SuspenseListRenderState);\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.renderingStartTime = 0;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailMode = tailMode;\n  }\n}\n\n// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  const nextProps = workInProgress.pendingProps;\n  const revealOrder: SuspenseListRevealOrder = nextProps.revealOrder;\n  const tailMode: SuspenseListTailMode = nextProps.tail;\n  const newChildren = nextProps.children;\n\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n\n  let suspenseContext: SuspenseContext = suspenseStackCursor.current;\n\n  const shouldForceFallback = hasSuspenseListContext(\n    suspenseContext,\n    (ForceSuspenseFallback: SuspenseContext),\n  );\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseListContext(\n      suspenseContext,\n      ForceSuspenseFallback,\n    );\n    workInProgress.flags |= DidCapture;\n  } else {\n    const didSuspendBefore =\n      current !== null && (current.flags & DidCapture) !== NoFlags;\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(\n        workInProgress,\n        workInProgress.child,\n        renderLanes,\n      );\n    }\n    suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n  }\n  pushSuspenseListContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    // In legacy mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards': {\n        const lastContentRow = findLastContentRow(workInProgress.child);\n        let tail;\n        if (lastContentRow === null) {\n          // The whole list is part of the tail.\n          // TODO: We could fast path by just rendering the tail now.\n          tail = workInProgress.child;\n          workInProgress.child = null;\n        } else {\n          // Disconnect the tail rows after the content row.\n          // We're going to render them separately later.\n          tail = lastContentRow.sibling;\n          lastContentRow.sibling = null;\n        }\n        initSuspenseListRenderState(\n          workInProgress,\n          false, // isBackwards\n          tail,\n          lastContentRow,\n          tailMode,\n        );\n        break;\n      }\n      case 'backwards': {\n        // We're going to find the first row that has existing content.\n        // At the same time we're going to reverse the list of everything\n        // we pass in the meantime. That's going to be our tail in reverse\n        // order.\n        let tail = null;\n        let row = workInProgress.child;\n        workInProgress.child = null;\n        while (row !== null) {\n          const currentRow = row.alternate;\n          // New rows can't be content rows.\n          if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n            // This is the beginning of the main content.\n            workInProgress.child = row;\n            break;\n          }\n          const nextRow = row.sibling;\n          row.sibling = tail;\n          tail = row;\n          row = nextRow;\n        }\n        // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n        initSuspenseListRenderState(\n          workInProgress,\n          true, // isBackwards\n          tail,\n          null, // last\n          tailMode,\n        );\n        break;\n      }\n      case 'together': {\n        initSuspenseListRenderState(\n          workInProgress,\n          false, // isBackwards\n          null, // tail\n          null, // last\n          undefined,\n        );\n        break;\n      }\n      default: {\n        // The default reveal order is the same as not having\n        // a boundary.\n        workInProgress.memoizedState = null;\n      }\n    }\n  }\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  const nextChildren = workInProgress.pendingProps;\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n\nfunction updateContextProvider(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  const providerType: ReactProviderType<any> = workInProgress.type;\n  const context: ReactContext<any> = providerType._context;\n\n  const newProps = workInProgress.pendingProps;\n  const oldProps = workInProgress.memoizedProps;\n\n  const newValue = newProps.value;\n\n  if (__DEV__) {\n    if (!('value' in newProps)) {\n      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n        console.error(\n          'The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?',\n        );\n      }\n    }\n    const providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\n    }\n  }\n\n  pushProvider(workInProgress, context, newValue);\n\n  if (enableLazyContextPropagation) {\n    // In the lazy propagation implementation, we don't scan for matching\n    // consumers until something bails out, because until something bails out\n    // we're going to visit those nodes, anyway. The trade-off is that it shifts\n    // responsibility to the consumer to track whether something has changed.\n  } else {\n    if (oldProps !== null) {\n      const oldValue = oldProps.value;\n      if (is(oldValue, newValue)) {\n        // No change. Bailout early if children are the same.\n        if (\n          oldProps.children === newProps.children &&\n          !hasLegacyContextChanged()\n        ) {\n          return bailoutOnAlreadyFinishedWork(\n            current,\n            workInProgress,\n            renderLanes,\n          );\n        }\n      } else {\n        // The context value changed. Search for matching consumers and schedule\n        // them to update.\n        propagateContextChange(workInProgress, context, renderLanes);\n      }\n    }\n  }\n\n  const newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nlet hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  let context: ReactContext<any> = workInProgress.type;\n  // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n  if (__DEV__) {\n    if ((context: any)._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n          console.error(\n            'Rendering <Context> directly is not supported and will be removed in ' +\n              'a future major release. Did you mean to render <Context.Consumer> instead?',\n          );\n        }\n      }\n    } else {\n      context = (context: any)._context;\n    }\n  }\n  const newProps = workInProgress.pendingProps;\n  const render = newProps.children;\n\n  if (__DEV__) {\n    if (typeof render !== 'function') {\n      console.error(\n        'A context consumer was rendered with multiple children, or a child ' +\n          \"that isn't a function. A context consumer expects a single child \" +\n          'that is a function. If you did pass a function, make sure there ' +\n          'is no trailing or leading whitespace around it.',\n      );\n    }\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  const newValue = readContext(context);\n  if (enableSchedulingProfiler) {\n    markComponentRenderStarted(workInProgress);\n  }\n  let newChildren;\n  if (__DEV__) {\n    ReactCurrentOwner.current = workInProgress;\n    setIsRendering(true);\n    newChildren = render(newValue);\n    setIsRendering(false);\n  } else {\n    newChildren = render(newValue);\n  }\n  if (enableSchedulingProfiler) {\n    markComponentRenderStopped();\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateScopeComponent(current, workInProgress, renderLanes) {\n  const nextProps = workInProgress.pendingProps;\n  const nextChildren = nextProps.children;\n\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nexport function markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n\nexport function checkIfWorkInProgressReceivedUpdate(): boolean {\n  return didReceiveUpdate;\n}\n\nfunction resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress) {\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    if (current !== null) {\n      // A lazy component only mounts if it suspended inside a non-\n      // concurrent tree, in an inconsistent state. We want to treat it like\n      // a new mount, even though an empty version of it already committed.\n      // Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null;\n      // Since this is conceptually a new fiber, schedule a Placement effect\n      workInProgress.flags |= Placement;\n    }\n  }\n}\n\nfunction bailoutOnAlreadyFinishedWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  markSkippedUpdateLanes(workInProgress.lanes);\n\n  // Check if the children have any pending work.\n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n\n    if (enableLazyContextPropagation && current !== null) {\n      // Before bailing out, check if there are any context changes in\n      // the children.\n      lazilyPropagateParentContextChanges(current, workInProgress, renderLanes);\n      if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  // This fiber doesn't have work, but its subtree does. Clone the child\n  // fibers and continue.\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction remountFiber(\n  current: Fiber,\n  oldWorkInProgress: Fiber,\n  newWorkInProgress: Fiber,\n): Fiber | null {\n  if (__DEV__) {\n    const returnFiber = oldWorkInProgress.return;\n    if (returnFiber === null) {\n      // eslint-disable-next-line react-internal/prod-error-codes\n      throw new Error('Cannot swap the root fiber.');\n    }\n\n    // Disconnect from the old current.\n    // It will get deleted.\n    current.alternate = null;\n    oldWorkInProgress.alternate = null;\n\n    // Connect to the new tree.\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref;\n\n    // Replace the child/sibling pointers above it.\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      let prevSibling = returnFiber.child;\n      if (prevSibling === null) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        throw new Error('Expected parent to have a child.');\n      }\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n        prevSibling = prevSibling.sibling;\n        if (prevSibling === null) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      prevSibling.sibling = newWorkInProgress;\n    }\n\n    // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n    const deletions = returnFiber.deletions;\n    if (deletions === null) {\n      returnFiber.deletions = [current];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(current);\n    }\n\n    newWorkInProgress.flags |= Placement;\n\n    // Restart work from the new fiber.\n    return newWorkInProgress;\n  } else {\n    throw new Error(\n      'Did not expect this call in production. ' +\n        'This is a bug in React. Please file an issue.',\n    );\n  }\n}\n\nfunction checkScheduledUpdateOrContext(\n  current: Fiber,\n  renderLanes: Lanes,\n): boolean {\n  // Before performing an early bailout, we must check if there are pending\n  // updates or context.\n  const updateLanes = current.lanes;\n  if (includesSomeLane(updateLanes, renderLanes)) {\n    return true;\n  }\n  // No pending update, but because context is propagated lazily, we need\n  // to check for a context change before we bail out.\n  if (enableLazyContextPropagation) {\n    const dependencies = current.dependencies;\n    if (dependencies !== null && checkIfContextChanged(dependencies)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction attemptEarlyBailoutIfNoScheduledUpdate(\n  current: Fiber,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  // This fiber does not have any pending work. Bailout without entering\n  // the begin phase. There's still some bookkeeping we that needs to be done\n  // in this optimized path, mostly pushing stuff onto the stack.\n  switch (workInProgress.tag) {\n    case HostRoot:\n      pushHostRootContext(workInProgress);\n      const root: FiberRoot = workInProgress.stateNode;\n      pushRootTransition(workInProgress, root, renderLanes);\n\n      if (enableTransitionTracing) {\n        pushRootMarkerInstance(workInProgress);\n      }\n\n      if (enableCache) {\n        const cache: Cache = current.memoizedState.cache;\n        pushCacheProvider(workInProgress, cache);\n      }\n      resetHydrationState();\n      break;\n    case HostResource:\n    case HostSingleton:\n    case HostComponent:\n      pushHostContext(workInProgress);\n      break;\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      if (isLegacyContextProvider(Component)) {\n        pushLegacyContextProvider(workInProgress);\n      }\n      break;\n    }\n    case HostPortal:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n    case ContextProvider: {\n      const newValue = workInProgress.memoizedProps.value;\n      const context: ReactContext<any> = workInProgress.type._context;\n      pushProvider(workInProgress, context, newValue);\n      break;\n    }\n    case Profiler:\n      if (enableProfilerTimer) {\n        // Profiler should only call onRender when one of its descendants actually rendered.\n        const hasChildWork = includesSomeLane(\n          renderLanes,\n          workInProgress.childLanes,\n        );\n        if (hasChildWork) {\n          workInProgress.flags |= Update;\n        }\n\n        if (enableProfilerCommitHooks) {\n          // Reset effect durations for the next eventual effect phase.\n          // These are reset during render to allow the DevTools commit hook a chance to read them,\n          const stateNode = workInProgress.stateNode;\n          stateNode.effectDuration = 0;\n          stateNode.passiveEffectDuration = 0;\n        }\n      }\n      break;\n    case SuspenseComponent: {\n      const state: SuspenseState | null = workInProgress.memoizedState;\n      if (state !== null) {\n        if (state.dehydrated !== null) {\n          // We're not going to render the children, so this is just to maintain\n          // push/pop symmetry\n          pushPrimaryTreeSuspenseHandler(workInProgress);\n          // We know that this component will suspend again because if it has\n          // been unsuspended it has committed as a resolved Suspense component.\n          // If it needs to be retried, it should have work scheduled on it.\n          workInProgress.flags |= DidCapture;\n          // We should never render the children of a dehydrated boundary until we\n          // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n          return null;\n        }\n\n        // If this boundary is currently timed out, we need to decide\n        // whether to retry the primary children, or to skip over it and\n        // go straight to the fallback. Check the priority of the primary\n        // child fragment.\n        const primaryChildFragment: Fiber = (workInProgress.child: any);\n        const primaryChildLanes = primaryChildFragment.childLanes;\n        if (includesSomeLane(renderLanes, primaryChildLanes)) {\n          // The primary children have pending work. Use the normal path\n          // to attempt to render the primary children again.\n          return updateSuspenseComponent(current, workInProgress, renderLanes);\n        } else {\n          // The primary child fragment does not have pending work marked\n          // on it\n          pushPrimaryTreeSuspenseHandler(workInProgress);\n          // The primary children do not have pending work with sufficient\n          // priority. Bailout.\n          const child = bailoutOnAlreadyFinishedWork(\n            current,\n            workInProgress,\n            renderLanes,\n          );\n          if (child !== null) {\n            // The fallback children have pending work. Skip over the\n            // primary children and work on the fallback.\n            return child.sibling;\n          } else {\n            // Note: We can return `null` here because we already checked\n            // whether there were nested context consumers, via the call to\n            // `bailoutOnAlreadyFinishedWork` above.\n            return null;\n          }\n        }\n      } else {\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n      }\n      break;\n    }\n    case SuspenseListComponent: {\n      const didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n\n      let hasChildWork = includesSomeLane(\n        renderLanes,\n        workInProgress.childLanes,\n      );\n\n      if (enableLazyContextPropagation && !hasChildWork) {\n        // Context changes may not have been propagated yet. We need to do\n        // that now, before we can decide whether to bail out.\n        // TODO: We use `childLanes` as a heuristic for whether there is\n        // remaining work in a few places, including\n        // `bailoutOnAlreadyFinishedWork` and\n        // `updateDehydratedSuspenseComponent`. We should maybe extract this\n        // into a dedicated function.\n        lazilyPropagateParentContextChanges(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n        hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n      }\n\n      if (didSuspendBefore) {\n        if (hasChildWork) {\n          // If something was in fallback state last time, and we have all the\n          // same children then we're still in progressive loading state.\n          // Something might get unblocked by state updates or retries in the\n          // tree which will affect the tail. So we need to use the normal\n          // path to compute the correct tail.\n          return updateSuspenseListComponent(\n            current,\n            workInProgress,\n            renderLanes,\n          );\n        }\n        // If none of the children had any work, that means that none of\n        // them got retried so they'll still be blocked in the same way\n        // as before. We can fast bail out.\n        workInProgress.flags |= DidCapture;\n      }\n\n      // If nothing suspended before and we're rendering the same children,\n      // then the tail doesn't matter. Anything new that suspends will work\n      // in the \"together\" mode, so we can continue from the state we had.\n      const renderState = workInProgress.memoizedState;\n      if (renderState !== null) {\n        // Reset to the \"together\" mode in case we've started a different\n        // update in the past but didn't complete it.\n        renderState.rendering = null;\n        renderState.tail = null;\n        renderState.lastEffect = null;\n      }\n      pushSuspenseListContext(workInProgress, suspenseStackCursor.current);\n\n      if (hasChildWork) {\n        break;\n      } else {\n        // If none of the children had any work, that means that none of\n        // them got retried so they'll still be blocked in the same way\n        // as before. We can fast bail out.\n        return null;\n      }\n    }\n    case OffscreenComponent:\n    case LegacyHiddenComponent: {\n      // Need to check if the tree still needs to be deferred. This is\n      // almost identical to the logic used in the normal update path,\n      // so we'll just enter that. The only difference is we'll bail out\n      // at the next level instead of this one, because the child props\n      // have not changed. Which is fine.\n      // TODO: Probably should refactor `beginWork` to split the bailout\n      // path from the normal path. I'm tempted to do a labeled break here\n      // but I won't :)\n      workInProgress.lanes = NoLanes;\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        const cache: Cache = current.memoizedState.cache;\n        pushCacheProvider(workInProgress, cache);\n      }\n      break;\n    }\n    case TracingMarkerComponent: {\n      if (enableTransitionTracing) {\n        const instance: TracingMarkerInstance | null = workInProgress.stateNode;\n        if (instance !== null) {\n          pushMarkerInstance(workInProgress, instance);\n        }\n      }\n    }\n  }\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\n\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  if (__DEV__) {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(\n        current,\n        workInProgress,\n        createFiberFromTypeAndProps(\n          workInProgress.type,\n          workInProgress.key,\n          workInProgress.pendingProps,\n          workInProgress._debugOwner || null,\n          workInProgress.mode,\n          workInProgress.lanes,\n        ),\n      );\n    }\n  }\n\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      // Force a re-render if the implementation changed due to hot reload:\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(\n        current,\n        renderLanes,\n      );\n      if (\n        !hasScheduledUpdateOrContext &&\n        // If this is the second pass of an error or suspense boundary, there\n        // may not be work scheduled on `current`, so we check for this flag.\n        (workInProgress.flags & DidCapture) === NoFlags\n      ) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      }\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n\n    if (getIsHydrating() && isForkedChild(workInProgress)) {\n      // Check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // In a true multi-threaded implementation, we would render children on\n      // parallel threads. This would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // We only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      const slotIndex = workInProgress.index;\n      const numberOfForks = getForksAtLevel(workInProgress);\n      pushTreeId(workInProgress, numberOfForks, slotIndex);\n    }\n  }\n\n  // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n  workInProgress.lanes = NoLanes;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        renderLanes,\n      );\n    }\n    case LazyComponent: {\n      const elementType = workInProgress.elementType;\n      return mountLazyComponent(\n        current,\n        workInProgress,\n        elementType,\n        renderLanes,\n      );\n    }\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n    case HostResource:\n      if (enableFloat && supportsResources) {\n        return updateHostResource(current, workInProgress, renderLanes);\n      }\n    // eslint-disable-next-line no-fallthrough\n    case HostSingleton:\n      if (enableHostSingletons && supportsSingletons) {\n        return updateHostSingleton(current, workInProgress, renderLanes);\n      }\n    // eslint-disable-next-line no-fallthrough\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderLanes);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n    case ForwardRef: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === type\n          ? unresolvedProps\n          : resolveDefaultProps(type, unresolvedProps);\n      return updateForwardRef(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n    case MemoComponent: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      // Resolve outer props first, then resolve inner props.\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = type.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentNameFromType(type),\n            );\n          }\n        }\n      }\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case SimpleMemoComponent: {\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes,\n      );\n    }\n    case IncompleteClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return mountIncompleteClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case SuspenseListComponent: {\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        return updateScopeComponent(current, workInProgress, renderLanes);\n      }\n      break;\n    }\n    case OffscreenComponent: {\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    }\n    case LegacyHiddenComponent: {\n      if (enableLegacyHidden) {\n        return updateLegacyHiddenComponent(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      }\n      break;\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        return updateCacheComponent(current, workInProgress, renderLanes);\n      }\n      break;\n    }\n    case TracingMarkerComponent: {\n      if (enableTransitionTracing) {\n        return updateTracingMarkerComponent(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      }\n      break;\n    }\n  }\n\n  throw new Error(\n    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +\n      'React. Please file an issue.',\n  );\n}\n\nexport {beginWork};\n"]},"metadata":{},"sourceType":"module"}