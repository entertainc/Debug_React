{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which can be\n// mutated and processed asynchronously before it is committed â€” a form of\n// double buffering. If a work-in-progress render is discarded before finishing,\n// we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\nimport { NoLane, NoLanes, OffscreenLane, isSubsetOfLanes, mergeLanes, removeLanes, isTransitionLane, intersectLanes, markRootEntangled } from './ReactFiberLane';\nimport { enterDisallowedContextReadInDEV, exitDisallowedContextReadInDEV } from './ReactFiberNewContext';\nimport { Callback, Visibility, ShouldCapture, DidCapture } from './ReactFiberFlags';\nimport getComponentNameFromFiber from './getComponentNameFromFiber';\nimport { debugRenderPhaseSideEffectsForStrictMode } from 'shared/ReactFeatureFlags';\nimport { StrictLegacyMode } from './ReactTypeOfMode';\nimport { markSkippedUpdateLanes, isUnsafeClassRenderPhaseUpdate, getWorkInProgressRootRenderLanes } from './ReactFiberWorkLoop';\nimport { enqueueConcurrentClassUpdate, unsafe_markUpdateLaneFromFiberToRoot } from './ReactFiberConcurrentUpdates';\nimport { setIsStrictModeForDevtools } from './ReactFiberDevToolsHook';\nimport assign from 'shared/assign';\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\n\nlet hasForceUpdate = false;\nlet didWarnUpdateInsideUpdate;\nlet currentlyProcessingQueue;\nexport let resetCurrentlyProcessingQueue;\n\nif (__DEV__) {\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n\n  resetCurrentlyProcessingQueue = () => {\n    currentlyProcessingQueue = null;\n  };\n}\n\nexport function initializeUpdateQueue(fiber) {\n  const queue = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      lanes: NoLanes,\n      hiddenCallbacks: null\n    },\n    callbacks: null\n  };\n  fiber.updateQueue = queue;\n}\nexport function cloneUpdateQueue(current, workInProgress) {\n  // Clone the update queue from current. Unless it's already a clone.\n  const queue = workInProgress.updateQueue;\n  const currentQueue = current.updateQueue;\n\n  if (queue === currentQueue) {\n    const clone = {\n      baseState: currentQueue.baseState,\n      firstBaseUpdate: currentQueue.firstBaseUpdate,\n      lastBaseUpdate: currentQueue.lastBaseUpdate,\n      shared: currentQueue.shared,\n      callbacks: null\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\nexport function createUpdate(eventTime, lane) {\n  const update = {\n    eventTime,\n    lane,\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n    next: null\n  };\n  return update;\n}\nexport function enqueueUpdate(fiber, update, lane) {\n  const updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return null;\n  }\n\n  const sharedQueue = updateQueue.shared;\n\n  if (__DEV__) {\n    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n      const componentName = getComponentNameFromFiber(fiber);\n      console.error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.\\n\\nPlease update the following component: %s', componentName);\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  if (isUnsafeClassRenderPhaseUpdate(fiber)) {\n    // This is an unsafe render phase update. Add directly to the update\n    // queue so we can process it immediately during the current render.\n    const pending = sharedQueue.pending;\n\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n\n    sharedQueue.pending = update; // Update the childLanes even though we're most likely already rendering\n    // this fiber. This is for backwards compatibility in the case where you\n    // update a different component during render phase than the one that is\n    // currently renderings (a pattern that is accompanied by a warning).\n\n    return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n  } else {\n    return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n  }\n}\nexport function entangleTransitions(root, fiber, lane) {\n  const updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  const sharedQueue = updateQueue.shared;\n\n  if (isTransitionLane(lane)) {\n    let queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n    // have finished. We can remove them from the shared queue, which represents\n    // a superset of the actually pending lanes. In some cases we may entangle\n    // more than we need to, but that's OK. In fact it's worse if we *don't*\n    // entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    const newQueueLanes = mergeLanes(queueLanes, lane);\n    sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\nexport function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n  // Captured updates are updates that are thrown by a child during the render\n  // phase. They should be discarded if the render is aborted. Therefore,\n  // we should only put them on the work-in-progress queue, not the current one.\n  let queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n\n  const current = workInProgress.alternate;\n\n  if (current !== null) {\n    const currentQueue = current.updateQueue;\n\n    if (queue === currentQueue) {\n      // The work-in-progress queue is the same as current. This happens when\n      // we bail out on a parent fiber that then captures an error thrown by\n      // a child. Since we want to append the update only to the work-in\n      // -progress queue, we need to clone the updates. We usually clone during\n      // processUpdateQueue, but that didn't happen in this case because we\n      // skipped over the parent when we bailed out.\n      let newFirst = null;\n      let newLast = null;\n      const firstBaseUpdate = queue.firstBaseUpdate;\n\n      if (firstBaseUpdate !== null) {\n        // Loop through the updates and clone them.\n        let update = firstBaseUpdate;\n\n        do {\n          const clone = {\n            eventTime: update.eventTime,\n            lane: update.lane,\n            tag: update.tag,\n            payload: update.payload,\n            // When this update is rebased, we should not fire its\n            // callback again.\n            callback: null,\n            next: null\n          };\n\n          if (newLast === null) {\n            newFirst = newLast = clone;\n          } else {\n            newLast.next = clone;\n            newLast = clone;\n          } // $FlowFixMe[incompatible-type] we bail out when we get a null\n\n\n          update = update.next;\n        } while (update !== null); // Append the captured update the end of the cloned list.\n\n\n        if (newLast === null) {\n          newFirst = newLast = capturedUpdate;\n        } else {\n          newLast.next = capturedUpdate;\n          newLast = capturedUpdate;\n        }\n      } else {\n        // There are no base updates.\n        newFirst = newLast = capturedUpdate;\n      }\n\n      queue = {\n        baseState: currentQueue.baseState,\n        firstBaseUpdate: newFirst,\n        lastBaseUpdate: newLast,\n        shared: currentQueue.shared,\n        callbacks: currentQueue.callbacks\n      };\n      workInProgress.updateQueue = queue;\n      return;\n    }\n  } // Append the update to the end of the list.\n\n\n  const lastBaseUpdate = queue.lastBaseUpdate;\n\n  if (lastBaseUpdate === null) {\n    queue.firstBaseUpdate = capturedUpdate;\n  } else {\n    lastBaseUpdate.next = capturedUpdate;\n  }\n\n  queue.lastBaseUpdate = capturedUpdate;\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        const payload = update.payload;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          if (__DEV__) {\n            enterDisallowedContextReadInDEV();\n          }\n\n          const nextState = payload.call(instance, prevState, nextProps);\n\n          if (__DEV__) {\n            if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n\n          return nextState;\n        } // State object\n\n\n        return payload;\n      }\n\n    case CaptureUpdate:\n      {\n        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n\n    case UpdateState:\n      {\n        const payload = update.payload;\n        let partialState;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          if (__DEV__) {\n            enterDisallowedContextReadInDEV();\n          }\n\n          partialState = payload.call(instance, prevState, nextProps);\n\n          if (__DEV__) {\n            if (debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n        } else {\n          // Partial state object\n          partialState = payload;\n        }\n\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        } // Merge the partial state and the previous state.\n\n\n        return assign({}, prevState, partialState);\n      }\n\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n\n  return prevState;\n}\n\nexport function processUpdateQueue(workInProgress, props, instance, renderLanes) {\n  // This is always non-null on a ClassComponent or HostRoot\n  const queue = workInProgress.updateQueue;\n  hasForceUpdate = false;\n\n  if (__DEV__) {\n    // $FlowFixMe[escaped-generic] discovered when updating Flow\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  let firstBaseUpdate = queue.firstBaseUpdate;\n  let lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n\n  let pendingQueue = queue.shared.pending;\n\n  if (pendingQueue !== null) {\n    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n    // and last so that it's non-circular.\n\n    const lastPendingUpdate = pendingQueue;\n    const firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null; // Append pending updates to base queue\n\n    if (lastBaseUpdate === null) {\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n\n    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n    // we need to transfer the updates to that queue, too. Because the base\n    // queue is a singly-linked list with no cycles, we can append to both\n    // lists and take advantage of structural sharing.\n    // TODO: Pass `current` as argument\n\n    const current = workInProgress.alternate;\n\n    if (current !== null) {\n      // This is always non-null on a ClassComponent or HostRoot\n      const currentQueue = current.updateQueue;\n      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  } // These values may change as we process the queue.\n\n\n  if (firstBaseUpdate !== null) {\n    // Iterate through the list of updates to compute the result.\n    let newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n    // from the original lanes.\n\n    let newLanes = NoLanes;\n    let newBaseState = null;\n    let newFirstBaseUpdate = null;\n    let newLastBaseUpdate = null;\n    let update = firstBaseUpdate;\n\n    do {\n      // TODO: Don't need this field anymore\n      const updateEventTime = update.eventTime; // An extra OffscreenLane bit is added to updates that were made to\n      // a hidden tree, so that we can distinguish them from updates that were\n      // already there when the tree was hidden.\n\n      const updateLane = removeLanes(update.lane, OffscreenLane);\n      const isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then\n      // it's not a \"base\" update and we should disregard the extra base lanes\n      // that were added to renderLanes when we entered the Offscreen tree.\n\n      const shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);\n\n      if (shouldSkipUpdate) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone = {\n          eventTime: updateEventTime,\n          lane: updateLane,\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n          next: null\n        };\n\n        if (newLastBaseUpdate === null) {\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        } // Update the remaining priority in the queue.\n\n\n        newLanes = mergeLanes(newLanes, updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newLastBaseUpdate !== null) {\n          const clone = {\n            eventTime: updateEventTime,\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            tag: update.tag,\n            payload: update.payload,\n            // When this update is rebased, we should not fire its\n            // callback again.\n            callback: null,\n            next: null\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        } // Process this update.\n\n\n        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n        const callback = update.callback;\n\n        if (callback !== null) {\n          workInProgress.flags |= Callback;\n\n          if (isHiddenUpdate) {\n            workInProgress.flags |= Visibility;\n          }\n\n          const callbacks = queue.callbacks;\n\n          if (callbacks === null) {\n            queue.callbacks = [callback];\n          } else {\n            callbacks.push(callback);\n          }\n        }\n      } // $FlowFixMe[incompatible-type] we bail out when we get a null\n\n\n      update = update.next;\n\n      if (update === null) {\n        pendingQueue = queue.shared.pending;\n\n        if (pendingQueue === null) {\n          break;\n        } else {\n          // An update was scheduled from inside a reducer. Add the new\n          // pending updates to the end of the list and keep processing.\n          const lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n          // unravel them when transferring them to the base queue.\n\n          const firstPendingUpdate = lastPendingUpdate.next;\n          lastPendingUpdate.next = null;\n          update = firstPendingUpdate;\n          queue.lastBaseUpdate = lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n\n    queue.baseState = newBaseState;\n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate;\n\n    if (firstBaseUpdate === null) {\n      // `queue.lanes` is used for entangling transitions. We can set it back to\n      // zero once the queue is empty.\n      queue.shared.lanes = NoLanes;\n    } // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n\n\n    markSkippedUpdateLanes(newLanes);\n    workInProgress.lanes = newLanes;\n    workInProgress.memoizedState = newState;\n  }\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  if (typeof callback !== 'function') {\n    throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + `received: ${callback}`);\n  }\n\n  callback.call(context);\n}\n\nexport function resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\nexport function checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\nexport function deferHiddenCallbacks(updateQueue) {\n  // When an update finishes on a hidden component, its callback should not\n  // be fired until/unless the component is made visible again. Stash the\n  // callback on the shared queue object so it can be fired later.\n  const newHiddenCallbacks = updateQueue.callbacks;\n\n  if (newHiddenCallbacks !== null) {\n    const existingHiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n\n    if (existingHiddenCallbacks === null) {\n      updateQueue.shared.hiddenCallbacks = newHiddenCallbacks;\n    } else {\n      updateQueue.shared.hiddenCallbacks = existingHiddenCallbacks.concat(newHiddenCallbacks);\n    }\n  }\n}\nexport function commitHiddenCallbacks(updateQueue, context) {\n  // This component is switching from hidden -> visible. Commit any callbacks\n  // that were previously deferred.\n  const hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n\n  if (hiddenCallbacks !== null) {\n    updateQueue.shared.hiddenCallbacks = null;\n\n    for (let i = 0; i < hiddenCallbacks.length; i++) {\n      const callback = hiddenCallbacks[i];\n      callCallback(callback, context);\n    }\n  }\n}\nexport function commitCallbacks(updateQueue, context) {\n  const callbacks = updateQueue.callbacks;\n\n  if (callbacks !== null) {\n    updateQueue.callbacks = null;\n\n    for (let i = 0; i < callbacks.length; i++) {\n      const callback = callbacks[i];\n      callCallback(callback, context);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberClassUpdateQueue.js"],"names":["NoLane","NoLanes","OffscreenLane","isSubsetOfLanes","mergeLanes","removeLanes","isTransitionLane","intersectLanes","markRootEntangled","enterDisallowedContextReadInDEV","exitDisallowedContextReadInDEV","Callback","Visibility","ShouldCapture","DidCapture","getComponentNameFromFiber","debugRenderPhaseSideEffectsForStrictMode","StrictLegacyMode","markSkippedUpdateLanes","isUnsafeClassRenderPhaseUpdate","getWorkInProgressRootRenderLanes","enqueueConcurrentClassUpdate","unsafe_markUpdateLaneFromFiberToRoot","setIsStrictModeForDevtools","assign","UpdateState","ReplaceState","ForceUpdate","CaptureUpdate","hasForceUpdate","didWarnUpdateInsideUpdate","currentlyProcessingQueue","resetCurrentlyProcessingQueue","__DEV__","initializeUpdateQueue","fiber","queue","baseState","memoizedState","firstBaseUpdate","lastBaseUpdate","shared","pending","lanes","hiddenCallbacks","callbacks","updateQueue","cloneUpdateQueue","current","workInProgress","currentQueue","clone","createUpdate","eventTime","lane","update","tag","payload","callback","next","enqueueUpdate","sharedQueue","componentName","console","error","entangleTransitions","root","queueLanes","pendingLanes","newQueueLanes","enqueueCapturedUpdate","capturedUpdate","alternate","newFirst","newLast","getStateFromUpdate","prevState","nextProps","instance","nextState","call","mode","flags","partialState","undefined","processUpdateQueue","props","renderLanes","pendingQueue","lastPendingUpdate","firstPendingUpdate","currentLastBaseUpdate","newState","newLanes","newBaseState","newFirstBaseUpdate","newLastBaseUpdate","updateEventTime","updateLane","isHiddenUpdate","shouldSkipUpdate","push","callCallback","context","Error","resetHasForceUpdateBeforeProcessing","checkHasForceUpdateAfterProcessing","deferHiddenCallbacks","newHiddenCallbacks","existingHiddenCallbacks","concat","commitHiddenCallbacks","i","length","commitCallbacks"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA,SACEA,MADF,EAEEC,OAFF,EAGEC,aAHF,EAIEC,eAJF,EAKEC,UALF,EAMEC,WANF,EAOEC,gBAPF,EAQEC,cARF,EASEC,iBATF,QAUO,kBAVP;AAWA,SACEC,+BADF,EAEEC,8BAFF,QAGO,wBAHP;AAIA,SACEC,QADF,EAEEC,UAFF,EAGEC,aAHF,EAIEC,UAJF,QAKO,mBALP;AAMA,OAAOC,yBAAP,MAAsC,6BAAtC;AAEA,SAAQC,wCAAR,QAAuD,0BAAvD;AAEA,SAAQC,gBAAR,QAA+B,mBAA/B;AACA,SACEC,sBADF,EAEEC,8BAFF,EAGEC,gCAHF,QAIO,sBAJP;AAKA,SACEC,4BADF,EAEEC,oCAFF,QAGO,+BAHP;AAIA,SAAQC,0BAAR,QAAyC,0BAAzC;AAEA,OAAOC,MAAP,MAAmB,eAAnB;AA6BA,OAAO,MAAMC,WAAW,GAAG,CAApB;AACP,OAAO,MAAMC,YAAY,GAAG,CAArB;AACP,OAAO,MAAMC,WAAW,GAAG,CAApB;AACP,OAAO,MAAMC,aAAa,GAAG,CAAtB,C,CAEP;AACA;AACA;;AACA,IAAIC,cAAc,GAAG,KAArB;AAEA,IAAIC,yBAAJ;AACA,IAAIC,wBAAJ;AACA,OAAO,IAAIC,6BAAJ;;AACP,IAAIC,OAAJ,EAAa;AACXH,EAAAA,yBAAyB,GAAG,KAA5B;AACAC,EAAAA,wBAAwB,GAAG,IAA3B;;AACAC,EAAA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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which can be\n// mutated and processed asynchronously before it is committed â€” a form of\n// double buffering. If a work-in-progress render is discarded before finishing,\n// we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Lanes, Lane} from './ReactFiberLane';\n\nimport {\n  NoLane,\n  NoLanes,\n  OffscreenLane,\n  isSubsetOfLanes,\n  mergeLanes,\n  removeLanes,\n  isTransitionLane,\n  intersectLanes,\n  markRootEntangled,\n} from './ReactFiberLane';\nimport {\n  enterDisallowedContextReadInDEV,\n  exitDisallowedContextReadInDEV,\n} from './ReactFiberNewContext';\nimport {\n  Callback,\n  Visibility,\n  ShouldCapture,\n  DidCapture,\n} from './ReactFiberFlags';\nimport getComponentNameFromFiber from './getComponentNameFromFiber';\n\nimport {debugRenderPhaseSideEffectsForStrictMode} from 'shared/ReactFeatureFlags';\n\nimport {StrictLegacyMode} from './ReactTypeOfMode';\nimport {\n  markSkippedUpdateLanes,\n  isUnsafeClassRenderPhaseUpdate,\n  getWorkInProgressRootRenderLanes,\n} from './ReactFiberWorkLoop';\nimport {\n  enqueueConcurrentClassUpdate,\n  unsafe_markUpdateLaneFromFiberToRoot,\n} from './ReactFiberConcurrentUpdates';\nimport {setIsStrictModeForDevtools} from './ReactFiberDevToolsHook';\n\nimport assign from 'shared/assign';\n\nexport type Update<State> = {\n  // TODO: Temporary field. Will remove this by storing a map of\n  // transition -> event time on the root.\n  eventTime: number,\n  lane: Lane,\n\n  tag: 0 | 1 | 2 | 3,\n  payload: any,\n  callback: (() => mixed) | null,\n\n  next: Update<State> | null,\n};\n\nexport type SharedQueue<State> = {\n  pending: Update<State> | null,\n  lanes: Lanes,\n  hiddenCallbacks: Array<() => mixed> | null,\n};\n\nexport type UpdateQueue<State> = {\n  baseState: State,\n  firstBaseUpdate: Update<State> | null,\n  lastBaseUpdate: Update<State> | null,\n  shared: SharedQueue<State>,\n  callbacks: Array<() => mixed> | null,\n};\n\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nlet hasForceUpdate = false;\n\nlet didWarnUpdateInsideUpdate;\nlet currentlyProcessingQueue;\nexport let resetCurrentlyProcessingQueue: () => void;\nif (__DEV__) {\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = () => {\n    currentlyProcessingQueue = null;\n  };\n}\n\nexport function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      lanes: NoLanes,\n      hiddenCallbacks: null,\n    },\n    callbacks: null,\n  };\n  fiber.updateQueue = queue;\n}\n\nexport function cloneUpdateQueue<State>(\n  current: Fiber,\n  workInProgress: Fiber,\n): void {\n  // Clone the update queue from current. Unless it's already a clone.\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n  const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n  if (queue === currentQueue) {\n    const clone: UpdateQueue<State> = {\n      baseState: currentQueue.baseState,\n      firstBaseUpdate: currentQueue.firstBaseUpdate,\n      lastBaseUpdate: currentQueue.lastBaseUpdate,\n      shared: currentQueue.shared,\n      callbacks: null,\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\n\nexport function createUpdate(eventTime: number, lane: Lane): Update<mixed> {\n  const update: Update<mixed> = {\n    eventTime,\n    lane,\n\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n\n    next: null,\n  };\n  return update;\n}\n\nexport function enqueueUpdate<State>(\n  fiber: Fiber,\n  update: Update<State>,\n  lane: Lane,\n): FiberRoot | null {\n  const updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return null;\n  }\n\n  const sharedQueue: SharedQueue<State> = (updateQueue: any).shared;\n\n  if (__DEV__) {\n    if (\n      currentlyProcessingQueue === sharedQueue &&\n      !didWarnUpdateInsideUpdate\n    ) {\n      const componentName = getComponentNameFromFiber(fiber);\n      console.error(\n        'An update (setState, replaceState, or forceUpdate) was scheduled ' +\n          'from inside an update function. Update functions should be pure, ' +\n          'with zero side-effects. Consider using componentDidUpdate or a ' +\n          'callback.\\n\\nPlease update the following component: %s',\n        componentName,\n      );\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n\n  if (isUnsafeClassRenderPhaseUpdate(fiber)) {\n    // This is an unsafe render phase update. Add directly to the update\n    // queue so we can process it immediately during the current render.\n    const pending = sharedQueue.pending;\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n    sharedQueue.pending = update;\n\n    // Update the childLanes even though we're most likely already rendering\n    // this fiber. This is for backwards compatibility in the case where you\n    // update a different component during render phase than the one that is\n    // currently renderings (a pattern that is accompanied by a warning).\n    return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n  } else {\n    return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n  }\n}\n\nexport function entangleTransitions(root: FiberRoot, fiber: Fiber, lane: Lane) {\n  const updateQueue = fiber.updateQueue;\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  const sharedQueue: SharedQueue<mixed> = (updateQueue: any).shared;\n  if (isTransitionLane(lane)) {\n    let queueLanes = sharedQueue.lanes;\n\n    // If any entangled lanes are no longer pending on the root, then they must\n    // have finished. We can remove them from the shared queue, which represents\n    // a superset of the actually pending lanes. In some cases we may entangle\n    // more than we need to, but that's OK. In fact it's worse if we *don't*\n    // entangle when we should.\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes);\n\n    // Entangle the new transition lane with the other transition lanes.\n    const newQueueLanes = mergeLanes(queueLanes, lane);\n    sharedQueue.lanes = newQueueLanes;\n    // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n    markRootEntangled(root, newQueueLanes);\n  }\n}\n\nexport function enqueueCapturedUpdate<State>(\n  workInProgress: Fiber,\n  capturedUpdate: Update<State>,\n) {\n  // Captured updates are updates that are thrown by a child during the render\n  // phase. They should be discarded if the render is aborted. Therefore,\n  // we should only put them on the work-in-progress queue, not the current one.\n  let queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n\n  // Check if the work-in-progress queue is a clone.\n  const current = workInProgress.alternate;\n  if (current !== null) {\n    const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n    if (queue === currentQueue) {\n      // The work-in-progress queue is the same as current. This happens when\n      // we bail out on a parent fiber that then captures an error thrown by\n      // a child. Since we want to append the update only to the work-in\n      // -progress queue, we need to clone the updates. We usually clone during\n      // processUpdateQueue, but that didn't happen in this case because we\n      // skipped over the parent when we bailed out.\n      let newFirst = null;\n      let newLast = null;\n      const firstBaseUpdate = queue.firstBaseUpdate;\n      if (firstBaseUpdate !== null) {\n        // Loop through the updates and clone them.\n        let update: Update<State> = firstBaseUpdate;\n        do {\n          const clone: Update<State> = {\n            eventTime: update.eventTime,\n            lane: update.lane,\n\n            tag: update.tag,\n            payload: update.payload,\n            // When this update is rebased, we should not fire its\n            // callback again.\n            callback: null,\n\n            next: null,\n          };\n          if (newLast === null) {\n            newFirst = newLast = clone;\n          } else {\n            newLast.next = clone;\n            newLast = clone;\n          }\n          // $FlowFixMe[incompatible-type] we bail out when we get a null\n          update = update.next;\n        } while (update !== null);\n\n        // Append the captured update the end of the cloned list.\n        if (newLast === null) {\n          newFirst = newLast = capturedUpdate;\n        } else {\n          newLast.next = capturedUpdate;\n          newLast = capturedUpdate;\n        }\n      } else {\n        // There are no base updates.\n        newFirst = newLast = capturedUpdate;\n      }\n      queue = {\n        baseState: currentQueue.baseState,\n        firstBaseUpdate: newFirst,\n        lastBaseUpdate: newLast,\n        shared: currentQueue.shared,\n        callbacks: currentQueue.callbacks,\n      };\n      workInProgress.updateQueue = queue;\n      return;\n    }\n  }\n\n  // Append the update to the end of the list.\n  const lastBaseUpdate = queue.lastBaseUpdate;\n  if (lastBaseUpdate === null) {\n    queue.firstBaseUpdate = capturedUpdate;\n  } else {\n    lastBaseUpdate.next = capturedUpdate;\n  }\n  queue.lastBaseUpdate = capturedUpdate;\n}\n\nfunction getStateFromUpdate<State>(\n  workInProgress: Fiber,\n  queue: UpdateQueue<State>,\n  update: Update<State>,\n  prevState: State,\n  nextProps: any,\n  instance: any,\n): any {\n  switch (update.tag) {\n    case ReplaceState: {\n      const payload = update.payload;\n      if (typeof payload === 'function') {\n        // Updater function\n        if (__DEV__) {\n          enterDisallowedContextReadInDEV();\n        }\n        const nextState = payload.call(instance, prevState, nextProps);\n        if (__DEV__) {\n          if (\n            debugRenderPhaseSideEffectsForStrictMode &&\n            workInProgress.mode & StrictLegacyMode\n          ) {\n            setIsStrictModeForDevtools(true);\n            try {\n              payload.call(instance, prevState, nextProps);\n            } finally {\n              setIsStrictModeForDevtools(false);\n            }\n          }\n          exitDisallowedContextReadInDEV();\n        }\n        return nextState;\n      }\n      // State object\n      return payload;\n    }\n    case CaptureUpdate: {\n      workInProgress.flags =\n        (workInProgress.flags & ~ShouldCapture) | DidCapture;\n    }\n    // Intentional fallthrough\n    case UpdateState: {\n      const payload = update.payload;\n      let partialState;\n      if (typeof payload === 'function') {\n        // Updater function\n        if (__DEV__) {\n          enterDisallowedContextReadInDEV();\n        }\n        partialState = payload.call(instance, prevState, nextProps);\n        if (__DEV__) {\n          if (\n            debugRenderPhaseSideEffectsForStrictMode &&\n            workInProgress.mode & StrictLegacyMode\n          ) {\n            setIsStrictModeForDevtools(true);\n            try {\n              payload.call(instance, prevState, nextProps);\n            } finally {\n              setIsStrictModeForDevtools(false);\n            }\n          }\n          exitDisallowedContextReadInDEV();\n        }\n      } else {\n        // Partial state object\n        partialState = payload;\n      }\n      if (partialState === null || partialState === undefined) {\n        // Null and undefined are treated as no-ops.\n        return prevState;\n      }\n      // Merge the partial state and the previous state.\n      return assign({}, prevState, partialState);\n    }\n    case ForceUpdate: {\n      hasForceUpdate = true;\n      return prevState;\n    }\n  }\n  return prevState;\n}\n\nexport function processUpdateQueue<State>(\n  workInProgress: Fiber,\n  props: any,\n  instance: any,\n  renderLanes: Lanes,\n): void {\n  // This is always non-null on a ClassComponent or HostRoot\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n\n  hasForceUpdate = false;\n\n  if (__DEV__) {\n    // $FlowFixMe[escaped-generic] discovered when updating Flow\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  let firstBaseUpdate = queue.firstBaseUpdate;\n  let lastBaseUpdate = queue.lastBaseUpdate;\n\n  // Check if there are pending updates. If so, transfer them to the base queue.\n  let pendingQueue = queue.shared.pending;\n  if (pendingQueue !== null) {\n    queue.shared.pending = null;\n\n    // The pending queue is circular. Disconnect the pointer between first\n    // and last so that it's non-circular.\n    const lastPendingUpdate = pendingQueue;\n    const firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null;\n    // Append pending updates to base queue\n    if (lastBaseUpdate === null) {\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n    lastBaseUpdate = lastPendingUpdate;\n\n    // If there's a current queue, and it's different from the base queue, then\n    // we need to transfer the updates to that queue, too. Because the base\n    // queue is a singly-linked list with no cycles, we can append to both\n    // lists and take advantage of structural sharing.\n    // TODO: Pass `current` as argument\n    const current = workInProgress.alternate;\n    if (current !== null) {\n      // This is always non-null on a ClassComponent or HostRoot\n      const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  }\n\n  // These values may change as we process the queue.\n  if (firstBaseUpdate !== null) {\n    // Iterate through the list of updates to compute the result.\n    let newState = queue.baseState;\n    // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n    // from the original lanes.\n    let newLanes = NoLanes;\n\n    let newBaseState = null;\n    let newFirstBaseUpdate = null;\n    let newLastBaseUpdate = null;\n\n    let update: Update<State> = firstBaseUpdate;\n    do {\n      // TODO: Don't need this field anymore\n      const updateEventTime = update.eventTime;\n\n      // An extra OffscreenLane bit is added to updates that were made to\n      // a hidden tree, so that we can distinguish them from updates that were\n      // already there when the tree was hidden.\n      const updateLane = removeLanes(update.lane, OffscreenLane);\n      const isHiddenUpdate = updateLane !== update.lane;\n\n      // Check if this update was made while the tree was hidden. If so, then\n      // it's not a \"base\" update and we should disregard the extra base lanes\n      // that were added to renderLanes when we entered the Offscreen tree.\n      const shouldSkipUpdate = isHiddenUpdate\n        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)\n        : !isSubsetOfLanes(renderLanes, updateLane);\n\n      if (shouldSkipUpdate) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone: Update<State> = {\n          eventTime: updateEventTime,\n          lane: updateLane,\n\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n\n          next: null,\n        };\n        if (newLastBaseUpdate === null) {\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        }\n        // Update the remaining priority in the queue.\n        newLanes = mergeLanes(newLanes, updateLane);\n      } else {\n        // This update does have sufficient priority.\n\n        if (newLastBaseUpdate !== null) {\n          const clone: Update<State> = {\n            eventTime: updateEventTime,\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n\n            tag: update.tag,\n            payload: update.payload,\n\n            // When this update is rebased, we should not fire its\n            // callback again.\n            callback: null,\n\n            next: null,\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        }\n\n        // Process this update.\n        newState = getStateFromUpdate(\n          workInProgress,\n          queue,\n          update,\n          newState,\n          props,\n          instance,\n        );\n        const callback = update.callback;\n        if (callback !== null) {\n          workInProgress.flags |= Callback;\n          if (isHiddenUpdate) {\n            workInProgress.flags |= Visibility;\n          }\n          const callbacks = queue.callbacks;\n          if (callbacks === null) {\n            queue.callbacks = [callback];\n          } else {\n            callbacks.push(callback);\n          }\n        }\n      }\n      // $FlowFixMe[incompatible-type] we bail out when we get a null\n      update = update.next;\n      if (update === null) {\n        pendingQueue = queue.shared.pending;\n        if (pendingQueue === null) {\n          break;\n        } else {\n          // An update was scheduled from inside a reducer. Add the new\n          // pending updates to the end of the list and keep processing.\n          const lastPendingUpdate = pendingQueue;\n          // Intentionally unsound. Pending updates form a circular list, but we\n          // unravel them when transferring them to the base queue.\n          const firstPendingUpdate = ((lastPendingUpdate.next: any): Update<State>);\n          lastPendingUpdate.next = null;\n          update = firstPendingUpdate;\n          queue.lastBaseUpdate = lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n\n    queue.baseState = ((newBaseState: any): State);\n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate;\n\n    if (firstBaseUpdate === null) {\n      // `queue.lanes` is used for entangling transitions. We can set it back to\n      // zero once the queue is empty.\n      queue.shared.lanes = NoLanes;\n    }\n\n    // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n    markSkippedUpdateLanes(newLanes);\n    workInProgress.lanes = newLanes;\n    workInProgress.memoizedState = newState;\n  }\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  if (typeof callback !== 'function') {\n    throw new Error(\n      'Invalid argument passed as callback. Expected a function. Instead ' +\n        `received: ${callback}`,\n    );\n  }\n\n  callback.call(context);\n}\n\nexport function resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nexport function checkHasForceUpdateAfterProcessing(): boolean {\n  return hasForceUpdate;\n}\n\nexport function deferHiddenCallbacks<State>(\n  updateQueue: UpdateQueue<State>,\n): void {\n  // When an update finishes on a hidden component, its callback should not\n  // be fired until/unless the component is made visible again. Stash the\n  // callback on the shared queue object so it can be fired later.\n  const newHiddenCallbacks = updateQueue.callbacks;\n  if (newHiddenCallbacks !== null) {\n    const existingHiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n    if (existingHiddenCallbacks === null) {\n      updateQueue.shared.hiddenCallbacks = newHiddenCallbacks;\n    } else {\n      updateQueue.shared.hiddenCallbacks = existingHiddenCallbacks.concat(\n        newHiddenCallbacks,\n      );\n    }\n  }\n}\n\nexport function commitHiddenCallbacks<State>(\n  updateQueue: UpdateQueue<State>,\n  context: any,\n): void {\n  // This component is switching from hidden -> visible. Commit any callbacks\n  // that were previously deferred.\n  const hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n  if (hiddenCallbacks !== null) {\n    updateQueue.shared.hiddenCallbacks = null;\n    for (let i = 0; i < hiddenCallbacks.length; i++) {\n      const callback = hiddenCallbacks[i];\n      callCallback(callback, context);\n    }\n  }\n}\n\nexport function commitCallbacks<State>(\n  updateQueue: UpdateQueue<State>,\n  context: any,\n): void {\n  const callbacks = updateQueue.callbacks;\n  if (callbacks !== null) {\n    updateQueue.callbacks = null;\n    for (let i = 0; i < callbacks.length; i++) {\n      const callback = callbacks[i];\n      callCallback(callback, context);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}