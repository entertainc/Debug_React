{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableProfiling } from './SchedulerFeatureFlags';\nlet runIdCounter = 0;\nlet mainThreadIdCounter = 0; // Bytes per element is 4\n\nconst INITIAL_EVENT_LOG_SIZE = 131072;\nconst MAX_EVENT_LOG_SIZE = 524288; // Equivalent to 2 megabytes\n\nlet eventLogSize = 0;\nlet eventLogBuffer = null;\nlet eventLog = null;\nlet eventLogIndex = 0;\nconst TaskStartEvent = 1;\nconst TaskCompleteEvent = 2;\nconst TaskErrorEvent = 3;\nconst TaskCancelEvent = 4;\nconst TaskRunEvent = 5;\nconst TaskYieldEvent = 6;\nconst SchedulerSuspendEvent = 7;\nconst SchedulerResumeEvent = 8;\n\nfunction logEvent(entries) {\n  if (eventLog !== null) {\n    const offset = eventLogIndex;\n    eventLogIndex += entries.length;\n\n    if (eventLogIndex + 1 > eventLogSize) {\n      eventLogSize *= 2;\n\n      if (eventLogSize > MAX_EVENT_LOG_SIZE) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error'](\"Scheduler Profiling: Event log exceeded maximum size. Don't \" + 'forget to call `stopLoggingProfilingEvents()`.');\n        stopLoggingProfilingEvents();\n        return;\n      }\n\n      const newEventLog = new Int32Array(eventLogSize * 4); // $FlowFixMe[incompatible-call] found when upgrading Flow\n\n      newEventLog.set(eventLog);\n      eventLogBuffer = newEventLog.buffer;\n      eventLog = newEventLog;\n    }\n\n    eventLog.set(entries, offset);\n  }\n}\n\nexport function startLoggingProfilingEvents() {\n  eventLogSize = INITIAL_EVENT_LOG_SIZE;\n  eventLogBuffer = new ArrayBuffer(eventLogSize * 4);\n  eventLog = new Int32Array(eventLogBuffer);\n  eventLogIndex = 0;\n}\nexport function stopLoggingProfilingEvents() {\n  const buffer = eventLogBuffer;\n  eventLogSize = 0;\n  eventLogBuffer = null;\n  eventLog = null;\n  eventLogIndex = 0;\n  return buffer;\n}\nexport function markTaskStart(task, ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      // performance.now returns a float, representing milliseconds. When the\n      // event is logged, it's coerced to an int. Convert to microseconds to\n      // maintain extra degrees of precision.\n      logEvent([TaskStartEvent, ms * 1000, task.id, task.priorityLevel]);\n    }\n  }\n}\nexport function markTaskCompleted(task, ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskCompleteEvent, ms * 1000, task.id]);\n    }\n  }\n}\nexport function markTaskCanceled(task, ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskCancelEvent, ms * 1000, task.id]);\n    }\n  }\n}\nexport function markTaskErrored(task, ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskErrorEvent, ms * 1000, task.id]);\n    }\n  }\n}\nexport function markTaskRun(task, ms) {\n  if (enableProfiling) {\n    runIdCounter++;\n\n    if (eventLog !== null) {\n      logEvent([TaskRunEvent, ms * 1000, task.id, runIdCounter]);\n    }\n  }\n}\nexport function markTaskYield(task, ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskYieldEvent, ms * 1000, task.id, runIdCounter]);\n    }\n  }\n}\nexport function markSchedulerSuspended(ms) {\n  if (enableProfiling) {\n    mainThreadIdCounter++;\n\n    if (eventLog !== null) {\n      logEvent([SchedulerSuspendEvent, ms * 1000, mainThreadIdCounter]);\n    }\n  }\n}\nexport function markSchedulerUnsuspended(ms) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([SchedulerResumeEvent, ms * 1000, mainThreadIdCounter]);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/scheduler/src/SchedulerProfiling.js"],"names":["enableProfiling","runIdCounter","mainThreadIdCounter","INITIAL_EVENT_LOG_SIZE","MAX_EVENT_LOG_SIZE","eventLogSize","eventLogBuffer","eventLog","eventLogIndex","TaskStartEvent","TaskCompleteEvent","TaskErrorEvent","TaskCancelEvent","TaskRunEvent","TaskYieldEvent","SchedulerSuspendEvent","SchedulerResumeEvent","logEvent","entries","offset","length","console","stopLoggingProfilingEvents","newEventLog","Int32Array","set","buffer","startLoggingProfilingEvents","ArrayBuffer","markTaskStart","task","ms","id","priorityLevel","markTaskCompleted","markTaskCanceled","markTaskErrored","markTaskRun","markTaskYield","markSchedulerSuspended","markSchedulerUnsuspended"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {PriorityLevel} from './SchedulerPriorities';\nimport {enableProfiling} from './SchedulerFeatureFlags';\n\nlet runIdCounter: number = 0;\nlet mainThreadIdCounter: number = 0;\n\n// Bytes per element is 4\nconst INITIAL_EVENT_LOG_SIZE = 131072;\nconst MAX_EVENT_LOG_SIZE = 524288; // Equivalent to 2 megabytes\n\nlet eventLogSize = 0;\nlet eventLogBuffer = null;\nlet eventLog = null;\nlet eventLogIndex = 0;\n\nconst TaskStartEvent = 1;\nconst TaskCompleteEvent = 2;\nconst TaskErrorEvent = 3;\nconst TaskCancelEvent = 4;\nconst TaskRunEvent = 5;\nconst TaskYieldEvent = 6;\nconst SchedulerSuspendEvent = 7;\nconst SchedulerResumeEvent = 8;\n\nfunction logEvent(entries: Array<number | PriorityLevel>) {\n  if (eventLog !== null) {\n    const offset = eventLogIndex;\n    eventLogIndex += entries.length;\n    if (eventLogIndex + 1 > eventLogSize) {\n      eventLogSize *= 2;\n      if (eventLogSize > MAX_EVENT_LOG_SIZE) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error'](\n          \"Scheduler Profiling: Event log exceeded maximum size. Don't \" +\n            'forget to call `stopLoggingProfilingEvents()`.',\n        );\n        stopLoggingProfilingEvents();\n        return;\n      }\n      const newEventLog = new Int32Array(eventLogSize * 4);\n      // $FlowFixMe[incompatible-call] found when upgrading Flow\n      newEventLog.set(eventLog);\n      eventLogBuffer = newEventLog.buffer;\n      eventLog = newEventLog;\n    }\n    eventLog.set(entries, offset);\n  }\n}\n\nexport function startLoggingProfilingEvents(): void {\n  eventLogSize = INITIAL_EVENT_LOG_SIZE;\n  eventLogBuffer = new ArrayBuffer(eventLogSize * 4);\n  eventLog = new Int32Array(eventLogBuffer);\n  eventLogIndex = 0;\n}\n\nexport function stopLoggingProfilingEvents(): ArrayBuffer | null {\n  const buffer = eventLogBuffer;\n  eventLogSize = 0;\n  eventLogBuffer = null;\n  eventLog = null;\n  eventLogIndex = 0;\n  return buffer;\n}\n\nexport function markTaskStart(\n  task: {\n    id: number,\n    priorityLevel: PriorityLevel,\n    ...\n  },\n  ms: number,\n) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      // performance.now returns a float, representing milliseconds. When the\n      // event is logged, it's coerced to an int. Convert to microseconds to\n      // maintain extra degrees of precision.\n      logEvent([TaskStartEvent, ms * 1000, task.id, task.priorityLevel]);\n    }\n  }\n}\n\nexport function markTaskCompleted(\n  task: {\n    id: number,\n    priorityLevel: PriorityLevel,\n    ...\n  },\n  ms: number,\n) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskCompleteEvent, ms * 1000, task.id]);\n    }\n  }\n}\n\nexport function markTaskCanceled(\n  task: {\n    id: number,\n    priorityLevel: PriorityLevel,\n    ...\n  },\n  ms: number,\n) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskCancelEvent, ms * 1000, task.id]);\n    }\n  }\n}\n\nexport function markTaskErrored(\n  task: {\n    id: number,\n    priorityLevel: PriorityLevel,\n    ...\n  },\n  ms: number,\n) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskErrorEvent, ms * 1000, task.id]);\n    }\n  }\n}\n\nexport function markTaskRun(\n  task: {\n    id: number,\n    priorityLevel: PriorityLevel,\n    ...\n  },\n  ms: number,\n) {\n  if (enableProfiling) {\n    runIdCounter++;\n\n    if (eventLog !== null) {\n      logEvent([TaskRunEvent, ms * 1000, task.id, runIdCounter]);\n    }\n  }\n}\n\nexport function markTaskYield(task: {id: number, ...}, ms: number) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([TaskYieldEvent, ms * 1000, task.id, runIdCounter]);\n    }\n  }\n}\n\nexport function markSchedulerSuspended(ms: number) {\n  if (enableProfiling) {\n    mainThreadIdCounter++;\n\n    if (eventLog !== null) {\n      logEvent([SchedulerSuspendEvent, ms * 1000, mainThreadIdCounter]);\n    }\n  }\n}\n\nexport function markSchedulerUnsuspended(ms: number) {\n  if (enableProfiling) {\n    if (eventLog !== null) {\n      logEvent([SchedulerResumeEvent, ms * 1000, mainThreadIdCounter]);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}