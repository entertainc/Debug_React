{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { NoTimestamp, SyncLane } from './ReactFiberLane';\nimport { isOffscreenManual } from './ReactFiberOffscreenComponent';\nimport { enableCreateEventHandleAPI, enableProfilerTimer, enableProfilerCommitHooks, enableProfilerNestedUpdatePhase, enableSchedulingProfiler, enableSuspenseCallback, enableScopeAPI, deletedTreeCleanUpLevel, enableUpdaterTracking, enableCache, enableTransitionTracing, enableUseEffectEventHook, enableFloat, enableLegacyHidden, enableHostSingletons } from 'shared/ReactFeatureFlags';\nimport { FunctionComponent, ForwardRef, ClassComponent, HostRoot, HostComponent, HostResource, HostSingleton, HostText, HostPortal, Profiler, SuspenseComponent, DehydratedFragment, IncompleteClassComponent, MemoComponent, SimpleMemoComponent, SuspenseListComponent, ScopeComponent, OffscreenComponent, LegacyHiddenComponent, CacheComponent, TracingMarkerComponent } from './ReactWorkTags';\nimport { NoFlags, ContentReset, Placement, ChildDeletion, Snapshot, Update, Callback, Ref, Hydrating, Passive, BeforeMutationMask, MutationMask, LayoutMask, PassiveMask, Visibility } from './ReactFiberFlags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport { resetCurrentFiber as resetCurrentDebugFiberInDEV, setCurrentFiber as setCurrentDebugFiberInDEV, getCurrentFiber as getCurrentDebugFiberInDEV } from './ReactCurrentFiber';\nimport { resolveDefaultProps } from './ReactFiberLazyComponent';\nimport { isCurrentUpdateNested, getCommitTime, recordLayoutEffectDuration, startLayoutEffectTimer, recordPassiveEffectDuration, startPassiveEffectTimer } from './ReactProfilerTimer';\nimport { ConcurrentMode, NoMode, ProfileMode } from './ReactTypeOfMode';\nimport { deferHiddenCallbacks, commitHiddenCallbacks, commitCallbacks } from './ReactFiberClassUpdateQueue';\nimport { getPublicInstance, supportsMutation, supportsPersistence, supportsHydration, supportsResources, supportsSingletons, commitMount, commitUpdate, resetTextContent, commitTextUpdate, appendChild, appendChildToContainer, insertBefore, insertInContainerBefore, removeChild, removeChildFromContainer, clearSuspenseBoundary, clearSuspenseBoundaryFromContainer, replaceContainerChildren, createContainerChildSet, hideInstance, hideTextInstance, unhideInstance, unhideTextInstance, commitHydratedContainer, commitHydratedSuspenseInstance, clearContainer, prepareScopeUpdate, prepareForCommit, beforeActiveInstanceBlur, detachDeletedInstance, acquireResource, releaseResource, clearSingleton, acquireSingletonInstance, releaseSingletonInstance } from './ReactFiberHostConfig';\nimport { captureCommitPhaseError, resolveRetryWakeable, markCommitTimeOfFallback, enqueuePendingPassiveProfilerEffect, restorePendingUpdaters, addTransitionStartCallbackToPendingTransition, addTransitionProgressCallbackToPendingTransition, addTransitionCompleteCallbackToPendingTransition, addMarkerProgressCallbackToPendingTransition, addMarkerIncompleteCallbackToPendingTransition, addMarkerCompleteCallbackToPendingTransition, setIsRunningInsertionEffect, getExecutionContext, CommitContext, NoContext } from './ReactFiberWorkLoop';\nimport { NoFlags as NoHookEffect, HasEffect as HookHasEffect, Layout as HookLayout, Insertion as HookInsertion, Passive as HookPassive } from './ReactHookEffectTags';\nimport { didWarnAboutReassigningProps } from './ReactFiberBeginWork';\nimport { doesFiberContain } from './ReactFiberTreeReflection';\nimport { invokeGuardedCallback, clearCaughtError } from 'shared/ReactErrorUtils';\nimport { isDevToolsPresent, markComponentPassiveEffectMountStarted, markComponentPassiveEffectMountStopped, markComponentPassiveEffectUnmountStarted, markComponentPassiveEffectUnmountStopped, markComponentLayoutEffectMountStarted, markComponentLayoutEffectMountStopped, markComponentLayoutEffectUnmountStarted, markComponentLayoutEffectUnmountStopped, onCommitUnmount } from './ReactFiberDevToolsHook';\nimport { releaseCache, retainCache } from './ReactFiberCacheComponent';\nimport { clearTransitionsForLanes } from './ReactFiberLane';\nimport { OffscreenVisible, OffscreenDetached, OffscreenPassiveEffectsConnected } from './ReactFiberOffscreenComponent';\nimport { TransitionRoot, TransitionTracingMarker } from './ReactFiberTracingMarkerComponent';\nimport { scheduleUpdateOnFiber } from './ReactFiberWorkLoop';\nimport { enqueueConcurrentRenderForLane } from './ReactFiberConcurrentUpdates';\nlet didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n\nif (__DEV__) {\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n} // Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n\n\nlet offscreenSubtreeIsHidden = false;\nlet offscreenSubtreeWasHidden = false;\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\nlet nextEffect = null; // Used for Profiling builds to track updaters.\n\nlet inProgressLanes = null;\nlet inProgressRoot = null;\n\nfunction shouldProfile(current) {\n  return enableProfilerTimer && enableProfilerCommitHooks && (current.mode & ProfileMode) !== NoMode && (getExecutionContext() & CommitContext) !== NoContext;\n}\n\nexport function reportUncaughtErrorInDEV(error) {\n  // Wrapping each small part of the commit phase into a guarded\n  // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n  // But we rely on it to surface errors to DEV tools like overlays\n  // (https://github.com/facebook/react/issues/21712).\n  // As a compromise, rethrow only caught errors in a guard.\n  if (__DEV__) {\n    invokeGuardedCallback(null, () => {\n      throw error;\n    });\n    clearCaughtError();\n  }\n}\n\nconst callComponentWillUnmountWithTimer = function (current, instance) {\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n\n  if (shouldProfile(current)) {\n    try {\n      startLayoutEffectTimer();\n      instance.componentWillUnmount();\n    } finally {\n      recordLayoutEffectDuration(current);\n    }\n  } else {\n    instance.componentWillUnmount();\n  }\n}; // Capture errors so they don't interrupt unmounting.\n\n\nfunction safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n  try {\n    callComponentWillUnmountWithTimer(current, instance);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyAttachRef(current, nearestMountedAncestor) {\n  try {\n    commitAttachRef(current);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nfunction safelyDetachRef(current, nearestMountedAncestor) {\n  const ref = current.ref;\n  const refCleanup = current.refCleanup;\n\n  if (ref !== null) {\n    if (typeof refCleanup === 'function') {\n      try {\n        if (shouldProfile(current)) {\n          try {\n            startLayoutEffectTimer();\n            refCleanup();\n          } finally {\n            recordLayoutEffectDuration(current);\n          }\n        } else {\n          refCleanup();\n        }\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      } finally {\n        // `refCleanup` has been called. Nullify all references to it to prevent double invocation.\n        current.refCleanup = null;\n        const finishedWork = current.alternate;\n\n        if (finishedWork != null) {\n          finishedWork.refCleanup = null;\n        }\n      }\n    } else if (typeof ref === 'function') {\n      let retVal;\n\n      try {\n        if (shouldProfile(current)) {\n          try {\n            startLayoutEffectTimer();\n            retVal = ref(null);\n          } finally {\n            recordLayoutEffectDuration(current);\n          }\n        } else {\n          retVal = ref(null);\n        }\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      }\n\n      if (__DEV__) {\n        if (typeof retVal === 'function') {\n          console.error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(current));\n        }\n      }\n    } else {\n      // $FlowFixMe unable to narrow type to RefObject\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n  try {\n    destroy();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nlet focusedInstanceHandle = null;\nlet shouldFireAfterActiveInstanceBlur = false;\nexport function commitBeforeMutationEffects(root, firstChild) {\n  focusedInstanceHandle = prepareForCommit(root.containerInfo);\n  nextEffect = firstChild;\n  commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n\n  const shouldFire = shouldFireAfterActiveInstanceBlur;\n  shouldFireAfterActiveInstanceBlur = false;\n  focusedInstanceHandle = null;\n  return shouldFire;\n}\n\nfunction commitBeforeMutationEffects_begin() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n    // Let's skip the whole loop if it's off.\n\n    if (enableCreateEventHandleAPI) {\n      // TODO: Should wrap this in flags check, too, as optimization\n      const deletions = fiber.deletions;\n\n      if (deletions !== null) {\n        for (let i = 0; i < deletions.length; i++) {\n          const deletion = deletions[i];\n          commitBeforeMutationEffectsDeletion(deletion);\n        }\n      }\n    }\n\n    const child = fiber.child;\n\n    if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitBeforeMutationEffects_complete();\n    }\n  }\n}\n\nfunction commitBeforeMutationEffects_complete() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    setCurrentDebugFiberInDEV(fiber);\n\n    try {\n      commitBeforeMutationEffectsOnFiber(fiber);\n    } catch (error) {\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentDebugFiberInDEV();\n    const sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork) {\n  const current = finishedWork.alternate;\n  const flags = finishedWork.flags;\n\n  if (enableCreateEventHandleAPI) {\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\n      // Check to see if the focused element was inside of a hidden (Suspense) subtree.\n      // TODO: Move this out of the hot path using a dedicated effect tag.\n      if (finishedWork.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current, finishedWork) && // $FlowFixMe[incompatible-call] found when upgrading Flow\n      doesFiberContain(finishedWork, focusedInstanceHandle)) {\n        shouldFireAfterActiveInstanceBlur = true;\n        beforeActiveInstanceBlur(finishedWork);\n      }\n    }\n  }\n\n  if ((flags & Snapshot) !== NoFlags) {\n    setCurrentDebugFiberInDEV(finishedWork);\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n      {\n        if (enableUseEffectEventHook) {\n          if ((flags & Update) !== NoFlags) {\n            commitUseEffectEventMount(finishedWork);\n          }\n        }\n\n        break;\n      }\n\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        break;\n      }\n\n    case ClassComponent:\n      {\n        if ((flags & Snapshot) !== NoFlags) {\n          if (current !== null) {\n            const prevProps = current.memoizedProps;\n            const prevState = current.memoizedState;\n            const instance = finishedWork.stateNode; // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n            if (__DEV__) {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  console.error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  console.error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            }\n\n            const snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n\n            if (__DEV__) {\n              const didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n                console.error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n              }\n            }\n\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          }\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n        if ((flags & Snapshot) !== NoFlags) {\n          if (supportsMutation) {\n            const root = finishedWork.stateNode;\n            clearContainer(root.containerInfo);\n          }\n        }\n\n        break;\n      }\n\n    case HostComponent:\n    case HostResource:\n    case HostSingleton:\n    case HostText:\n    case HostPortal:\n    case IncompleteClassComponent:\n      // Nothing to do for these component types\n      break;\n\n    default:\n      {\n        if ((flags & Snapshot) !== NoFlags) {\n          throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n        }\n      }\n  }\n\n  if ((flags & Snapshot) !== NoFlags) {\n    resetCurrentDebugFiberInDEV();\n  }\n}\n\nfunction commitBeforeMutationEffectsDeletion(deletion) {\n  if (enableCreateEventHandleAPI) {\n    // TODO (effects) It would be nice to avoid calling doesFiberContain()\n    // Maybe we can repurpose one of the subtreeFlags positions for this instead?\n    // Use it to store which part of the tree the focused instance is in?\n    // This assumes we can safely determine that instance during the \"render\" phase.\n    if (doesFiberContain(deletion, focusedInstanceHandle)) {\n      shouldFireAfterActiveInstanceBlur = true;\n      beforeActiveInstanceBlur(deletion);\n    }\n  }\n}\n\nfunction commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n  const updateQueue = finishedWork.updateQueue;\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n\n        if (destroy !== undefined) {\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStarted(finishedWork);\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStarted(finishedWork);\n            }\n          }\n\n          if (__DEV__) {\n            if ((flags & HookInsertion) !== NoHookEffect) {\n              setIsRunningInsertionEffect(true);\n            }\n          }\n\n          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n\n          if (__DEV__) {\n            if ((flags & HookInsertion) !== NoHookEffect) {\n              setIsRunningInsertionEffect(false);\n            }\n          }\n\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStopped();\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitHookEffectListMount(flags, finishedWork) {\n  const updateQueue = finishedWork.updateQueue;\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStarted(finishedWork);\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStarted(finishedWork);\n          }\n        } // Mount\n\n\n        const create = effect.create;\n\n        if (__DEV__) {\n          if ((flags & HookInsertion) !== NoHookEffect) {\n            setIsRunningInsertionEffect(true);\n          }\n        }\n\n        effect.destroy = create();\n\n        if (__DEV__) {\n          if ((flags & HookInsertion) !== NoHookEffect) {\n            setIsRunningInsertionEffect(false);\n          }\n        }\n\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStopped();\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStopped();\n          }\n        }\n\n        if (__DEV__) {\n          const destroy = effect.destroy;\n\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            let hookName;\n\n            if ((effect.tag & HookLayout) !== NoFlags) {\n              hookName = 'useLayoutEffect';\n            } else if ((effect.tag & HookInsertion) !== NoFlags) {\n              hookName = 'useInsertionEffect';\n            } else {\n              hookName = 'useEffect';\n            }\n\n            let addendum;\n\n            if (destroy === null) {\n              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n\n            console.error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitUseEffectEventMount(finishedWork) {\n  const updateQueue = finishedWork.updateQueue;\n  const eventPayloads = updateQueue !== null ? updateQueue.events : null;\n\n  if (eventPayloads !== null) {\n    for (let ii = 0; ii < eventPayloads.length; ii++) {\n      const {\n        ref,\n        nextImpl\n      } = eventPayloads[ii];\n      ref.impl = nextImpl;\n    }\n  }\n}\n\nexport function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n  if (enableProfilerTimer && enableProfilerCommitHooks && getExecutionContext() & CommitContext) {\n    // Only Profilers with work in their subtree will have an Update effect scheduled.\n    if ((finishedWork.flags & Update) !== NoFlags) {\n      switch (finishedWork.tag) {\n        case Profiler:\n          {\n            const {\n              passiveEffectDuration\n            } = finishedWork.stateNode;\n            const {\n              id,\n              onPostCommit\n            } = finishedWork.memoizedProps; // This value will still reflect the previous commit phase.\n            // It does not get reset until the start of the next commit phase.\n\n            const commitTime = getCommitTime();\n            let phase = finishedWork.alternate === null ? 'mount' : 'update';\n\n            if (enableProfilerNestedUpdatePhase) {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onPostCommit === 'function') {\n              onPostCommit(id, phase, passiveEffectDuration, commitTime);\n            } // Bubble times to the next nearest ancestor Profiler.\n            // After we process that Profiler, we'll bubble further up.\n\n\n            let parentFiber = finishedWork.return;\n\n            outer: while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  const root = parentFiber.stateNode;\n                  root.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n\n                case Profiler:\n                  const parentStateNode = parentFiber.stateNode;\n                  parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n              }\n\n              parentFiber = parentFiber.return;\n            }\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    }\n  }\n}\n\nfunction commitHookLayoutEffects(finishedWork, hookFlags) {\n  // At this point layout effects have already been destroyed (during mutation phase).\n  // This is done to prevent sibling component effects from interfering with each other,\n  // e.g. a destroy function in one component should never override a ref set\n  // by a create function in another component during the same commit.\n  if (shouldProfile(finishedWork)) {\n    try {\n      startLayoutEffectTimer();\n      commitHookEffectListMount(hookFlags, finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n\n    recordLayoutEffectDuration(finishedWork);\n  } else {\n    try {\n      commitHookEffectListMount(hookFlags, finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\n\nfunction commitClassLayoutLifecycles(finishedWork, current) {\n  const instance = finishedWork.stateNode;\n\n  if (current === null) {\n    // We could update instance props and state here,\n    // but instead we rely on them being set during last render.\n    // TODO: revisit this when we implement resuming.\n    if (__DEV__) {\n      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n        if (instance.props !== finishedWork.memoizedProps) {\n          console.error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n        }\n\n        if (instance.state !== finishedWork.memoizedState) {\n          console.error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n        }\n      }\n    }\n\n    if (shouldProfile(finishedWork)) {\n      try {\n        startLayoutEffectTimer();\n        instance.componentDidMount();\n      } catch (error) {\n        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n      }\n\n      recordLayoutEffectDuration(finishedWork);\n    } else {\n      try {\n        instance.componentDidMount();\n      } catch (error) {\n        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n      }\n    }\n  } else {\n    const prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n    const prevState = current.memoizedState; // We could update instance props and state here,\n    // but instead we rely on them being set during last render.\n    // TODO: revisit this when we implement resuming.\n\n    if (__DEV__) {\n      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n        if (instance.props !== finishedWork.memoizedProps) {\n          console.error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n        }\n\n        if (instance.state !== finishedWork.memoizedState) {\n          console.error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n        }\n      }\n    }\n\n    if (shouldProfile(finishedWork)) {\n      try {\n        startLayoutEffectTimer();\n        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n      } catch (error) {\n        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n      }\n\n      recordLayoutEffectDuration(finishedWork);\n    } else {\n      try {\n        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n      } catch (error) {\n        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n      }\n    }\n  }\n}\n\nfunction commitClassCallbacks(finishedWork) {\n  // TODO: I think this is now always non-null by the time it reaches the\n  // commit phase. Consider removing the type check.\n  const updateQueue = finishedWork.updateQueue;\n\n  if (updateQueue !== null) {\n    const instance = finishedWork.stateNode;\n\n    if (__DEV__) {\n      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n        if (instance.props !== finishedWork.memoizedProps) {\n          console.error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n        }\n\n        if (instance.state !== finishedWork.memoizedState) {\n          console.error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n        }\n      }\n    } // We could update instance props and state here,\n    // but instead we rely on them being set during last render.\n    // TODO: revisit this when we implement resuming.\n\n\n    try {\n      commitCallbacks(updateQueue, instance);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\n\nfunction commitHostComponentMount(finishedWork) {\n  const type = finishedWork.type;\n  const props = finishedWork.memoizedProps;\n  const instance = finishedWork.stateNode;\n\n  try {\n    commitMount(instance, type, props, finishedWork);\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\n\nfunction commitProfilerUpdate(finishedWork, current) {\n  if (enableProfilerTimer && getExecutionContext() & CommitContext) {\n    try {\n      const {\n        onCommit,\n        onRender\n      } = finishedWork.memoizedProps;\n      const {\n        effectDuration\n      } = finishedWork.stateNode;\n      const commitTime = getCommitTime();\n      let phase = current === null ? 'mount' : 'update';\n\n      if (enableProfilerNestedUpdatePhase) {\n        if (isCurrentUpdateNested()) {\n          phase = 'nested-update';\n        }\n      }\n\n      if (typeof onRender === 'function') {\n        onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n      }\n\n      if (enableProfilerCommitHooks) {\n        if (typeof onCommit === 'function') {\n          onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n        } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n        // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n        // because the effect is also where times bubble to parent Profilers.\n\n\n        enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n        // Do not reset these values until the next render so DevTools has a chance to read them first.\n\n        let parentFiber = finishedWork.return;\n\n        outer: while (parentFiber !== null) {\n          switch (parentFiber.tag) {\n            case HostRoot:\n              const root = parentFiber.stateNode;\n              root.effectDuration += effectDuration;\n              break outer;\n\n            case Profiler:\n              const parentStateNode = parentFiber.stateNode;\n              parentStateNode.effectDuration += effectDuration;\n              break outer;\n          }\n\n          parentFiber = parentFiber.return;\n        }\n      }\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\n\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n  // When updating this function, also update reappearLayoutEffects, which does\n  // most of the same things when an offscreen tree goes from hidden -> visible.\n  const flags = finishedWork.flags;\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n\n        if (flags & Update) {\n          commitHookLayoutEffects(finishedWork, HookLayout | HookHasEffect);\n        }\n\n        break;\n      }\n\n    case ClassComponent:\n      {\n        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n\n        if (flags & Update) {\n          commitClassLayoutLifecycles(finishedWork, current);\n        }\n\n        if (flags & Callback) {\n          commitClassCallbacks(finishedWork);\n        }\n\n        if (flags & Ref) {\n          safelyAttachRef(finishedWork, finishedWork.return);\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n\n        if (flags & Callback) {\n          // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n          const updateQueue = finishedWork.updateQueue;\n\n          if (updateQueue !== null) {\n            let instance = null;\n\n            if (finishedWork.child !== null) {\n              switch (finishedWork.child.tag) {\n                case HostSingleton:\n                case HostComponent:\n                  instance = getPublicInstance(finishedWork.child.stateNode);\n                  break;\n\n                case ClassComponent:\n                  instance = finishedWork.child.stateNode;\n                  break;\n              }\n            }\n\n            try {\n              commitCallbacks(updateQueue, instance);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        break;\n      }\n\n    case HostResource:\n      {\n        if (enableFloat && supportsResources) {\n          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n\n          if (flags & Ref) {\n            safelyAttachRef(finishedWork, finishedWork.return);\n          }\n\n          break;\n        }\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    case HostSingleton:\n    case HostComponent:\n      {\n        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes); // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n\n        if (current === null && flags & Update) {\n          commitHostComponentMount(finishedWork);\n        }\n\n        if (flags & Ref) {\n          safelyAttachRef(finishedWork, finishedWork.return);\n        }\n\n        break;\n      }\n\n    case Profiler:\n      {\n        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes); // TODO: Should this fire inside an offscreen tree? Or should it wait to\n        // fire when the tree becomes visible again.\n\n        if (flags & Update) {\n          commitProfilerUpdate(finishedWork, current);\n        }\n\n        break;\n      }\n\n    case SuspenseComponent:\n      {\n        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n\n        if (flags & Update) {\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        const isModernRoot = (finishedWork.mode & ConcurrentMode) !== NoMode;\n\n        if (isModernRoot) {\n          const isHidden = finishedWork.memoizedState !== null;\n          const newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n\n          if (newOffscreenSubtreeIsHidden) {// The Offscreen tree is hidden. Skip over its layout effects.\n          } else {\n            // The Offscreen tree is visible.\n            const wasHidden = current !== null && current.memoizedState !== null;\n            const newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n            const prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n            const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n            offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n            offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n\n            if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n              // This is the root of a reappearing boundary. As we continue\n              // traversing the layout effects, we must also re-mount layout\n              // effects that were unmounted when the Offscreen subtree was\n              // hidden. So this is a superset of the normal commitLayoutEffects.\n              const includeWorkInProgressEffects = (finishedWork.subtreeFlags & LayoutMask) !== NoFlags;\n              recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n            } else {\n              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n            }\n\n            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n          }\n        } else {\n          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n        }\n\n        if (flags & Ref) {\n          const props = finishedWork.memoizedProps;\n\n          if (props.mode === 'manual') {\n            safelyAttachRef(finishedWork, finishedWork.return);\n          } else {\n            safelyDetachRef(finishedWork, finishedWork.return);\n          }\n        }\n\n        break;\n      }\n\n    default:\n      {\n        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork, committedLanes);\n        break;\n      }\n  }\n}\n\nfunction abortRootTransitions(root, abort, deletedTransitions, deletedOffscreenInstance, isInDeletedTree) {\n  if (enableTransitionTracing) {\n    const rootTransitions = root.incompleteTransitions;\n    deletedTransitions.forEach(transition => {\n      if (rootTransitions.has(transition)) {\n        const transitionInstance = rootTransitions.get(transition);\n\n        if (transitionInstance.aborts === null) {\n          transitionInstance.aborts = [];\n        }\n\n        transitionInstance.aborts.push(abort);\n\n        if (deletedOffscreenInstance !== null) {\n          if (transitionInstance.pendingBoundaries !== null && transitionInstance.pendingBoundaries.has(deletedOffscreenInstance)) {\n            // $FlowFixMe[incompatible-use] found when upgrading Flow\n            transitionInstance.pendingBoundaries.delete(deletedOffscreenInstance);\n          }\n        }\n      }\n    });\n  }\n}\n\nfunction abortTracingMarkerTransitions(abortedFiber, abort, deletedTransitions, deletedOffscreenInstance, isInDeletedTree) {\n  if (enableTransitionTracing) {\n    const markerInstance = abortedFiber.stateNode;\n    const markerTransitions = markerInstance.transitions;\n    const pendingBoundaries = markerInstance.pendingBoundaries;\n\n    if (markerTransitions !== null) {\n      // TODO: Refactor this code. Is there a way to move this code to\n      // the deletions phase instead of calculating it here while making sure\n      // complete is called appropriately?\n      deletedTransitions.forEach(transition => {\n        // If one of the transitions on the tracing marker is a transition\n        // that was in an aborted subtree, we will abort that tracing marker\n        if (abortedFiber !== null && markerTransitions.has(transition) && (markerInstance.aborts === null || !markerInstance.aborts.includes(abort))) {\n          if (markerInstance.transitions !== null) {\n            if (markerInstance.aborts === null) {\n              markerInstance.aborts = [abort];\n              addMarkerIncompleteCallbackToPendingTransition(abortedFiber.memoizedProps.name, markerInstance.transitions, markerInstance.aborts);\n            } else {\n              markerInstance.aborts.push(abort);\n            } // We only want to call onTransitionProgress when the marker hasn't been\n            // deleted\n\n\n            if (deletedOffscreenInstance !== null && !isInDeletedTree && pendingBoundaries !== null && pendingBoundaries.has(deletedOffscreenInstance)) {\n              pendingBoundaries.delete(deletedOffscreenInstance);\n              addMarkerProgressCallbackToPendingTransition(abortedFiber.memoizedProps.name, deletedTransitions, pendingBoundaries);\n            }\n          }\n        }\n      });\n    }\n  }\n}\n\nfunction abortParentMarkerTransitionsForDeletedFiber(abortedFiber, abort, deletedTransitions, deletedOffscreenInstance, isInDeletedTree) {\n  if (enableTransitionTracing) {\n    // Find all pending markers that are waiting on child suspense boundaries in the\n    // aborted subtree and cancels them\n    let fiber = abortedFiber;\n\n    while (fiber !== null) {\n      switch (fiber.tag) {\n        case TracingMarkerComponent:\n          abortTracingMarkerTransitions(fiber, abort, deletedTransitions, deletedOffscreenInstance, isInDeletedTree);\n          break;\n\n        case HostRoot:\n          const root = fiber.stateNode;\n          abortRootTransitions(root, abort, deletedTransitions, deletedOffscreenInstance, isInDeletedTree);\n          break;\n\n        default:\n          break;\n      }\n\n      fiber = fiber.return;\n    }\n  }\n}\n\nfunction commitTransitionProgress(offscreenFiber) {\n  if (enableTransitionTracing) {\n    // This function adds suspense boundaries to the root\n    // or tracing marker's pendingBoundaries map.\n    // When a suspense boundary goes from a resolved to a fallback\n    // state we add the boundary to the map, and when it goes from\n    // a fallback to a resolved state, we remove the boundary from\n    // the map.\n    // We use stateNode on the Offscreen component as a stable object\n    // that doesnt change from render to render. This way we can\n    // distinguish between different Offscreen instances (vs. the same\n    // Offscreen instance with different fibers)\n    const offscreenInstance = offscreenFiber.stateNode;\n    let prevState = null;\n    const previousFiber = offscreenFiber.alternate;\n\n    if (previousFiber !== null && previousFiber.memoizedState !== null) {\n      prevState = previousFiber.memoizedState;\n    }\n\n    const nextState = offscreenFiber.memoizedState;\n    const wasHidden = prevState !== null;\n    const isHidden = nextState !== null;\n    const pendingMarkers = offscreenInstance._pendingMarkers; // If there is a name on the suspense boundary, store that in\n    // the pending boundaries.\n\n    let name = null;\n    const parent = offscreenFiber.return;\n\n    if (parent !== null && parent.tag === SuspenseComponent && parent.memoizedProps.unstable_name) {\n      name = parent.memoizedProps.unstable_name;\n    }\n\n    if (!wasHidden && isHidden) {\n      // The suspense boundaries was just hidden. Add the boundary\n      // to the pending boundary set if it's there\n      if (pendingMarkers !== null) {\n        pendingMarkers.forEach(markerInstance => {\n          const pendingBoundaries = markerInstance.pendingBoundaries;\n          const transitions = markerInstance.transitions;\n          const markerName = markerInstance.name;\n\n          if (pendingBoundaries !== null && !pendingBoundaries.has(offscreenInstance)) {\n            pendingBoundaries.set(offscreenInstance, {\n              name\n            });\n\n            if (transitions !== null) {\n              if (markerInstance.tag === TransitionTracingMarker && markerName !== null) {\n                addMarkerProgressCallbackToPendingTransition(markerName, transitions, pendingBoundaries);\n              } else if (markerInstance.tag === TransitionRoot) {\n                transitions.forEach(transition => {\n                  addTransitionProgressCallbackToPendingTransition(transition, pendingBoundaries);\n                });\n              }\n            }\n          }\n        });\n      }\n    } else if (wasHidden && !isHidden) {\n      // The suspense boundary went from hidden to visible. Remove\n      // the boundary from the pending suspense boundaries set\n      // if it's there\n      if (pendingMarkers !== null) {\n        pendingMarkers.forEach(markerInstance => {\n          const pendingBoundaries = markerInstance.pendingBoundaries;\n          const transitions = markerInstance.transitions;\n          const markerName = markerInstance.name;\n\n          if (pendingBoundaries !== null && pendingBoundaries.has(offscreenInstance)) {\n            pendingBoundaries.delete(offscreenInstance);\n\n            if (transitions !== null) {\n              if (markerInstance.tag === TransitionTracingMarker && markerName !== null) {\n                addMarkerProgressCallbackToPendingTransition(markerName, transitions, pendingBoundaries); // If there are no more unresolved suspense boundaries, the interaction\n                // is considered finished\n\n                if (pendingBoundaries.size === 0) {\n                  if (markerInstance.aborts === null) {\n                    addMarkerCompleteCallbackToPendingTransition(markerName, transitions);\n                  }\n\n                  markerInstance.transitions = null;\n                  markerInstance.pendingBoundaries = null;\n                  markerInstance.aborts = null;\n                }\n              } else if (markerInstance.tag === TransitionRoot) {\n                transitions.forEach(transition => {\n                  addTransitionProgressCallbackToPendingTransition(transition, pendingBoundaries);\n                });\n              }\n            }\n          }\n        });\n      }\n    }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  // Only hide or unhide the top-most host nodes.\n  let hostSubtreeRoot = null;\n\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    let node = finishedWork;\n\n    while (true) {\n      if (node.tag === HostComponent || (enableFloat && supportsResources ? node.tag === HostResource : false) || (enableHostSingletons && supportsSingletons ? node.tag === HostSingleton : false)) {\n        if (hostSubtreeRoot === null) {\n          hostSubtreeRoot = node;\n\n          try {\n            const instance = node.stateNode;\n\n            if (isHidden) {\n              hideInstance(instance);\n            } else {\n              unhideInstance(node.stateNode, node.memoizedProps);\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      } else if (node.tag === HostText) {\n        if (hostSubtreeRoot === null) {\n          try {\n            const instance = node.stateNode;\n\n            if (isHidden) {\n              hideTextInstance(instance);\n            } else {\n              unhideTextInstance(instance, node.memoizedProps);\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) {// Found a nested Offscreen component that is hidden.\n        // Don't search any deeper. This tree should remain hidden.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === finishedWork) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n\n        if (hostSubtreeRoot === node) {\n          hostSubtreeRoot = null;\n        }\n\n        node = node.return;\n      }\n\n      if (hostSubtreeRoot === node) {\n        hostSubtreeRoot = null;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  const ref = finishedWork.ref;\n\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n\n    switch (finishedWork.tag) {\n      case HostResource:\n      case HostSingleton:\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n\n      default:\n        instanceToUse = instance;\n    } // Moved outside to ensure DCE works with this flag\n\n\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n      instanceToUse = instance;\n    }\n\n    if (typeof ref === 'function') {\n      if (shouldProfile(finishedWork)) {\n        try {\n          startLayoutEffectTimer();\n          finishedWork.refCleanup = ref(instanceToUse);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        finishedWork.refCleanup = ref(instanceToUse);\n      }\n    } else {\n      if (__DEV__) {\n        if (!ref.hasOwnProperty('current')) {\n          console.error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n        }\n      } // $FlowFixMe unable to narrow type to the non-function case\n\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction detachFiberMutation(fiber) {\n  // Cut off the return pointer to disconnect it from the tree.\n  // This enables us to detect and warn against state updates on an unmounted component.\n  // It also prevents events from bubbling from within disconnected components.\n  //\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child.\n  // This child itself will be GC:ed when the parent updates the next time.\n  //\n  // Note that we can't clear child or sibling pointers yet.\n  // They're needed for passive effects and for findDOMNode.\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n  //\n  // Don't reset the alternate yet, either. We need that so we can detach the\n  // alternate's fields in the passive phase. Clearing the return pointer is\n  // sufficient for findDOMNode semantics.\n  const alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n\n  fiber.return = null;\n}\n\nfunction detachFiberAfterEffects(fiber) {\n  const alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    fiber.alternate = null;\n    detachFiberAfterEffects(alternate);\n  } // Note: Defensively using negation instead of < in case\n  // `deletedTreeCleanUpLevel` is undefined.\n\n\n  if (!(deletedTreeCleanUpLevel >= 2)) {\n    // This is the default branch (level 0).\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.dependencies = null;\n    fiber.memoizedProps = null;\n    fiber.memoizedState = null;\n    fiber.pendingProps = null;\n    fiber.sibling = null;\n    fiber.stateNode = null;\n    fiber.updateQueue = null;\n\n    if (__DEV__) {\n      fiber._debugOwner = null;\n    }\n  } else {\n    // Clear cyclical Fiber fields. This level alone is designed to roughly\n    // approximate the planned Fiber refactor. In that world, `setState` will be\n    // bound to a special \"instance\" object instead of a Fiber. The Instance\n    // object will not have any of these fields. It will only be connected to\n    // the fiber tree via a single link at the root. So if this level alone is\n    // sufficient to fix memory issues, that bodes well for our plans.\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n    // tree, which has its own pointers to children, parents, and siblings.\n    // The other host nodes also point back to fibers, so we should detach that\n    // one, too.\n\n    if (fiber.tag === HostComponent) {\n      const hostInstance = fiber.stateNode;\n\n      if (hostInstance !== null) {\n        detachDeletedInstance(hostInstance);\n      }\n    }\n\n    fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We\n    // already disconnect the `return` pointer at the root of the deleted\n    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n    // cyclical — it's only cyclical when combined with `child`, `sibling`, and\n    // `alternate`. But we'll clear it in the next level anyway, just in case.\n\n    if (__DEV__) {\n      fiber._debugOwner = null;\n    }\n\n    if (deletedTreeCleanUpLevel >= 3) {\n      // Theoretically, nothing in here should be necessary, because we already\n      // disconnected the fiber from the tree. So even if something leaks this\n      // particular fiber, it won't leak anything else\n      //\n      // The purpose of this branch is to be super aggressive so we can measure\n      // if there's any difference in memory impact. If there is, that could\n      // indicate a React leak we don't know about.\n      fiber.return = null;\n      fiber.dependencies = null;\n      fiber.memoizedProps = null;\n      fiber.memoizedState = null;\n      fiber.pendingProps = null;\n      fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n\n      fiber.updateQueue = null;\n    }\n  }\n}\n\nfunction emptyPortalContainer(current) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  const portal = current.stateNode;\n  const {\n    containerInfo\n  } = portal;\n  const emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction getHostParentFiber(fiber) {\n  let parent = fiber.return;\n\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n\n    parent = parent.return;\n  }\n\n  throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n}\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || (enableFloat && supportsResources ? fiber.tag === HostResource : false) || (enableHostSingletons && supportsSingletons ? fiber.tag === HostSingleton : false) || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  let node = fiber;\n\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      } // $FlowFixMe[incompatible-type] found when upgrading Flow\n\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n\n    while (node.tag !== HostComponent && node.tag !== HostText && (!(enableHostSingletons && supportsSingletons) ? true : node.tag !== HostSingleton) && node.tag !== DehydratedFragment) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.flags & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      } // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n\n\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    } // Check if this host node is stable or about to be placed.\n\n\n    if (!(node.flags & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  if (enableHostSingletons && supportsSingletons) {\n    if (finishedWork.tag === HostSingleton) {\n      // Singletons are already in the Host and don't need to be placed\n      // Since they operate somewhat like Portals though their children will\n      // have Placement and will get placed inside them\n      return;\n    }\n  } // Recursively insert all host nodes into the parent.\n\n\n  const parentFiber = getHostParentFiber(finishedWork);\n\n  switch (parentFiber.tag) {\n    case HostSingleton:\n      {\n        if (enableHostSingletons && supportsSingletons) {\n          const parent = parentFiber.stateNode;\n          const before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n          // children to find all the terminal nodes.\n\n          insertOrAppendPlacementNode(finishedWork, before, parent);\n          break;\n        }\n      }\n    // eslint-disable-next-line no-fallthrough\n\n    case HostComponent:\n      {\n        const parent = parentFiber.stateNode;\n\n        if (parentFiber.flags & ContentReset) {\n          // Reset the text content of the parent before doing any insertions\n          resetTextContent(parent); // Clear ContentReset from the effect tag\n\n          parentFiber.flags &= ~ContentReset;\n        }\n\n        const before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n        // children to find all the terminal nodes.\n\n        insertOrAppendPlacementNode(finishedWork, before, parent);\n        break;\n      }\n\n    case HostRoot:\n    case HostPortal:\n      {\n        const parent = parentFiber.stateNode.containerInfo;\n        const before = getHostSibling(finishedWork);\n        insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n        break;\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n}\n\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  const {\n    tag\n  } = node;\n  const isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    const stateNode = node.stateNode;\n\n    if (before) {\n      insertInContainerBefore(parent, stateNode, before);\n    } else {\n      appendChildToContainer(parent, stateNode);\n    }\n  } else if (tag === HostPortal || (enableHostSingletons && supportsSingletons ? tag === HostSingleton : false)) {// If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n    // If the insertion is a HostSingleton then it will be placed independently\n  } else {\n    const child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n      let sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  const {\n    tag\n  } = node;\n  const isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    const stateNode = node.stateNode;\n\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } else if (tag === HostPortal || (enableHostSingletons && supportsSingletons ? tag === HostSingleton : false)) {// If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n    // If the insertion is a HostSingleton then it will be placed independently\n  } else {\n    const child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      let sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n} // These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\n\n\nlet hostParent = null;\nlet hostParentIsContainer = false;\n\nfunction commitDeletionEffects(root, returnFiber, deletedFiber) {\n  if (supportsMutation) {\n    // We only have the top Fiber that was deleted but we need to recurse down its\n    // children to find all the terminal nodes.\n    // Recursively delete all host nodes from the parent, detach refs, clean\n    // up mounted layout effects, and call componentWillUnmount.\n    // We only need to remove the topmost host child in each branch. But then we\n    // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n    // could split this into two separate traversals functions, where the second\n    // one doesn't include any removeChild logic. This is maybe the same\n    // function as \"disappearLayoutEffects\" (or whatever that turns into after\n    // the layout phase is refactored to use recursion).\n    // Before starting, find the nearest host parent on the stack so we know\n    // which instance/container to remove the children from.\n    // TODO: Instead of searching up the fiber return path on every deletion, we\n    // can track the nearest host component on the JS stack as we traverse the\n    // tree during the commit phase. This would make insertions faster, too.\n    let parent = returnFiber;\n\n    findParent: while (parent !== null) {\n      switch (parent.tag) {\n        case HostSingleton:\n        case HostComponent:\n          {\n            hostParent = parent.stateNode;\n            hostParentIsContainer = false;\n            break findParent;\n          }\n\n        case HostRoot:\n          {\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = true;\n            break findParent;\n          }\n\n        case HostPortal:\n          {\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = true;\n            break findParent;\n          }\n      }\n\n      parent = parent.return;\n    }\n\n    if (hostParent === null) {\n      throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n    }\n\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n    hostParent = null;\n    hostParentIsContainer = false;\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n  }\n\n  detachFiberMutation(deletedFiber);\n}\n\nfunction recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n  // TODO: Use a static flag to skip trees that don't have unmount effects\n  let child = parent.child;\n\n  while (child !== null) {\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n    child = child.sibling;\n  }\n}\n\nfunction commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n  onCommitUnmount(deletedFiber); // The cases in this outer switch modify the stack before they traverse\n  // into their subtree. There are simpler cases in the inner switch\n  // that don't modify the stack.\n\n  switch (deletedFiber.tag) {\n    case HostResource:\n      {\n        if (enableFloat && supportsResources) {\n          if (!offscreenSubtreeWasHidden) {\n            safelyDetachRef(deletedFiber, nearestMountedAncestor);\n          }\n\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n\n          if (deletedFiber.memoizedState) {\n            releaseResource(deletedFiber.memoizedState);\n          }\n\n          return;\n        }\n      }\n    // eslint-disable-next-line no-fallthrough\n\n    case HostSingleton:\n      {\n        if (enableHostSingletons && supportsSingletons) {\n          if (!offscreenSubtreeWasHidden) {\n            safelyDetachRef(deletedFiber, nearestMountedAncestor);\n          }\n\n          const prevHostParent = hostParent;\n          const prevHostParentIsContainer = hostParentIsContainer;\n          hostParent = deletedFiber.stateNode;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber); // Normally this is called in passive unmount effect phase however with\n          // HostSingleton we warn if you acquire one that is already associated to\n          // a different fiber. To increase our chances of avoiding this, specifically\n          // if you keyed a HostSingleton so there will be a delete followed by a Placement\n          // we treat detach eagerly here\n\n          releaseSingletonInstance(deletedFiber.stateNode);\n          hostParent = prevHostParent;\n          hostParentIsContainer = prevHostParentIsContainer;\n          return;\n        }\n      }\n    // eslint-disable-next-line no-fallthrough\n\n    case HostComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n        } // Intentional fallthrough to next branch\n\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    case HostText:\n      {\n        // We only need to remove the nearest host child. Set the host parent\n        // to `null` on the stack to indicate that nested children don't\n        // need to be removed.\n        if (supportsMutation) {\n          const prevHostParent = hostParent;\n          const prevHostParentIsContainer = hostParentIsContainer;\n          hostParent = null;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          hostParent = prevHostParent;\n          hostParentIsContainer = prevHostParentIsContainer;\n\n          if (hostParent !== null) {\n            // Now that all the child effects have unmounted, we can remove the\n            // node from the tree.\n            if (hostParentIsContainer) {\n              removeChildFromContainer(hostParent, deletedFiber.stateNode);\n            } else {\n              removeChild(hostParent, deletedFiber.stateNode);\n            }\n          }\n        } else {\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        return;\n      }\n\n    case DehydratedFragment:\n      {\n        if (enableSuspenseCallback) {\n          const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n          if (hydrationCallbacks !== null) {\n            const onDeleted = hydrationCallbacks.onDeleted;\n\n            if (onDeleted) {\n              onDeleted(deletedFiber.stateNode);\n            }\n          }\n        } // Dehydrated fragments don't have any children\n        // Delete the dehydrated suspense boundary and all of its content.\n\n\n        if (supportsMutation) {\n          if (hostParent !== null) {\n            if (hostParentIsContainer) {\n              clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n            } else {\n              clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostPortal:\n      {\n        if (supportsMutation) {\n          // When we go into a portal, it becomes the parent to remove from.\n          const prevHostParent = hostParent;\n          const prevHostParentIsContainer = hostParentIsContainer;\n          hostParent = deletedFiber.stateNode.containerInfo;\n          hostParentIsContainer = true;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          hostParent = prevHostParent;\n          hostParentIsContainer = prevHostParentIsContainer;\n        } else {\n          emptyPortalContainer(deletedFiber);\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        return;\n      }\n\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          const updateQueue = deletedFiber.updateQueue;\n\n          if (updateQueue !== null) {\n            const lastEffect = updateQueue.lastEffect;\n\n            if (lastEffect !== null) {\n              const firstEffect = lastEffect.next;\n              let effect = firstEffect;\n\n              do {\n                const {\n                  destroy,\n                  tag\n                } = effect;\n\n                if (destroy !== undefined) {\n                  if ((tag & HookInsertion) !== NoHookEffect) {\n                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                  } else if ((tag & HookLayout) !== NoHookEffect) {\n                    if (enableSchedulingProfiler) {\n                      markComponentLayoutEffectUnmountStarted(deletedFiber);\n                    }\n\n                    if (shouldProfile(deletedFiber)) {\n                      startLayoutEffectTimer();\n                      safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                      recordLayoutEffectDuration(deletedFiber);\n                    } else {\n                      safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                    }\n\n                    if (enableSchedulingProfiler) {\n                      markComponentLayoutEffectUnmountStopped();\n                    }\n                  }\n                }\n\n                effect = effect.next;\n              } while (effect !== firstEffect);\n            }\n          }\n        }\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case ClassComponent:\n      {\n        if (!offscreenSubtreeWasHidden) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n          const instance = deletedFiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n          }\n        }\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n        }\n\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n\n    case OffscreenComponent:\n      {\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n\n        if (deletedFiber.mode & ConcurrentMode) {\n          // If this offscreen component is hidden, we already unmounted it. Before\n          // deleting the children, track that it's already unmounted so that we\n          // don't attempt to unmount the effects again.\n          // TODO: If the tree is hidden, in most cases we should be able to skip\n          // over the nested children entirely. An exception is we haven't yet found\n          // the topmost host node to delete, which we already track on the stack.\n          // But the other case is portals, which need to be detached no matter how\n          // deeply they are nested. We should use a subtree flag to track whether a\n          // subtree includes a nested portal.\n          const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        } else {\n          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        return;\n      }\n  }\n}\n\nfunction commitSuspenseCallback(finishedWork) {\n  // TODO: Move this to passive phase\n  const newState = finishedWork.memoizedState;\n\n  if (enableSuspenseCallback && newState !== null) {\n    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;\n\n    if (typeof suspenseCallback === 'function') {\n      const wakeables = finishedWork.updateQueue;\n\n      if (wakeables !== null) {\n        suspenseCallback(new Set(wakeables));\n      }\n    } else if (__DEV__) {\n      if (suspenseCallback !== undefined) {\n        console.error('Unexpected type for suspenseCallback.');\n      }\n    }\n  }\n}\n\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (!supportsHydration) {\n    return;\n  }\n\n  const newState = finishedWork.memoizedState;\n\n  if (newState === null) {\n    const current = finishedWork.alternate;\n\n    if (current !== null) {\n      const prevState = current.memoizedState;\n\n      if (prevState !== null) {\n        const suspenseInstance = prevState.dehydrated;\n\n        if (suspenseInstance !== null) {\n          try {\n            commitHydratedSuspenseInstance(suspenseInstance);\n\n            if (enableSuspenseCallback) {\n              const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n\n              if (hydrationCallbacks !== null) {\n                const onHydrated = hydrationCallbacks.onHydrated;\n\n                if (onHydrated) {\n                  onHydrated(suspenseInstance);\n                }\n              }\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction getRetryCache(finishedWork) {\n  // TODO: Unify the interface for the retry cache so we don't have to switch\n  // on the tag like this.\n  switch (finishedWork.tag) {\n    case SuspenseComponent:\n    case SuspenseListComponent:\n      {\n        let retryCache = finishedWork.stateNode;\n\n        if (retryCache === null) {\n          retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n        }\n\n        return retryCache;\n      }\n\n    case OffscreenComponent:\n      {\n        const instance = finishedWork.stateNode; // $FlowFixMe[incompatible-type-arg] found when upgrading Flow\n\n        let retryCache = // $FlowFixMe[incompatible-type] found when upgrading Flow\n        instance._retryCache;\n\n        if (retryCache === null) {\n          // $FlowFixMe[incompatible-type]\n          retryCache = instance._retryCache = new PossiblyWeakSet();\n        }\n\n        return retryCache;\n      }\n\n    default:\n      {\n        throw new Error(`Unexpected Suspense handler tag (${finishedWork.tag}). This is a ` + 'bug in React.');\n      }\n  }\n}\n\nexport function detachOffscreenInstance(instance) {\n  const fiber = instance._current;\n\n  if (fiber === null) {\n    throw new Error('Calling Offscreen.detach before instance handle has been set.');\n  }\n\n  if ((instance._pendingVisibility & OffscreenDetached) !== NoFlags) {\n    // The instance is already detached, this is a noop.\n    return;\n  } // TODO: There is an opportunity to optimise this by not entering commit phase\n  // and unmounting effects directly.\n\n\n  const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n  if (root !== null) {\n    instance._pendingVisibility |= OffscreenDetached;\n    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n  }\n}\nexport function attachOffscreenInstance(instance) {\n  const fiber = instance._current;\n\n  if (fiber === null) {\n    throw new Error('Calling Offscreen.detach before instance handle has been set.');\n  }\n\n  if ((instance._pendingVisibility & OffscreenDetached) === NoFlags) {\n    // The instance is already attached, this is a noop.\n    return;\n  }\n\n  const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n\n  if (root !== null) {\n    instance._pendingVisibility &= ~OffscreenDetached;\n    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork, wakeables) {\n  // If this boundary just timed out, then it will have a set of wakeables.\n  // For each wakeable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  const retryCache = getRetryCache(finishedWork);\n  wakeables.forEach(wakeable => {\n    // Memoize using the boundary fiber to prevent redundant listeners.\n    const retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n\n    if (!retryCache.has(wakeable)) {\n      retryCache.add(wakeable);\n\n      if (enableUpdaterTracking) {\n        if (isDevToolsPresent) {\n          if (inProgressLanes !== null && inProgressRoot !== null) {\n            // If we have pending work still, associate the original updaters with it.\n            restorePendingUpdaters(inProgressRoot, inProgressLanes);\n          } else {\n            throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n          }\n        }\n      }\n\n      wakeable.then(retry, retry);\n    }\n  });\n} // This function detects when a Suspense boundary goes from visible to hidden.\n// It returns false if the boundary is already hidden.\n// TODO: Use an effect tag.\n\n\nexport function isSuspenseBoundaryBeingHidden(current, finishedWork) {\n  if (current !== null) {\n    const oldState = current.memoizedState;\n\n    if (oldState === null || oldState.dehydrated !== null) {\n      const newState = finishedWork.memoizedState;\n      return newState !== null && newState.dehydrated === null;\n    }\n  }\n\n  return false;\n}\nexport function commitMutationEffects(root, finishedWork, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  setCurrentDebugFiberInDEV(finishedWork);\n  commitMutationEffectsOnFiber(finishedWork, root, committedLanes);\n  setCurrentDebugFiberInDEV(finishedWork);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction recursivelyTraverseMutationEffects(root, parentFiber, lanes) {\n  // Deletions effects can be scheduled on any fiber type. They need to happen\n  // before the children effects hae fired.\n  const deletions = parentFiber.deletions;\n\n  if (deletions !== null) {\n    for (let i = 0; i < deletions.length; i++) {\n      const childToDelete = deletions[i];\n\n      try {\n        commitDeletionEffects(root, parentFiber, childToDelete);\n      } catch (error) {\n        captureCommitPhaseError(childToDelete, parentFiber, error);\n      }\n    }\n  }\n\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n\n  if (parentFiber.subtreeFlags & MutationMask) {\n    let child = parentFiber.child;\n\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      commitMutationEffectsOnFiber(child, root, lanes);\n      child = child.sibling;\n    }\n  }\n\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n  const current = finishedWork.alternate;\n  const flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber,\n  // because the fiber tag is more specific. An exception is any flag related\n  // to reconciliation, because those can be set on all fiber types.\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          try {\n            commitHookEffectListUnmount(HookInsertion | HookHasEffect, finishedWork, finishedWork.return);\n            commitHookEffectListMount(HookInsertion | HookHasEffect, finishedWork);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          } // Layout effects are destroyed during the mutation phase so that all\n          // destroy functions for all fibers are called before any create functions.\n          // This prevents sibling component effects from interfering with each other,\n          // e.g. a destroy function in one component should never override a ref set\n          // by a create function in another component during the same commit.\n\n\n          if (shouldProfile(finishedWork)) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n\n            recordLayoutEffectDuration(finishedWork);\n          } else {\n            try {\n              commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork, finishedWork.return);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case ClassComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(current, current.return);\n          }\n        }\n\n        if (flags & Callback && offscreenSubtreeIsHidden) {\n          const updateQueue = finishedWork.updateQueue;\n\n          if (updateQueue !== null) {\n            deferHiddenCallbacks(updateQueue);\n          }\n        }\n\n        return;\n      }\n\n    case HostResource:\n      {\n        if (enableFloat && supportsResources) {\n          recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n          commitReconciliationEffects(finishedWork);\n\n          if (flags & Ref) {\n            if (current !== null) {\n              safelyDetachRef(current, current.return);\n            }\n          }\n\n          if (flags & Update) {\n            const newResource = finishedWork.memoizedState;\n\n            if (current !== null) {\n              const currentResource = current.memoizedState;\n\n              if (currentResource !== newResource) {\n                releaseResource(currentResource);\n              }\n            }\n\n            finishedWork.stateNode = newResource ? acquireResource(newResource) : null;\n          }\n\n          return;\n        }\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    case HostSingleton:\n      {\n        if (enableHostSingletons && supportsSingletons) {\n          if (flags & Update) {\n            const previousWork = finishedWork.alternate;\n\n            if (previousWork === null) {\n              const singleton = finishedWork.stateNode;\n              const props = finishedWork.memoizedProps; // This was a new mount, we need to clear and set initial properties\n\n              clearSingleton(singleton);\n              acquireSingletonInstance(finishedWork.type, props, singleton, finishedWork);\n            }\n          }\n        }\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    case HostComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(current, current.return);\n          }\n        }\n\n        if (supportsMutation) {\n          // TODO: ContentReset gets cleared by the children during the commit\n          // phase. This is a refactor hazard because it means we must read\n          // flags the flags after `commitReconciliationEffects` has already run;\n          // the order matters. We should refactor so that ContentReset does not\n          // rely on mutating the flag during commit. Like by setting a flag\n          // during the render phase instead.\n          if (finishedWork.flags & ContentReset) {\n            const instance = finishedWork.stateNode;\n\n            try {\n              resetTextContent(instance);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n\n          if (flags & Update) {\n            const instance = finishedWork.stateNode;\n\n            if (instance != null) {\n              // Commit the work prepared earlier.\n              const newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n              // as the newProps. The updatePayload will contain the real change in\n              // this case.\n\n              const oldProps = current !== null ? current.memoizedProps : newProps;\n              const type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n              const updatePayload = finishedWork.updateQueue;\n              finishedWork.updateQueue = null;\n\n              if (updatePayload !== null) {\n                try {\n                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n                } catch (error) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n              }\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostText:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsMutation) {\n            if (finishedWork.stateNode === null) {\n              throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            }\n\n            const textInstance = finishedWork.stateNode;\n            const newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n\n            const oldText = current !== null ? current.memoizedProps : newText;\n\n            try {\n              commitTextUpdate(textInstance, oldText, newText);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostRoot:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsMutation && supportsHydration) {\n            if (current !== null) {\n              const prevRootState = current.memoizedState;\n\n              if (prevRootState.isDehydrated) {\n                try {\n                  commitHydratedContainer(root.containerInfo);\n                } catch (error) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n              }\n            }\n          }\n\n          if (supportsPersistence) {\n            const containerInfo = root.containerInfo;\n            const pendingChildren = root.pendingChildren;\n\n            try {\n              replaceContainerChildren(containerInfo, pendingChildren);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case HostPortal:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          if (supportsPersistence) {\n            const portal = finishedWork.stateNode;\n            const containerInfo = portal.containerInfo;\n            const pendingChildren = portal.pendingChildren;\n\n            try {\n              replaceContainerChildren(containerInfo, pendingChildren);\n            } catch (error) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case SuspenseComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n        const offscreenFiber = finishedWork.child;\n\n        if (offscreenFiber.flags & Visibility) {\n          const newState = offscreenFiber.memoizedState;\n          const isHidden = newState !== null;\n\n          if (isHidden) {\n            const wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;\n\n            if (!wasHidden) {\n              // TODO: Move to passive phase\n              markCommitTimeOfFallback();\n            }\n          }\n        }\n\n        if (flags & Update) {\n          try {\n            commitSuspenseCallback(finishedWork);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n\n          const wakeables = finishedWork.updateQueue;\n\n          if (wakeables !== null) {\n            finishedWork.updateQueue = null;\n            attachSuspenseRetryListeners(finishedWork, wakeables);\n          }\n        }\n\n        return;\n      }\n\n    case OffscreenComponent:\n      {\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(current, current.return);\n          }\n        }\n\n        const newState = finishedWork.memoizedState;\n        const isHidden = newState !== null;\n        const wasHidden = current !== null && current.memoizedState !== null;\n\n        if (finishedWork.mode & ConcurrentMode) {\n          // Before committing the children, track on the stack whether this\n          // offscreen subtree was already hidden, so that we don't unmount the\n          // effects again.\n          const prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n          const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n          recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n        } else {\n          recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        }\n\n        commitReconciliationEffects(finishedWork);\n        const offscreenInstance = finishedWork.stateNode; // TODO: Add explicit effect flag to set _current.\n\n        offscreenInstance._current = finishedWork; // Offscreen stores pending changes to visibility in `_pendingVisibility`. This is\n        // to support batching of `attach` and `detach` calls.\n\n        offscreenInstance._visibility &= ~OffscreenDetached;\n        offscreenInstance._visibility |= offscreenInstance._pendingVisibility & OffscreenDetached;\n\n        if (flags & Visibility) {\n          // Track the current state on the Offscreen instance so we can\n          // read it during an event\n          if (isHidden) {\n            offscreenInstance._visibility &= ~OffscreenVisible;\n          } else {\n            offscreenInstance._visibility |= OffscreenVisible;\n          }\n\n          if (isHidden) {\n            const isUpdate = current !== null;\n            const wasHiddenByAncestorOffscreen = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden; // Only trigger disapper layout effects if:\n            //   - This is an update, not first mount.\n            //   - This Offscreen was not hidden before.\n            //   - Ancestor Offscreen was not hidden in previous commit.\n\n            if (isUpdate && !wasHidden && !wasHiddenByAncestorOffscreen) {\n              if ((finishedWork.mode & ConcurrentMode) !== NoMode) {\n                // Disappear the layout effects of all the children\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n              }\n            }\n          } else {\n            if (wasHidden) {// TODO: Move re-appear call here for symmetry?\n            }\n          } // Offscreen with manual mode manages visibility manually.\n\n\n          if (supportsMutation && !isOffscreenManual(finishedWork)) {\n            // TODO: This needs to run whenever there's an insertion or update\n            // inside a hidden Offscreen tree.\n            hideOrUnhideAllChildren(finishedWork, isHidden);\n          }\n        } // TODO: Move to passive phase\n\n\n        if (flags & Update) {\n          const offscreenQueue = finishedWork.updateQueue;\n\n          if (offscreenQueue !== null) {\n            const wakeables = offscreenQueue.wakeables;\n\n            if (wakeables !== null) {\n              offscreenQueue.wakeables = null;\n              attachSuspenseRetryListeners(finishedWork, wakeables);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case SuspenseListComponent:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Update) {\n          const wakeables = finishedWork.updateQueue;\n\n          if (wakeables !== null) {\n            finishedWork.updateQueue = null;\n            attachSuspenseRetryListeners(finishedWork, wakeables);\n          }\n        }\n\n        return;\n      }\n\n    case ScopeComponent:\n      {\n        if (enableScopeAPI) {\n          recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n          commitReconciliationEffects(finishedWork); // TODO: This is a temporary solution that allowed us to transition away\n          // from React Flare on www.\n\n          if (flags & Ref) {\n            if (current !== null) {\n              safelyDetachRef(finishedWork, finishedWork.return);\n            }\n\n            safelyAttachRef(finishedWork, finishedWork.return);\n          }\n\n          if (flags & Update) {\n            const scopeInstance = finishedWork.stateNode;\n            prepareScopeUpdate(scopeInstance, finishedWork);\n          }\n        }\n\n        return;\n      }\n\n    default:\n      {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n        return;\n      }\n  }\n}\n\nfunction commitReconciliationEffects(finishedWork) {\n  // Placement effects (insertions, reorders) can be scheduled on any fiber\n  // type. They needs to happen after the children effects have fired, but\n  // before the effects on this fiber have fired.\n  const flags = finishedWork.flags;\n\n  if (flags & Placement) {\n    try {\n      commitPlacement(finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    } // Clear the \"placement\" from effect tag so that we know that this is\n    // inserted, before any life-cycles like componentDidMount gets called.\n    // TODO: findDOMNode doesn't rely on this any more but isMounted does\n    // and isMounted is deprecated anyway so we should be able to kill this.\n\n\n    finishedWork.flags &= ~Placement;\n  }\n\n  if (flags & Hydrating) {\n    finishedWork.flags &= ~Hydrating;\n  }\n}\n\nexport function commitLayoutEffects(finishedWork, root, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  const current = finishedWork.alternate;\n  commitLayoutEffectOnFiber(root, current, finishedWork, committedLanes);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction recursivelyTraverseLayoutEffects(root, parentFiber, lanes) {\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n\n  if (parentFiber.subtreeFlags & LayoutMask) {\n    let child = parentFiber.child;\n\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      const current = child.alternate;\n      commitLayoutEffectOnFiber(root, current, child, lanes);\n      child = child.sibling;\n    }\n  }\n\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nexport function disappearLayoutEffects(finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        // TODO (Offscreen) Check: flags & LayoutStatic\n        if (shouldProfile(finishedWork)) {\n          try {\n            startLayoutEffectTimer();\n            commitHookEffectListUnmount(HookLayout, finishedWork, finishedWork.return);\n          } finally {\n            recordLayoutEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListUnmount(HookLayout, finishedWork, finishedWork.return);\n        }\n\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      }\n\n    case ClassComponent:\n      {\n        // TODO (Offscreen) Check: flags & RefStatic\n        safelyDetachRef(finishedWork, finishedWork.return);\n        const instance = finishedWork.stateNode;\n\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n        }\n\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      }\n\n    case HostResource:\n    case HostSingleton:\n    case HostComponent:\n      {\n        // TODO (Offscreen) Check: flags & RefStatic\n        safelyDetachRef(finishedWork, finishedWork.return);\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        // TODO (Offscreen) Check: flags & RefStatic\n        safelyDetachRef(finishedWork, finishedWork.return);\n        const isHidden = finishedWork.memoizedState !== null;\n\n        if (isHidden) {// Nested Offscreen tree is already hidden. Don't disappear\n          // its effects.\n        } else {\n          recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      }\n  }\n}\n\nfunction recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n  // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n  let child = parentFiber.child;\n\n  while (child !== null) {\n    disappearLayoutEffects(child);\n    child = child.sibling;\n  }\n}\n\nexport function reappearLayoutEffects(finishedRoot, current, finishedWork, // This function visits both newly finished work and nodes that were re-used\n// from a previously committed tree. We cannot check non-static flags if the\n// node was reused.\nincludeWorkInProgressEffects) {\n  // Turn on layout effects in a tree that previously disappeared.\n  const flags = finishedWork.flags;\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Check flags & LayoutStatic\n\n        commitHookLayoutEffects(finishedWork, HookLayout);\n        break;\n      }\n\n    case ClassComponent:\n      {\n        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Check for LayoutStatic flag\n\n        const instance = finishedWork.stateNode;\n\n        if (typeof instance.componentDidMount === 'function') {\n          try {\n            instance.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        } // Commit any callbacks that would have fired while the component\n        // was hidden.\n\n\n        const updateQueue = finishedWork.updateQueue;\n\n        if (updateQueue !== null) {\n          commitHiddenCallbacks(updateQueue, instance);\n        } // If this is newly finished work, check for setState callbacks\n\n\n        if (includeWorkInProgressEffects && flags & Callback) {\n          commitClassCallbacks(finishedWork);\n        } // TODO: Check flags & RefStatic\n\n\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      }\n    // Unlike commitLayoutEffectsOnFiber, we don't need to handle HostRoot\n    // because this function only visits nodes that are inside an\n    // Offscreen fiber.\n    // case HostRoot: {\n    //  ...\n    // }\n\n    case HostResource:\n    case HostSingleton:\n    case HostComponent:\n      {\n        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n\n        if (includeWorkInProgressEffects && current === null && flags & Update) {\n          commitHostComponentMount(finishedWork);\n        } // TODO: Check flags & Ref\n\n\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      }\n\n    case Profiler:\n      {\n        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Figure out how Profiler updates should work with Offscreen\n\n        if (includeWorkInProgressEffects && flags & Update) {\n          commitProfilerUpdate(finishedWork, current);\n        }\n\n        break;\n      }\n\n    case SuspenseComponent:\n      {\n        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Figure out how Suspense hydration callbacks should work\n        // with Offscreen.\n\n        if (includeWorkInProgressEffects && flags & Update) {\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        const offscreenState = finishedWork.memoizedState;\n        const isHidden = offscreenState !== null;\n\n        if (isHidden) {// Nested Offscreen tree is still hidden. Don't re-appear its effects.\n        } else {\n          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n        } // TODO: Check flags & Ref\n\n\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      }\n\n    default:\n      {\n        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n        break;\n      }\n  }\n}\n\nfunction recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n  // This function visits both newly finished work and nodes that were re-used\n  // from a previously committed tree. We cannot check non-static flags if the\n  // node was reused.\n  const childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & LayoutMask) !== NoFlags; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n  let child = parentFiber.child;\n\n  while (child !== null) {\n    const current = child.alternate;\n    reappearLayoutEffects(finishedRoot, current, child, childShouldIncludeWorkInProgressEffects);\n    child = child.sibling;\n  }\n\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitHookPassiveMountEffects(finishedWork, hookFlags) {\n  if (shouldProfile(finishedWork)) {\n    startPassiveEffectTimer();\n\n    try {\n      commitHookEffectListMount(hookFlags, finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n\n    recordPassiveEffectDuration(finishedWork);\n  } else {\n    try {\n      commitHookEffectListMount(hookFlags, finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\n\nfunction commitOffscreenPassiveMountEffects(current, finishedWork, instance) {\n  if (enableCache) {\n    let previousCache = null;\n\n    if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n      previousCache = current.memoizedState.cachePool.pool;\n    }\n\n    let nextCache = null;\n\n    if (finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null) {\n      nextCache = finishedWork.memoizedState.cachePool.pool;\n    } // Retain/release the cache used for pending (suspended) nodes.\n    // Note that this is only reached in the non-suspended/visible case:\n    // when the content is suspended/hidden, the retain/release occurs\n    // via the parent Suspense component (see case above).\n\n\n    if (nextCache !== previousCache) {\n      if (nextCache != null) {\n        retainCache(nextCache);\n      }\n\n      if (previousCache != null) {\n        releaseCache(previousCache);\n      }\n    }\n  }\n\n  if (enableTransitionTracing) {\n    // TODO: Pre-rendering should not be counted as part of a transition. We\n    // may add separate logs for pre-rendering, but it's not part of the\n    // primary metrics.\n    const offscreenState = finishedWork.memoizedState;\n    const queue = finishedWork.updateQueue;\n    const isHidden = offscreenState !== null;\n\n    if (queue !== null) {\n      if (isHidden) {\n        const transitions = queue.transitions;\n\n        if (transitions !== null) {\n          transitions.forEach(transition => {\n            // Add all the transitions saved in the update queue during\n            // the render phase (ie the transitions associated with this boundary)\n            // into the transitions set.\n            if (instance._transitions === null) {\n              instance._transitions = new Set();\n            }\n\n            instance._transitions.add(transition);\n          });\n        }\n\n        const markerInstances = queue.markerInstances;\n\n        if (markerInstances !== null) {\n          markerInstances.forEach(markerInstance => {\n            const markerTransitions = markerInstance.transitions; // There should only be a few tracing marker transitions because\n            // they should be only associated with the transition that\n            // caused them\n\n            if (markerTransitions !== null) {\n              markerTransitions.forEach(transition => {\n                if (instance._transitions === null) {\n                  instance._transitions = new Set();\n                } else if (instance._transitions.has(transition)) {\n                  if (markerInstance.pendingBoundaries === null) {\n                    markerInstance.pendingBoundaries = new Map();\n                  }\n\n                  if (instance._pendingMarkers === null) {\n                    instance._pendingMarkers = new Set();\n                  }\n\n                  instance._pendingMarkers.add(markerInstance);\n                }\n              });\n            }\n          });\n        }\n      }\n\n      finishedWork.updateQueue = null;\n    }\n\n    commitTransitionProgress(finishedWork); // TODO: Refactor this into an if/else branch\n\n    if (!isHidden) {\n      instance._transitions = null;\n      instance._pendingMarkers = null;\n    }\n  }\n}\n\nfunction commitCachePassiveMountEffect(current, finishedWork) {\n  if (enableCache) {\n    let previousCache = null;\n\n    if (finishedWork.alternate !== null) {\n      previousCache = finishedWork.alternate.memoizedState.cache;\n    }\n\n    const nextCache = finishedWork.memoizedState.cache; // Retain/release the cache. In theory the cache component\n    // could be \"borrowing\" a cache instance owned by some parent,\n    // in which case we could avoid retaining/releasing. But it\n    // is non-trivial to determine when that is the case, so we\n    // always retain/release.\n\n    if (nextCache !== previousCache) {\n      retainCache(nextCache);\n\n      if (previousCache != null) {\n        releaseCache(previousCache);\n      }\n    }\n  }\n}\n\nfunction commitTracingMarkerPassiveMountEffect(finishedWork) {\n  // Get the transitions that were initiatized during the render\n  // and add a start transition callback for each of them\n  // We will only call this on initial mount of the tracing marker\n  // only if there are no suspense children\n  const instance = finishedWork.stateNode;\n\n  if (instance.transitions !== null && instance.pendingBoundaries === null) {\n    addMarkerCompleteCallbackToPendingTransition(finishedWork.memoizedProps.name, instance.transitions);\n    instance.transitions = null;\n    instance.pendingBoundaries = null;\n    instance.aborts = null;\n    instance.name = null;\n  }\n}\n\nexport function commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {\n  setCurrentDebugFiberInDEV(finishedWork);\n  commitPassiveMountOnFiber(root, finishedWork, committedLanes, committedTransitions);\n  resetCurrentDebugFiberInDEV();\n}\n\nfunction recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n\n  if (parentFiber.subtreeFlags & PassiveMask) {\n    let child = parentFiber.child;\n\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      commitPassiveMountOnFiber(root, child, committedLanes, committedTransitions);\n      child = child.sibling;\n    }\n  }\n\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n  // When updating this function, also update reconnectPassiveEffects, which does\n  // most of the same things when an offscreen tree goes from hidden -> visible,\n  // or when toggling effects inside a hidden tree.\n  const flags = finishedWork.flags;\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n\n        if (flags & Passive) {\n          commitHookPassiveMountEffects(finishedWork, HookPassive | HookHasEffect);\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n\n        if (flags & Passive) {\n          if (enableCache) {\n            let previousCache = null;\n\n            if (finishedWork.alternate !== null) {\n              previousCache = finishedWork.alternate.memoizedState.cache;\n            }\n\n            const nextCache = finishedWork.memoizedState.cache; // Retain/release the root cache.\n            // Note that on initial mount, previousCache and nextCache will be the same\n            // and this retain won't occur. To counter this, we instead retain the HostRoot's\n            // initial cache when creating the root itself (see createFiberRoot() in\n            // ReactFiberRoot.js). Subsequent updates that change the cache are reflected\n            // here, such that previous/next caches are retained correctly.\n\n            if (nextCache !== previousCache) {\n              retainCache(nextCache);\n\n              if (previousCache != null) {\n                releaseCache(previousCache);\n              }\n            }\n          }\n\n          if (enableTransitionTracing) {\n            // Get the transitions that were initiatized during the render\n            // and add a start transition callback for each of them\n            const root = finishedWork.stateNode;\n            const incompleteTransitions = root.incompleteTransitions; // Initial render\n\n            if (committedTransitions !== null) {\n              committedTransitions.forEach(transition => {\n                addTransitionStartCallbackToPendingTransition(transition);\n              });\n              clearTransitionsForLanes(finishedRoot, committedLanes);\n            }\n\n            incompleteTransitions.forEach((markerInstance, transition) => {\n              const pendingBoundaries = markerInstance.pendingBoundaries;\n\n              if (pendingBoundaries === null || pendingBoundaries.size === 0) {\n                if (markerInstance.aborts === null) {\n                  addTransitionCompleteCallbackToPendingTransition(transition);\n                }\n\n                incompleteTransitions.delete(transition);\n              }\n            });\n            clearTransitionsForLanes(finishedRoot, committedLanes);\n          }\n        }\n\n        break;\n      }\n\n    case LegacyHiddenComponent:\n      {\n        if (enableLegacyHidden) {\n          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n\n          if (flags & Passive) {\n            const current = finishedWork.alternate;\n            const instance = finishedWork.stateNode;\n            commitOffscreenPassiveMountEffects(current, finishedWork, instance);\n          }\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        // TODO: Pass `current` as argument to this function\n        const instance = finishedWork.stateNode;\n        const nextState = finishedWork.memoizedState;\n        const isHidden = nextState !== null;\n\n        if (isHidden) {\n          if (instance._visibility & OffscreenPassiveEffectsConnected) {\n            // The effects are currently connected. Update them.\n            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n          } else {\n            if (finishedWork.mode & ConcurrentMode) {\n              // The effects are currently disconnected. Since the tree is hidden,\n              // don't connect them. This also applies to the initial render.\n              if (enableCache || enableTransitionTracing) {\n                // \"Atomic\" effects are ones that need to fire on every commit,\n                // even during pre-rendering. An example is updating the reference\n                // count on cache instances.\n                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n              }\n            } else {\n              // Legacy Mode: Fire the effects even if the tree is hidden.\n              instance._visibility |= OffscreenPassiveEffectsConnected;\n              recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n            }\n          }\n        } else {\n          // Tree is visible\n          if (instance._visibility & OffscreenPassiveEffectsConnected) {\n            // The effects are currently connected. Update them.\n            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n          } else {\n            // The effects are currently disconnected. Reconnect them, while also\n            // firing effects inside newly mounted trees. This also applies to\n            // the initial render.\n            instance._visibility |= OffscreenPassiveEffectsConnected;\n            const includeWorkInProgressEffects = (finishedWork.subtreeFlags & PassiveMask) !== NoFlags;\n            recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n          }\n        }\n\n        if (flags & Passive) {\n          const current = finishedWork.alternate;\n          commitOffscreenPassiveMountEffects(current, finishedWork, instance);\n        }\n\n        break;\n      }\n\n    case CacheComponent:\n      {\n        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n\n        if (flags & Passive) {\n          // TODO: Pass `current` as argument to this function\n          const current = finishedWork.alternate;\n          commitCachePassiveMountEffect(current, finishedWork);\n        }\n\n        break;\n      }\n\n    case TracingMarkerComponent:\n      {\n        if (enableTransitionTracing) {\n          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n\n          if (flags & Passive) {\n            commitTracingMarkerPassiveMountEffect(finishedWork);\n          }\n\n          break;\n        } // Intentional fallthrough to next branch\n\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      {\n        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n        break;\n      }\n  }\n}\n\nfunction recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n  // This function visits both newly finished work and nodes that were re-used\n  // from a previously committed tree. We cannot check non-static flags if the\n  // node was reused.\n  const childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & PassiveMask) !== NoFlags; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n  let child = parentFiber.child;\n\n  while (child !== null) {\n    reconnectPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, childShouldIncludeWorkInProgressEffects);\n    child = child.sibling;\n  }\n\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nexport function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, // This function visits both newly finished work and nodes that were re-used\n// from a previously committed tree. We cannot check non-static flags if the\n// node was reused.\nincludeWorkInProgressEffects) {\n  const flags = finishedWork.flags;\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects); // TODO: Check for PassiveStatic flag\n\n        commitHookPassiveMountEffects(finishedWork, HookPassive);\n        break;\n      }\n    // Unlike commitPassiveMountOnFiber, we don't need to handle HostRoot\n    // because this function only visits nodes that are inside an\n    // Offscreen fiber.\n    // case HostRoot: {\n    //  ...\n    // }\n\n    case LegacyHiddenComponent:\n      {\n        if (enableLegacyHidden) {\n          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n\n          if (includeWorkInProgressEffects && flags & Passive) {\n            // TODO: Pass `current` as argument to this function\n            const current = finishedWork.alternate;\n            const instance = finishedWork.stateNode;\n            commitOffscreenPassiveMountEffects(current, finishedWork, instance);\n          }\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        const instance = finishedWork.stateNode;\n        const nextState = finishedWork.memoizedState;\n        const isHidden = nextState !== null;\n\n        if (isHidden) {\n          if (instance._visibility & OffscreenPassiveEffectsConnected) {\n            // The effects are currently connected. Update them.\n            recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n          } else {\n            if (finishedWork.mode & ConcurrentMode) {\n              // The effects are currently disconnected. Since the tree is hidden,\n              // don't connect them. This also applies to the initial render.\n              if (enableCache || enableTransitionTracing) {\n                // \"Atomic\" effects are ones that need to fire on every commit,\n                // even during pre-rendering. An example is updating the reference\n                // count on cache instances.\n                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n              }\n            } else {\n              // Legacy Mode: Fire the effects even if the tree is hidden.\n              instance._visibility |= OffscreenPassiveEffectsConnected;\n              recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n            }\n          }\n        } else {\n          // Tree is visible\n          // Since we're already inside a reconnecting tree, it doesn't matter\n          // whether the effects are currently connected. In either case, we'll\n          // continue traversing the tree and firing all the effects.\n          //\n          // We do need to set the \"connected\" flag on the instance, though.\n          instance._visibility |= OffscreenPassiveEffectsConnected;\n          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n        }\n\n        if (includeWorkInProgressEffects && flags & Passive) {\n          // TODO: Pass `current` as argument to this function\n          const current = finishedWork.alternate;\n          commitOffscreenPassiveMountEffects(current, finishedWork, instance);\n        }\n\n        break;\n      }\n\n    case CacheComponent:\n      {\n        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n\n        if (includeWorkInProgressEffects && flags & Passive) {\n          // TODO: Pass `current` as argument to this function\n          const current = finishedWork.alternate;\n          commitCachePassiveMountEffect(current, finishedWork);\n        }\n\n        break;\n      }\n\n    case TracingMarkerComponent:\n      {\n        if (enableTransitionTracing) {\n          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n\n          if (includeWorkInProgressEffects && flags & Passive) {\n            commitTracingMarkerPassiveMountEffect(finishedWork);\n          }\n\n          break;\n        } // Intentional fallthrough to next branch\n\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      {\n        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n        break;\n      }\n  }\n}\n\nfunction recursivelyTraverseAtomicPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions) {\n  // \"Atomic\" effects are ones that need to fire on every commit, even during\n  // pre-rendering. We call this function when traversing a hidden tree whose\n  // regular effects are currently disconnected.\n  const prevDebugFiber = getCurrentDebugFiberInDEV(); // TODO: Add special flag for atomic effects\n\n  if (parentFiber.subtreeFlags & PassiveMask) {\n    let child = parentFiber.child;\n\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      commitAtomicPassiveEffects(finishedRoot, child, committedLanes, committedTransitions);\n      child = child.sibling;\n    }\n  }\n\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n  // \"Atomic\" effects are ones that need to fire on every commit, even during\n  // pre-rendering. We call this function when traversing a hidden tree whose\n  // regular effects are currently disconnected.\n  const flags = finishedWork.flags;\n\n  switch (finishedWork.tag) {\n    case OffscreenComponent:\n      {\n        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n\n        if (flags & Passive) {\n          // TODO: Pass `current` as argument to this function\n          const current = finishedWork.alternate;\n          const instance = finishedWork.stateNode;\n          commitOffscreenPassiveMountEffects(current, finishedWork, instance);\n        }\n\n        break;\n      }\n\n    case CacheComponent:\n      {\n        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n\n        if (flags & Passive) {\n          // TODO: Pass `current` as argument to this function\n          const current = finishedWork.alternate;\n          commitCachePassiveMountEffect(current, finishedWork);\n        }\n\n        break;\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      {\n        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n        break;\n      }\n  }\n}\n\nexport function commitPassiveUnmountEffects(finishedWork) {\n  setCurrentDebugFiberInDEV(finishedWork);\n  commitPassiveUnmountOnFiber(finishedWork);\n  resetCurrentDebugFiberInDEV();\n}\n\nfunction detachAlternateSiblings(parentFiber) {\n  if (deletedTreeCleanUpLevel >= 1) {\n    // A fiber was deleted from this parent fiber, but it's still part of the\n    // previous (alternate) parent fiber's list of children. Because children\n    // are a linked list, an earlier sibling that's still alive will be\n    // connected to the deleted fiber via its `alternate`:\n    //\n    //   live fiber --alternate--> previous live fiber --sibling--> deleted\n    //   fiber\n    //\n    // We can't disconnect `alternate` on nodes that haven't been deleted yet,\n    // but we can disconnect the `sibling` and `child` pointers.\n    const previousFiber = parentFiber.alternate;\n\n    if (previousFiber !== null) {\n      let detachedChild = previousFiber.child;\n\n      if (detachedChild !== null) {\n        previousFiber.child = null;\n\n        do {\n          // $FlowFixMe[incompatible-use] found when upgrading Flow\n          const detachedSibling = detachedChild.sibling; // $FlowFixMe[incompatible-use] found when upgrading Flow\n\n          detachedChild.sibling = null;\n          detachedChild = detachedSibling;\n        } while (detachedChild !== null);\n      }\n    }\n  }\n}\n\nfunction commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n  if (shouldProfile(finishedWork)) {\n    startPassiveEffectTimer();\n    commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    recordPassiveEffectDuration(finishedWork);\n  } else {\n    commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n  }\n}\n\nfunction recursivelyTraversePassiveUnmountEffects(parentFiber) {\n  // Deletions effects can be scheduled on any fiber type. They need to happen\n  // before the children effects have fired.\n  const deletions = parentFiber.deletions;\n\n  if ((parentFiber.flags & ChildDeletion) !== NoFlags) {\n    if (deletions !== null) {\n      for (let i = 0; i < deletions.length; i++) {\n        const childToDelete = deletions[i]; // TODO: Convert this to use recursion\n\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n      }\n    }\n\n    detachAlternateSiblings(parentFiber);\n  }\n\n  const prevDebugFiber = getCurrentDebugFiberInDEV(); // TODO: Split PassiveMask into separate masks for mount and unmount?\n\n  if (parentFiber.subtreeFlags & PassiveMask) {\n    let child = parentFiber.child;\n\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      commitPassiveUnmountOnFiber(child);\n      child = child.sibling;\n    }\n  }\n\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitPassiveUnmountOnFiber(finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        recursivelyTraversePassiveUnmountEffects(finishedWork);\n\n        if (finishedWork.flags & Passive) {\n          commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, HookPassive | HookHasEffect);\n        }\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        const instance = finishedWork.stateNode;\n        const nextState = finishedWork.memoizedState;\n        const isHidden = nextState !== null;\n\n        if (isHidden && instance._visibility & OffscreenPassiveEffectsConnected && (finishedWork.return === null || finishedWork.return.tag !== SuspenseComponent)) {\n          // The effects are currently connected. Disconnect them.\n          // TODO: Add option or heuristic to delay before disconnecting the\n          // effects. Then if the tree reappears before the delay has elapsed, we\n          // can skip toggling the effects entirely.\n          instance._visibility &= ~OffscreenPassiveEffectsConnected;\n          recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        } else {\n          recursivelyTraversePassiveUnmountEffects(finishedWork);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        recursivelyTraversePassiveUnmountEffects(finishedWork);\n        break;\n      }\n  }\n}\n\nfunction recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n  // Deletions effects can be scheduled on any fiber type. They need to happen\n  // before the children effects have fired.\n  const deletions = parentFiber.deletions;\n\n  if ((parentFiber.flags & ChildDeletion) !== NoFlags) {\n    if (deletions !== null) {\n      for (let i = 0; i < deletions.length; i++) {\n        const childToDelete = deletions[i]; // TODO: Convert this to use recursion\n\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n      }\n    }\n\n    detachAlternateSiblings(parentFiber);\n  }\n\n  const prevDebugFiber = getCurrentDebugFiberInDEV(); // TODO: Check PassiveStatic flag\n\n  let child = parentFiber.child;\n\n  while (child !== null) {\n    setCurrentDebugFiberInDEV(child);\n    disconnectPassiveEffect(child);\n    child = child.sibling;\n  }\n\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nexport function disconnectPassiveEffect(finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        // TODO: Check PassiveStatic flag\n        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, HookPassive); // When disconnecting passive effects, we fire the effects in the same\n        // order as during a deletiong: parent before child\n\n        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        const instance = finishedWork.stateNode;\n\n        if (instance._visibility & OffscreenPassiveEffectsConnected) {\n          instance._visibility &= ~OffscreenPassiveEffectsConnected;\n          recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        } else {// The effects are already disconnected.\n        }\n\n        break;\n      }\n\n    default:\n      {\n        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        break;\n      }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect; // Deletion effects fire in parent -> child order\n    // TODO: Check if fiber has a PassiveStatic flag\n\n    setCurrentDebugFiberInDEV(fiber);\n    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n    resetCurrentDebugFiberInDEV();\n    const child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n\n    if (child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const sibling = fiber.sibling;\n    const returnFiber = fiber.return;\n\n    if (deletedTreeCleanUpLevel >= 2) {\n      // Recursively traverse the entire deleted tree and clean up fiber fields.\n      // This is more aggressive than ideal, and the long term goal is to only\n      // have to detach the deleted tree at the root.\n      detachFiberAfterEffects(fiber);\n\n      if (fiber === deletedSubtreeRoot) {\n        nextEffect = null;\n        return;\n      }\n    } else {\n      // This is the default branch (level 0). We do not recursively clear all\n      // the fiber fields. Only the root of the deleted subtree.\n      if (fiber === deletedSubtreeRoot) {\n        detachFiberAfterEffects(fiber);\n        nextEffect = null;\n        return;\n      }\n    }\n\n    if (sibling !== null) {\n      sibling.return = returnFiber;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = returnFiber;\n  }\n}\n\nfunction commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        commitHookPassiveUnmountEffects(current, nearestMountedAncestor, HookPassive);\n        break;\n      }\n    // TODO: run passive unmount effects when unmounting a root.\n    // Because passive unmount effects are not currently run,\n    // the cache instance owned by the root will never be freed.\n    // When effects are run, the cache should be freed here:\n    // case HostRoot: {\n    //   if (enableCache) {\n    //     const cache = current.memoizedState.cache;\n    //     releaseCache(cache);\n    //   }\n    //   break;\n    // }\n\n    case LegacyHiddenComponent:\n    case OffscreenComponent:\n      {\n        if (enableCache) {\n          if (current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n            const cache = current.memoizedState.cachePool.pool; // Retain/release the cache used for pending (suspended) nodes.\n            // Note that this is only reached in the non-suspended/visible case:\n            // when the content is suspended/hidden, the retain/release occurs\n            // via the parent Suspense component (see case above).\n\n            if (cache != null) {\n              retainCache(cache);\n            }\n          }\n        }\n\n        break;\n      }\n\n    case SuspenseComponent:\n      {\n        if (enableTransitionTracing) {\n          // We need to mark this fiber's parents as deleted\n          const offscreenFiber = current.child;\n          const instance = offscreenFiber.stateNode;\n          const transitions = instance._transitions;\n\n          if (transitions !== null) {\n            const abortReason = {\n              reason: 'suspense',\n              name: current.memoizedProps.unstable_name || null\n            };\n\n            if (current.memoizedState === null || current.memoizedState.dehydrated === null) {\n              abortParentMarkerTransitionsForDeletedFiber(offscreenFiber, abortReason, transitions, instance, true);\n\n              if (nearestMountedAncestor !== null) {\n                abortParentMarkerTransitionsForDeletedFiber(nearestMountedAncestor, abortReason, transitions, instance, false);\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n    case CacheComponent:\n      {\n        if (enableCache) {\n          const cache = current.memoizedState.cache;\n          releaseCache(cache);\n        }\n\n        break;\n      }\n\n    case TracingMarkerComponent:\n      {\n        if (enableTransitionTracing) {\n          // We need to mark this fiber's parents as deleted\n          const instance = current.stateNode;\n          const transitions = instance.transitions;\n\n          if (transitions !== null) {\n            const abortReason = {\n              reason: 'marker',\n              name: current.memoizedProps.name\n            };\n            abortParentMarkerTransitionsForDeletedFiber(current, abortReason, transitions, null, true);\n\n            if (nearestMountedAncestor !== null) {\n              abortParentMarkerTransitionsForDeletedFiber(nearestMountedAncestor, abortReason, transitions, null, false);\n            }\n          }\n        }\n\n        break;\n      }\n  }\n}\n\nfunction invokeLayoutEffectMountInDEV(fiber) {\n  if (__DEV__) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(HookLayout | HookHasEffect, fiber);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          const instance = fiber.stateNode;\n\n          try {\n            instance.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectMountInDEV(fiber) {\n  if (__DEV__) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(HookPassive | HookHasEffect, fiber);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokeLayoutEffectUnmountInDEV(fiber) {\n  if (__DEV__) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(HookLayout | HookHasEffect, fiber, fiber.return);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          const instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectUnmountInDEV(fiber) {\n  if (__DEV__) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(HookPassive | HookHasEffect, fiber, fiber.return);\n          } catch (error) {\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n        }\n    }\n  }\n}\n\nexport { commitPlacement, commitAttachRef, invokeLayoutEffectMountInDEV, invokeLayoutEffectUnmountInDEV, invokePassiveEffectMountInDEV, invokePassiveEffectUnmountInDEV };","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberCommitWork.js"],"names":["NoTimestamp","SyncLane","isOffscreenManual","enableCreateEventHandleAPI","enableProfilerTimer","enableProfilerCommitHooks","enableProfilerNestedUpdatePhase","enableSchedulingProfiler","enableSuspenseCallback","enableScopeAPI","deletedTreeCleanUpLevel","enableUpdaterTracking","enableCache","enableTransitionTracing","enableUseEffectEventHook","enableFloat","enableLegacyHidden","enableHostSingletons","FunctionComponent","ForwardRef","ClassComponent","HostRoot","HostComponent","HostResource","HostSingleton","HostText","HostPortal","Profiler","SuspenseComponent","DehydratedFragment","IncompleteClassComponent","MemoComponent","SimpleMemoComponent","SuspenseListComponent","ScopeComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","TracingMarkerComponent","NoFlags","ContentReset","Placement","ChildDeletion","Snapshot","Update","Callback","Ref","Hydrating","Passive","BeforeMutationMask","MutationMask","LayoutMask","PassiveMask","Visibility","getComponentNameFromFiber","resetCurrentFiber","resetCurrentDebugFiberInDEV","setCurrentFiber","setCurrentDebugFiberInDEV","getCurrentFiber","getCurrentDebugFiberInDEV","resolveDefaultProps","isCurrentUpdateNested","getCommitTime","recordLayoutEffectDuration","startLayoutEffectTimer","recordPassiveEffectDuration","startPassiveEffectTimer","ConcurrentMode","NoMode","ProfileMode","deferHiddenCallbacks","commitHiddenCallbacks","commitCallbacks","getPublicInstance","supportsMutation","supportsPersistence","supportsHydration","supportsResources","supportsSingletons","commitMount","commitUpdate","resetTextContent","commitTextUpdate","appendChild","appendChildToContainer","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","clearSuspenseBoundary","clearSuspenseBoundaryFromContainer","replaceContainerChildren","createContainerChildSet","hideInstance","hideTextInstance","unhideInstance","unhideTextInstance","commitHydratedContainer","commitHydratedSuspenseInstance","clearContainer","prepareScopeUpdate","prepareForCommit","beforeActiveInstanceBlur","detachDeletedInstance","acquireResource","releaseResource","clearSingleton","acquireSingletonInstance","releaseSingletonInstance","captureCommitPhaseError","resolveRetryWakeable","markCommitTimeOfFallback","enqueuePendingPassiveProfilerEffect","restorePendingUpdaters","addTransitionStartCallbackToPendingTransition","addTransitionProgressCallbackToPendingTransition","addTransitionCompleteCallbackToPendingTransition","addMarkerProgressCallbackToPendingTransition","addMarkerIncompleteCallbackToPendingTransition","addMarkerCompleteCallbackToPendingTransition","setIsRunningInsertionEffect","getExecutionContext","CommitContext","NoContext","NoHookEffect","HasEffect","HookHasEffect","Layout","HookLayout","Insertion","HookInsertion","HookPassive","didWarnAboutReassigningProps","doesFiberContain","invokeGuardedCallback","clearCaughtError","isDevToolsPresent","markComponentPassiveEffectMountStarted","markComponentPassiveEffectMountStopped","markComponentPassiveEffectUnmountStarted","markComponentPassiveEffectUnmountStopped","markComponentLayoutEffectMountStarted","markComponentLayoutEffectMountStopped","markComponentLayoutEffectUnmountStarted","markComponentLayoutEffectUnmountStopped","onCommitUnmount","releaseCache","retainCache","clearTransitionsForLanes","OffscreenVisible","OffscreenDetached","OffscreenPassiveEffectsConnected","TransitionRoot","TransitionTracingMarker","scheduleUpdateOnFiber","enqueueConcurrentRenderForLane","didWarnAboutUndefinedSnapshotBeforeUpdate","__DEV__","Set","offscreenSubtreeIsHidden","offscreenSubtreeWasHidden","PossiblyWeakSet","WeakSet","nextEffect","inProgressLanes","inProgressRoot","shouldProfile","current","mode","reportUncaughtErrorInDEV","error","callComponentWillUnmountWithTimer","instance","props","memoizedProps","state","memoizedState","componentWillUnmount","safelyCallComponentWillUnmount","nearestMountedAncestor","safelyAttachRef","commitAttachRef","safelyDetachRef","ref","refCleanup","finishedWork","alternate","retVal","console","safelyCallDestroy","destroy","focusedInstanceHandle","shouldFireAfterActiveInstanceBlur","commitBeforeMutationEffects","root","firstChild","containerInfo","commitBeforeMutationEffects_begin","shouldFire","fiber","deletions","i","length","deletion","commitBeforeMutationEffectsDeletion","child","subtreeFlags","return","commitBeforeMutationEffects_complete","commitBeforeMutationEffectsOnFiber","sibling","flags","tag","isSuspenseBoundaryBeingHidden","commitUseEffectEventMount","prevProps","prevState","stateNode","type","elementType","snapshot","getSnapshotBeforeUpdate","didWarnSet","undefined","has","add","__reactInternalSnapshotBeforeUpdate","Error","commitHookEffectListUnmount","updateQueue","lastEffect","firstEffect","next","effect","commitHookEffectListMount","create","hookName","addendum","then","eventPayloads","events","ii","nextImpl","impl","commitPassiveEffectDurations","finishedRoot","passiveEffectDuration","id","onPostCommit","commitTime","phase","parentFiber","outer","parentStateNode","commitHookLayoutEffects","hookFlags","commitClassLayoutLifecycles","componentDidMount","componentDidUpdate","commitClassCallbacks","commitHostComponentMount","commitProfilerUpdate","onCommit","onRender","effectDuration","actualDuration","treeBaseDuration","actualStartTime","commitLayoutEffectOnFiber","committedLanes","recursivelyTraverseLayoutEffects","commitSuspenseHydrationCallbacks","isModernRoot","isHidden","newOffscreenSubtreeIsHidden","wasHidden","newOffscreenSubtreeWasHidden","prevOffscreenSubtreeIsHidden","prevOffscreenSubtreeWasHidden","includeWorkInProgressEffects","recursivelyTraverseReappearLayoutEffects","abortRootTransitions","abort","deletedTransitions","deletedOffscreenInstance","isInDeletedTree","rootTransitions","incompleteTransitions","forEach","transition","transitionInstance","get","aborts","push","pendingBoundaries","delete","abortTracingMarkerTransitions","abortedFiber","markerInstance","markerTransitions","transitions","includes","name","abortParentMarkerTransitionsForDeletedFiber","commitTransitionProgress","offscreenFiber","offscreenInstance","previousFiber","nextState","pendingMarkers","_pendingMarkers","parent","unstable_name","markerName","set","size","hideOrUnhideAllChildren","hostSubtreeRoot","node","instanceToUse","hasOwnProperty","detachFiberMutation","detachFiberAfterEffects","dependencies","pendingProps","_debugOwner","hostInstance","emptyPortalContainer","portal","emptyChildSet","getHostParentFiber","isHostParent","getHostSibling","siblings","commitPlacement","before","insertOrAppendPlacementNode","insertOrAppendPlacementNodeIntoContainer","isHost","hostParent","hostParentIsContainer","commitDeletionEffects","returnFiber","deletedFiber","findParent","commitDeletionEffectsOnFiber","recursivelyTraverseDeletionEffects","prevHostParent","prevHostParentIsContainer","hydrationCallbacks","onDeleted","commitSuspenseCallback","newState","suspenseCallback","wakeables","suspenseInstance","dehydrated","onHydrated","getRetryCache","retryCache","_retryCache","detachOffscreenInstance","_current","_pendingVisibility","attachOffscreenInstance","attachSuspenseRetryListeners","wakeable","retry","bind","oldState","commitMutationEffects","commitMutationEffectsOnFiber","recursivelyTraverseMutationEffects","lanes","childToDelete","prevDebugFiber","commitReconciliationEffects","newResource","currentResource","previousWork","singleton","newProps","oldProps","updatePayload","textInstance","newText","oldText","prevRootState","isDehydrated","pendingChildren","_visibility","isUpdate","wasHiddenByAncestorOffscreen","recursivelyTraverseDisappearLayoutEffects","offscreenQueue","scopeInstance","commitLayoutEffects","disappearLayoutEffects","reappearLayoutEffects","offscreenState","childShouldIncludeWorkInProgressEffects","commitHookPassiveMountEffects","commitOffscreenPassiveMountEffects","previousCache","cachePool","pool","nextCache","queue","_transitions","markerInstances","Map","commitCachePassiveMountEffect","cache","commitTracingMarkerPassiveMountEffect","commitPassiveMountEffects","committedTransitions","commitPassiveMountOnFiber","recursivelyTraversePassiveMountEffects","recursivelyTraverseAtomicPassiveEffects","recursivelyTraverseReconnectPassiveEffects","reconnectPassiveEffects","commitAtomicPassiveEffects","commitPassiveUnmountEffects","commitPassiveUnmountOnFiber","detachAlternateSiblings","detachedChild","detachedSibling","commitHookPassiveUnmountEffects","recursivelyTraversePassiveUnmountEffects","commitPassiveUnmountEffectsInsideOfDeletedTree_begin","recursivelyTraverseDisconnectPassiveEffects","disconnectPassiveEffect","deletedSubtreeRoot","commitPassiveUnmountInsideDeletedTreeOnFiber","commitPassiveUnmountEffectsInsideOfDeletedTree_complete","abortReason","reason","invokeLayoutEffectMountInDEV","invokePassiveEffectMountInDEV","invokeLayoutEffectUnmountInDEV","invokePassiveEffectUnmountInDEV"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  Instance,\n  TextInstance,\n  SuspenseInstance,\n  Container,\n  ChildSet,\n  UpdatePayload,\n} from './ReactFiberHostConfig';\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Lanes} from './ReactFiberLane';\nimport {NoTimestamp, SyncLane} from './ReactFiberLane';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\nimport type {UpdateQueue} from './ReactFiberClassUpdateQueue';\nimport type {FunctionComponentUpdateQueue} from './ReactFiberHooks';\nimport type {Wakeable} from 'shared/ReactTypes';\nimport {isOffscreenManual} from './ReactFiberOffscreenComponent';\nimport type {\n  OffscreenState,\n  OffscreenInstance,\n  OffscreenQueue,\n  OffscreenProps,\n} from './ReactFiberOffscreenComponent';\nimport type {HookFlags} from './ReactHookEffectTags';\nimport type {Cache} from './ReactFiberCacheComponent';\nimport type {RootState} from './ReactFiberRoot';\nimport type {\n  Transition,\n  TracingMarkerInstance,\n  TransitionAbort,\n} from './ReactFiberTracingMarkerComponent';\n\nimport {\n  enableCreateEventHandleAPI,\n  enableProfilerTimer,\n  enableProfilerCommitHooks,\n  enableProfilerNestedUpdatePhase,\n  enableSchedulingProfiler,\n  enableSuspenseCallback,\n  enableScopeAPI,\n  deletedTreeCleanUpLevel,\n  enableUpdaterTracking,\n  enableCache,\n  enableTransitionTracing,\n  enableUseEffectEventHook,\n  enableFloat,\n  enableLegacyHidden,\n  enableHostSingletons,\n} from 'shared/ReactFeatureFlags';\nimport {\n  FunctionComponent,\n  ForwardRef,\n  ClassComponent,\n  HostRoot,\n  HostComponent,\n  HostResource,\n  HostSingleton,\n  HostText,\n  HostPortal,\n  Profiler,\n  SuspenseComponent,\n  DehydratedFragment,\n  IncompleteClassComponent,\n  MemoComponent,\n  SimpleMemoComponent,\n  SuspenseListComponent,\n  ScopeComponent,\n  OffscreenComponent,\n  LegacyHiddenComponent,\n  CacheComponent,\n  TracingMarkerComponent,\n} from './ReactWorkTags';\nimport {\n  NoFlags,\n  ContentReset,\n  Placement,\n  ChildDeletion,\n  Snapshot,\n  Update,\n  Callback,\n  Ref,\n  Hydrating,\n  Passive,\n  BeforeMutationMask,\n  MutationMask,\n  LayoutMask,\n  PassiveMask,\n  Visibility,\n} from './ReactFiberFlags';\nimport getComponentNameFromFiber from 'react-reconciler/src/getComponentNameFromFiber';\nimport {\n  resetCurrentFiber as resetCurrentDebugFiberInDEV,\n  setCurrentFiber as setCurrentDebugFiberInDEV,\n  getCurrentFiber as getCurrentDebugFiberInDEV,\n} from './ReactCurrentFiber';\nimport {resolveDefaultProps} from './ReactFiberLazyComponent';\nimport {\n  isCurrentUpdateNested,\n  getCommitTime,\n  recordLayoutEffectDuration,\n  startLayoutEffectTimer,\n  recordPassiveEffectDuration,\n  startPassiveEffectTimer,\n} from './ReactProfilerTimer';\nimport {ConcurrentMode, NoMode, ProfileMode} from './ReactTypeOfMode';\nimport {\n  deferHiddenCallbacks,\n  commitHiddenCallbacks,\n  commitCallbacks,\n} from './ReactFiberClassUpdateQueue';\nimport {\n  getPublicInstance,\n  supportsMutation,\n  supportsPersistence,\n  supportsHydration,\n  supportsResources,\n  supportsSingletons,\n  commitMount,\n  commitUpdate,\n  resetTextContent,\n  commitTextUpdate,\n  appendChild,\n  appendChildToContainer,\n  insertBefore,\n  insertInContainerBefore,\n  removeChild,\n  removeChildFromContainer,\n  clearSuspenseBoundary,\n  clearSuspenseBoundaryFromContainer,\n  replaceContainerChildren,\n  createContainerChildSet,\n  hideInstance,\n  hideTextInstance,\n  unhideInstance,\n  unhideTextInstance,\n  commitHydratedContainer,\n  commitHydratedSuspenseInstance,\n  clearContainer,\n  prepareScopeUpdate,\n  prepareForCommit,\n  beforeActiveInstanceBlur,\n  detachDeletedInstance,\n  acquireResource,\n  releaseResource,\n  clearSingleton,\n  acquireSingletonInstance,\n  releaseSingletonInstance,\n} from './ReactFiberHostConfig';\nimport {\n  captureCommitPhaseError,\n  resolveRetryWakeable,\n  markCommitTimeOfFallback,\n  enqueuePendingPassiveProfilerEffect,\n  restorePendingUpdaters,\n  addTransitionStartCallbackToPendingTransition,\n  addTransitionProgressCallbackToPendingTransition,\n  addTransitionCompleteCallbackToPendingTransition,\n  addMarkerProgressCallbackToPendingTransition,\n  addMarkerIncompleteCallbackToPendingTransition,\n  addMarkerCompleteCallbackToPendingTransition,\n  setIsRunningInsertionEffect,\n  getExecutionContext,\n  CommitContext,\n  NoContext,\n} from './ReactFiberWorkLoop';\nimport {\n  NoFlags as NoHookEffect,\n  HasEffect as HookHasEffect,\n  Layout as HookLayout,\n  Insertion as HookInsertion,\n  Passive as HookPassive,\n} from './ReactHookEffectTags';\nimport {didWarnAboutReassigningProps} from './ReactFiberBeginWork';\nimport {doesFiberContain} from './ReactFiberTreeReflection';\nimport {invokeGuardedCallback, clearCaughtError} from 'shared/ReactErrorUtils';\nimport {\n  isDevToolsPresent,\n  markComponentPassiveEffectMountStarted,\n  markComponentPassiveEffectMountStopped,\n  markComponentPassiveEffectUnmountStarted,\n  markComponentPassiveEffectUnmountStopped,\n  markComponentLayoutEffectMountStarted,\n  markComponentLayoutEffectMountStopped,\n  markComponentLayoutEffectUnmountStarted,\n  markComponentLayoutEffectUnmountStopped,\n  onCommitUnmount,\n} from './ReactFiberDevToolsHook';\nimport {releaseCache, retainCache} from './ReactFiberCacheComponent';\nimport {clearTransitionsForLanes} from './ReactFiberLane';\nimport {\n  OffscreenVisible,\n  OffscreenDetached,\n  OffscreenPassiveEffectsConnected,\n} from './ReactFiberOffscreenComponent';\nimport {\n  TransitionRoot,\n  TransitionTracingMarker,\n} from './ReactFiberTracingMarkerComponent';\nimport {scheduleUpdateOnFiber} from './ReactFiberWorkLoop';\nimport {enqueueConcurrentRenderForLane} from './ReactFiberConcurrentUpdates';\n\nlet didWarnAboutUndefinedSnapshotBeforeUpdate: Set<mixed> | null = null;\nif (__DEV__) {\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\n// Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\nlet offscreenSubtreeIsHidden: boolean = false;\nlet offscreenSubtreeWasHidden: boolean = false;\n\nconst PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\n\nlet nextEffect: Fiber | null = null;\n\n// Used for Profiling builds to track updaters.\nlet inProgressLanes: Lanes | null = null;\nlet inProgressRoot: FiberRoot | null = null;\n\nfunction shouldProfile(current: Fiber): boolean {\n  return (\n    enableProfilerTimer &&\n    enableProfilerCommitHooks &&\n    (current.mode & ProfileMode) !== NoMode &&\n    (getExecutionContext() & CommitContext) !== NoContext\n  );\n}\n\nexport function reportUncaughtErrorInDEV(error: mixed) {\n  // Wrapping each small part of the commit phase into a guarded\n  // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n  // But we rely on it to surface errors to DEV tools like overlays\n  // (https://github.com/facebook/react/issues/21712).\n  // As a compromise, rethrow only caught errors in a guard.\n  if (__DEV__) {\n    invokeGuardedCallback(null, () => {\n      throw error;\n    });\n    clearCaughtError();\n  }\n}\n\nconst callComponentWillUnmountWithTimer = function(current, instance) {\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n  if (shouldProfile(current)) {\n    try {\n      startLayoutEffectTimer();\n      instance.componentWillUnmount();\n    } finally {\n      recordLayoutEffectDuration(current);\n    }\n  } else {\n    instance.componentWillUnmount();\n  }\n};\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(\n  current: Fiber,\n  nearestMountedAncestor: Fiber | null,\n  instance: any,\n) {\n  try {\n    callComponentWillUnmountWithTimer(current, instance);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\n// Capture errors so they don't interrupt mounting.\nfunction safelyAttachRef(current: Fiber, nearestMountedAncestor: Fiber | null) {\n  try {\n    commitAttachRef(current);\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nfunction safelyDetachRef(current: Fiber, nearestMountedAncestor: Fiber | null) {\n  const ref = current.ref;\n  const refCleanup = current.refCleanup;\n\n  if (ref !== null) {\n    if (typeof refCleanup === 'function') {\n      try {\n        if (shouldProfile(current)) {\n          try {\n            startLayoutEffectTimer();\n            refCleanup();\n          } finally {\n            recordLayoutEffectDuration(current);\n          }\n        } else {\n          refCleanup();\n        }\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      } finally {\n        // `refCleanup` has been called. Nullify all references to it to prevent double invocation.\n        current.refCleanup = null;\n        const finishedWork = current.alternate;\n        if (finishedWork != null) {\n          finishedWork.refCleanup = null;\n        }\n      }\n    } else if (typeof ref === 'function') {\n      let retVal;\n      try {\n        if (shouldProfile(current)) {\n          try {\n            startLayoutEffectTimer();\n            retVal = ref(null);\n          } finally {\n            recordLayoutEffectDuration(current);\n          }\n        } else {\n          retVal = ref(null);\n        }\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      }\n      if (__DEV__) {\n        if (typeof retVal === 'function') {\n          console.error(\n            'Unexpected return value from a callback ref in %s. ' +\n              'A callback ref should not return a function.',\n            getComponentNameFromFiber(current),\n          );\n        }\n      }\n    } else {\n      // $FlowFixMe unable to narrow type to RefObject\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(\n  current: Fiber,\n  nearestMountedAncestor: Fiber | null,\n  destroy: () => void,\n) {\n  try {\n    destroy();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nlet focusedInstanceHandle: null | Fiber = null;\nlet shouldFireAfterActiveInstanceBlur: boolean = false;\n\nexport function commitBeforeMutationEffects(\n  root: FiberRoot,\n  firstChild: Fiber,\n): boolean {\n  focusedInstanceHandle = prepareForCommit(root.containerInfo);\n\n  nextEffect = firstChild;\n  commitBeforeMutationEffects_begin();\n\n  // We no longer need to track the active instance fiber\n  const shouldFire = shouldFireAfterActiveInstanceBlur;\n  shouldFireAfterActiveInstanceBlur = false;\n  focusedInstanceHandle = null;\n\n  return shouldFire;\n}\n\nfunction commitBeforeMutationEffects_begin() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    // This phase is only used for beforeActiveInstanceBlur.\n    // Let's skip the whole loop if it's off.\n    if (enableCreateEventHandleAPI) {\n      // TODO: Should wrap this in flags check, too, as optimization\n      const deletions = fiber.deletions;\n      if (deletions !== null) {\n        for (let i = 0; i < deletions.length; i++) {\n          const deletion = deletions[i];\n          commitBeforeMutationEffectsDeletion(deletion);\n        }\n      }\n    }\n\n    const child = fiber.child;\n    if (\n      (fiber.subtreeFlags & BeforeMutationMask) !== NoFlags &&\n      child !== null\n    ) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitBeforeMutationEffects_complete();\n    }\n  }\n}\n\nfunction commitBeforeMutationEffects_complete() {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    setCurrentDebugFiberInDEV(fiber);\n    try {\n      commitBeforeMutationEffectsOnFiber(fiber);\n    } catch (error) {\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n    resetCurrentDebugFiberInDEV();\n\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork: Fiber) {\n  const current = finishedWork.alternate;\n  const flags = finishedWork.flags;\n\n  if (enableCreateEventHandleAPI) {\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\n      // Check to see if the focused element was inside of a hidden (Suspense) subtree.\n      // TODO: Move this out of the hot path using a dedicated effect tag.\n      if (\n        finishedWork.tag === SuspenseComponent &&\n        isSuspenseBoundaryBeingHidden(current, finishedWork) &&\n        // $FlowFixMe[incompatible-call] found when upgrading Flow\n        doesFiberContain(finishedWork, focusedInstanceHandle)\n      ) {\n        shouldFireAfterActiveInstanceBlur = true;\n        beforeActiveInstanceBlur(finishedWork);\n      }\n    }\n  }\n\n  if ((flags & Snapshot) !== NoFlags) {\n    setCurrentDebugFiberInDEV(finishedWork);\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent: {\n      if (enableUseEffectEventHook) {\n        if ((flags & Update) !== NoFlags) {\n          commitUseEffectEventMount(finishedWork);\n        }\n      }\n      break;\n    }\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      break;\n    }\n    case ClassComponent: {\n      if ((flags & Snapshot) !== NoFlags) {\n        if (current !== null) {\n          const prevProps = current.memoizedProps;\n          const prevState = current.memoizedState;\n          const instance = finishedWork.stateNode;\n          // We could update instance props and state here,\n          // but instead we rely on them being set during last render.\n          // TODO: revisit this when we implement resuming.\n          if (__DEV__) {\n            if (\n              finishedWork.type === finishedWork.elementType &&\n              !didWarnAboutReassigningProps\n            ) {\n              if (instance.props !== finishedWork.memoizedProps) {\n                console.error(\n                  'Expected %s props to match memoized props before ' +\n                    'getSnapshotBeforeUpdate. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.props`. ' +\n                    'Please file an issue.',\n                  getComponentNameFromFiber(finishedWork) || 'instance',\n                );\n              }\n              if (instance.state !== finishedWork.memoizedState) {\n                console.error(\n                  'Expected %s state to match memoized state before ' +\n                    'getSnapshotBeforeUpdate. ' +\n                    'This might either be because of a bug in React, or because ' +\n                    'a component reassigns its own `this.state`. ' +\n                    'Please file an issue.',\n                  getComponentNameFromFiber(finishedWork) || 'instance',\n                );\n              }\n            }\n          }\n          const snapshot = instance.getSnapshotBeforeUpdate(\n            finishedWork.elementType === finishedWork.type\n              ? prevProps\n              : resolveDefaultProps(finishedWork.type, prevProps),\n            prevState,\n          );\n          if (__DEV__) {\n            const didWarnSet = ((didWarnAboutUndefinedSnapshotBeforeUpdate: any): Set<mixed>);\n            if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n              didWarnSet.add(finishedWork.type);\n              console.error(\n                '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' +\n                  'must be returned. You have returned undefined.',\n                getComponentNameFromFiber(finishedWork),\n              );\n            }\n          }\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n        }\n      }\n      break;\n    }\n    case HostRoot: {\n      if ((flags & Snapshot) !== NoFlags) {\n        if (supportsMutation) {\n          const root = finishedWork.stateNode;\n          clearContainer(root.containerInfo);\n        }\n      }\n      break;\n    }\n    case HostComponent:\n    case HostResource:\n    case HostSingleton:\n    case HostText:\n    case HostPortal:\n    case IncompleteClassComponent:\n      // Nothing to do for these component types\n      break;\n    default: {\n      if ((flags & Snapshot) !== NoFlags) {\n        throw new Error(\n          'This unit of work tag should not have side-effects. This error is ' +\n            'likely caused by a bug in React. Please file an issue.',\n        );\n      }\n    }\n  }\n\n  if ((flags & Snapshot) !== NoFlags) {\n    resetCurrentDebugFiberInDEV();\n  }\n}\n\nfunction commitBeforeMutationEffectsDeletion(deletion: Fiber) {\n  if (enableCreateEventHandleAPI) {\n    // TODO (effects) It would be nice to avoid calling doesFiberContain()\n    // Maybe we can repurpose one of the subtreeFlags positions for this instead?\n    // Use it to store which part of the tree the focused instance is in?\n    // This assumes we can safely determine that instance during the \"render\" phase.\n    if (doesFiberContain(deletion, ((focusedInstanceHandle: any): Fiber))) {\n      shouldFireAfterActiveInstanceBlur = true;\n      beforeActiveInstanceBlur(deletion);\n    }\n  }\n}\n\nfunction commitHookEffectListUnmount(\n  flags: HookFlags,\n  finishedWork: Fiber,\n  nearestMountedAncestor: Fiber | null,\n) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & flags) === flags) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n        if (destroy !== undefined) {\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStarted(finishedWork);\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStarted(finishedWork);\n            }\n          }\n\n          if (__DEV__) {\n            if ((flags & HookInsertion) !== NoHookEffect) {\n              setIsRunningInsertionEffect(true);\n            }\n          }\n          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n          if (__DEV__) {\n            if ((flags & HookInsertion) !== NoHookEffect) {\n              setIsRunningInsertionEffect(false);\n            }\n          }\n\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStopped();\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitHookEffectListMount(flags: HookFlags, finishedWork: Fiber) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & flags) === flags) {\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStarted(finishedWork);\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStarted(finishedWork);\n          }\n        }\n\n        // Mount\n        const create = effect.create;\n        if (__DEV__) {\n          if ((flags & HookInsertion) !== NoHookEffect) {\n            setIsRunningInsertionEffect(true);\n          }\n        }\n        effect.destroy = create();\n        if (__DEV__) {\n          if ((flags & HookInsertion) !== NoHookEffect) {\n            setIsRunningInsertionEffect(false);\n          }\n        }\n\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStopped();\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStopped();\n          }\n        }\n\n        if (__DEV__) {\n          const destroy = effect.destroy;\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            let hookName;\n            if ((effect.tag & HookLayout) !== NoFlags) {\n              hookName = 'useLayoutEffect';\n            } else if ((effect.tag & HookInsertion) !== NoFlags) {\n              hookName = 'useInsertionEffect';\n            } else {\n              hookName = 'useEffect';\n            }\n            let addendum;\n            if (destroy === null) {\n              addendum =\n                ' You returned null. If your effect does not require clean ' +\n                'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum =\n                '\\n\\nIt looks like you wrote ' +\n                hookName +\n                '(async () => ...) or returned a Promise. ' +\n                'Instead, write the async function inside your effect ' +\n                'and call it immediately:\\n\\n' +\n                hookName +\n                '(() => {\\n' +\n                '  async function fetchData() {\\n' +\n                '    // You can await here\\n' +\n                '    const response = await MyAPI.getData(someId);\\n' +\n                '    // ...\\n' +\n                '  }\\n' +\n                '  fetchData();\\n' +\n                `}, [someId]); // Or [] if effect doesn't need props or state\\n\\n` +\n                'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n            console.error(\n              '%s must not return anything besides a function, ' +\n                'which is used for clean-up.%s',\n              hookName,\n              addendum,\n            );\n          }\n        }\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitUseEffectEventMount(finishedWork: Fiber) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  const eventPayloads = updateQueue !== null ? updateQueue.events : null;\n  if (eventPayloads !== null) {\n    for (let ii = 0; ii < eventPayloads.length; ii++) {\n      const {ref, nextImpl} = eventPayloads[ii];\n      ref.impl = nextImpl;\n    }\n  }\n}\n\nexport function commitPassiveEffectDurations(\n  finishedRoot: FiberRoot,\n  finishedWork: Fiber,\n): void {\n  if (\n    enableProfilerTimer &&\n    enableProfilerCommitHooks &&\n    getExecutionContext() & CommitContext\n  ) {\n    // Only Profilers with work in their subtree will have an Update effect scheduled.\n    if ((finishedWork.flags & Update) !== NoFlags) {\n      switch (finishedWork.tag) {\n        case Profiler: {\n          const {passiveEffectDuration} = finishedWork.stateNode;\n          const {id, onPostCommit} = finishedWork.memoizedProps;\n\n          // This value will still reflect the previous commit phase.\n          // It does not get reset until the start of the next commit phase.\n          const commitTime = getCommitTime();\n\n          let phase = finishedWork.alternate === null ? 'mount' : 'update';\n          if (enableProfilerNestedUpdatePhase) {\n            if (isCurrentUpdateNested()) {\n              phase = 'nested-update';\n            }\n          }\n\n          if (typeof onPostCommit === 'function') {\n            onPostCommit(id, phase, passiveEffectDuration, commitTime);\n          }\n\n          // Bubble times to the next nearest ancestor Profiler.\n          // After we process that Profiler, we'll bubble further up.\n          let parentFiber = finishedWork.return;\n          outer: while (parentFiber !== null) {\n            switch (parentFiber.tag) {\n              case HostRoot:\n                const root = parentFiber.stateNode;\n                root.passiveEffectDuration += passiveEffectDuration;\n                break outer;\n              case Profiler:\n                const parentStateNode = parentFiber.stateNode;\n                parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                break outer;\n            }\n            parentFiber = parentFiber.return;\n          }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  }\n}\n\nfunction commitHookLayoutEffects(finishedWork: Fiber, hookFlags: HookFlags) {\n  // At this point layout effects have already been destroyed (during mutation phase).\n  // This is done to prevent sibling component effects from interfering with each other,\n  // e.g. a destroy function in one component should never override a ref set\n  // by a create function in another component during the same commit.\n  if (shouldProfile(finishedWork)) {\n    try {\n      startLayoutEffectTimer();\n      commitHookEffectListMount(hookFlags, finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n    recordLayoutEffectDuration(finishedWork);\n  } else {\n    try {\n      commitHookEffectListMount(hookFlags, finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\n\nfunction commitClassLayoutLifecycles(\n  finishedWork: Fiber,\n  current: Fiber | null,\n) {\n  const instance = finishedWork.stateNode;\n  if (current === null) {\n    // We could update instance props and state here,\n    // but instead we rely on them being set during last render.\n    // TODO: revisit this when we implement resuming.\n    if (__DEV__) {\n      if (\n        finishedWork.type === finishedWork.elementType &&\n        !didWarnAboutReassigningProps\n      ) {\n        if (instance.props !== finishedWork.memoizedProps) {\n          console.error(\n            'Expected %s props to match memoized props before ' +\n              'componentDidMount. ' +\n              'This might either be because of a bug in React, or because ' +\n              'a component reassigns its own `this.props`. ' +\n              'Please file an issue.',\n            getComponentNameFromFiber(finishedWork) || 'instance',\n          );\n        }\n        if (instance.state !== finishedWork.memoizedState) {\n          console.error(\n            'Expected %s state to match memoized state before ' +\n              'componentDidMount. ' +\n              'This might either be because of a bug in React, or because ' +\n              'a component reassigns its own `this.state`. ' +\n              'Please file an issue.',\n            getComponentNameFromFiber(finishedWork) || 'instance',\n          );\n        }\n      }\n    }\n    if (shouldProfile(finishedWork)) {\n      try {\n        startLayoutEffectTimer();\n        instance.componentDidMount();\n      } catch (error) {\n        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n      }\n      recordLayoutEffectDuration(finishedWork);\n    } else {\n      try {\n        instance.componentDidMount();\n      } catch (error) {\n        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n      }\n    }\n  } else {\n    const prevProps =\n      finishedWork.elementType === finishedWork.type\n        ? current.memoizedProps\n        : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n    const prevState = current.memoizedState;\n    // We could update instance props and state here,\n    // but instead we rely on them being set during last render.\n    // TODO: revisit this when we implement resuming.\n    if (__DEV__) {\n      if (\n        finishedWork.type === finishedWork.elementType &&\n        !didWarnAboutReassigningProps\n      ) {\n        if (instance.props !== finishedWork.memoizedProps) {\n          console.error(\n            'Expected %s props to match memoized props before ' +\n              'componentDidUpdate. ' +\n              'This might either be because of a bug in React, or because ' +\n              'a component reassigns its own `this.props`. ' +\n              'Please file an issue.',\n            getComponentNameFromFiber(finishedWork) || 'instance',\n          );\n        }\n        if (instance.state !== finishedWork.memoizedState) {\n          console.error(\n            'Expected %s state to match memoized state before ' +\n              'componentDidUpdate. ' +\n              'This might either be because of a bug in React, or because ' +\n              'a component reassigns its own `this.state`. ' +\n              'Please file an issue.',\n            getComponentNameFromFiber(finishedWork) || 'instance',\n          );\n        }\n      }\n    }\n    if (shouldProfile(finishedWork)) {\n      try {\n        startLayoutEffectTimer();\n        instance.componentDidUpdate(\n          prevProps,\n          prevState,\n          instance.__reactInternalSnapshotBeforeUpdate,\n        );\n      } catch (error) {\n        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n      }\n      recordLayoutEffectDuration(finishedWork);\n    } else {\n      try {\n        instance.componentDidUpdate(\n          prevProps,\n          prevState,\n          instance.__reactInternalSnapshotBeforeUpdate,\n        );\n      } catch (error) {\n        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n      }\n    }\n  }\n}\n\nfunction commitClassCallbacks(finishedWork: Fiber) {\n  // TODO: I think this is now always non-null by the time it reaches the\n  // commit phase. Consider removing the type check.\n  const updateQueue: UpdateQueue<mixed> | null = (finishedWork.updateQueue: any);\n  if (updateQueue !== null) {\n    const instance = finishedWork.stateNode;\n    if (__DEV__) {\n      if (\n        finishedWork.type === finishedWork.elementType &&\n        !didWarnAboutReassigningProps\n      ) {\n        if (instance.props !== finishedWork.memoizedProps) {\n          console.error(\n            'Expected %s props to match memoized props before ' +\n              'processing the update queue. ' +\n              'This might either be because of a bug in React, or because ' +\n              'a component reassigns its own `this.props`. ' +\n              'Please file an issue.',\n            getComponentNameFromFiber(finishedWork) || 'instance',\n          );\n        }\n        if (instance.state !== finishedWork.memoizedState) {\n          console.error(\n            'Expected %s state to match memoized state before ' +\n              'processing the update queue. ' +\n              'This might either be because of a bug in React, or because ' +\n              'a component reassigns its own `this.state`. ' +\n              'Please file an issue.',\n            getComponentNameFromFiber(finishedWork) || 'instance',\n          );\n        }\n      }\n    }\n    // We could update instance props and state here,\n    // but instead we rely on them being set during last render.\n    // TODO: revisit this when we implement resuming.\n    try {\n      commitCallbacks(updateQueue, instance);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\n\nfunction commitHostComponentMount(finishedWork: Fiber) {\n  const type = finishedWork.type;\n  const props = finishedWork.memoizedProps;\n  const instance: Instance = finishedWork.stateNode;\n  try {\n    commitMount(instance, type, props, finishedWork);\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\n\nfunction commitProfilerUpdate(finishedWork: Fiber, current: Fiber | null) {\n  if (enableProfilerTimer && getExecutionContext() & CommitContext) {\n    try {\n      const {onCommit, onRender} = finishedWork.memoizedProps;\n      const {effectDuration} = finishedWork.stateNode;\n\n      const commitTime = getCommitTime();\n\n      let phase = current === null ? 'mount' : 'update';\n      if (enableProfilerNestedUpdatePhase) {\n        if (isCurrentUpdateNested()) {\n          phase = 'nested-update';\n        }\n      }\n\n      if (typeof onRender === 'function') {\n        onRender(\n          finishedWork.memoizedProps.id,\n          phase,\n          finishedWork.actualDuration,\n          finishedWork.treeBaseDuration,\n          finishedWork.actualStartTime,\n          commitTime,\n        );\n      }\n\n      if (enableProfilerCommitHooks) {\n        if (typeof onCommit === 'function') {\n          onCommit(\n            finishedWork.memoizedProps.id,\n            phase,\n            effectDuration,\n            commitTime,\n          );\n        }\n\n        // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n        // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n        // because the effect is also where times bubble to parent Profilers.\n        enqueuePendingPassiveProfilerEffect(finishedWork);\n\n        // Propagate layout effect durations to the next nearest Profiler ancestor.\n        // Do not reset these values until the next render so DevTools has a chance to read them first.\n        let parentFiber = finishedWork.return;\n        outer: while (parentFiber !== null) {\n          switch (parentFiber.tag) {\n            case HostRoot:\n              const root = parentFiber.stateNode;\n              root.effectDuration += effectDuration;\n              break outer;\n            case Profiler:\n              const parentStateNode = parentFiber.stateNode;\n              parentStateNode.effectDuration += effectDuration;\n              break outer;\n          }\n          parentFiber = parentFiber.return;\n        }\n      }\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\n\nfunction commitLayoutEffectOnFiber(\n  finishedRoot: FiberRoot,\n  current: Fiber | null,\n  finishedWork: Fiber,\n  committedLanes: Lanes,\n): void {\n  // When updating this function, also update reappearLayoutEffects, which does\n  // most of the same things when an offscreen tree goes from hidden -> visible.\n  const flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      recursivelyTraverseLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n      );\n      if (flags & Update) {\n        commitHookLayoutEffects(finishedWork, HookLayout | HookHasEffect);\n      }\n      break;\n    }\n    case ClassComponent: {\n      recursivelyTraverseLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n      );\n      if (flags & Update) {\n        commitClassLayoutLifecycles(finishedWork, current);\n      }\n\n      if (flags & Callback) {\n        commitClassCallbacks(finishedWork);\n      }\n\n      if (flags & Ref) {\n        safelyAttachRef(finishedWork, finishedWork.return);\n      }\n      break;\n    }\n    case HostRoot: {\n      recursivelyTraverseLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n      );\n      if (flags & Callback) {\n        // TODO: I think this is now always non-null by the time it reaches the\n        // commit phase. Consider removing the type check.\n        const updateQueue: UpdateQueue<mixed> | null = (finishedWork.updateQueue: any);\n        if (updateQueue !== null) {\n          let instance = null;\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostSingleton:\n              case HostComponent:\n                instance = getPublicInstance(finishedWork.child.stateNode);\n                break;\n              case ClassComponent:\n                instance = finishedWork.child.stateNode;\n                break;\n            }\n          }\n          try {\n            commitCallbacks(updateQueue, instance);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      }\n      break;\n    }\n    case HostResource: {\n      if (enableFloat && supportsResources) {\n        recursivelyTraverseLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n        );\n\n        if (flags & Ref) {\n          safelyAttachRef(finishedWork, finishedWork.return);\n        }\n        break;\n      }\n    }\n    // eslint-disable-next-line-no-fallthrough\n    case HostSingleton:\n    case HostComponent: {\n      recursivelyTraverseLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n      );\n\n      // Renderers may schedule work to be done after host components are mounted\n      // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n      // These effects should only be committed when components are first mounted,\n      // aka when there is no current/alternate.\n      if (current === null && flags & Update) {\n        commitHostComponentMount(finishedWork);\n      }\n\n      if (flags & Ref) {\n        safelyAttachRef(finishedWork, finishedWork.return);\n      }\n      break;\n    }\n    case Profiler: {\n      recursivelyTraverseLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n      );\n      // TODO: Should this fire inside an offscreen tree? Or should it wait to\n      // fire when the tree becomes visible again.\n      if (flags & Update) {\n        commitProfilerUpdate(finishedWork, current);\n      }\n      break;\n    }\n    case SuspenseComponent: {\n      recursivelyTraverseLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n      );\n      if (flags & Update) {\n        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n      }\n      break;\n    }\n    case OffscreenComponent: {\n      const isModernRoot = (finishedWork.mode & ConcurrentMode) !== NoMode;\n      if (isModernRoot) {\n        const isHidden = finishedWork.memoizedState !== null;\n        const newOffscreenSubtreeIsHidden =\n          isHidden || offscreenSubtreeIsHidden;\n        if (newOffscreenSubtreeIsHidden) {\n          // The Offscreen tree is hidden. Skip over its layout effects.\n        } else {\n          // The Offscreen tree is visible.\n\n          const wasHidden = current !== null && current.memoizedState !== null;\n          const newOffscreenSubtreeWasHidden =\n            wasHidden || offscreenSubtreeWasHidden;\n          const prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n          const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n          offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n          offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n\n          if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n            // This is the root of a reappearing boundary. As we continue\n            // traversing the layout effects, we must also re-mount layout\n            // effects that were unmounted when the Offscreen subtree was\n            // hidden. So this is a superset of the normal commitLayoutEffects.\n            const includeWorkInProgressEffects =\n              (finishedWork.subtreeFlags & LayoutMask) !== NoFlags;\n            recursivelyTraverseReappearLayoutEffects(\n              finishedRoot,\n              finishedWork,\n              includeWorkInProgressEffects,\n            );\n          } else {\n            recursivelyTraverseLayoutEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n            );\n          }\n          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        }\n      } else {\n        recursivelyTraverseLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n        );\n      }\n      if (flags & Ref) {\n        const props: OffscreenProps = finishedWork.memoizedProps;\n        if (props.mode === 'manual') {\n          safelyAttachRef(finishedWork, finishedWork.return);\n        } else {\n          safelyDetachRef(finishedWork, finishedWork.return);\n        }\n      }\n      break;\n    }\n    default: {\n      recursivelyTraverseLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n      );\n      break;\n    }\n  }\n}\n\nfunction abortRootTransitions(\n  root: FiberRoot,\n  abort: TransitionAbort,\n  deletedTransitions: Set<Transition>,\n  deletedOffscreenInstance: OffscreenInstance | null,\n  isInDeletedTree: boolean,\n) {\n  if (enableTransitionTracing) {\n    const rootTransitions = root.incompleteTransitions;\n    deletedTransitions.forEach(transition => {\n      if (rootTransitions.has(transition)) {\n        const transitionInstance: TracingMarkerInstance = (rootTransitions.get(\n          transition,\n        ): any);\n        if (transitionInstance.aborts === null) {\n          transitionInstance.aborts = [];\n        }\n        transitionInstance.aborts.push(abort);\n\n        if (deletedOffscreenInstance !== null) {\n          if (\n            transitionInstance.pendingBoundaries !== null &&\n            transitionInstance.pendingBoundaries.has(deletedOffscreenInstance)\n          ) {\n            // $FlowFixMe[incompatible-use] found when upgrading Flow\n            transitionInstance.pendingBoundaries.delete(\n              deletedOffscreenInstance,\n            );\n          }\n        }\n      }\n    });\n  }\n}\n\nfunction abortTracingMarkerTransitions(\n  abortedFiber: Fiber,\n  abort: TransitionAbort,\n  deletedTransitions: Set<Transition>,\n  deletedOffscreenInstance: OffscreenInstance | null,\n  isInDeletedTree: boolean,\n) {\n  if (enableTransitionTracing) {\n    const markerInstance: TracingMarkerInstance = abortedFiber.stateNode;\n    const markerTransitions = markerInstance.transitions;\n    const pendingBoundaries = markerInstance.pendingBoundaries;\n    if (markerTransitions !== null) {\n      // TODO: Refactor this code. Is there a way to move this code to\n      // the deletions phase instead of calculating it here while making sure\n      // complete is called appropriately?\n      deletedTransitions.forEach(transition => {\n        // If one of the transitions on the tracing marker is a transition\n        // that was in an aborted subtree, we will abort that tracing marker\n        if (\n          abortedFiber !== null &&\n          markerTransitions.has(transition) &&\n          (markerInstance.aborts === null ||\n            !markerInstance.aborts.includes(abort))\n        ) {\n          if (markerInstance.transitions !== null) {\n            if (markerInstance.aborts === null) {\n              markerInstance.aborts = [abort];\n              addMarkerIncompleteCallbackToPendingTransition(\n                abortedFiber.memoizedProps.name,\n                markerInstance.transitions,\n                markerInstance.aborts,\n              );\n            } else {\n              markerInstance.aborts.push(abort);\n            }\n\n            // We only want to call onTransitionProgress when the marker hasn't been\n            // deleted\n            if (\n              deletedOffscreenInstance !== null &&\n              !isInDeletedTree &&\n              pendingBoundaries !== null &&\n              pendingBoundaries.has(deletedOffscreenInstance)\n            ) {\n              pendingBoundaries.delete(deletedOffscreenInstance);\n\n              addMarkerProgressCallbackToPendingTransition(\n                abortedFiber.memoizedProps.name,\n                deletedTransitions,\n                pendingBoundaries,\n              );\n            }\n          }\n        }\n      });\n    }\n  }\n}\n\nfunction abortParentMarkerTransitionsForDeletedFiber(\n  abortedFiber: Fiber,\n  abort: TransitionAbort,\n  deletedTransitions: Set<Transition>,\n  deletedOffscreenInstance: OffscreenInstance | null,\n  isInDeletedTree: boolean,\n) {\n  if (enableTransitionTracing) {\n    // Find all pending markers that are waiting on child suspense boundaries in the\n    // aborted subtree and cancels them\n    let fiber: null | Fiber = abortedFiber;\n    while (fiber !== null) {\n      switch (fiber.tag) {\n        case TracingMarkerComponent:\n          abortTracingMarkerTransitions(\n            fiber,\n            abort,\n            deletedTransitions,\n            deletedOffscreenInstance,\n            isInDeletedTree,\n          );\n          break;\n        case HostRoot:\n          const root = fiber.stateNode;\n          abortRootTransitions(\n            root,\n            abort,\n            deletedTransitions,\n            deletedOffscreenInstance,\n            isInDeletedTree,\n          );\n\n          break;\n        default:\n          break;\n      }\n\n      fiber = fiber.return;\n    }\n  }\n}\n\nfunction commitTransitionProgress(offscreenFiber: Fiber) {\n  if (enableTransitionTracing) {\n    // This function adds suspense boundaries to the root\n    // or tracing marker's pendingBoundaries map.\n    // When a suspense boundary goes from a resolved to a fallback\n    // state we add the boundary to the map, and when it goes from\n    // a fallback to a resolved state, we remove the boundary from\n    // the map.\n\n    // We use stateNode on the Offscreen component as a stable object\n    // that doesnt change from render to render. This way we can\n    // distinguish between different Offscreen instances (vs. the same\n    // Offscreen instance with different fibers)\n    const offscreenInstance: OffscreenInstance = offscreenFiber.stateNode;\n\n    let prevState: SuspenseState | null = null;\n    const previousFiber = offscreenFiber.alternate;\n    if (previousFiber !== null && previousFiber.memoizedState !== null) {\n      prevState = previousFiber.memoizedState;\n    }\n    const nextState: SuspenseState | null = offscreenFiber.memoizedState;\n\n    const wasHidden = prevState !== null;\n    const isHidden = nextState !== null;\n\n    const pendingMarkers = offscreenInstance._pendingMarkers;\n    // If there is a name on the suspense boundary, store that in\n    // the pending boundaries.\n    let name = null;\n    const parent = offscreenFiber.return;\n    if (\n      parent !== null &&\n      parent.tag === SuspenseComponent &&\n      parent.memoizedProps.unstable_name\n    ) {\n      name = parent.memoizedProps.unstable_name;\n    }\n\n    if (!wasHidden && isHidden) {\n      // The suspense boundaries was just hidden. Add the boundary\n      // to the pending boundary set if it's there\n      if (pendingMarkers !== null) {\n        pendingMarkers.forEach(markerInstance => {\n          const pendingBoundaries = markerInstance.pendingBoundaries;\n          const transitions = markerInstance.transitions;\n          const markerName = markerInstance.name;\n          if (\n            pendingBoundaries !== null &&\n            !pendingBoundaries.has(offscreenInstance)\n          ) {\n            pendingBoundaries.set(offscreenInstance, {\n              name,\n            });\n            if (transitions !== null) {\n              if (\n                markerInstance.tag === TransitionTracingMarker &&\n                markerName !== null\n              ) {\n                addMarkerProgressCallbackToPendingTransition(\n                  markerName,\n                  transitions,\n                  pendingBoundaries,\n                );\n              } else if (markerInstance.tag === TransitionRoot) {\n                transitions.forEach(transition => {\n                  addTransitionProgressCallbackToPendingTransition(\n                    transition,\n                    pendingBoundaries,\n                  );\n                });\n              }\n            }\n          }\n        });\n      }\n    } else if (wasHidden && !isHidden) {\n      // The suspense boundary went from hidden to visible. Remove\n      // the boundary from the pending suspense boundaries set\n      // if it's there\n      if (pendingMarkers !== null) {\n        pendingMarkers.forEach(markerInstance => {\n          const pendingBoundaries = markerInstance.pendingBoundaries;\n          const transitions = markerInstance.transitions;\n          const markerName = markerInstance.name;\n          if (\n            pendingBoundaries !== null &&\n            pendingBoundaries.has(offscreenInstance)\n          ) {\n            pendingBoundaries.delete(offscreenInstance);\n            if (transitions !== null) {\n              if (\n                markerInstance.tag === TransitionTracingMarker &&\n                markerName !== null\n              ) {\n                addMarkerProgressCallbackToPendingTransition(\n                  markerName,\n                  transitions,\n                  pendingBoundaries,\n                );\n\n                // If there are no more unresolved suspense boundaries, the interaction\n                // is considered finished\n                if (pendingBoundaries.size === 0) {\n                  if (markerInstance.aborts === null) {\n                    addMarkerCompleteCallbackToPendingTransition(\n                      markerName,\n                      transitions,\n                    );\n                  }\n                  markerInstance.transitions = null;\n                  markerInstance.pendingBoundaries = null;\n                  markerInstance.aborts = null;\n                }\n              } else if (markerInstance.tag === TransitionRoot) {\n                transitions.forEach(transition => {\n                  addTransitionProgressCallbackToPendingTransition(\n                    transition,\n                    pendingBoundaries,\n                  );\n                });\n              }\n            }\n          }\n        });\n      }\n    }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  // Only hide or unhide the top-most host nodes.\n  let hostSubtreeRoot = null;\n\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    let node: Fiber = finishedWork;\n    while (true) {\n      if (\n        node.tag === HostComponent ||\n        (enableFloat && supportsResources\n          ? node.tag === HostResource\n          : false) ||\n        (enableHostSingletons && supportsSingletons\n          ? node.tag === HostSingleton\n          : false)\n      ) {\n        if (hostSubtreeRoot === null) {\n          hostSubtreeRoot = node;\n          try {\n            const instance = node.stateNode;\n            if (isHidden) {\n              hideInstance(instance);\n            } else {\n              unhideInstance(node.stateNode, node.memoizedProps);\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      } else if (node.tag === HostText) {\n        if (hostSubtreeRoot === null) {\n          try {\n            const instance = node.stateNode;\n            if (isHidden) {\n              hideTextInstance(instance);\n            } else {\n              unhideTextInstance(instance, node.memoizedProps);\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      } else if (\n        (node.tag === OffscreenComponent ||\n          node.tag === LegacyHiddenComponent) &&\n        (node.memoizedState: OffscreenState) !== null &&\n        node !== finishedWork\n      ) {\n        // Found a nested Offscreen component that is hidden.\n        // Don't search any deeper. This tree should remain hidden.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === finishedWork) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n\n        if (hostSubtreeRoot === node) {\n          hostSubtreeRoot = null;\n        }\n\n        node = node.return;\n      }\n\n      if (hostSubtreeRoot === node) {\n        hostSubtreeRoot = null;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork: Fiber) {\n  const ref = finishedWork.ref;\n  if (ref !== null) {\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n    switch (finishedWork.tag) {\n      case HostResource:\n      case HostSingleton:\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    // Moved outside to ensure DCE works with this flag\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n      instanceToUse = instance;\n    }\n    if (typeof ref === 'function') {\n      if (shouldProfile(finishedWork)) {\n        try {\n          startLayoutEffectTimer();\n          finishedWork.refCleanup = ref(instanceToUse);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        finishedWork.refCleanup = ref(instanceToUse);\n      }\n    } else {\n      if (__DEV__) {\n        if (!ref.hasOwnProperty('current')) {\n          console.error(\n            'Unexpected ref object provided for %s. ' +\n              'Use either a ref-setter function or React.createRef().',\n            getComponentNameFromFiber(finishedWork),\n          );\n        }\n      }\n\n      // $FlowFixMe unable to narrow type to the non-function case\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction detachFiberMutation(fiber: Fiber) {\n  // Cut off the return pointer to disconnect it from the tree.\n  // This enables us to detect and warn against state updates on an unmounted component.\n  // It also prevents events from bubbling from within disconnected components.\n  //\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child.\n  // This child itself will be GC:ed when the parent updates the next time.\n  //\n  // Note that we can't clear child or sibling pointers yet.\n  // They're needed for passive effects and for findDOMNode.\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n  //\n  // Don't reset the alternate yet, either. We need that so we can detach the\n  // alternate's fields in the passive phase. Clearing the return pointer is\n  // sufficient for findDOMNode semantics.\n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n  fiber.return = null;\n}\n\nfunction detachFiberAfterEffects(fiber: Fiber) {\n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    fiber.alternate = null;\n    detachFiberAfterEffects(alternate);\n  }\n\n  // Note: Defensively using negation instead of < in case\n  // `deletedTreeCleanUpLevel` is undefined.\n  if (!(deletedTreeCleanUpLevel >= 2)) {\n    // This is the default branch (level 0).\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.dependencies = null;\n    fiber.memoizedProps = null;\n    fiber.memoizedState = null;\n    fiber.pendingProps = null;\n    fiber.sibling = null;\n    fiber.stateNode = null;\n    fiber.updateQueue = null;\n\n    if (__DEV__) {\n      fiber._debugOwner = null;\n    }\n  } else {\n    // Clear cyclical Fiber fields. This level alone is designed to roughly\n    // approximate the planned Fiber refactor. In that world, `setState` will be\n    // bound to a special \"instance\" object instead of a Fiber. The Instance\n    // object will not have any of these fields. It will only be connected to\n    // the fiber tree via a single link at the root. So if this level alone is\n    // sufficient to fix memory issues, that bodes well for our plans.\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.sibling = null;\n\n    // The `stateNode` is cyclical because on host nodes it points to the host\n    // tree, which has its own pointers to children, parents, and siblings.\n    // The other host nodes also point back to fibers, so we should detach that\n    // one, too.\n    if (fiber.tag === HostComponent) {\n      const hostInstance: Instance = fiber.stateNode;\n      if (hostInstance !== null) {\n        detachDeletedInstance(hostInstance);\n      }\n    }\n    fiber.stateNode = null;\n\n    // I'm intentionally not clearing the `return` field in this level. We\n    // already disconnect the `return` pointer at the root of the deleted\n    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n    // cyclical — it's only cyclical when combined with `child`, `sibling`, and\n    // `alternate`. But we'll clear it in the next level anyway, just in case.\n\n    if (__DEV__) {\n      fiber._debugOwner = null;\n    }\n\n    if (deletedTreeCleanUpLevel >= 3) {\n      // Theoretically, nothing in here should be necessary, because we already\n      // disconnected the fiber from the tree. So even if something leaks this\n      // particular fiber, it won't leak anything else\n      //\n      // The purpose of this branch is to be super aggressive so we can measure\n      // if there's any difference in memory impact. If there is, that could\n      // indicate a React leak we don't know about.\n      fiber.return = null;\n      fiber.dependencies = null;\n      fiber.memoizedProps = null;\n      fiber.memoizedState = null;\n      fiber.pendingProps = null;\n      fiber.stateNode = null;\n      // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n      fiber.updateQueue = null;\n    }\n  }\n}\n\nfunction emptyPortalContainer(current: Fiber) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  const portal: {\n    containerInfo: Container,\n    pendingChildren: ChildSet,\n    ...\n  } = current.stateNode;\n  const {containerInfo} = portal;\n  const emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction getHostParentFiber(fiber: Fiber): Fiber {\n  let parent = fiber.return;\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n    parent = parent.return;\n  }\n\n  throw new Error(\n    'Expected to find a host parent. This error is likely caused by a bug ' +\n      'in React. Please file an issue.',\n  );\n}\n\nfunction isHostParent(fiber: Fiber): boolean {\n  return (\n    fiber.tag === HostComponent ||\n    fiber.tag === HostRoot ||\n    (enableFloat && supportsResources ? fiber.tag === HostResource : false) ||\n    (enableHostSingletons && supportsSingletons\n      ? fiber.tag === HostSingleton\n      : false) ||\n    fiber.tag === HostPortal\n  );\n}\n\nfunction getHostSibling(fiber: Fiber): ?Instance {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  let node: Fiber = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      // $FlowFixMe[incompatible-type] found when upgrading Flow\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (\n      node.tag !== HostComponent &&\n      node.tag !== HostText &&\n      (!(enableHostSingletons && supportsSingletons)\n        ? true\n        : node.tag !== HostSingleton) &&\n      node.tag !== DehydratedFragment\n    ) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.flags & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.flags & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork: Fiber): void {\n  if (!supportsMutation) {\n    return;\n  }\n\n  if (enableHostSingletons && supportsSingletons) {\n    if (finishedWork.tag === HostSingleton) {\n      // Singletons are already in the Host and don't need to be placed\n      // Since they operate somewhat like Portals though their children will\n      // have Placement and will get placed inside them\n      return;\n    }\n  }\n  // Recursively insert all host nodes into the parent.\n  const parentFiber = getHostParentFiber(finishedWork);\n\n  switch (parentFiber.tag) {\n    case HostSingleton: {\n      if (enableHostSingletons && supportsSingletons) {\n        const parent: Instance = parentFiber.stateNode;\n        const before = getHostSibling(finishedWork);\n        // We only have the top Fiber that was inserted but we need to recurse down its\n        // children to find all the terminal nodes.\n        insertOrAppendPlacementNode(finishedWork, before, parent);\n        break;\n      }\n    }\n    // eslint-disable-next-line no-fallthrough\n    case HostComponent: {\n      const parent: Instance = parentFiber.stateNode;\n      if (parentFiber.flags & ContentReset) {\n        // Reset the text content of the parent before doing any insertions\n        resetTextContent(parent);\n        // Clear ContentReset from the effect tag\n        parentFiber.flags &= ~ContentReset;\n      }\n\n      const before = getHostSibling(finishedWork);\n      // We only have the top Fiber that was inserted but we need to recurse down its\n      // children to find all the terminal nodes.\n      insertOrAppendPlacementNode(finishedWork, before, parent);\n      break;\n    }\n    case HostRoot:\n    case HostPortal: {\n      const parent: Container = parentFiber.stateNode.containerInfo;\n      const before = getHostSibling(finishedWork);\n      insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n      break;\n    }\n    // eslint-disable-next-line-no-fallthrough\n    default:\n      throw new Error(\n        'Invalid host parent fiber. This error is likely caused by a bug ' +\n          'in React. Please file an issue.',\n      );\n  }\n}\n\nfunction insertOrAppendPlacementNodeIntoContainer(\n  node: Fiber,\n  before: ?Instance,\n  parent: Container,\n): void {\n  const {tag} = node;\n  const isHost = tag === HostComponent || tag === HostText;\n  if (isHost) {\n    const stateNode = node.stateNode;\n    if (before) {\n      insertInContainerBefore(parent, stateNode, before);\n    } else {\n      appendChildToContainer(parent, stateNode);\n    }\n  } else if (\n    tag === HostPortal ||\n    (enableHostSingletons && supportsSingletons ? tag === HostSingleton : false)\n  ) {\n    // If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n    // If the insertion is a HostSingleton then it will be placed independently\n  } else {\n    const child = node.child;\n    if (child !== null) {\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n      let sibling = child.sibling;\n      while (sibling !== null) {\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction insertOrAppendPlacementNode(\n  node: Fiber,\n  before: ?Instance,\n  parent: Instance,\n): void {\n  const {tag} = node;\n  const isHost = tag === HostComponent || tag === HostText;\n  if (isHost) {\n    const stateNode = node.stateNode;\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } else if (\n    tag === HostPortal ||\n    (enableHostSingletons && supportsSingletons ? tag === HostSingleton : false)\n  ) {\n    // If the insertion itself is a portal, then we don't want to traverse\n    // down its children. Instead, we'll get insertions from each child in\n    // the portal directly.\n    // If the insertion is a HostSingleton then it will be placed independently\n  } else {\n    const child = node.child;\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      let sibling = child.sibling;\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\n// These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\nlet hostParent: Instance | Container | null = null;\nlet hostParentIsContainer: boolean = false;\n\nfunction commitDeletionEffects(\n  root: FiberRoot,\n  returnFiber: Fiber,\n  deletedFiber: Fiber,\n) {\n  if (supportsMutation) {\n    // We only have the top Fiber that was deleted but we need to recurse down its\n    // children to find all the terminal nodes.\n\n    // Recursively delete all host nodes from the parent, detach refs, clean\n    // up mounted layout effects, and call componentWillUnmount.\n\n    // We only need to remove the topmost host child in each branch. But then we\n    // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n    // could split this into two separate traversals functions, where the second\n    // one doesn't include any removeChild logic. This is maybe the same\n    // function as \"disappearLayoutEffects\" (or whatever that turns into after\n    // the layout phase is refactored to use recursion).\n\n    // Before starting, find the nearest host parent on the stack so we know\n    // which instance/container to remove the children from.\n    // TODO: Instead of searching up the fiber return path on every deletion, we\n    // can track the nearest host component on the JS stack as we traverse the\n    // tree during the commit phase. This would make insertions faster, too.\n    let parent: null | Fiber = returnFiber;\n    findParent: while (parent !== null) {\n      switch (parent.tag) {\n        case HostSingleton:\n        case HostComponent: {\n          hostParent = parent.stateNode;\n          hostParentIsContainer = false;\n          break findParent;\n        }\n        case HostRoot: {\n          hostParent = parent.stateNode.containerInfo;\n          hostParentIsContainer = true;\n          break findParent;\n        }\n        case HostPortal: {\n          hostParent = parent.stateNode.containerInfo;\n          hostParentIsContainer = true;\n          break findParent;\n        }\n      }\n      parent = parent.return;\n    }\n    if (hostParent === null) {\n      throw new Error(\n        'Expected to find a host parent. This error is likely caused by ' +\n          'a bug in React. Please file an issue.',\n      );\n    }\n\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n    hostParent = null;\n    hostParentIsContainer = false;\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n  }\n\n  detachFiberMutation(deletedFiber);\n}\n\nfunction recursivelyTraverseDeletionEffects(\n  finishedRoot,\n  nearestMountedAncestor,\n  parent,\n) {\n  // TODO: Use a static flag to skip trees that don't have unmount effects\n  let child = parent.child;\n  while (child !== null) {\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n    child = child.sibling;\n  }\n}\n\nfunction commitDeletionEffectsOnFiber(\n  finishedRoot: FiberRoot,\n  nearestMountedAncestor: Fiber,\n  deletedFiber: Fiber,\n) {\n  onCommitUnmount(deletedFiber);\n\n  // The cases in this outer switch modify the stack before they traverse\n  // into their subtree. There are simpler cases in the inner switch\n  // that don't modify the stack.\n  switch (deletedFiber.tag) {\n    case HostResource: {\n      if (enableFloat && supportsResources) {\n        if (!offscreenSubtreeWasHidden) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n        }\n        recursivelyTraverseDeletionEffects(\n          finishedRoot,\n          nearestMountedAncestor,\n          deletedFiber,\n        );\n        if (deletedFiber.memoizedState) {\n          releaseResource(deletedFiber.memoizedState);\n        }\n        return;\n      }\n    }\n    // eslint-disable-next-line no-fallthrough\n    case HostSingleton: {\n      if (enableHostSingletons && supportsSingletons) {\n        if (!offscreenSubtreeWasHidden) {\n          safelyDetachRef(deletedFiber, nearestMountedAncestor);\n        }\n\n        const prevHostParent = hostParent;\n        const prevHostParentIsContainer = hostParentIsContainer;\n        hostParent = deletedFiber.stateNode;\n        recursivelyTraverseDeletionEffects(\n          finishedRoot,\n          nearestMountedAncestor,\n          deletedFiber,\n        );\n\n        // Normally this is called in passive unmount effect phase however with\n        // HostSingleton we warn if you acquire one that is already associated to\n        // a different fiber. To increase our chances of avoiding this, specifically\n        // if you keyed a HostSingleton so there will be a delete followed by a Placement\n        // we treat detach eagerly here\n        releaseSingletonInstance(deletedFiber.stateNode);\n\n        hostParent = prevHostParent;\n        hostParentIsContainer = prevHostParentIsContainer;\n\n        return;\n      }\n    }\n    // eslint-disable-next-line no-fallthrough\n    case HostComponent: {\n      if (!offscreenSubtreeWasHidden) {\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      }\n      // Intentional fallthrough to next branch\n    }\n    // eslint-disable-next-line-no-fallthrough\n    case HostText: {\n      // We only need to remove the nearest host child. Set the host parent\n      // to `null` on the stack to indicate that nested children don't\n      // need to be removed.\n      if (supportsMutation) {\n        const prevHostParent = hostParent;\n        const prevHostParentIsContainer = hostParentIsContainer;\n        hostParent = null;\n        recursivelyTraverseDeletionEffects(\n          finishedRoot,\n          nearestMountedAncestor,\n          deletedFiber,\n        );\n        hostParent = prevHostParent;\n        hostParentIsContainer = prevHostParentIsContainer;\n\n        if (hostParent !== null) {\n          // Now that all the child effects have unmounted, we can remove the\n          // node from the tree.\n          if (hostParentIsContainer) {\n            removeChildFromContainer(\n              ((hostParent: any): Container),\n              (deletedFiber.stateNode: Instance | TextInstance),\n            );\n          } else {\n            removeChild(\n              ((hostParent: any): Instance),\n              (deletedFiber.stateNode: Instance | TextInstance),\n            );\n          }\n        }\n      } else {\n        recursivelyTraverseDeletionEffects(\n          finishedRoot,\n          nearestMountedAncestor,\n          deletedFiber,\n        );\n      }\n      return;\n    }\n    case DehydratedFragment: {\n      if (enableSuspenseCallback) {\n        const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n        if (hydrationCallbacks !== null) {\n          const onDeleted = hydrationCallbacks.onDeleted;\n          if (onDeleted) {\n            onDeleted((deletedFiber.stateNode: SuspenseInstance));\n          }\n        }\n      }\n\n      // Dehydrated fragments don't have any children\n\n      // Delete the dehydrated suspense boundary and all of its content.\n      if (supportsMutation) {\n        if (hostParent !== null) {\n          if (hostParentIsContainer) {\n            clearSuspenseBoundaryFromContainer(\n              ((hostParent: any): Container),\n              (deletedFiber.stateNode: SuspenseInstance),\n            );\n          } else {\n            clearSuspenseBoundary(\n              ((hostParent: any): Instance),\n              (deletedFiber.stateNode: SuspenseInstance),\n            );\n          }\n        }\n      }\n      return;\n    }\n    case HostPortal: {\n      if (supportsMutation) {\n        // When we go into a portal, it becomes the parent to remove from.\n        const prevHostParent = hostParent;\n        const prevHostParentIsContainer = hostParentIsContainer;\n        hostParent = deletedFiber.stateNode.containerInfo;\n        hostParentIsContainer = true;\n        recursivelyTraverseDeletionEffects(\n          finishedRoot,\n          nearestMountedAncestor,\n          deletedFiber,\n        );\n        hostParent = prevHostParent;\n        hostParentIsContainer = prevHostParentIsContainer;\n      } else {\n        emptyPortalContainer(deletedFiber);\n\n        recursivelyTraverseDeletionEffects(\n          finishedRoot,\n          nearestMountedAncestor,\n          deletedFiber,\n        );\n      }\n      return;\n    }\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      if (!offscreenSubtreeWasHidden) {\n        const updateQueue: FunctionComponentUpdateQueue | null = (deletedFiber.updateQueue: any);\n        if (updateQueue !== null) {\n          const lastEffect = updateQueue.lastEffect;\n          if (lastEffect !== null) {\n            const firstEffect = lastEffect.next;\n\n            let effect = firstEffect;\n            do {\n              const {destroy, tag} = effect;\n              if (destroy !== undefined) {\n                if ((tag & HookInsertion) !== NoHookEffect) {\n                  safelyCallDestroy(\n                    deletedFiber,\n                    nearestMountedAncestor,\n                    destroy,\n                  );\n                } else if ((tag & HookLayout) !== NoHookEffect) {\n                  if (enableSchedulingProfiler) {\n                    markComponentLayoutEffectUnmountStarted(deletedFiber);\n                  }\n\n                  if (shouldProfile(deletedFiber)) {\n                    startLayoutEffectTimer();\n                    safelyCallDestroy(\n                      deletedFiber,\n                      nearestMountedAncestor,\n                      destroy,\n                    );\n                    recordLayoutEffectDuration(deletedFiber);\n                  } else {\n                    safelyCallDestroy(\n                      deletedFiber,\n                      nearestMountedAncestor,\n                      destroy,\n                    );\n                  }\n\n                  if (enableSchedulingProfiler) {\n                    markComponentLayoutEffectUnmountStopped();\n                  }\n                }\n              }\n              effect = effect.next;\n            } while (effect !== firstEffect);\n          }\n        }\n      }\n\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber,\n      );\n      return;\n    }\n    case ClassComponent: {\n      if (!offscreenSubtreeWasHidden) {\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n        const instance = deletedFiber.stateNode;\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(\n            deletedFiber,\n            nearestMountedAncestor,\n            instance,\n          );\n        }\n      }\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber,\n      );\n      return;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      }\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber,\n      );\n      return;\n    }\n    case OffscreenComponent: {\n      safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      if (deletedFiber.mode & ConcurrentMode) {\n        // If this offscreen component is hidden, we already unmounted it. Before\n        // deleting the children, track that it's already unmounted so that we\n        // don't attempt to unmount the effects again.\n        // TODO: If the tree is hidden, in most cases we should be able to skip\n        // over the nested children entirely. An exception is we haven't yet found\n        // the topmost host node to delete, which we already track on the stack.\n        // But the other case is portals, which need to be detached no matter how\n        // deeply they are nested. We should use a subtree flag to track whether a\n        // subtree includes a nested portal.\n        const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n        offscreenSubtreeWasHidden =\n          prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n\n        recursivelyTraverseDeletionEffects(\n          finishedRoot,\n          nearestMountedAncestor,\n          deletedFiber,\n        );\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n      } else {\n        recursivelyTraverseDeletionEffects(\n          finishedRoot,\n          nearestMountedAncestor,\n          deletedFiber,\n        );\n      }\n      break;\n    }\n    default: {\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber,\n      );\n      return;\n    }\n  }\n}\nfunction commitSuspenseCallback(finishedWork: Fiber) {\n  // TODO: Move this to passive phase\n  const newState: SuspenseState | null = finishedWork.memoizedState;\n  if (enableSuspenseCallback && newState !== null) {\n    const suspenseCallback = finishedWork.memoizedProps.suspenseCallback;\n    if (typeof suspenseCallback === 'function') {\n      const wakeables: Set<Wakeable> | null = (finishedWork.updateQueue: any);\n      if (wakeables !== null) {\n        suspenseCallback(new Set(wakeables));\n      }\n    } else if (__DEV__) {\n      if (suspenseCallback !== undefined) {\n        console.error('Unexpected type for suspenseCallback.');\n      }\n    }\n  }\n}\n\nfunction commitSuspenseHydrationCallbacks(\n  finishedRoot: FiberRoot,\n  finishedWork: Fiber,\n) {\n  if (!supportsHydration) {\n    return;\n  }\n  const newState: SuspenseState | null = finishedWork.memoizedState;\n  if (newState === null) {\n    const current = finishedWork.alternate;\n    if (current !== null) {\n      const prevState: SuspenseState | null = current.memoizedState;\n      if (prevState !== null) {\n        const suspenseInstance = prevState.dehydrated;\n        if (suspenseInstance !== null) {\n          try {\n            commitHydratedSuspenseInstance(suspenseInstance);\n            if (enableSuspenseCallback) {\n              const hydrationCallbacks = finishedRoot.hydrationCallbacks;\n              if (hydrationCallbacks !== null) {\n                const onHydrated = hydrationCallbacks.onHydrated;\n                if (onHydrated) {\n                  onHydrated(suspenseInstance);\n                }\n              }\n            }\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction getRetryCache(finishedWork) {\n  // TODO: Unify the interface for the retry cache so we don't have to switch\n  // on the tag like this.\n  switch (finishedWork.tag) {\n    case SuspenseComponent:\n    case SuspenseListComponent: {\n      let retryCache = finishedWork.stateNode;\n      if (retryCache === null) {\n        retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n      }\n      return retryCache;\n    }\n    case OffscreenComponent: {\n      const instance: OffscreenInstance = finishedWork.stateNode;\n      // $FlowFixMe[incompatible-type-arg] found when upgrading Flow\n      let retryCache: null | Set<Wakeable> | WeakSet<Wakeable> =\n        // $FlowFixMe[incompatible-type] found when upgrading Flow\n        instance._retryCache;\n      if (retryCache === null) {\n        // $FlowFixMe[incompatible-type]\n        retryCache = instance._retryCache = new PossiblyWeakSet();\n      }\n      return retryCache;\n    }\n    default: {\n      throw new Error(\n        `Unexpected Suspense handler tag (${finishedWork.tag}). This is a ` +\n          'bug in React.',\n      );\n    }\n  }\n}\n\nexport function detachOffscreenInstance(instance: OffscreenInstance): void {\n  const fiber = instance._current;\n  if (fiber === null) {\n    throw new Error(\n      'Calling Offscreen.detach before instance handle has been set.',\n    );\n  }\n\n  if ((instance._pendingVisibility & OffscreenDetached) !== NoFlags) {\n    // The instance is already detached, this is a noop.\n    return;\n  }\n\n  // TODO: There is an opportunity to optimise this by not entering commit phase\n  // and unmounting effects directly.\n  const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n  if (root !== null) {\n    instance._pendingVisibility |= OffscreenDetached;\n    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n  }\n}\n\nexport function attachOffscreenInstance(instance: OffscreenInstance): void {\n  const fiber = instance._current;\n  if (fiber === null) {\n    throw new Error(\n      'Calling Offscreen.detach before instance handle has been set.',\n    );\n  }\n\n  if ((instance._pendingVisibility & OffscreenDetached) === NoFlags) {\n    // The instance is already attached, this is a noop.\n    return;\n  }\n\n  const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n  if (root !== null) {\n    instance._pendingVisibility &= ~OffscreenDetached;\n    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n  }\n}\n\nfunction attachSuspenseRetryListeners(\n  finishedWork: Fiber,\n  wakeables: Set<Wakeable>,\n) {\n  // If this boundary just timed out, then it will have a set of wakeables.\n  // For each wakeable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  const retryCache = getRetryCache(finishedWork);\n  wakeables.forEach(wakeable => {\n    // Memoize using the boundary fiber to prevent redundant listeners.\n    const retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n    if (!retryCache.has(wakeable)) {\n      retryCache.add(wakeable);\n\n      if (enableUpdaterTracking) {\n        if (isDevToolsPresent) {\n          if (inProgressLanes !== null && inProgressRoot !== null) {\n            // If we have pending work still, associate the original updaters with it.\n            restorePendingUpdaters(inProgressRoot, inProgressLanes);\n          } else {\n            throw Error(\n              'Expected finished root and lanes to be set. This is a bug in React.',\n            );\n          }\n        }\n      }\n\n      wakeable.then(retry, retry);\n    }\n  });\n}\n\n// This function detects when a Suspense boundary goes from visible to hidden.\n// It returns false if the boundary is already hidden.\n// TODO: Use an effect tag.\nexport function isSuspenseBoundaryBeingHidden(\n  current: Fiber | null,\n  finishedWork: Fiber,\n): boolean {\n  if (current !== null) {\n    const oldState: SuspenseState | null = current.memoizedState;\n    if (oldState === null || oldState.dehydrated !== null) {\n      const newState: SuspenseState | null = finishedWork.memoizedState;\n      return newState !== null && newState.dehydrated === null;\n    }\n  }\n  return false;\n}\n\nexport function commitMutationEffects(\n  root: FiberRoot,\n  finishedWork: Fiber,\n  committedLanes: Lanes,\n) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n\n  setCurrentDebugFiberInDEV(finishedWork);\n  commitMutationEffectsOnFiber(finishedWork, root, committedLanes);\n  setCurrentDebugFiberInDEV(finishedWork);\n\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction recursivelyTraverseMutationEffects(\n  root: FiberRoot,\n  parentFiber: Fiber,\n  lanes: Lanes,\n) {\n  // Deletions effects can be scheduled on any fiber type. They need to happen\n  // before the children effects hae fired.\n  const deletions = parentFiber.deletions;\n  if (deletions !== null) {\n    for (let i = 0; i < deletions.length; i++) {\n      const childToDelete = deletions[i];\n      try {\n        commitDeletionEffects(root, parentFiber, childToDelete);\n      } catch (error) {\n        captureCommitPhaseError(childToDelete, parentFiber, error);\n      }\n    }\n  }\n\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n  if (parentFiber.subtreeFlags & MutationMask) {\n    let child = parentFiber.child;\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      commitMutationEffectsOnFiber(child, root, lanes);\n      child = child.sibling;\n    }\n  }\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitMutationEffectsOnFiber(\n  finishedWork: Fiber,\n  root: FiberRoot,\n  lanes: Lanes,\n) {\n  const current = finishedWork.alternate;\n  const flags = finishedWork.flags;\n\n  // The effect flag should be checked *after* we refine the type of fiber,\n  // because the fiber tag is more specific. An exception is any flag related\n  // to reconciliation, because those can be set on all fiber types.\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n      commitReconciliationEffects(finishedWork);\n\n      if (flags & Update) {\n        try {\n          commitHookEffectListUnmount(\n            HookInsertion | HookHasEffect,\n            finishedWork,\n            finishedWork.return,\n          );\n          commitHookEffectListMount(\n            HookInsertion | HookHasEffect,\n            finishedWork,\n          );\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n        // Layout effects are destroyed during the mutation phase so that all\n        // destroy functions for all fibers are called before any create functions.\n        // This prevents sibling component effects from interfering with each other,\n        // e.g. a destroy function in one component should never override a ref set\n        // by a create function in another component during the same commit.\n        if (shouldProfile(finishedWork)) {\n          try {\n            startLayoutEffectTimer();\n            commitHookEffectListUnmount(\n              HookLayout | HookHasEffect,\n              finishedWork,\n              finishedWork.return,\n            );\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n          recordLayoutEffectDuration(finishedWork);\n        } else {\n          try {\n            commitHookEffectListUnmount(\n              HookLayout | HookHasEffect,\n              finishedWork,\n              finishedWork.return,\n            );\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      }\n      return;\n    }\n    case ClassComponent: {\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n      commitReconciliationEffects(finishedWork);\n\n      if (flags & Ref) {\n        if (current !== null) {\n          safelyDetachRef(current, current.return);\n        }\n      }\n\n      if (flags & Callback && offscreenSubtreeIsHidden) {\n        const updateQueue: UpdateQueue<mixed> | null = (finishedWork.updateQueue: any);\n        if (updateQueue !== null) {\n          deferHiddenCallbacks(updateQueue);\n        }\n      }\n      return;\n    }\n    case HostResource: {\n      if (enableFloat && supportsResources) {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(current, current.return);\n          }\n        }\n\n        if (flags & Update) {\n          const newResource = finishedWork.memoizedState;\n          if (current !== null) {\n            const currentResource = current.memoizedState;\n            if (currentResource !== newResource) {\n              releaseResource(currentResource);\n            }\n          }\n          finishedWork.stateNode = newResource\n            ? acquireResource(newResource)\n            : null;\n        }\n        return;\n      }\n    }\n    // eslint-disable-next-line-no-fallthrough\n    case HostSingleton: {\n      if (enableHostSingletons && supportsSingletons) {\n        if (flags & Update) {\n          const previousWork = finishedWork.alternate;\n          if (previousWork === null) {\n            const singleton = finishedWork.stateNode;\n            const props = finishedWork.memoizedProps;\n            // This was a new mount, we need to clear and set initial properties\n            clearSingleton(singleton);\n            acquireSingletonInstance(\n              finishedWork.type,\n              props,\n              singleton,\n              finishedWork,\n            );\n          }\n        }\n      }\n    }\n    // eslint-disable-next-line-no-fallthrough\n    case HostComponent: {\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n      commitReconciliationEffects(finishedWork);\n\n      if (flags & Ref) {\n        if (current !== null) {\n          safelyDetachRef(current, current.return);\n        }\n      }\n      if (supportsMutation) {\n        // TODO: ContentReset gets cleared by the children during the commit\n        // phase. This is a refactor hazard because it means we must read\n        // flags the flags after `commitReconciliationEffects` has already run;\n        // the order matters. We should refactor so that ContentReset does not\n        // rely on mutating the flag during commit. Like by setting a flag\n        // during the render phase instead.\n        if (finishedWork.flags & ContentReset) {\n          const instance: Instance = finishedWork.stateNode;\n          try {\n            resetTextContent(instance);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n\n        if (flags & Update) {\n          const instance: Instance = finishedWork.stateNode;\n          if (instance != null) {\n            // Commit the work prepared earlier.\n            const newProps = finishedWork.memoizedProps;\n            // For hydration we reuse the update path but we treat the oldProps\n            // as the newProps. The updatePayload will contain the real change in\n            // this case.\n            const oldProps =\n              current !== null ? current.memoizedProps : newProps;\n            const type = finishedWork.type;\n            // TODO: Type the updateQueue to be specific to host components.\n            const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);\n            finishedWork.updateQueue = null;\n            if (updatePayload !== null) {\n              try {\n                commitUpdate(\n                  instance,\n                  updatePayload,\n                  type,\n                  oldProps,\n                  newProps,\n                  finishedWork,\n                );\n              } catch (error) {\n                captureCommitPhaseError(\n                  finishedWork,\n                  finishedWork.return,\n                  error,\n                );\n              }\n            }\n          }\n        }\n      }\n      return;\n    }\n    case HostText: {\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n      commitReconciliationEffects(finishedWork);\n\n      if (flags & Update) {\n        if (supportsMutation) {\n          if (finishedWork.stateNode === null) {\n            throw new Error(\n              'This should have a text node initialized. This error is likely ' +\n                'caused by a bug in React. Please file an issue.',\n            );\n          }\n\n          const textInstance: TextInstance = finishedWork.stateNode;\n          const newText: string = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          const oldText: string =\n            current !== null ? current.memoizedProps : newText;\n\n          try {\n            commitTextUpdate(textInstance, oldText, newText);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      }\n      return;\n    }\n    case HostRoot: {\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n      commitReconciliationEffects(finishedWork);\n\n      if (flags & Update) {\n        if (supportsMutation && supportsHydration) {\n          if (current !== null) {\n            const prevRootState: RootState = current.memoizedState;\n            if (prevRootState.isDehydrated) {\n              try {\n                commitHydratedContainer(root.containerInfo);\n              } catch (error) {\n                captureCommitPhaseError(\n                  finishedWork,\n                  finishedWork.return,\n                  error,\n                );\n              }\n            }\n          }\n        }\n        if (supportsPersistence) {\n          const containerInfo = root.containerInfo;\n          const pendingChildren = root.pendingChildren;\n          try {\n            replaceContainerChildren(containerInfo, pendingChildren);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      }\n      return;\n    }\n    case HostPortal: {\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n      commitReconciliationEffects(finishedWork);\n\n      if (flags & Update) {\n        if (supportsPersistence) {\n          const portal = finishedWork.stateNode;\n          const containerInfo = portal.containerInfo;\n          const pendingChildren = portal.pendingChildren;\n          try {\n            replaceContainerChildren(containerInfo, pendingChildren);\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        }\n      }\n      return;\n    }\n    case SuspenseComponent: {\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n      commitReconciliationEffects(finishedWork);\n\n      const offscreenFiber: Fiber = (finishedWork.child: any);\n\n      if (offscreenFiber.flags & Visibility) {\n        const newState: OffscreenState | null = offscreenFiber.memoizedState;\n        const isHidden = newState !== null;\n        if (isHidden) {\n          const wasHidden =\n            offscreenFiber.alternate !== null &&\n            offscreenFiber.alternate.memoizedState !== null;\n          if (!wasHidden) {\n            // TODO: Move to passive phase\n            markCommitTimeOfFallback();\n          }\n        }\n      }\n\n      if (flags & Update) {\n        try {\n          commitSuspenseCallback(finishedWork);\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n        const wakeables: Set<Wakeable> | null = (finishedWork.updateQueue: any);\n        if (wakeables !== null) {\n          finishedWork.updateQueue = null;\n          attachSuspenseRetryListeners(finishedWork, wakeables);\n        }\n      }\n      return;\n    }\n    case OffscreenComponent: {\n      if (flags & Ref) {\n        if (current !== null) {\n          safelyDetachRef(current, current.return);\n        }\n      }\n\n      const newState: OffscreenState | null = finishedWork.memoizedState;\n      const isHidden = newState !== null;\n      const wasHidden = current !== null && current.memoizedState !== null;\n\n      if (finishedWork.mode & ConcurrentMode) {\n        // Before committing the children, track on the stack whether this\n        // offscreen subtree was already hidden, so that we don't unmount the\n        // effects again.\n        const prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n        const prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n      } else {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n      }\n\n      commitReconciliationEffects(finishedWork);\n\n      const offscreenInstance: OffscreenInstance = finishedWork.stateNode;\n\n      // TODO: Add explicit effect flag to set _current.\n      offscreenInstance._current = finishedWork;\n\n      // Offscreen stores pending changes to visibility in `_pendingVisibility`. This is\n      // to support batching of `attach` and `detach` calls.\n      offscreenInstance._visibility &= ~OffscreenDetached;\n      offscreenInstance._visibility |=\n        offscreenInstance._pendingVisibility & OffscreenDetached;\n\n      if (flags & Visibility) {\n        // Track the current state on the Offscreen instance so we can\n        // read it during an event\n        if (isHidden) {\n          offscreenInstance._visibility &= ~OffscreenVisible;\n        } else {\n          offscreenInstance._visibility |= OffscreenVisible;\n        }\n\n        if (isHidden) {\n          const isUpdate = current !== null;\n          const wasHiddenByAncestorOffscreen =\n            offscreenSubtreeIsHidden || offscreenSubtreeWasHidden;\n          // Only trigger disapper layout effects if:\n          //   - This is an update, not first mount.\n          //   - This Offscreen was not hidden before.\n          //   - Ancestor Offscreen was not hidden in previous commit.\n          if (isUpdate && !wasHidden && !wasHiddenByAncestorOffscreen) {\n            if ((finishedWork.mode & ConcurrentMode) !== NoMode) {\n              // Disappear the layout effects of all the children\n              recursivelyTraverseDisappearLayoutEffects(finishedWork);\n            }\n          }\n        } else {\n          if (wasHidden) {\n            // TODO: Move re-appear call here for symmetry?\n          }\n        }\n\n        // Offscreen with manual mode manages visibility manually.\n        if (supportsMutation && !isOffscreenManual(finishedWork)) {\n          // TODO: This needs to run whenever there's an insertion or update\n          // inside a hidden Offscreen tree.\n          hideOrUnhideAllChildren(finishedWork, isHidden);\n        }\n      }\n\n      // TODO: Move to passive phase\n      if (flags & Update) {\n        const offscreenQueue: OffscreenQueue | null = (finishedWork.updateQueue: any);\n        if (offscreenQueue !== null) {\n          const wakeables = offscreenQueue.wakeables;\n          if (wakeables !== null) {\n            offscreenQueue.wakeables = null;\n            attachSuspenseRetryListeners(finishedWork, wakeables);\n          }\n        }\n      }\n      return;\n    }\n    case SuspenseListComponent: {\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n      commitReconciliationEffects(finishedWork);\n\n      if (flags & Update) {\n        const wakeables: Set<Wakeable> | null = (finishedWork.updateQueue: any);\n        if (wakeables !== null) {\n          finishedWork.updateQueue = null;\n          attachSuspenseRetryListeners(finishedWork, wakeables);\n        }\n      }\n      return;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n        commitReconciliationEffects(finishedWork);\n\n        // TODO: This is a temporary solution that allowed us to transition away\n        // from React Flare on www.\n        if (flags & Ref) {\n          if (current !== null) {\n            safelyDetachRef(finishedWork, finishedWork.return);\n          }\n          safelyAttachRef(finishedWork, finishedWork.return);\n        }\n        if (flags & Update) {\n          const scopeInstance = finishedWork.stateNode;\n          prepareScopeUpdate(scopeInstance, finishedWork);\n        }\n      }\n      return;\n    }\n    default: {\n      recursivelyTraverseMutationEffects(root, finishedWork, lanes);\n      commitReconciliationEffects(finishedWork);\n\n      return;\n    }\n  }\n}\nfunction commitReconciliationEffects(finishedWork: Fiber) {\n  // Placement effects (insertions, reorders) can be scheduled on any fiber\n  // type. They needs to happen after the children effects have fired, but\n  // before the effects on this fiber have fired.\n  const flags = finishedWork.flags;\n  if (flags & Placement) {\n    try {\n      commitPlacement(finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n    // Clear the \"placement\" from effect tag so that we know that this is\n    // inserted, before any life-cycles like componentDidMount gets called.\n    // TODO: findDOMNode doesn't rely on this any more but isMounted does\n    // and isMounted is deprecated anyway so we should be able to kill this.\n    finishedWork.flags &= ~Placement;\n  }\n  if (flags & Hydrating) {\n    finishedWork.flags &= ~Hydrating;\n  }\n}\n\nexport function commitLayoutEffects(\n  finishedWork: Fiber,\n  root: FiberRoot,\n  committedLanes: Lanes,\n): void {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n\n  const current = finishedWork.alternate;\n  commitLayoutEffectOnFiber(root, current, finishedWork, committedLanes);\n\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction recursivelyTraverseLayoutEffects(\n  root: FiberRoot,\n  parentFiber: Fiber,\n  lanes: Lanes,\n) {\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n  if (parentFiber.subtreeFlags & LayoutMask) {\n    let child = parentFiber.child;\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      const current = child.alternate;\n      commitLayoutEffectOnFiber(root, current, child, lanes);\n      child = child.sibling;\n    }\n  }\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nexport function disappearLayoutEffects(finishedWork: Fiber) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      // TODO (Offscreen) Check: flags & LayoutStatic\n      if (shouldProfile(finishedWork)) {\n        try {\n          startLayoutEffectTimer();\n          commitHookEffectListUnmount(\n            HookLayout,\n            finishedWork,\n            finishedWork.return,\n          );\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        commitHookEffectListUnmount(\n          HookLayout,\n          finishedWork,\n          finishedWork.return,\n        );\n      }\n\n      recursivelyTraverseDisappearLayoutEffects(finishedWork);\n      break;\n    }\n    case ClassComponent: {\n      // TODO (Offscreen) Check: flags & RefStatic\n      safelyDetachRef(finishedWork, finishedWork.return);\n\n      const instance = finishedWork.stateNode;\n      if (typeof instance.componentWillUnmount === 'function') {\n        safelyCallComponentWillUnmount(\n          finishedWork,\n          finishedWork.return,\n          instance,\n        );\n      }\n\n      recursivelyTraverseDisappearLayoutEffects(finishedWork);\n      break;\n    }\n    case HostResource:\n    case HostSingleton:\n    case HostComponent: {\n      // TODO (Offscreen) Check: flags & RefStatic\n      safelyDetachRef(finishedWork, finishedWork.return);\n\n      recursivelyTraverseDisappearLayoutEffects(finishedWork);\n      break;\n    }\n    case OffscreenComponent: {\n      // TODO (Offscreen) Check: flags & RefStatic\n      safelyDetachRef(finishedWork, finishedWork.return);\n\n      const isHidden = finishedWork.memoizedState !== null;\n      if (isHidden) {\n        // Nested Offscreen tree is already hidden. Don't disappear\n        // its effects.\n      } else {\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n      }\n      break;\n    }\n    default: {\n      recursivelyTraverseDisappearLayoutEffects(finishedWork);\n      break;\n    }\n  }\n}\n\nfunction recursivelyTraverseDisappearLayoutEffects(parentFiber: Fiber) {\n  // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n  let child = parentFiber.child;\n  while (child !== null) {\n    disappearLayoutEffects(child);\n    child = child.sibling;\n  }\n}\n\nexport function reappearLayoutEffects(\n  finishedRoot: FiberRoot,\n  current: Fiber | null,\n  finishedWork: Fiber,\n  // This function visits both newly finished work and nodes that were re-used\n  // from a previously committed tree. We cannot check non-static flags if the\n  // node was reused.\n  includeWorkInProgressEffects: boolean,\n) {\n  // Turn on layout effects in a tree that previously disappeared.\n  const flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      recursivelyTraverseReappearLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        includeWorkInProgressEffects,\n      );\n      // TODO: Check flags & LayoutStatic\n      commitHookLayoutEffects(finishedWork, HookLayout);\n      break;\n    }\n    case ClassComponent: {\n      recursivelyTraverseReappearLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        includeWorkInProgressEffects,\n      );\n\n      // TODO: Check for LayoutStatic flag\n      const instance = finishedWork.stateNode;\n      if (typeof instance.componentDidMount === 'function') {\n        try {\n          instance.componentDidMount();\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n\n      // Commit any callbacks that would have fired while the component\n      // was hidden.\n      const updateQueue: UpdateQueue<mixed> | null = (finishedWork.updateQueue: any);\n      if (updateQueue !== null) {\n        commitHiddenCallbacks(updateQueue, instance);\n      }\n\n      // If this is newly finished work, check for setState callbacks\n      if (includeWorkInProgressEffects && flags & Callback) {\n        commitClassCallbacks(finishedWork);\n      }\n\n      // TODO: Check flags & RefStatic\n      safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    }\n    // Unlike commitLayoutEffectsOnFiber, we don't need to handle HostRoot\n    // because this function only visits nodes that are inside an\n    // Offscreen fiber.\n    // case HostRoot: {\n    //  ...\n    // }\n    case HostResource:\n    case HostSingleton:\n    case HostComponent: {\n      recursivelyTraverseReappearLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        includeWorkInProgressEffects,\n      );\n\n      // Renderers may schedule work to be done after host components are mounted\n      // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n      // These effects should only be committed when components are first mounted,\n      // aka when there is no current/alternate.\n      if (includeWorkInProgressEffects && current === null && flags & Update) {\n        commitHostComponentMount(finishedWork);\n      }\n\n      // TODO: Check flags & Ref\n      safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    }\n    case Profiler: {\n      recursivelyTraverseReappearLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        includeWorkInProgressEffects,\n      );\n      // TODO: Figure out how Profiler updates should work with Offscreen\n      if (includeWorkInProgressEffects && flags & Update) {\n        commitProfilerUpdate(finishedWork, current);\n      }\n      break;\n    }\n    case SuspenseComponent: {\n      recursivelyTraverseReappearLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        includeWorkInProgressEffects,\n      );\n\n      // TODO: Figure out how Suspense hydration callbacks should work\n      // with Offscreen.\n      if (includeWorkInProgressEffects && flags & Update) {\n        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n      }\n      break;\n    }\n    case OffscreenComponent: {\n      const offscreenState: OffscreenState = finishedWork.memoizedState;\n      const isHidden = offscreenState !== null;\n      if (isHidden) {\n        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n      } else {\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects,\n        );\n      }\n      // TODO: Check flags & Ref\n      safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    }\n    default: {\n      recursivelyTraverseReappearLayoutEffects(\n        finishedRoot,\n        finishedWork,\n        includeWorkInProgressEffects,\n      );\n      break;\n    }\n  }\n}\n\nfunction recursivelyTraverseReappearLayoutEffects(\n  finishedRoot: FiberRoot,\n  parentFiber: Fiber,\n  includeWorkInProgressEffects: boolean,\n) {\n  // This function visits both newly finished work and nodes that were re-used\n  // from a previously committed tree. We cannot check non-static flags if the\n  // node was reused.\n  const childShouldIncludeWorkInProgressEffects =\n    includeWorkInProgressEffects &&\n    (parentFiber.subtreeFlags & LayoutMask) !== NoFlags;\n\n  // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n  let child = parentFiber.child;\n  while (child !== null) {\n    const current = child.alternate;\n    reappearLayoutEffects(\n      finishedRoot,\n      current,\n      child,\n      childShouldIncludeWorkInProgressEffects,\n    );\n    child = child.sibling;\n  }\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitHookPassiveMountEffects(\n  finishedWork: Fiber,\n  hookFlags: HookFlags,\n) {\n  if (shouldProfile(finishedWork)) {\n    startPassiveEffectTimer();\n    try {\n      commitHookEffectListMount(hookFlags, finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n    recordPassiveEffectDuration(finishedWork);\n  } else {\n    try {\n      commitHookEffectListMount(hookFlags, finishedWork);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\n\nfunction commitOffscreenPassiveMountEffects(\n  current: Fiber | null,\n  finishedWork: Fiber,\n  instance: OffscreenInstance,\n) {\n  if (enableCache) {\n    let previousCache: Cache | null = null;\n    if (\n      current !== null &&\n      current.memoizedState !== null &&\n      current.memoizedState.cachePool !== null\n    ) {\n      previousCache = current.memoizedState.cachePool.pool;\n    }\n    let nextCache: Cache | null = null;\n    if (\n      finishedWork.memoizedState !== null &&\n      finishedWork.memoizedState.cachePool !== null\n    ) {\n      nextCache = finishedWork.memoizedState.cachePool.pool;\n    }\n    // Retain/release the cache used for pending (suspended) nodes.\n    // Note that this is only reached in the non-suspended/visible case:\n    // when the content is suspended/hidden, the retain/release occurs\n    // via the parent Suspense component (see case above).\n    if (nextCache !== previousCache) {\n      if (nextCache != null) {\n        retainCache(nextCache);\n      }\n      if (previousCache != null) {\n        releaseCache(previousCache);\n      }\n    }\n  }\n\n  if (enableTransitionTracing) {\n    // TODO: Pre-rendering should not be counted as part of a transition. We\n    // may add separate logs for pre-rendering, but it's not part of the\n    // primary metrics.\n    const offscreenState: OffscreenState = finishedWork.memoizedState;\n    const queue: OffscreenQueue | null = (finishedWork.updateQueue: any);\n\n    const isHidden = offscreenState !== null;\n    if (queue !== null) {\n      if (isHidden) {\n        const transitions = queue.transitions;\n        if (transitions !== null) {\n          transitions.forEach(transition => {\n            // Add all the transitions saved in the update queue during\n            // the render phase (ie the transitions associated with this boundary)\n            // into the transitions set.\n            if (instance._transitions === null) {\n              instance._transitions = new Set();\n            }\n            instance._transitions.add(transition);\n          });\n        }\n\n        const markerInstances = queue.markerInstances;\n        if (markerInstances !== null) {\n          markerInstances.forEach(markerInstance => {\n            const markerTransitions = markerInstance.transitions;\n            // There should only be a few tracing marker transitions because\n            // they should be only associated with the transition that\n            // caused them\n            if (markerTransitions !== null) {\n              markerTransitions.forEach(transition => {\n                if (instance._transitions === null) {\n                  instance._transitions = new Set();\n                } else if (instance._transitions.has(transition)) {\n                  if (markerInstance.pendingBoundaries === null) {\n                    markerInstance.pendingBoundaries = new Map();\n                  }\n                  if (instance._pendingMarkers === null) {\n                    instance._pendingMarkers = new Set();\n                  }\n\n                  instance._pendingMarkers.add(markerInstance);\n                }\n              });\n            }\n          });\n        }\n      }\n\n      finishedWork.updateQueue = null;\n    }\n\n    commitTransitionProgress(finishedWork);\n\n    // TODO: Refactor this into an if/else branch\n    if (!isHidden) {\n      instance._transitions = null;\n      instance._pendingMarkers = null;\n    }\n  }\n}\n\nfunction commitCachePassiveMountEffect(\n  current: Fiber | null,\n  finishedWork: Fiber,\n) {\n  if (enableCache) {\n    let previousCache: Cache | null = null;\n    if (finishedWork.alternate !== null) {\n      previousCache = finishedWork.alternate.memoizedState.cache;\n    }\n    const nextCache = finishedWork.memoizedState.cache;\n    // Retain/release the cache. In theory the cache component\n    // could be \"borrowing\" a cache instance owned by some parent,\n    // in which case we could avoid retaining/releasing. But it\n    // is non-trivial to determine when that is the case, so we\n    // always retain/release.\n    if (nextCache !== previousCache) {\n      retainCache(nextCache);\n      if (previousCache != null) {\n        releaseCache(previousCache);\n      }\n    }\n  }\n}\n\nfunction commitTracingMarkerPassiveMountEffect(finishedWork: Fiber) {\n  // Get the transitions that were initiatized during the render\n  // and add a start transition callback for each of them\n  // We will only call this on initial mount of the tracing marker\n  // only if there are no suspense children\n  const instance = finishedWork.stateNode;\n  if (instance.transitions !== null && instance.pendingBoundaries === null) {\n    addMarkerCompleteCallbackToPendingTransition(\n      finishedWork.memoizedProps.name,\n      instance.transitions,\n    );\n    instance.transitions = null;\n    instance.pendingBoundaries = null;\n    instance.aborts = null;\n    instance.name = null;\n  }\n}\n\nexport function commitPassiveMountEffects(\n  root: FiberRoot,\n  finishedWork: Fiber,\n  committedLanes: Lanes,\n  committedTransitions: Array<Transition> | null,\n): void {\n  setCurrentDebugFiberInDEV(finishedWork);\n  commitPassiveMountOnFiber(\n    root,\n    finishedWork,\n    committedLanes,\n    committedTransitions,\n  );\n  resetCurrentDebugFiberInDEV();\n}\n\nfunction recursivelyTraversePassiveMountEffects(\n  root: FiberRoot,\n  parentFiber: Fiber,\n  committedLanes: Lanes,\n  committedTransitions: Array<Transition> | null,\n) {\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n  if (parentFiber.subtreeFlags & PassiveMask) {\n    let child = parentFiber.child;\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      commitPassiveMountOnFiber(\n        root,\n        child,\n        committedLanes,\n        committedTransitions,\n      );\n      child = child.sibling;\n    }\n  }\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitPassiveMountOnFiber(\n  finishedRoot: FiberRoot,\n  finishedWork: Fiber,\n  committedLanes: Lanes,\n  committedTransitions: Array<Transition> | null,\n): void {\n  // When updating this function, also update reconnectPassiveEffects, which does\n  // most of the same things when an offscreen tree goes from hidden -> visible,\n  // or when toggling effects inside a hidden tree.\n  const flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions,\n      );\n      if (flags & Passive) {\n        commitHookPassiveMountEffects(\n          finishedWork,\n          HookPassive | HookHasEffect,\n        );\n      }\n      break;\n    }\n    case HostRoot: {\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions,\n      );\n      if (flags & Passive) {\n        if (enableCache) {\n          let previousCache: Cache | null = null;\n          if (finishedWork.alternate !== null) {\n            previousCache = finishedWork.alternate.memoizedState.cache;\n          }\n          const nextCache = finishedWork.memoizedState.cache;\n          // Retain/release the root cache.\n          // Note that on initial mount, previousCache and nextCache will be the same\n          // and this retain won't occur. To counter this, we instead retain the HostRoot's\n          // initial cache when creating the root itself (see createFiberRoot() in\n          // ReactFiberRoot.js). Subsequent updates that change the cache are reflected\n          // here, such that previous/next caches are retained correctly.\n          if (nextCache !== previousCache) {\n            retainCache(nextCache);\n            if (previousCache != null) {\n              releaseCache(previousCache);\n            }\n          }\n        }\n\n        if (enableTransitionTracing) {\n          // Get the transitions that were initiatized during the render\n          // and add a start transition callback for each of them\n          const root: FiberRoot = finishedWork.stateNode;\n          const incompleteTransitions = root.incompleteTransitions;\n          // Initial render\n          if (committedTransitions !== null) {\n            committedTransitions.forEach(transition => {\n              addTransitionStartCallbackToPendingTransition(transition);\n            });\n\n            clearTransitionsForLanes(finishedRoot, committedLanes);\n          }\n\n          incompleteTransitions.forEach((markerInstance, transition) => {\n            const pendingBoundaries = markerInstance.pendingBoundaries;\n            if (pendingBoundaries === null || pendingBoundaries.size === 0) {\n              if (markerInstance.aborts === null) {\n                addTransitionCompleteCallbackToPendingTransition(transition);\n              }\n              incompleteTransitions.delete(transition);\n            }\n          });\n\n          clearTransitionsForLanes(finishedRoot, committedLanes);\n        }\n      }\n      break;\n    }\n    case LegacyHiddenComponent: {\n      if (enableLegacyHidden) {\n        recursivelyTraversePassiveMountEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n        );\n\n        if (flags & Passive) {\n          const current = finishedWork.alternate;\n          const instance: OffscreenInstance = finishedWork.stateNode;\n          commitOffscreenPassiveMountEffects(current, finishedWork, instance);\n        }\n      }\n      break;\n    }\n    case OffscreenComponent: {\n      // TODO: Pass `current` as argument to this function\n      const instance: OffscreenInstance = finishedWork.stateNode;\n      const nextState: OffscreenState | null = finishedWork.memoizedState;\n\n      const isHidden = nextState !== null;\n\n      if (isHidden) {\n        if (instance._visibility & OffscreenPassiveEffectsConnected) {\n          // The effects are currently connected. Update them.\n          recursivelyTraversePassiveMountEffects(\n            finishedRoot,\n            finishedWork,\n            committedLanes,\n            committedTransitions,\n          );\n        } else {\n          if (finishedWork.mode & ConcurrentMode) {\n            // The effects are currently disconnected. Since the tree is hidden,\n            // don't connect them. This also applies to the initial render.\n            if (enableCache || enableTransitionTracing) {\n              // \"Atomic\" effects are ones that need to fire on every commit,\n              // even during pre-rendering. An example is updating the reference\n              // count on cache instances.\n              recursivelyTraverseAtomicPassiveEffects(\n                finishedRoot,\n                finishedWork,\n                committedLanes,\n                committedTransitions,\n              );\n            }\n          } else {\n            // Legacy Mode: Fire the effects even if the tree is hidden.\n            instance._visibility |= OffscreenPassiveEffectsConnected;\n            recursivelyTraversePassiveMountEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions,\n            );\n          }\n        }\n      } else {\n        // Tree is visible\n        if (instance._visibility & OffscreenPassiveEffectsConnected) {\n          // The effects are currently connected. Update them.\n          recursivelyTraversePassiveMountEffects(\n            finishedRoot,\n            finishedWork,\n            committedLanes,\n            committedTransitions,\n          );\n        } else {\n          // The effects are currently disconnected. Reconnect them, while also\n          // firing effects inside newly mounted trees. This also applies to\n          // the initial render.\n          instance._visibility |= OffscreenPassiveEffectsConnected;\n\n          const includeWorkInProgressEffects =\n            (finishedWork.subtreeFlags & PassiveMask) !== NoFlags;\n          recursivelyTraverseReconnectPassiveEffects(\n            finishedRoot,\n            finishedWork,\n            committedLanes,\n            committedTransitions,\n            includeWorkInProgressEffects,\n          );\n        }\n      }\n\n      if (flags & Passive) {\n        const current = finishedWork.alternate;\n        commitOffscreenPassiveMountEffects(current, finishedWork, instance);\n      }\n      break;\n    }\n    case CacheComponent: {\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions,\n      );\n      if (flags & Passive) {\n        // TODO: Pass `current` as argument to this function\n        const current = finishedWork.alternate;\n        commitCachePassiveMountEffect(current, finishedWork);\n      }\n      break;\n    }\n    case TracingMarkerComponent: {\n      if (enableTransitionTracing) {\n        recursivelyTraversePassiveMountEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n        );\n        if (flags & Passive) {\n          commitTracingMarkerPassiveMountEffect(finishedWork);\n        }\n        break;\n      }\n      // Intentional fallthrough to next branch\n    }\n    // eslint-disable-next-line-no-fallthrough\n    default: {\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions,\n      );\n      break;\n    }\n  }\n}\n\nfunction recursivelyTraverseReconnectPassiveEffects(\n  finishedRoot: FiberRoot,\n  parentFiber: Fiber,\n  committedLanes: Lanes,\n  committedTransitions: Array<Transition> | null,\n  includeWorkInProgressEffects: boolean,\n) {\n  // This function visits both newly finished work and nodes that were re-used\n  // from a previously committed tree. We cannot check non-static flags if the\n  // node was reused.\n  const childShouldIncludeWorkInProgressEffects =\n    includeWorkInProgressEffects &&\n    (parentFiber.subtreeFlags & PassiveMask) !== NoFlags;\n\n  // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n  let child = parentFiber.child;\n  while (child !== null) {\n    reconnectPassiveEffects(\n      finishedRoot,\n      child,\n      committedLanes,\n      committedTransitions,\n      childShouldIncludeWorkInProgressEffects,\n    );\n    child = child.sibling;\n  }\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nexport function reconnectPassiveEffects(\n  finishedRoot: FiberRoot,\n  finishedWork: Fiber,\n  committedLanes: Lanes,\n  committedTransitions: Array<Transition> | null,\n  // This function visits both newly finished work and nodes that were re-used\n  // from a previously committed tree. We cannot check non-static flags if the\n  // node was reused.\n  includeWorkInProgressEffects: boolean,\n) {\n  const flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      recursivelyTraverseReconnectPassiveEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions,\n        includeWorkInProgressEffects,\n      );\n      // TODO: Check for PassiveStatic flag\n      commitHookPassiveMountEffects(finishedWork, HookPassive);\n      break;\n    }\n    // Unlike commitPassiveMountOnFiber, we don't need to handle HostRoot\n    // because this function only visits nodes that are inside an\n    // Offscreen fiber.\n    // case HostRoot: {\n    //  ...\n    // }\n    case LegacyHiddenComponent: {\n      if (enableLegacyHidden) {\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects,\n        );\n\n        if (includeWorkInProgressEffects && flags & Passive) {\n          // TODO: Pass `current` as argument to this function\n          const current: Fiber | null = finishedWork.alternate;\n          const instance: OffscreenInstance = finishedWork.stateNode;\n          commitOffscreenPassiveMountEffects(current, finishedWork, instance);\n        }\n      }\n      break;\n    }\n    case OffscreenComponent: {\n      const instance: OffscreenInstance = finishedWork.stateNode;\n      const nextState: OffscreenState | null = finishedWork.memoizedState;\n\n      const isHidden = nextState !== null;\n\n      if (isHidden) {\n        if (instance._visibility & OffscreenPassiveEffectsConnected) {\n          // The effects are currently connected. Update them.\n          recursivelyTraverseReconnectPassiveEffects(\n            finishedRoot,\n            finishedWork,\n            committedLanes,\n            committedTransitions,\n            includeWorkInProgressEffects,\n          );\n        } else {\n          if (finishedWork.mode & ConcurrentMode) {\n            // The effects are currently disconnected. Since the tree is hidden,\n            // don't connect them. This also applies to the initial render.\n            if (enableCache || enableTransitionTracing) {\n              // \"Atomic\" effects are ones that need to fire on every commit,\n              // even during pre-rendering. An example is updating the reference\n              // count on cache instances.\n              recursivelyTraverseAtomicPassiveEffects(\n                finishedRoot,\n                finishedWork,\n                committedLanes,\n                committedTransitions,\n              );\n            }\n          } else {\n            // Legacy Mode: Fire the effects even if the tree is hidden.\n            instance._visibility |= OffscreenPassiveEffectsConnected;\n            recursivelyTraverseReconnectPassiveEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions,\n              includeWorkInProgressEffects,\n            );\n          }\n        }\n      } else {\n        // Tree is visible\n\n        // Since we're already inside a reconnecting tree, it doesn't matter\n        // whether the effects are currently connected. In either case, we'll\n        // continue traversing the tree and firing all the effects.\n        //\n        // We do need to set the \"connected\" flag on the instance, though.\n        instance._visibility |= OffscreenPassiveEffectsConnected;\n\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects,\n        );\n      }\n\n      if (includeWorkInProgressEffects && flags & Passive) {\n        // TODO: Pass `current` as argument to this function\n        const current: Fiber | null = finishedWork.alternate;\n        commitOffscreenPassiveMountEffects(current, finishedWork, instance);\n      }\n      break;\n    }\n    case CacheComponent: {\n      recursivelyTraverseReconnectPassiveEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions,\n        includeWorkInProgressEffects,\n      );\n      if (includeWorkInProgressEffects && flags & Passive) {\n        // TODO: Pass `current` as argument to this function\n        const current = finishedWork.alternate;\n        commitCachePassiveMountEffect(current, finishedWork);\n      }\n      break;\n    }\n    case TracingMarkerComponent: {\n      if (enableTransitionTracing) {\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects,\n        );\n        if (includeWorkInProgressEffects && flags & Passive) {\n          commitTracingMarkerPassiveMountEffect(finishedWork);\n        }\n        break;\n      }\n      // Intentional fallthrough to next branch\n    }\n    // eslint-disable-next-line-no-fallthrough\n    default: {\n      recursivelyTraverseReconnectPassiveEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions,\n        includeWorkInProgressEffects,\n      );\n      break;\n    }\n  }\n}\n\nfunction recursivelyTraverseAtomicPassiveEffects(\n  finishedRoot: FiberRoot,\n  parentFiber: Fiber,\n  committedLanes: Lanes,\n  committedTransitions: Array<Transition> | null,\n) {\n  // \"Atomic\" effects are ones that need to fire on every commit, even during\n  // pre-rendering. We call this function when traversing a hidden tree whose\n  // regular effects are currently disconnected.\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n  // TODO: Add special flag for atomic effects\n  if (parentFiber.subtreeFlags & PassiveMask) {\n    let child = parentFiber.child;\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      commitAtomicPassiveEffects(\n        finishedRoot,\n        child,\n        committedLanes,\n        committedTransitions,\n      );\n      child = child.sibling;\n    }\n  }\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitAtomicPassiveEffects(\n  finishedRoot: FiberRoot,\n  finishedWork: Fiber,\n  committedLanes: Lanes,\n  committedTransitions: Array<Transition> | null,\n) {\n  // \"Atomic\" effects are ones that need to fire on every commit, even during\n  // pre-rendering. We call this function when traversing a hidden tree whose\n  // regular effects are currently disconnected.\n  const flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case OffscreenComponent: {\n      recursivelyTraverseAtomicPassiveEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions,\n      );\n      if (flags & Passive) {\n        // TODO: Pass `current` as argument to this function\n        const current = finishedWork.alternate;\n        const instance: OffscreenInstance = finishedWork.stateNode;\n        commitOffscreenPassiveMountEffects(current, finishedWork, instance);\n      }\n      break;\n    }\n    case CacheComponent: {\n      recursivelyTraverseAtomicPassiveEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions,\n      );\n      if (flags & Passive) {\n        // TODO: Pass `current` as argument to this function\n        const current = finishedWork.alternate;\n        commitCachePassiveMountEffect(current, finishedWork);\n      }\n      break;\n    }\n    // eslint-disable-next-line-no-fallthrough\n    default: {\n      recursivelyTraverseAtomicPassiveEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions,\n      );\n      break;\n    }\n  }\n}\n\nexport function commitPassiveUnmountEffects(finishedWork: Fiber): void {\n  setCurrentDebugFiberInDEV(finishedWork);\n  commitPassiveUnmountOnFiber(finishedWork);\n  resetCurrentDebugFiberInDEV();\n}\n\nfunction detachAlternateSiblings(parentFiber: Fiber) {\n  if (deletedTreeCleanUpLevel >= 1) {\n    // A fiber was deleted from this parent fiber, but it's still part of the\n    // previous (alternate) parent fiber's list of children. Because children\n    // are a linked list, an earlier sibling that's still alive will be\n    // connected to the deleted fiber via its `alternate`:\n    //\n    //   live fiber --alternate--> previous live fiber --sibling--> deleted\n    //   fiber\n    //\n    // We can't disconnect `alternate` on nodes that haven't been deleted yet,\n    // but we can disconnect the `sibling` and `child` pointers.\n\n    const previousFiber = parentFiber.alternate;\n    if (previousFiber !== null) {\n      let detachedChild = previousFiber.child;\n      if (detachedChild !== null) {\n        previousFiber.child = null;\n        do {\n          // $FlowFixMe[incompatible-use] found when upgrading Flow\n          const detachedSibling = detachedChild.sibling;\n          // $FlowFixMe[incompatible-use] found when upgrading Flow\n          detachedChild.sibling = null;\n          detachedChild = detachedSibling;\n        } while (detachedChild !== null);\n      }\n    }\n  }\n}\n\nfunction commitHookPassiveUnmountEffects(\n  finishedWork: Fiber,\n  nearestMountedAncestor,\n  hookFlags: HookFlags,\n) {\n  if (shouldProfile(finishedWork)) {\n    startPassiveEffectTimer();\n    commitHookEffectListUnmount(\n      hookFlags,\n      finishedWork,\n      nearestMountedAncestor,\n    );\n    recordPassiveEffectDuration(finishedWork);\n  } else {\n    commitHookEffectListUnmount(\n      hookFlags,\n      finishedWork,\n      nearestMountedAncestor,\n    );\n  }\n}\n\nfunction recursivelyTraversePassiveUnmountEffects(parentFiber: Fiber): void {\n  // Deletions effects can be scheduled on any fiber type. They need to happen\n  // before the children effects have fired.\n  const deletions = parentFiber.deletions;\n\n  if ((parentFiber.flags & ChildDeletion) !== NoFlags) {\n    if (deletions !== null) {\n      for (let i = 0; i < deletions.length; i++) {\n        const childToDelete = deletions[i];\n        // TODO: Convert this to use recursion\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n          childToDelete,\n          parentFiber,\n        );\n      }\n    }\n    detachAlternateSiblings(parentFiber);\n  }\n\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n  // TODO: Split PassiveMask into separate masks for mount and unmount?\n  if (parentFiber.subtreeFlags & PassiveMask) {\n    let child = parentFiber.child;\n    while (child !== null) {\n      setCurrentDebugFiberInDEV(child);\n      commitPassiveUnmountOnFiber(child);\n      child = child.sibling;\n    }\n  }\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nfunction commitPassiveUnmountOnFiber(finishedWork: Fiber): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      if (finishedWork.flags & Passive) {\n        commitHookPassiveUnmountEffects(\n          finishedWork,\n          finishedWork.return,\n          HookPassive | HookHasEffect,\n        );\n      }\n      break;\n    }\n    case OffscreenComponent: {\n      const instance: OffscreenInstance = finishedWork.stateNode;\n      const nextState: OffscreenState | null = finishedWork.memoizedState;\n\n      const isHidden = nextState !== null;\n\n      if (\n        isHidden &&\n        instance._visibility & OffscreenPassiveEffectsConnected &&\n        // For backwards compatibility, don't unmount when a tree suspends. In\n        // the future we may change this to unmount after a delay.\n        (finishedWork.return === null ||\n          finishedWork.return.tag !== SuspenseComponent)\n      ) {\n        // The effects are currently connected. Disconnect them.\n        // TODO: Add option or heuristic to delay before disconnecting the\n        // effects. Then if the tree reappears before the delay has elapsed, we\n        // can skip toggling the effects entirely.\n        instance._visibility &= ~OffscreenPassiveEffectsConnected;\n        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n      } else {\n        recursivelyTraversePassiveUnmountEffects(finishedWork);\n      }\n\n      break;\n    }\n    default: {\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    }\n  }\n}\n\nfunction recursivelyTraverseDisconnectPassiveEffects(parentFiber: Fiber): void {\n  // Deletions effects can be scheduled on any fiber type. They need to happen\n  // before the children effects have fired.\n  const deletions = parentFiber.deletions;\n\n  if ((parentFiber.flags & ChildDeletion) !== NoFlags) {\n    if (deletions !== null) {\n      for (let i = 0; i < deletions.length; i++) {\n        const childToDelete = deletions[i];\n        // TODO: Convert this to use recursion\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n          childToDelete,\n          parentFiber,\n        );\n      }\n    }\n    detachAlternateSiblings(parentFiber);\n  }\n\n  const prevDebugFiber = getCurrentDebugFiberInDEV();\n  // TODO: Check PassiveStatic flag\n  let child = parentFiber.child;\n  while (child !== null) {\n    setCurrentDebugFiberInDEV(child);\n    disconnectPassiveEffect(child);\n    child = child.sibling;\n  }\n  setCurrentDebugFiberInDEV(prevDebugFiber);\n}\n\nexport function disconnectPassiveEffect(finishedWork: Fiber): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      // TODO: Check PassiveStatic flag\n      commitHookPassiveUnmountEffects(\n        finishedWork,\n        finishedWork.return,\n        HookPassive,\n      );\n      // When disconnecting passive effects, we fire the effects in the same\n      // order as during a deletiong: parent before child\n      recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n      break;\n    }\n    case OffscreenComponent: {\n      const instance: OffscreenInstance = finishedWork.stateNode;\n      if (instance._visibility & OffscreenPassiveEffectsConnected) {\n        instance._visibility &= ~OffscreenPassiveEffectsConnected;\n        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n      } else {\n        // The effects are already disconnected.\n      }\n      break;\n    }\n    default: {\n      recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n      break;\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n  deletedSubtreeRoot: Fiber,\n  nearestMountedAncestor: Fiber | null,\n) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    // Deletion effects fire in parent -> child order\n    // TODO: Check if fiber has a PassiveStatic flag\n    setCurrentDebugFiberInDEV(fiber);\n    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n    resetCurrentDebugFiberInDEV();\n\n    const child = fiber.child;\n    // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n    if (child !== null) {\n      child.return = fiber;\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(\n        deletedSubtreeRoot,\n      );\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_complete(\n  deletedSubtreeRoot: Fiber,\n) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    const sibling = fiber.sibling;\n    const returnFiber = fiber.return;\n\n    if (deletedTreeCleanUpLevel >= 2) {\n      // Recursively traverse the entire deleted tree and clean up fiber fields.\n      // This is more aggressive than ideal, and the long term goal is to only\n      // have to detach the deleted tree at the root.\n      detachFiberAfterEffects(fiber);\n      if (fiber === deletedSubtreeRoot) {\n        nextEffect = null;\n        return;\n      }\n    } else {\n      // This is the default branch (level 0). We do not recursively clear all\n      // the fiber fields. Only the root of the deleted subtree.\n      if (fiber === deletedSubtreeRoot) {\n        detachFiberAfterEffects(fiber);\n        nextEffect = null;\n        return;\n      }\n    }\n\n    if (sibling !== null) {\n      sibling.return = returnFiber;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = returnFiber;\n  }\n}\n\nfunction commitPassiveUnmountInsideDeletedTreeOnFiber(\n  current: Fiber,\n  nearestMountedAncestor: Fiber | null,\n): void {\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent: {\n      commitHookPassiveUnmountEffects(\n        current,\n        nearestMountedAncestor,\n        HookPassive,\n      );\n      break;\n    }\n    // TODO: run passive unmount effects when unmounting a root.\n    // Because passive unmount effects are not currently run,\n    // the cache instance owned by the root will never be freed.\n    // When effects are run, the cache should be freed here:\n    // case HostRoot: {\n    //   if (enableCache) {\n    //     const cache = current.memoizedState.cache;\n    //     releaseCache(cache);\n    //   }\n    //   break;\n    // }\n    case LegacyHiddenComponent:\n    case OffscreenComponent: {\n      if (enableCache) {\n        if (\n          current.memoizedState !== null &&\n          current.memoizedState.cachePool !== null\n        ) {\n          const cache: Cache = current.memoizedState.cachePool.pool;\n          // Retain/release the cache used for pending (suspended) nodes.\n          // Note that this is only reached in the non-suspended/visible case:\n          // when the content is suspended/hidden, the retain/release occurs\n          // via the parent Suspense component (see case above).\n          if (cache != null) {\n            retainCache(cache);\n          }\n        }\n      }\n      break;\n    }\n    case SuspenseComponent: {\n      if (enableTransitionTracing) {\n        // We need to mark this fiber's parents as deleted\n        const offscreenFiber: Fiber = (current.child: any);\n        const instance: OffscreenInstance = offscreenFiber.stateNode;\n        const transitions = instance._transitions;\n        if (transitions !== null) {\n          const abortReason = {\n            reason: 'suspense',\n            name: current.memoizedProps.unstable_name || null,\n          };\n          if (\n            current.memoizedState === null ||\n            current.memoizedState.dehydrated === null\n          ) {\n            abortParentMarkerTransitionsForDeletedFiber(\n              offscreenFiber,\n              abortReason,\n              transitions,\n              instance,\n              true,\n            );\n\n            if (nearestMountedAncestor !== null) {\n              abortParentMarkerTransitionsForDeletedFiber(\n                nearestMountedAncestor,\n                abortReason,\n                transitions,\n                instance,\n                false,\n              );\n            }\n          }\n        }\n      }\n      break;\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        const cache = current.memoizedState.cache;\n        releaseCache(cache);\n      }\n      break;\n    }\n    case TracingMarkerComponent: {\n      if (enableTransitionTracing) {\n        // We need to mark this fiber's parents as deleted\n        const instance: TracingMarkerInstance = current.stateNode;\n        const transitions = instance.transitions;\n        if (transitions !== null) {\n          const abortReason = {\n            reason: 'marker',\n            name: current.memoizedProps.name,\n          };\n          abortParentMarkerTransitionsForDeletedFiber(\n            current,\n            abortReason,\n            transitions,\n            null,\n            true,\n          );\n\n          if (nearestMountedAncestor !== null) {\n            abortParentMarkerTransitionsForDeletedFiber(\n              nearestMountedAncestor,\n              abortReason,\n              transitions,\n              null,\n              false,\n            );\n          }\n        }\n      }\n      break;\n    }\n  }\n}\n\nfunction invokeLayoutEffectMountInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        try {\n          commitHookEffectListMount(HookLayout | HookHasEffect, fiber);\n        } catch (error) {\n          captureCommitPhaseError(fiber, fiber.return, error);\n        }\n        break;\n      }\n      case ClassComponent: {\n        const instance = fiber.stateNode;\n        try {\n          instance.componentDidMount();\n        } catch (error) {\n          captureCommitPhaseError(fiber, fiber.return, error);\n        }\n        break;\n      }\n    }\n  }\n}\n\nfunction invokePassiveEffectMountInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        try {\n          commitHookEffectListMount(HookPassive | HookHasEffect, fiber);\n        } catch (error) {\n          captureCommitPhaseError(fiber, fiber.return, error);\n        }\n        break;\n      }\n    }\n  }\n}\n\nfunction invokeLayoutEffectUnmountInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        try {\n          commitHookEffectListUnmount(\n            HookLayout | HookHasEffect,\n            fiber,\n            fiber.return,\n          );\n        } catch (error) {\n          captureCommitPhaseError(fiber, fiber.return, error);\n        }\n        break;\n      }\n      case ClassComponent: {\n        const instance = fiber.stateNode;\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n        }\n        break;\n      }\n    }\n  }\n}\n\nfunction invokePassiveEffectUnmountInDEV(fiber: Fiber): void {\n  if (__DEV__) {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        try {\n          commitHookEffectListUnmount(\n            HookPassive | HookHasEffect,\n            fiber,\n            fiber.return,\n          );\n        } catch (error) {\n          captureCommitPhaseError(fiber, fiber.return, error);\n        }\n      }\n    }\n  }\n}\n\nexport {\n  commitPlacement,\n  commitAttachRef,\n  invokeLayoutEffectMountInDEV,\n  invokeLayoutEffectUnmountInDEV,\n  invokePassiveEffectMountInDEV,\n  invokePassiveEffectUnmountInDEV,\n};\n"]},"metadata":{},"sourceType":"module"}