{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n// We use the existence of the state object as an indicator that the component\n// is hidden.\nexport const OffscreenVisible =\n/*                     */\n0b001;\nexport const OffscreenDetached =\n/*                    */\n0b010;\nexport const OffscreenPassiveEffectsConnected =\n/*     */\n0b100;\nexport function isOffscreenManual(offscreenFiber) {\n  return offscreenFiber.memoizedProps !== null && offscreenFiber.memoizedProps.mode === 'manual';\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberOffscreenComponent.js"],"names":["OffscreenVisible","OffscreenDetached","OffscreenPassiveEffectsConnected","isOffscreenManual","offscreenFiber","memoizedProps","mode"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsBA;AACA;AAiBA,OAAO,MAAMA,gBAAgB;AAAG;AAA0B,KAAnD;AACP,OAAO,MAAMC,iBAAiB;AAAG;AAAyB,KAAnD;AACP,OAAO,MAAMC,gCAAgC;AAAG;AAAU,KAAnD;AAgBP,OAAO,SAASC,iBAAT,CAA2BC,cAA3B,EAA2D;AAChE,SACEA,cAAc,CAACC,aAAf,KAAiC,IAAjC,IACAD,cAAc,CAACC,aAAf,CAA6BC,IAA7B,KAAsC,QAFxC;AAID","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactNodeList, OffscreenMode, Wakeable} from 'shared/ReactTypes';\nimport type {Lanes} from './ReactFiberLane';\nimport type {SpawnedCachePool} from './ReactFiberCacheComponent';\nimport type {Fiber} from './ReactInternalTypes';\nimport type {\n  Transition,\n  TracingMarkerInstance,\n} from './ReactFiberTracingMarkerComponent';\n\nexport type OffscreenProps = {\n  // TODO: Pick an API before exposing the Offscreen type. I've chosen an enum\n  // for now, since we might have multiple variants. For example, hiding the\n  // content without changing the layout.\n  //\n  // Default mode is visible. Kind of a weird default for a component\n  // called \"Offscreen.\" Possible alt: <Visibility />?\n  mode?: OffscreenMode | null | void,\n  children?: ReactNodeList,\n};\n\n// We use the existence of the state object as an indicator that the component\n// is hidden.\nexport type OffscreenState = {\n  // TODO: This doesn't do anything, yet. It's always NoLanes. But eventually it\n  // will represent the pending work that must be included in the render in\n  // order to unhide the component.\n  baseLanes: Lanes,\n  cachePool: SpawnedCachePool | null,\n};\n\nexport type OffscreenQueue = {\n  transitions: Array<Transition> | null,\n  markerInstances: Array<TracingMarkerInstance> | null,\n  wakeables: Set<Wakeable> | null,\n};\n\ntype OffscreenVisibility = number;\n\nexport const OffscreenVisible = /*                     */ 0b001;\nexport const OffscreenDetached = /*                    */ 0b010;\nexport const OffscreenPassiveEffectsConnected = /*     */ 0b100;\n\nexport type OffscreenInstance = {\n  _pendingVisibility: OffscreenVisibility,\n  _visibility: OffscreenVisibility,\n  _pendingMarkers: Set<TracingMarkerInstance> | null,\n  _transitions: Set<Transition> | null,\n  // $FlowFixMe[incompatible-type-arg] found when upgrading Flow\n  _retryCache: WeakSet<Wakeable> | Set<Wakeable> | null,\n\n  // Represents the current Offscreen fiber\n  _current: Fiber | null,\n  detach: () => void,\n  attach: () => void,\n};\n\nexport function isOffscreenManual(offscreenFiber: Fiber): boolean {\n  return (\n    offscreenFiber.memoizedProps !== null &&\n    offscreenFiber.memoizedProps.mode === 'manual'\n  );\n}\n"]},"metadata":{},"sourceType":"module"}