{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { getPropertyInfo, shouldIgnoreAttribute, shouldRemoveAttribute, isAttributeNameSafe, BOOLEAN, OVERLOADED_BOOLEAN } from '../shared/DOMProperty';\nimport sanitizeURL from '../shared/sanitizeURL';\nimport { disableJavaScriptURLs, enableTrustedTypesIntegration, enableCustomElementPropertySupport } from 'shared/ReactFeatureFlags';\nimport { checkAttributeStringCoercion } from 'shared/CheckStringCoercion';\nimport { getFiberCurrentPropsFromNode } from './ReactDOMComponentTree';\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nexport function getValueForProperty(node, name, expected, propertyInfo) {\n  if (__DEV__) {\n    if (propertyInfo.mustUseProperty) {\n      const {\n        propertyName\n      } = propertyInfo;\n      return node[propertyName];\n    } else {\n      // This check protects multiple uses of `expected`, which is why the\n      // react-internal/safe-string-coercion rule is disabled in several spots\n      // below.\n      if (__DEV__) {\n        checkAttributeStringCoercion(expected, name);\n      }\n\n      if (!disableJavaScriptURLs && propertyInfo.sanitizeURL) {\n        // If we haven't fully disabled javascript: URLs, and if\n        // the hydration is successful of a javascript: URL, we\n        // still want to warn on the client.\n        // eslint-disable-next-line react-internal/safe-string-coercion\n        sanitizeURL('' + expected);\n      }\n\n      const attributeName = propertyInfo.attributeName;\n      let stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          const value = node.getAttribute(attributeName);\n\n          if (value === '') {\n            return true;\n          }\n\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n          if (value === '' + expected) {\n            return expected;\n          }\n\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        } // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n\n\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue; // eslint-disable-next-line react-internal/safe-string-coercion\n      } else if (stringValue === '' + expected) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\n\nexport function getValueForAttribute(node, name, expected, isCustomComponentTag) {\n  if (__DEV__) {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n\n    const value = node.getAttribute(name);\n\n    if (enableCustomElementPropertySupport) {\n      if (isCustomComponentTag && value === '') {\n        return true;\n      }\n    }\n\n    if (__DEV__) {\n      checkAttributeStringCoercion(expected, name);\n    }\n\n    if (value === '' + expected) {\n      return expected;\n    }\n\n    return value;\n  }\n}\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\n\nexport function setValueForProperty(node, name, value, isCustomComponentTag) {\n  const propertyInfo = getPropertyInfo(name);\n\n  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n    return;\n  }\n\n  if (enableCustomElementPropertySupport && isCustomComponentTag && name[0] === 'o' && name[1] === 'n') {\n    let eventName = name.replace(/Capture$/, '');\n    const useCapture = name !== eventName;\n    eventName = eventName.slice(2);\n    const prevProps = getFiberCurrentPropsFromNode(node);\n    const prevValue = prevProps != null ? prevProps[name] : null;\n\n    if (typeof prevValue === 'function') {\n      node.removeEventListener(eventName, prevValue, useCapture);\n    }\n\n    if (typeof value === 'function') {\n      if (typeof prevValue !== 'function' && prevValue !== null) {\n        // If we previously assigned a non-function type into this node, then\n        // remove it when switching to event listener mode.\n        if (name in node) {\n          node[name] = null;\n        } else if (node.hasAttribute(name)) {\n          node.removeAttribute(name);\n        }\n      } // $FlowFixMe value can't be casted to EventListener.\n\n\n      node.addEventListener(eventName, value, useCapture);\n      return;\n    }\n  }\n\n  if (enableCustomElementPropertySupport && isCustomComponentTag && name in node) {\n    node[name] = value;\n    return;\n  }\n\n  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n    value = null;\n  }\n\n  if (enableCustomElementPropertySupport) {\n    if (isCustomComponentTag && value === true) {\n      value = '';\n    }\n  } // If the prop isn't in the special list, treat it as a simple attribute.\n\n\n  if (isCustomComponentTag || propertyInfo === null) {\n    if (isAttributeNameSafe(name)) {\n      const attributeName = name;\n\n      if (value === null) {\n        node.removeAttribute(attributeName);\n      } else {\n        if (__DEV__) {\n          checkAttributeStringCoercion(value, name);\n        }\n\n        node.setAttribute(attributeName, enableTrustedTypesIntegration ? value : '' + value);\n      }\n    }\n\n    return;\n  }\n\n  const {\n    mustUseProperty\n  } = propertyInfo;\n\n  if (mustUseProperty) {\n    const {\n      propertyName\n    } = propertyInfo;\n\n    if (value === null) {\n      const {\n        type\n      } = propertyInfo;\n      node[propertyName] = type === BOOLEAN ? false : '';\n    } else {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      node[propertyName] = value;\n    }\n\n    return;\n  } // The rest are treated as attributes with special cases.\n\n\n  const {\n    attributeName,\n    attributeNamespace\n  } = propertyInfo;\n\n  if (value === null) {\n    node.removeAttribute(attributeName);\n  } else {\n    const {\n      type\n    } = propertyInfo;\n    let attributeValue;\n\n    if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {\n      // If attribute type is boolean, we know for sure it won't be an execution sink\n      // and we won't require Trusted Type here.\n      attributeValue = '';\n    } else {\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      if (enableTrustedTypesIntegration) {\n        attributeValue = value;\n      } else {\n        if (__DEV__) {\n          checkAttributeStringCoercion(value, attributeName);\n        }\n\n        attributeValue = '' + value;\n      }\n\n      if (propertyInfo.sanitizeURL) {\n        sanitizeURL(attributeValue.toString());\n      }\n    }\n\n    if (attributeNamespace) {\n      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\n    } else {\n      node.setAttribute(attributeName, attributeValue);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-dom-bindings/src/client/DOMPropertyOperations.js"],"names":["getPropertyInfo","shouldIgnoreAttribute","shouldRemoveAttribute","isAttributeNameSafe","BOOLEAN","OVERLOADED_BOOLEAN","sanitizeURL","disableJavaScriptURLs","enableTrustedTypesIntegration","enableCustomElementPropertySupport","checkAttributeStringCoercion","getFiberCurrentPropsFromNode","getValueForProperty","node","name","expected","propertyInfo","__DEV__","mustUseProperty","propertyName","attributeName","stringValue","type","hasAttribute","value","getAttribute","getValueForAttribute","isCustomComponentTag","undefined","setValueForProperty","eventName","replace","useCapture","slice","prevProps","prevValue","removeEventListener","removeAttribute","addEventListener","setAttribute","attributeNamespace","attributeValue","toString","setAttributeNS"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {\n  getPropertyInfo,\n  shouldIgnoreAttribute,\n  shouldRemoveAttribute,\n  isAttributeNameSafe,\n  BOOLEAN,\n  OVERLOADED_BOOLEAN,\n} from '../shared/DOMProperty';\nimport sanitizeURL from '../shared/sanitizeURL';\nimport {\n  disableJavaScriptURLs,\n  enableTrustedTypesIntegration,\n  enableCustomElementPropertySupport,\n} from 'shared/ReactFeatureFlags';\nimport {checkAttributeStringCoercion} from 'shared/CheckStringCoercion';\nimport {getFiberCurrentPropsFromNode} from './ReactDOMComponentTree';\n\nimport type {PropertyInfo} from '../shared/DOMProperty';\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nexport function getValueForProperty(\n  node: Element,\n  name: string,\n  expected: mixed,\n  propertyInfo: PropertyInfo,\n): mixed {\n  if (__DEV__) {\n    if (propertyInfo.mustUseProperty) {\n      const {propertyName} = propertyInfo;\n      return (node: any)[propertyName];\n    } else {\n      // This check protects multiple uses of `expected`, which is why the\n      // react-internal/safe-string-coercion rule is disabled in several spots\n      // below.\n      if (__DEV__) {\n        checkAttributeStringCoercion(expected, name);\n      }\n\n      if (!disableJavaScriptURLs && propertyInfo.sanitizeURL) {\n        // If we haven't fully disabled javascript: URLs, and if\n        // the hydration is successful of a javascript: URL, we\n        // still want to warn on the client.\n        // eslint-disable-next-line react-internal/safe-string-coercion\n        sanitizeURL('' + (expected: any));\n      }\n\n      const attributeName = propertyInfo.attributeName;\n\n      let stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          const value = node.getAttribute(attributeName);\n          if (value === '') {\n            return true;\n          }\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          }\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          if (value === '' + (expected: any)) {\n            return expected;\n          }\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        }\n        // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue;\n        // eslint-disable-next-line react-internal/safe-string-coercion\n      } else if (stringValue === '' + (expected: any)) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}\n\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\nexport function getValueForAttribute(\n  node: Element,\n  name: string,\n  expected: mixed,\n  isCustomComponentTag: boolean,\n): mixed {\n  if (__DEV__) {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n    const value = node.getAttribute(name);\n\n    if (enableCustomElementPropertySupport) {\n      if (isCustomComponentTag && value === '') {\n        return true;\n      }\n    }\n\n    if (__DEV__) {\n      checkAttributeStringCoercion(expected, name);\n    }\n    if (value === '' + (expected: any)) {\n      return expected;\n    }\n    return value;\n  }\n}\n\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\nexport function setValueForProperty(\n  node: Element,\n  name: string,\n  value: mixed,\n  isCustomComponentTag: boolean,\n) {\n  const propertyInfo = getPropertyInfo(name);\n  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n    return;\n  }\n\n  if (\n    enableCustomElementPropertySupport &&\n    isCustomComponentTag &&\n    name[0] === 'o' &&\n    name[1] === 'n'\n  ) {\n    let eventName = name.replace(/Capture$/, '');\n    const useCapture = name !== eventName;\n    eventName = eventName.slice(2);\n\n    const prevProps = getFiberCurrentPropsFromNode(node);\n    const prevValue = prevProps != null ? prevProps[name] : null;\n    if (typeof prevValue === 'function') {\n      node.removeEventListener(eventName, prevValue, useCapture);\n    }\n    if (typeof value === 'function') {\n      if (typeof prevValue !== 'function' && prevValue !== null) {\n        // If we previously assigned a non-function type into this node, then\n        // remove it when switching to event listener mode.\n        if (name in (node: any)) {\n          (node: any)[name] = null;\n        } else if (node.hasAttribute(name)) {\n          node.removeAttribute(name);\n        }\n      }\n\n      // $FlowFixMe value can't be casted to EventListener.\n      node.addEventListener(eventName, (value: EventListener), useCapture);\n      return;\n    }\n  }\n\n  if (\n    enableCustomElementPropertySupport &&\n    isCustomComponentTag &&\n    name in (node: any)\n  ) {\n    (node: any)[name] = value;\n    return;\n  }\n\n  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n    value = null;\n  }\n  if (enableCustomElementPropertySupport) {\n    if (isCustomComponentTag && value === true) {\n      value = '';\n    }\n  }\n\n  // If the prop isn't in the special list, treat it as a simple attribute.\n  if (isCustomComponentTag || propertyInfo === null) {\n    if (isAttributeNameSafe(name)) {\n      const attributeName = name;\n      if (value === null) {\n        node.removeAttribute(attributeName);\n      } else {\n        if (__DEV__) {\n          checkAttributeStringCoercion(value, name);\n        }\n        node.setAttribute(\n          attributeName,\n          enableTrustedTypesIntegration ? (value: any) : '' + (value: any),\n        );\n      }\n    }\n    return;\n  }\n  const {mustUseProperty} = propertyInfo;\n  if (mustUseProperty) {\n    const {propertyName} = propertyInfo;\n    if (value === null) {\n      const {type} = propertyInfo;\n      (node: any)[propertyName] = type === BOOLEAN ? false : '';\n    } else {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      (node: any)[propertyName] = value;\n    }\n    return;\n  }\n  // The rest are treated as attributes with special cases.\n  const {attributeName, attributeNamespace} = propertyInfo;\n  if (value === null) {\n    node.removeAttribute(attributeName);\n  } else {\n    const {type} = propertyInfo;\n    let attributeValue;\n    if (type === BOOLEAN || (type === OVERLOADED_BOOLEAN && value === true)) {\n      // If attribute type is boolean, we know for sure it won't be an execution sink\n      // and we won't require Trusted Type here.\n      attributeValue = '';\n    } else {\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      if (enableTrustedTypesIntegration) {\n        attributeValue = (value: any);\n      } else {\n        if (__DEV__) {\n          checkAttributeStringCoercion(value, attributeName);\n        }\n        attributeValue = '' + (value: any);\n      }\n      if (propertyInfo.sanitizeURL) {\n        sanitizeURL(attributeValue.toString());\n      }\n    }\n    if (attributeNamespace) {\n      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\n    } else {\n      node.setAttribute(attributeName, attributeValue);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}