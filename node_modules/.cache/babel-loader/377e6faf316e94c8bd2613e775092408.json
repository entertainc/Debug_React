{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { createCursor, push, pop } from './ReactFiberStack';\nimport { getWorkInProgressTransitions } from './ReactFiberWorkLoop';\nexport const TransitionRoot = 0;\nexport const TransitionTracingMarker = 1;\nexport function processTransitionCallbacks(pendingTransitions, endTime, callbacks) {\n  if (enableTransitionTracing) {\n    if (pendingTransitions !== null) {\n      const transitionStart = pendingTransitions.transitionStart;\n      const onTransitionStart = callbacks.onTransitionStart;\n\n      if (transitionStart !== null && onTransitionStart != null) {\n        transitionStart.forEach(transition => onTransitionStart(transition.name, transition.startTime));\n      }\n\n      const markerProgress = pendingTransitions.markerProgress;\n      const onMarkerProgress = callbacks.onMarkerProgress;\n\n      if (onMarkerProgress != null && markerProgress !== null) {\n        markerProgress.forEach((markerInstance, markerName) => {\n          if (markerInstance.transitions !== null) {\n            // TODO: Clone the suspense object so users can't modify it\n            const pending = markerInstance.pendingBoundaries !== null ? Array.from(markerInstance.pendingBoundaries.values()) : [];\n            markerInstance.transitions.forEach(transition => {\n              onMarkerProgress(transition.name, markerName, transition.startTime, endTime, pending);\n            });\n          }\n        });\n      }\n\n      const markerComplete = pendingTransitions.markerComplete;\n      const onMarkerComplete = callbacks.onMarkerComplete;\n\n      if (markerComplete !== null && onMarkerComplete != null) {\n        markerComplete.forEach((transitions, markerName) => {\n          transitions.forEach(transition => {\n            onMarkerComplete(transition.name, markerName, transition.startTime, endTime);\n          });\n        });\n      }\n\n      const markerIncomplete = pendingTransitions.markerIncomplete;\n      const onMarkerIncomplete = callbacks.onMarkerIncomplete;\n\n      if (onMarkerIncomplete != null && markerIncomplete !== null) {\n        markerIncomplete.forEach(({\n          transitions,\n          aborts\n        }, markerName) => {\n          transitions.forEach(transition => {\n            const filteredAborts = [];\n            aborts.forEach(abort => {\n              switch (abort.reason) {\n                case 'marker':\n                  {\n                    filteredAborts.push({\n                      type: 'marker',\n                      name: abort.name,\n                      endTime\n                    });\n                    break;\n                  }\n\n                case 'suspense':\n                  {\n                    filteredAborts.push({\n                      type: 'suspense',\n                      name: abort.name,\n                      endTime\n                    });\n                    break;\n                  }\n\n                default:\n                  {\n                    break;\n                  }\n              }\n            });\n\n            if (filteredAborts.length > 0) {\n              onMarkerIncomplete(transition.name, markerName, transition.startTime, filteredAborts);\n            }\n          });\n        });\n      }\n\n      const transitionProgress = pendingTransitions.transitionProgress;\n      const onTransitionProgress = callbacks.onTransitionProgress;\n\n      if (onTransitionProgress != null && transitionProgress !== null) {\n        transitionProgress.forEach((pending, transition) => {\n          onTransitionProgress(transition.name, transition.startTime, endTime, Array.from(pending.values()));\n        });\n      }\n\n      const transitionComplete = pendingTransitions.transitionComplete;\n      const onTransitionComplete = callbacks.onTransitionComplete;\n\n      if (transitionComplete !== null && onTransitionComplete != null) {\n        transitionComplete.forEach(transition => onTransitionComplete(transition.name, transition.startTime, endTime));\n      }\n    }\n  }\n} // For every tracing marker, store a pointer to it. We will later access it\n// to get the set of suspense boundaries that need to resolve before the\n// tracing marker can be logged as complete\n// This code lives separate from the ReactFiberTransition code because\n// we push and pop on the tracing marker, not the suspense boundary\n\nconst markerInstanceStack = createCursor(null);\nexport function pushRootMarkerInstance(workInProgress) {\n  if (enableTransitionTracing) {\n    // On the root, every transition gets mapped to it's own map of\n    // suspense boundaries. The transition is marked as complete when\n    // the suspense boundaries map is empty. We do this because every\n    // transition completes at different times and depends on different\n    // suspense boundaries to complete. We store all the transitions\n    // along with its map of suspense boundaries in the root incomplete\n    // transitions map. Each entry in this map functions like a tracing\n    // marker does, so we can push it onto the marker instance stack\n    const transitions = getWorkInProgressTransitions();\n    const root = workInProgress.stateNode;\n\n    if (transitions !== null) {\n      transitions.forEach(transition => {\n        if (!root.incompleteTransitions.has(transition)) {\n          const markerInstance = {\n            tag: TransitionRoot,\n            transitions: new Set([transition]),\n            pendingBoundaries: null,\n            aborts: null,\n            name: null\n          };\n          root.incompleteTransitions.set(transition, markerInstance);\n        }\n      });\n    }\n\n    const markerInstances = []; // For ever transition on the suspense boundary, we push the transition\n    // along with its map of pending suspense boundaries onto the marker\n    // instance stack.\n\n    root.incompleteTransitions.forEach(markerInstance => {\n      markerInstances.push(markerInstance);\n    });\n    push(markerInstanceStack, markerInstances, workInProgress);\n  }\n}\nexport function popRootMarkerInstance(workInProgress) {\n  if (enableTransitionTracing) {\n    pop(markerInstanceStack, workInProgress);\n  }\n}\nexport function pushMarkerInstance(workInProgress, markerInstance) {\n  if (enableTransitionTracing) {\n    if (markerInstanceStack.current === null) {\n      push(markerInstanceStack, [markerInstance], workInProgress);\n    } else {\n      push(markerInstanceStack, markerInstanceStack.current.concat(markerInstance), workInProgress);\n    }\n  }\n}\nexport function popMarkerInstance(workInProgress) {\n  if (enableTransitionTracing) {\n    pop(markerInstanceStack, workInProgress);\n  }\n}\nexport function getMarkerInstances() {\n  if (enableTransitionTracing) {\n    return markerInstanceStack.current;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberTracingMarkerComponent.js"],"names":["enableTransitionTracing","createCursor","push","pop","getWorkInProgressTransitions","TransitionRoot","TransitionTracingMarker","processTransitionCallbacks","pendingTransitions","endTime","callbacks","transitionStart","onTransitionStart","forEach","transition","name","startTime","markerProgress","onMarkerProgress","markerInstance","markerName","transitions","pending","pendingBoundaries","Array","from","values","markerComplete","onMarkerComplete","markerIncomplete","onMarkerIncomplete","aborts","filteredAborts","abort","reason","type","length","transitionProgress","onTransitionProgress","transitionComplete","onTransitionComplete","markerInstanceStack","pushRootMarkerInstance","workInProgress","root","stateNode","incompleteTransitions","has","tag","Set","set","markerInstances","popRootMarkerInstance","pushMarkerInstance","current","concat","popMarkerInstance","getMarkerInstances"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  TransitionTracingCallbacks,\n  Fiber,\n  FiberRoot,\n} from './ReactInternalTypes';\nimport type {OffscreenInstance} from './ReactFiberOffscreenComponent';\nimport type {StackCursor} from './ReactFiberStack';\n\nimport {enableTransitionTracing} from 'shared/ReactFeatureFlags';\nimport {createCursor, push, pop} from './ReactFiberStack';\nimport {getWorkInProgressTransitions} from './ReactFiberWorkLoop';\n\nexport type SuspenseInfo = {name: string | null};\n\nexport type PendingTransitionCallbacks = {\n  transitionStart: Array<Transition> | null,\n  transitionProgress: Map<Transition, PendingBoundaries> | null,\n  transitionComplete: Array<Transition> | null,\n  markerProgress: Map<\n    string,\n    {pendingBoundaries: PendingBoundaries, transitions: Set<Transition>},\n  > | null,\n  markerIncomplete: Map<\n    string,\n    {aborts: Array<TransitionAbort>, transitions: Set<Transition>},\n  > | null,\n  markerComplete: Map<string, Set<Transition>> | null,\n};\n\nexport type Transition = {\n  name: string,\n  startTime: number,\n};\n\nexport type BatchConfigTransition = {\n  name?: string,\n  startTime?: number,\n  _updatedFibers?: Set<Fiber>,\n};\n\n// TODO: Is there a way to not include the tag or name here?\nexport type TracingMarkerInstance = {\n  tag?: TracingMarkerTag,\n  transitions: Set<Transition> | null,\n  pendingBoundaries: PendingBoundaries | null,\n  aborts: Array<TransitionAbort> | null,\n  name: string | null,\n};\n\nexport type TransitionAbort = {\n  reason: 'error' | 'unknown' | 'marker' | 'suspense',\n  name?: string | null,\n};\n\nexport const TransitionRoot = 0;\nexport const TransitionTracingMarker = 1;\nexport type TracingMarkerTag = 0 | 1;\n\nexport type PendingBoundaries = Map<OffscreenInstance, SuspenseInfo>;\n\nexport function processTransitionCallbacks(\n  pendingTransitions: PendingTransitionCallbacks,\n  endTime: number,\n  callbacks: TransitionTracingCallbacks,\n): void {\n  if (enableTransitionTracing) {\n    if (pendingTransitions !== null) {\n      const transitionStart = pendingTransitions.transitionStart;\n      const onTransitionStart = callbacks.onTransitionStart;\n      if (transitionStart !== null && onTransitionStart != null) {\n        transitionStart.forEach(transition =>\n          onTransitionStart(transition.name, transition.startTime),\n        );\n      }\n\n      const markerProgress = pendingTransitions.markerProgress;\n      const onMarkerProgress = callbacks.onMarkerProgress;\n      if (onMarkerProgress != null && markerProgress !== null) {\n        markerProgress.forEach((markerInstance, markerName) => {\n          if (markerInstance.transitions !== null) {\n            // TODO: Clone the suspense object so users can't modify it\n            const pending =\n              markerInstance.pendingBoundaries !== null\n                ? Array.from(markerInstance.pendingBoundaries.values())\n                : [];\n            markerInstance.transitions.forEach(transition => {\n              onMarkerProgress(\n                transition.name,\n                markerName,\n                transition.startTime,\n                endTime,\n                pending,\n              );\n            });\n          }\n        });\n      }\n\n      const markerComplete = pendingTransitions.markerComplete;\n      const onMarkerComplete = callbacks.onMarkerComplete;\n      if (markerComplete !== null && onMarkerComplete != null) {\n        markerComplete.forEach((transitions, markerName) => {\n          transitions.forEach(transition => {\n            onMarkerComplete(\n              transition.name,\n              markerName,\n              transition.startTime,\n              endTime,\n            );\n          });\n        });\n      }\n\n      const markerIncomplete = pendingTransitions.markerIncomplete;\n      const onMarkerIncomplete = callbacks.onMarkerIncomplete;\n      if (onMarkerIncomplete != null && markerIncomplete !== null) {\n        markerIncomplete.forEach(({transitions, aborts}, markerName) => {\n          transitions.forEach(transition => {\n            const filteredAborts = [];\n            aborts.forEach(abort => {\n              switch (abort.reason) {\n                case 'marker': {\n                  filteredAborts.push({\n                    type: 'marker',\n                    name: abort.name,\n                    endTime,\n                  });\n                  break;\n                }\n                case 'suspense': {\n                  filteredAborts.push({\n                    type: 'suspense',\n                    name: abort.name,\n                    endTime,\n                  });\n                  break;\n                }\n                default: {\n                  break;\n                }\n              }\n            });\n\n            if (filteredAborts.length > 0) {\n              onMarkerIncomplete(\n                transition.name,\n                markerName,\n                transition.startTime,\n                filteredAborts,\n              );\n            }\n          });\n        });\n      }\n\n      const transitionProgress = pendingTransitions.transitionProgress;\n      const onTransitionProgress = callbacks.onTransitionProgress;\n      if (onTransitionProgress != null && transitionProgress !== null) {\n        transitionProgress.forEach((pending, transition) => {\n          onTransitionProgress(\n            transition.name,\n            transition.startTime,\n            endTime,\n            Array.from(pending.values()),\n          );\n        });\n      }\n\n      const transitionComplete = pendingTransitions.transitionComplete;\n      const onTransitionComplete = callbacks.onTransitionComplete;\n      if (transitionComplete !== null && onTransitionComplete != null) {\n        transitionComplete.forEach(transition =>\n          onTransitionComplete(transition.name, transition.startTime, endTime),\n        );\n      }\n    }\n  }\n}\n\n// For every tracing marker, store a pointer to it. We will later access it\n// to get the set of suspense boundaries that need to resolve before the\n// tracing marker can be logged as complete\n// This code lives separate from the ReactFiberTransition code because\n// we push and pop on the tracing marker, not the suspense boundary\nconst markerInstanceStack: StackCursor<Array<TracingMarkerInstance> | null> = createCursor(\n  null,\n);\n\nexport function pushRootMarkerInstance(workInProgress: Fiber): void {\n  if (enableTransitionTracing) {\n    // On the root, every transition gets mapped to it's own map of\n    // suspense boundaries. The transition is marked as complete when\n    // the suspense boundaries map is empty. We do this because every\n    // transition completes at different times and depends on different\n    // suspense boundaries to complete. We store all the transitions\n    // along with its map of suspense boundaries in the root incomplete\n    // transitions map. Each entry in this map functions like a tracing\n    // marker does, so we can push it onto the marker instance stack\n    const transitions = getWorkInProgressTransitions();\n    const root: FiberRoot = workInProgress.stateNode;\n\n    if (transitions !== null) {\n      transitions.forEach(transition => {\n        if (!root.incompleteTransitions.has(transition)) {\n          const markerInstance: TracingMarkerInstance = {\n            tag: TransitionRoot,\n            transitions: new Set([transition]),\n            pendingBoundaries: null,\n            aborts: null,\n            name: null,\n          };\n          root.incompleteTransitions.set(transition, markerInstance);\n        }\n      });\n    }\n\n    const markerInstances = [];\n    // For ever transition on the suspense boundary, we push the transition\n    // along with its map of pending suspense boundaries onto the marker\n    // instance stack.\n    root.incompleteTransitions.forEach(markerInstance => {\n      markerInstances.push(markerInstance);\n    });\n    push(markerInstanceStack, markerInstances, workInProgress);\n  }\n}\n\nexport function popRootMarkerInstance(workInProgress: Fiber) {\n  if (enableTransitionTracing) {\n    pop(markerInstanceStack, workInProgress);\n  }\n}\n\nexport function pushMarkerInstance(\n  workInProgress: Fiber,\n  markerInstance: TracingMarkerInstance,\n): void {\n  if (enableTransitionTracing) {\n    if (markerInstanceStack.current === null) {\n      push(markerInstanceStack, [markerInstance], workInProgress);\n    } else {\n      push(\n        markerInstanceStack,\n        markerInstanceStack.current.concat(markerInstance),\n        workInProgress,\n      );\n    }\n  }\n}\n\nexport function popMarkerInstance(workInProgress: Fiber): void {\n  if (enableTransitionTracing) {\n    pop(markerInstanceStack, workInProgress);\n  }\n}\n\nexport function getMarkerInstances(): Array<TracingMarkerInstance> | null {\n  if (enableTransitionTracing) {\n    return markerInstanceStack.current;\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}