{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay } from 'shared/ReactFeatureFlags';\nimport { isDiscreteEventThatRequiresHydration, queueDiscreteEvent, hasQueuedDiscreteEvents, clearIfContinuousEvent, queueIfContinuousEvent, attemptSynchronousHydration } from './ReactDOMEventReplaying';\nimport { getNearestMountedFiber, getContainerFromFiber, getSuspenseInstanceFromFiber } from 'react-reconciler/src/ReactFiberTreeReflection';\nimport { HostRoot, SuspenseComponent } from 'react-reconciler/src/ReactWorkTags';\nimport { IS_CAPTURE_PHASE } from './EventSystemFlags';\nimport getEventTarget from './getEventTarget';\nimport { getInstanceFromNode, getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { dispatchEventForPluginEventSystem } from './DOMPluginEventSystem';\nimport { getCurrentPriorityLevel as getCurrentSchedulerPriorityLevel, IdlePriority as IdleSchedulerPriority, ImmediatePriority as ImmediateSchedulerPriority, LowPriority as LowSchedulerPriority, NormalPriority as NormalSchedulerPriority, UserBlockingPriority as UserBlockingSchedulerPriority } from 'react-reconciler/src/Scheduler';\nimport { DiscreteEventPriority, ContinuousEventPriority, DefaultEventPriority, IdleEventPriority, getCurrentUpdatePriority, setCurrentUpdatePriority } from 'react-reconciler/src/ReactEventPriorities';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport { isRootDehydrated } from 'react-reconciler/src/ReactFiberShellHydration';\nconst {\n  ReactCurrentBatchConfig\n} = ReactSharedInternals; // TODO: can we stop exporting these?\n\nexport let _enabled = true; // This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\n\nexport function setEnabled(enabled) {\n  _enabled = !!enabled;\n}\nexport function isEnabled() {\n  return _enabled;\n}\nexport function createEventListenerWrapper(targetContainer, domEventName, eventSystemFlags) {\n  return dispatchEvent.bind(null, domEventName, eventSystemFlags, targetContainer);\n}\nexport function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {\n  const eventPriority = getEventPriority(domEventName);\n  let listenerWrapper;\n\n  switch (eventPriority) {\n    case DiscreteEventPriority:\n      listenerWrapper = dispatchDiscreteEvent;\n      break;\n\n    case ContinuousEventPriority:\n      listenerWrapper = dispatchContinuousEvent;\n      break;\n\n    case DefaultEventPriority:\n    default:\n      listenerWrapper = dispatchEvent;\n      break;\n  }\n\n  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);\n}\n\nfunction dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = null;\n\n  try {\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nfunction dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = null;\n\n  try {\n    setCurrentUpdatePriority(ContinuousEventPriority);\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nexport function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n  } else {\n    dispatchEventOriginal(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n  }\n}\n\nfunction dispatchEventOriginal(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  // TODO: replaying capture phase events is currently broken\n  // because we used to do it during top-level native bubble handlers\n  // but now we use different bubble and capture handlers.\n  // In eager mode, we attach capture listeners early, so we need\n  // to filter them out until we fix the logic to handle them correctly.\n  const allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;\n\n  if (allowReplay && hasQueuedDiscreteEvents() && isDiscreteEventThatRequiresHydration(domEventName)) {\n    // If we already have a queue of discrete events, and this is another discrete\n    // event, then we can't dispatch it regardless of its target, since they\n    // need to dispatch in order.\n    queueDiscreteEvent(null, // Flags that we're not actually blocked on anything as far as we know.\n    domEventName, eventSystemFlags, targetContainer, nativeEvent);\n    return;\n  }\n\n  const blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n  if (blockedOn === null) {\n    dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n\n    if (allowReplay) {\n      clearIfContinuousEvent(domEventName, nativeEvent);\n    }\n\n    return;\n  }\n\n  if (allowReplay) {\n    if (isDiscreteEventThatRequiresHydration(domEventName)) {\n      // This to be replayed later once the target is available.\n      queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n      return;\n    }\n\n    if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {\n      return;\n    } // We need to clear only if we didn't queue because\n    // queueing is accumulative.\n\n\n    clearIfContinuousEvent(domEventName, nativeEvent);\n  } // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n\n\n  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\n}\n\nfunction dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  let blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n  if (blockedOn === null) {\n    dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n    clearIfContinuousEvent(domEventName, nativeEvent);\n    return;\n  }\n\n  if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {\n    nativeEvent.stopPropagation();\n    return;\n  } // We need to clear only if we didn't queue because\n  // queueing is accumulative.\n\n\n  clearIfContinuousEvent(domEventName, nativeEvent);\n\n  if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {\n    while (blockedOn !== null) {\n      const fiber = getInstanceFromNode(blockedOn);\n\n      if (fiber !== null) {\n        attemptSynchronousHydration(fiber);\n      }\n\n      const nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n      if (nextBlockedOn === null) {\n        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n      }\n\n      if (nextBlockedOn === blockedOn) {\n        break;\n      }\n\n      blockedOn = nextBlockedOn;\n    }\n\n    if (blockedOn !== null) {\n      nativeEvent.stopPropagation();\n    }\n\n    return;\n  } // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n\n\n  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\n}\n\nexport let return_targetInst = null; // Returns a SuspenseInstance or Container if it's blocked.\n// The return_targetInst field above is conceptually part of the return value.\n\nexport function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  // TODO: Warn if _enabled is false.\n  return_targetInst = null;\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    const nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted === null) {\n      // This tree has been unmounted already. Dispatch without a target.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\n\n        if (instance !== null) {\n          // Queue the event to be replayed later. Abort dispatching since we\n          // don't want this event dispatched twice through the event system.\n          // TODO: If this is the first discrete event in the queue. Schedule an increased\n          // priority for this boundary.\n          return instance;\n        } // This shouldn't happen, something went wrong but to avoid blocking\n        // the whole system, dispatch the event without a target.\n        // TODO: Warn.\n\n\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        const root = nearestMounted.stateNode;\n\n        if (isRootDehydrated(root)) {\n          // If this happens during a replay something went wrong and it might block\n          // the whole system.\n          return getContainerFromFiber(nearestMounted);\n        }\n\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n\n  return_targetInst = targetInst; // We're not blocked on anything.\n\n  return null;\n}\nexport function getEventPriority(domEventName) {\n  switch (domEventName) {\n    // Used by SimpleEventPlugin:\n    case 'cancel':\n    case 'click':\n    case 'close':\n    case 'contextmenu':\n    case 'copy':\n    case 'cut':\n    case 'auxclick':\n    case 'dblclick':\n    case 'dragend':\n    case 'dragstart':\n    case 'drop':\n    case 'focusin':\n    case 'focusout':\n    case 'input':\n    case 'invalid':\n    case 'keydown':\n    case 'keypress':\n    case 'keyup':\n    case 'mousedown':\n    case 'mouseup':\n    case 'paste':\n    case 'pause':\n    case 'play':\n    case 'pointercancel':\n    case 'pointerdown':\n    case 'pointerup':\n    case 'ratechange':\n    case 'reset':\n    case 'resize':\n    case 'seeked':\n    case 'submit':\n    case 'touchcancel':\n    case 'touchend':\n    case 'touchstart':\n    case 'volumechange': // Used by polyfills:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'change':\n    case 'selectionchange':\n    case 'textInput':\n    case 'compositionstart':\n    case 'compositionend':\n    case 'compositionupdate': // Only enableCreateEventHandleAPI:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'beforeblur':\n    case 'afterblur': // Not used by React but could be by user code:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'beforeinput':\n    case 'blur':\n    case 'fullscreenchange':\n    case 'focus':\n    case 'hashchange':\n    case 'popstate':\n    case 'select':\n    case 'selectstart':\n      return DiscreteEventPriority;\n\n    case 'drag':\n    case 'dragenter':\n    case 'dragexit':\n    case 'dragleave':\n    case 'dragover':\n    case 'mousemove':\n    case 'mouseout':\n    case 'mouseover':\n    case 'pointermove':\n    case 'pointerout':\n    case 'pointerover':\n    case 'scroll':\n    case 'toggle':\n    case 'touchmove':\n    case 'wheel': // Not used by React but could be by user code:\n    // eslint-disable-next-line no-fallthrough\n\n    case 'mouseenter':\n    case 'mouseleave':\n    case 'pointerenter':\n    case 'pointerleave':\n      return ContinuousEventPriority;\n\n    case 'message':\n      {\n        // We might be in the Scheduler callback.\n        // Eventually this mechanism will be replaced by a check\n        // of the current priority on the native scheduler.\n        const schedulerPriority = getCurrentSchedulerPriorityLevel();\n\n        switch (schedulerPriority) {\n          case ImmediateSchedulerPriority:\n            return DiscreteEventPriority;\n\n          case UserBlockingSchedulerPriority:\n            return ContinuousEventPriority;\n\n          case NormalSchedulerPriority:\n          case LowSchedulerPriority:\n            // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\n            return DefaultEventPriority;\n\n          case IdleSchedulerPriority:\n            return IdleEventPriority;\n\n          default:\n            return DefaultEventPriority;\n        }\n      }\n\n    default:\n      return DefaultEventPriority;\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-dom-bindings/src/events/ReactDOMEventListener.js"],"names":["enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay","isDiscreteEventThatRequiresHydration","queueDiscreteEvent","hasQueuedDiscreteEvents","clearIfContinuousEvent","queueIfContinuousEvent","attemptSynchronousHydration","getNearestMountedFiber","getContainerFromFiber","getSuspenseInstanceFromFiber","HostRoot","SuspenseComponent","IS_CAPTURE_PHASE","getEventTarget","getInstanceFromNode","getClosestInstanceFromNode","dispatchEventForPluginEventSystem","getCurrentPriorityLevel","getCurrentSchedulerPriorityLevel","IdlePriority","IdleSchedulerPriority","ImmediatePriority","ImmediateSchedulerPriority","LowPriority","LowSchedulerPriority","NormalPriority","NormalSchedulerPriority","UserBlockingPriority","UserBlockingSchedulerPriority","DiscreteEventPriority","ContinuousEventPriority","DefaultEventPriority","IdleEventPriority","getCurrentUpdatePriority","setCurrentUpdatePriority","ReactSharedInternals","isRootDehydrated","ReactCurrentBatchConfig","_enabled","setEnabled","enabled","isEnabled","createEventListenerWrapper","targetContainer","domEventName","eventSystemFlags","dispatchEvent","bind","createEventListenerWrapperWithPriority","eventPriority","getEventPriority","listenerWrapper","dispatchDiscreteEvent","dispatchContinuousEvent","container","nativeEvent","previousPriority","prevTransition","transition","dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay","dispatchEventOriginal","allowReplay","blockedOn","findInstanceBlockingEvent","return_targetInst","stopPropagation","fiber","nextBlockedOn","nativeEventTarget","targetInst","nearestMounted","tag","instance","root","stateNode","schedulerPriority"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {EventPriority} from 'react-reconciler/src/ReactEventPriorities';\nimport type {AnyNativeEvent} from '../events/PluginModuleType';\nimport type {Fiber, FiberRoot} from 'react-reconciler/src/ReactInternalTypes';\nimport type {Container, SuspenseInstance} from '../client/ReactDOMHostConfig';\nimport type {DOMEventName} from '../events/DOMEventNames';\nimport {enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay} from 'shared/ReactFeatureFlags';\nimport {\n  isDiscreteEventThatRequiresHydration,\n  queueDiscreteEvent,\n  hasQueuedDiscreteEvents,\n  clearIfContinuousEvent,\n  queueIfContinuousEvent,\n  attemptSynchronousHydration,\n} from './ReactDOMEventReplaying';\nimport {\n  getNearestMountedFiber,\n  getContainerFromFiber,\n  getSuspenseInstanceFromFiber,\n} from 'react-reconciler/src/ReactFiberTreeReflection';\nimport {HostRoot, SuspenseComponent} from 'react-reconciler/src/ReactWorkTags';\nimport {type EventSystemFlags, IS_CAPTURE_PHASE} from './EventSystemFlags';\n\nimport getEventTarget from './getEventTarget';\nimport {\n  getInstanceFromNode,\n  getClosestInstanceFromNode,\n} from '../client/ReactDOMComponentTree';\n\nimport {dispatchEventForPluginEventSystem} from './DOMPluginEventSystem';\n\nimport {\n  getCurrentPriorityLevel as getCurrentSchedulerPriorityLevel,\n  IdlePriority as IdleSchedulerPriority,\n  ImmediatePriority as ImmediateSchedulerPriority,\n  LowPriority as LowSchedulerPriority,\n  NormalPriority as NormalSchedulerPriority,\n  UserBlockingPriority as UserBlockingSchedulerPriority,\n} from 'react-reconciler/src/Scheduler';\nimport {\n  DiscreteEventPriority,\n  ContinuousEventPriority,\n  DefaultEventPriority,\n  IdleEventPriority,\n  getCurrentUpdatePriority,\n  setCurrentUpdatePriority,\n} from 'react-reconciler/src/ReactEventPriorities';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {isRootDehydrated} from 'react-reconciler/src/ReactFiberShellHydration';\n\nconst {ReactCurrentBatchConfig} = ReactSharedInternals;\n\n// TODO: can we stop exporting these?\nexport let _enabled: boolean = true;\n\n// This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\nexport function setEnabled(enabled: ?boolean): void {\n  _enabled = !!enabled;\n}\n\nexport function isEnabled(): boolean {\n  return _enabled;\n}\n\nexport function createEventListenerWrapper(\n  targetContainer: EventTarget,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n): Function {\n  return dispatchEvent.bind(\n    null,\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n  );\n}\n\nexport function createEventListenerWrapperWithPriority(\n  targetContainer: EventTarget,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n): Function {\n  const eventPriority = getEventPriority(domEventName);\n  let listenerWrapper;\n  switch (eventPriority) {\n    case DiscreteEventPriority:\n      listenerWrapper = dispatchDiscreteEvent;\n      break;\n    case ContinuousEventPriority:\n      listenerWrapper = dispatchContinuousEvent;\n      break;\n    case DefaultEventPriority:\n    default:\n      listenerWrapper = dispatchEvent;\n      break;\n  }\n  return listenerWrapper.bind(\n    null,\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n  );\n}\n\nfunction dispatchDiscreteEvent(\n  domEventName,\n  eventSystemFlags,\n  container,\n  nativeEvent,\n) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = null;\n  try {\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nfunction dispatchContinuousEvent(\n  domEventName,\n  eventSystemFlags,\n  container,\n  nativeEvent,\n) {\n  const previousPriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = null;\n  try {\n    setCurrentUpdatePriority(ContinuousEventPriority);\n    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\nexport function dispatchEvent(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): void {\n  if (!_enabled) {\n    return;\n  }\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(\n      domEventName,\n      eventSystemFlags,\n      targetContainer,\n      nativeEvent,\n    );\n  } else {\n    dispatchEventOriginal(\n      domEventName,\n      eventSystemFlags,\n      targetContainer,\n      nativeEvent,\n    );\n  }\n}\n\nfunction dispatchEventOriginal(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n) {\n  // TODO: replaying capture phase events is currently broken\n  // because we used to do it during top-level native bubble handlers\n  // but now we use different bubble and capture handlers.\n  // In eager mode, we attach capture listeners early, so we need\n  // to filter them out until we fix the logic to handle them correctly.\n  const allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;\n\n  if (\n    allowReplay &&\n    hasQueuedDiscreteEvents() &&\n    isDiscreteEventThatRequiresHydration(domEventName)\n  ) {\n    // If we already have a queue of discrete events, and this is another discrete\n    // event, then we can't dispatch it regardless of its target, since they\n    // need to dispatch in order.\n    queueDiscreteEvent(\n      null, // Flags that we're not actually blocked on anything as far as we know.\n      domEventName,\n      eventSystemFlags,\n      targetContainer,\n      nativeEvent,\n    );\n    return;\n  }\n\n  const blockedOn = findInstanceBlockingEvent(\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n    nativeEvent,\n  );\n  if (blockedOn === null) {\n    dispatchEventForPluginEventSystem(\n      domEventName,\n      eventSystemFlags,\n      nativeEvent,\n      return_targetInst,\n      targetContainer,\n    );\n    if (allowReplay) {\n      clearIfContinuousEvent(domEventName, nativeEvent);\n    }\n    return;\n  }\n\n  if (allowReplay) {\n    if (isDiscreteEventThatRequiresHydration(domEventName)) {\n      // This to be replayed later once the target is available.\n      queueDiscreteEvent(\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent,\n      );\n      return;\n    }\n    if (\n      queueIfContinuousEvent(\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent,\n      )\n    ) {\n      return;\n    }\n    // We need to clear only if we didn't queue because\n    // queueing is accumulative.\n    clearIfContinuousEvent(domEventName, nativeEvent);\n  }\n\n  // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n  dispatchEventForPluginEventSystem(\n    domEventName,\n    eventSystemFlags,\n    nativeEvent,\n    null,\n    targetContainer,\n  );\n}\n\nfunction dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n) {\n  let blockedOn = findInstanceBlockingEvent(\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n    nativeEvent,\n  );\n  if (blockedOn === null) {\n    dispatchEventForPluginEventSystem(\n      domEventName,\n      eventSystemFlags,\n      nativeEvent,\n      return_targetInst,\n      targetContainer,\n    );\n    clearIfContinuousEvent(domEventName, nativeEvent);\n    return;\n  }\n\n  if (\n    queueIfContinuousEvent(\n      blockedOn,\n      domEventName,\n      eventSystemFlags,\n      targetContainer,\n      nativeEvent,\n    )\n  ) {\n    nativeEvent.stopPropagation();\n    return;\n  }\n  // We need to clear only if we didn't queue because\n  // queueing is accumulative.\n  clearIfContinuousEvent(domEventName, nativeEvent);\n\n  if (\n    eventSystemFlags & IS_CAPTURE_PHASE &&\n    isDiscreteEventThatRequiresHydration(domEventName)\n  ) {\n    while (blockedOn !== null) {\n      const fiber = getInstanceFromNode(blockedOn);\n      if (fiber !== null) {\n        attemptSynchronousHydration(fiber);\n      }\n      const nextBlockedOn = findInstanceBlockingEvent(\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent,\n      );\n      if (nextBlockedOn === null) {\n        dispatchEventForPluginEventSystem(\n          domEventName,\n          eventSystemFlags,\n          nativeEvent,\n          return_targetInst,\n          targetContainer,\n        );\n      }\n      if (nextBlockedOn === blockedOn) {\n        break;\n      }\n      blockedOn = nextBlockedOn;\n    }\n    if (blockedOn !== null) {\n      nativeEvent.stopPropagation();\n    }\n    return;\n  }\n\n  // This is not replayable so we'll invoke it but without a target,\n  // in case the event system needs to trace it.\n  dispatchEventForPluginEventSystem(\n    domEventName,\n    eventSystemFlags,\n    nativeEvent,\n    null,\n    targetContainer,\n  );\n}\n\nexport let return_targetInst: null | Fiber = null;\n\n// Returns a SuspenseInstance or Container if it's blocked.\n// The return_targetInst field above is conceptually part of the return value.\nexport function findInstanceBlockingEvent(\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): null | Container | SuspenseInstance {\n  // TODO: Warn if _enabled is false.\n\n  return_targetInst = null;\n\n  const nativeEventTarget = getEventTarget(nativeEvent);\n  let targetInst = getClosestInstanceFromNode(nativeEventTarget);\n\n  if (targetInst !== null) {\n    const nearestMounted = getNearestMountedFiber(targetInst);\n    if (nearestMounted === null) {\n      // This tree has been unmounted already. Dispatch without a target.\n      targetInst = null;\n    } else {\n      const tag = nearestMounted.tag;\n      if (tag === SuspenseComponent) {\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\n        if (instance !== null) {\n          // Queue the event to be replayed later. Abort dispatching since we\n          // don't want this event dispatched twice through the event system.\n          // TODO: If this is the first discrete event in the queue. Schedule an increased\n          // priority for this boundary.\n          return instance;\n        }\n        // This shouldn't happen, something went wrong but to avoid blocking\n        // the whole system, dispatch the event without a target.\n        // TODO: Warn.\n        targetInst = null;\n      } else if (tag === HostRoot) {\n        const root: FiberRoot = nearestMounted.stateNode;\n        if (isRootDehydrated(root)) {\n          // If this happens during a replay something went wrong and it might block\n          // the whole system.\n          return getContainerFromFiber(nearestMounted);\n        }\n        targetInst = null;\n      } else if (nearestMounted !== targetInst) {\n        // If we get an event (ex: img onload) before committing that\n        // component's mount, ignore it for now (that is, treat it as if it was an\n        // event on a non-React tree). We might also consider queueing events and\n        // dispatching them after the mount.\n        targetInst = null;\n      }\n    }\n  }\n  return_targetInst = targetInst;\n  // We're not blocked on anything.\n  return null;\n}\n\nexport function getEventPriority(domEventName: DOMEventName): EventPriority {\n  switch (domEventName) {\n    // Used by SimpleEventPlugin:\n    case 'cancel':\n    case 'click':\n    case 'close':\n    case 'contextmenu':\n    case 'copy':\n    case 'cut':\n    case 'auxclick':\n    case 'dblclick':\n    case 'dragend':\n    case 'dragstart':\n    case 'drop':\n    case 'focusin':\n    case 'focusout':\n    case 'input':\n    case 'invalid':\n    case 'keydown':\n    case 'keypress':\n    case 'keyup':\n    case 'mousedown':\n    case 'mouseup':\n    case 'paste':\n    case 'pause':\n    case 'play':\n    case 'pointercancel':\n    case 'pointerdown':\n    case 'pointerup':\n    case 'ratechange':\n    case 'reset':\n    case 'resize':\n    case 'seeked':\n    case 'submit':\n    case 'touchcancel':\n    case 'touchend':\n    case 'touchstart':\n    case 'volumechange':\n    // Used by polyfills:\n    // eslint-disable-next-line no-fallthrough\n    case 'change':\n    case 'selectionchange':\n    case 'textInput':\n    case 'compositionstart':\n    case 'compositionend':\n    case 'compositionupdate':\n    // Only enableCreateEventHandleAPI:\n    // eslint-disable-next-line no-fallthrough\n    case 'beforeblur':\n    case 'afterblur':\n    // Not used by React but could be by user code:\n    // eslint-disable-next-line no-fallthrough\n    case 'beforeinput':\n    case 'blur':\n    case 'fullscreenchange':\n    case 'focus':\n    case 'hashchange':\n    case 'popstate':\n    case 'select':\n    case 'selectstart':\n      return DiscreteEventPriority;\n    case 'drag':\n    case 'dragenter':\n    case 'dragexit':\n    case 'dragleave':\n    case 'dragover':\n    case 'mousemove':\n    case 'mouseout':\n    case 'mouseover':\n    case 'pointermove':\n    case 'pointerout':\n    case 'pointerover':\n    case 'scroll':\n    case 'toggle':\n    case 'touchmove':\n    case 'wheel':\n    // Not used by React but could be by user code:\n    // eslint-disable-next-line no-fallthrough\n    case 'mouseenter':\n    case 'mouseleave':\n    case 'pointerenter':\n    case 'pointerleave':\n      return ContinuousEventPriority;\n    case 'message': {\n      // We might be in the Scheduler callback.\n      // Eventually this mechanism will be replaced by a check\n      // of the current priority on the native scheduler.\n      const schedulerPriority = getCurrentSchedulerPriorityLevel();\n      switch (schedulerPriority) {\n        case ImmediateSchedulerPriority:\n          return DiscreteEventPriority;\n        case UserBlockingSchedulerPriority:\n          return ContinuousEventPriority;\n        case NormalSchedulerPriority:\n        case LowSchedulerPriority:\n          // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\n          return DefaultEventPriority;\n        case IdleSchedulerPriority:\n          return IdleEventPriority;\n        default:\n          return DefaultEventPriority;\n      }\n    }\n    default:\n      return DefaultEventPriority;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}