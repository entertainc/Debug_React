{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactCurrentCache from './ReactCurrentCache';\nconst UNTERMINATED = 0;\nconst TERMINATED = 1;\nconst ERRORED = 2;\n\nfunction createCacheRoot() {\n  return new WeakMap();\n}\n\nfunction createCacheNode() {\n  return {\n    s: UNTERMINATED,\n    // status, represents whether the cached computation returned a value or threw an error\n    v: undefined,\n    // value, either the cached result or an error, depending on s\n    o: null,\n    // object cache, a WeakMap where non-primitive arguments are stored\n    p: null // primitive cache, a regular Map where primitive arguments are stored.\n\n  };\n}\n\nexport function cache(fn) {\n  return function () {\n    const dispatcher = ReactCurrentCache.current;\n\n    if (!dispatcher) {\n      // If there is no dispatcher, then we treat this as not being cached.\n      // $FlowFixMe: We don't want to use rest arguments since we transpile the code.\n      return fn.apply(null, arguments);\n    }\n\n    const fnMap = dispatcher.getCacheForType(createCacheRoot);\n    const fnNode = fnMap.get(fn);\n    let cacheNode;\n\n    if (fnNode === undefined) {\n      cacheNode = createCacheNode();\n      fnMap.set(fn, cacheNode);\n    } else {\n      cacheNode = fnNode;\n    }\n\n    for (let i = 0, l = arguments.length; i < l; i++) {\n      const arg = arguments[i];\n\n      if (typeof arg === 'function' || typeof arg === 'object' && arg !== null) {\n        // Objects go into a WeakMap\n        let objectCache = cacheNode.o;\n\n        if (objectCache === null) {\n          cacheNode.o = objectCache = new WeakMap();\n        }\n\n        const objectNode = objectCache.get(arg);\n\n        if (objectNode === undefined) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        // Primitives go into a regular Map\n        let primitiveCache = cacheNode.p;\n\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = new Map();\n        }\n\n        const primitiveNode = primitiveCache.get(arg);\n\n        if (primitiveNode === undefined) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n\n    if (cacheNode.s === TERMINATED) {\n      return cacheNode.v;\n    }\n\n    if (cacheNode.s === ERRORED) {\n      throw cacheNode.v;\n    }\n\n    try {\n      // $FlowFixMe: We don't want to use rest arguments since we transpile the code.\n      const result = fn.apply(null, arguments);\n      const terminatedNode = cacheNode;\n      terminatedNode.s = TERMINATED;\n      terminatedNode.v = result;\n      return result;\n    } catch (error) {\n      // We store the first error that's thrown and rethrow it.\n      const erroredNode = cacheNode;\n      erroredNode.s = ERRORED;\n      erroredNode.v = error;\n      throw error;\n    }\n  };\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react/src/ReactCache.js"],"names":["ReactCurrentCache","UNTERMINATED","TERMINATED","ERRORED","createCacheRoot","WeakMap","createCacheNode","s","v","undefined","o","p","cache","fn","dispatcher","current","apply","arguments","fnMap","getCacheForType","fnNode","get","cacheNode","set","i","l","length","arg","objectCache","objectNode","primitiveCache","Map","primitiveNode","result","terminatedNode","error","erroredNode"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport ReactCurrentCache from './ReactCurrentCache';\n\nconst UNTERMINATED = 0;\nconst TERMINATED = 1;\nconst ERRORED = 2;\n\ntype UnterminatedCacheNode<T> = {\n  s: 0,\n  v: void,\n  o: null | WeakMap<Function | Object, CacheNode<T>>,\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>,\n};\n\ntype TerminatedCacheNode<T> = {\n  s: 1,\n  v: T,\n  o: null | WeakMap<Function | Object, CacheNode<T>>,\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>,\n};\n\ntype ErroredCacheNode<T> = {\n  s: 2,\n  v: mixed,\n  o: null | WeakMap<Function | Object, CacheNode<T>>,\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>,\n};\n\ntype CacheNode<T> =\n  | TerminatedCacheNode<T>\n  | UnterminatedCacheNode<T>\n  | ErroredCacheNode<T>;\n\nfunction createCacheRoot<T>(): WeakMap<Function | Object, CacheNode<T>> {\n  return new WeakMap();\n}\n\nfunction createCacheNode<T>(): CacheNode<T> {\n  return {\n    s: UNTERMINATED, // status, represents whether the cached computation returned a value or threw an error\n    v: undefined, // value, either the cached result or an error, depending on s\n    o: null, // object cache, a WeakMap where non-primitive arguments are stored\n    p: null, // primitive cache, a regular Map where primitive arguments are stored.\n  };\n}\n\nexport function cache<A: Iterable<mixed>, T>(fn: (...A) => T): (...A) => T {\n  return function() {\n    const dispatcher = ReactCurrentCache.current;\n    if (!dispatcher) {\n      // If there is no dispatcher, then we treat this as not being cached.\n      // $FlowFixMe: We don't want to use rest arguments since we transpile the code.\n      return fn.apply(null, arguments);\n    }\n    const fnMap = dispatcher.getCacheForType(createCacheRoot);\n    const fnNode = fnMap.get(fn);\n    let cacheNode: CacheNode<T>;\n    if (fnNode === undefined) {\n      cacheNode = createCacheNode();\n      fnMap.set(fn, cacheNode);\n    } else {\n      cacheNode = fnNode;\n    }\n    for (let i = 0, l = arguments.length; i < l; i++) {\n      const arg = arguments[i];\n      if (\n        typeof arg === 'function' ||\n        (typeof arg === 'object' && arg !== null)\n      ) {\n        // Objects go into a WeakMap\n        let objectCache = cacheNode.o;\n        if (objectCache === null) {\n          cacheNode.o = objectCache = new WeakMap();\n        }\n        const objectNode = objectCache.get(arg);\n        if (objectNode === undefined) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        // Primitives go into a regular Map\n        let primitiveCache = cacheNode.p;\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = new Map();\n        }\n        const primitiveNode = primitiveCache.get(arg);\n        if (primitiveNode === undefined) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n    if (cacheNode.s === TERMINATED) {\n      return cacheNode.v;\n    }\n    if (cacheNode.s === ERRORED) {\n      throw cacheNode.v;\n    }\n    try {\n      // $FlowFixMe: We don't want to use rest arguments since we transpile the code.\n      const result = fn.apply(null, arguments);\n      const terminatedNode: TerminatedCacheNode<T> = (cacheNode: any);\n      terminatedNode.s = TERMINATED;\n      terminatedNode.v = result;\n      return result;\n    } catch (error) {\n      // We store the first error that's thrown and rethrow it.\n      const erroredNode: ErroredCacheNode<T> = (cacheNode: any);\n      erroredNode.s = ERRORED;\n      erroredNode.v = error;\n      throw error;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}