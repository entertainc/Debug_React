{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableCache, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { isPrimaryRenderer } from './ReactFiberHostConfig';\nimport { createCursor, push, pop } from './ReactFiberStack';\nimport { getWorkInProgressRoot, getWorkInProgressTransitions } from './ReactFiberWorkLoop';\nimport { createCache, retainCache, CacheContext } from './ReactFiberCacheComponent';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nconst {\n  ReactCurrentBatchConfig\n} = ReactSharedInternals;\nexport const NoTransition = null;\nexport function requestCurrentTransition() {\n  return ReactCurrentBatchConfig.transition;\n} // When retrying a Suspense/Offscreen boundary, we restore the cache that was\n// used during the previous render by placing it here, on the stack.\n\nconst resumedCache = createCursor(null); // During the render/synchronous commit phase, we don't actually process the\n// transitions. Therefore, we want to lazily combine transitions. Instead of\n// comparing the arrays of transitions when we combine them and storing them\n// and filtering out the duplicates, we will instead store the unprocessed transitions\n// in an array and actually filter them in the passive phase.\n\nconst transitionStack = createCursor(null);\n\nfunction peekCacheFromPool() {\n  if (!enableCache) {\n    return null;\n  } // Check if the cache pool already has a cache we can use.\n  // If we're rendering inside a Suspense boundary that is currently hidden,\n  // we should use the same cache that we used during the previous render, if\n  // one exists.\n\n\n  const cacheResumedFromPreviousRender = resumedCache.current;\n\n  if (cacheResumedFromPreviousRender !== null) {\n    return cacheResumedFromPreviousRender;\n  } // Otherwise, check the root's cache pool.\n\n\n  const root = getWorkInProgressRoot();\n  const cacheFromRootCachePool = root.pooledCache;\n  return cacheFromRootCachePool;\n}\n\nexport function requestCacheFromPool(renderLanes) {\n  // Similar to previous function, except if there's not already a cache in the\n  // pool, we allocate a new one.\n  const cacheFromPool = peekCacheFromPool();\n\n  if (cacheFromPool !== null) {\n    return cacheFromPool;\n  } // Create a fresh cache and add it to the root cache pool. A cache can have\n  // multiple owners:\n  // - A cache pool that lives on the FiberRoot. This is where all fresh caches\n  //   are originally created (TODO: except during refreshes, until we implement\n  //   this correctly). The root takes ownership immediately when the cache is\n  //   created. Conceptually, root.pooledCache is an Option<Arc<Cache>> (owned),\n  //   and the return value of this function is a &Arc<Cache> (borrowed).\n  // - One of several fiber types: host root, cache boundary, suspense\n  //   component. These retain and release in the commit phase.\n\n\n  const root = getWorkInProgressRoot();\n  const freshCache = createCache();\n  root.pooledCache = freshCache;\n  retainCache(freshCache);\n\n  if (freshCache !== null) {\n    root.pooledCacheLanes |= renderLanes;\n  }\n\n  return freshCache;\n}\nexport function pushRootTransition(workInProgress, root, renderLanes) {\n  if (enableTransitionTracing) {\n    const rootTransitions = getWorkInProgressTransitions();\n    push(transitionStack, rootTransitions, workInProgress);\n  }\n}\nexport function popRootTransition(workInProgress, root, renderLanes) {\n  if (enableTransitionTracing) {\n    pop(transitionStack, workInProgress);\n  }\n}\nexport function pushTransition(offscreenWorkInProgress, prevCachePool, newTransitions) {\n  if (enableCache) {\n    if (prevCachePool === null) {\n      push(resumedCache, resumedCache.current, offscreenWorkInProgress);\n    } else {\n      push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n  }\n\n  if (enableTransitionTracing) {\n    if (transitionStack.current === null) {\n      push(transitionStack, newTransitions, offscreenWorkInProgress);\n    } else if (newTransitions === null) {\n      push(transitionStack, transitionStack.current, offscreenWorkInProgress);\n    } else {\n      push(transitionStack, transitionStack.current.concat(newTransitions), offscreenWorkInProgress);\n    }\n  }\n}\nexport function popTransition(workInProgress, current) {\n  if (current !== null) {\n    if (enableTransitionTracing) {\n      pop(transitionStack, workInProgress);\n    }\n\n    if (enableCache) {\n      pop(resumedCache, workInProgress);\n    }\n  }\n}\nexport function getPendingTransitions() {\n  if (!enableTransitionTracing) {\n    return null;\n  }\n\n  return transitionStack.current;\n}\nexport function getSuspendedCache() {\n  if (!enableCache) {\n    return null;\n  } // This function is called when a Suspense boundary suspends. It returns the\n  // cache that would have been used to render fresh data during this render,\n  // if there was any, so that we can resume rendering with the same cache when\n  // we receive more data.\n\n\n  const cacheFromPool = peekCacheFromPool();\n\n  if (cacheFromPool === null) {\n    return null;\n  }\n\n  return {\n    // We must also save the parent, so that when we resume we can detect\n    // a refresh.\n    parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n    pool: cacheFromPool\n  };\n}\nexport function getOffscreenDeferredCache() {\n  if (!enableCache) {\n    return null;\n  }\n\n  const cacheFromPool = peekCacheFromPool();\n\n  if (cacheFromPool === null) {\n    return null;\n  }\n\n  return {\n    // We must also store the parent, so that when we resume we can detect\n    // a refresh.\n    parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n    pool: cacheFromPool\n  };\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberTransition.js"],"names":["enableCache","enableTransitionTracing","isPrimaryRenderer","createCursor","push","pop","getWorkInProgressRoot","getWorkInProgressTransitions","createCache","retainCache","CacheContext","ReactSharedInternals","ReactCurrentBatchConfig","NoTransition","requestCurrentTransition","transition","resumedCache","transitionStack","peekCacheFromPool","cacheResumedFromPreviousRender","current","root","cacheFromRootCachePool","pooledCache","requestCacheFromPool","renderLanes","cacheFromPool","freshCache","pooledCacheLanes","pushRootTransition","workInProgress","rootTransitions","popRootTransition","pushTransition","offscreenWorkInProgress","prevCachePool","newTransitions","pool","concat","popTransition","getPendingTransitions","getSuspendedCache","parent","_currentValue","_currentValue2","getOffscreenDeferredCache"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport type {Fiber, FiberRoot} from './ReactInternalTypes';\nimport type {Lanes} from './ReactFiberLane';\nimport type {StackCursor} from './ReactFiberStack';\nimport type {Cache, SpawnedCachePool} from './ReactFiberCacheComponent';\nimport type {Transition} from './ReactFiberTracingMarkerComponent';\n\nimport {enableCache, enableTransitionTracing} from 'shared/ReactFeatureFlags';\nimport {isPrimaryRenderer} from './ReactFiberHostConfig';\nimport {createCursor, push, pop} from './ReactFiberStack';\nimport {\n  getWorkInProgressRoot,\n  getWorkInProgressTransitions,\n} from './ReactFiberWorkLoop';\nimport {\n  createCache,\n  retainCache,\n  CacheContext,\n} from './ReactFiberCacheComponent';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nconst {ReactCurrentBatchConfig} = ReactSharedInternals;\n\nexport const NoTransition = null;\n\nexport function requestCurrentTransition(): Transition | null {\n  return ReactCurrentBatchConfig.transition;\n}\n\n// When retrying a Suspense/Offscreen boundary, we restore the cache that was\n// used during the previous render by placing it here, on the stack.\nconst resumedCache: StackCursor<Cache | null> = createCursor(null);\n\n// During the render/synchronous commit phase, we don't actually process the\n// transitions. Therefore, we want to lazily combine transitions. Instead of\n// comparing the arrays of transitions when we combine them and storing them\n// and filtering out the duplicates, we will instead store the unprocessed transitions\n// in an array and actually filter them in the passive phase.\nconst transitionStack: StackCursor<Array<Transition> | null> = createCursor(\n  null,\n);\n\nfunction peekCacheFromPool(): Cache | null {\n  if (!enableCache) {\n    return (null: any);\n  }\n\n  // Check if the cache pool already has a cache we can use.\n\n  // If we're rendering inside a Suspense boundary that is currently hidden,\n  // we should use the same cache that we used during the previous render, if\n  // one exists.\n  const cacheResumedFromPreviousRender = resumedCache.current;\n  if (cacheResumedFromPreviousRender !== null) {\n    return cacheResumedFromPreviousRender;\n  }\n\n  // Otherwise, check the root's cache pool.\n  const root = (getWorkInProgressRoot(): any);\n  const cacheFromRootCachePool = root.pooledCache;\n\n  return cacheFromRootCachePool;\n}\n\nexport function requestCacheFromPool(renderLanes: Lanes): Cache {\n  // Similar to previous function, except if there's not already a cache in the\n  // pool, we allocate a new one.\n  const cacheFromPool = peekCacheFromPool();\n  if (cacheFromPool !== null) {\n    return cacheFromPool;\n  }\n\n  // Create a fresh cache and add it to the root cache pool. A cache can have\n  // multiple owners:\n  // - A cache pool that lives on the FiberRoot. This is where all fresh caches\n  //   are originally created (TODO: except during refreshes, until we implement\n  //   this correctly). The root takes ownership immediately when the cache is\n  //   created. Conceptually, root.pooledCache is an Option<Arc<Cache>> (owned),\n  //   and the return value of this function is a &Arc<Cache> (borrowed).\n  // - One of several fiber types: host root, cache boundary, suspense\n  //   component. These retain and release in the commit phase.\n\n  const root = (getWorkInProgressRoot(): any);\n  const freshCache = createCache();\n  root.pooledCache = freshCache;\n  retainCache(freshCache);\n  if (freshCache !== null) {\n    root.pooledCacheLanes |= renderLanes;\n  }\n  return freshCache;\n}\n\nexport function pushRootTransition(\n  workInProgress: Fiber,\n  root: FiberRoot,\n  renderLanes: Lanes,\n) {\n  if (enableTransitionTracing) {\n    const rootTransitions = getWorkInProgressTransitions();\n    push(transitionStack, rootTransitions, workInProgress);\n  }\n}\n\nexport function popRootTransition(\n  workInProgress: Fiber,\n  root: FiberRoot,\n  renderLanes: Lanes,\n) {\n  if (enableTransitionTracing) {\n    pop(transitionStack, workInProgress);\n  }\n}\n\nexport function pushTransition(\n  offscreenWorkInProgress: Fiber,\n  prevCachePool: SpawnedCachePool | null,\n  newTransitions: Array<Transition> | null,\n): void {\n  if (enableCache) {\n    if (prevCachePool === null) {\n      push(resumedCache, resumedCache.current, offscreenWorkInProgress);\n    } else {\n      push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n  }\n\n  if (enableTransitionTracing) {\n    if (transitionStack.current === null) {\n      push(transitionStack, newTransitions, offscreenWorkInProgress);\n    } else if (newTransitions === null) {\n      push(transitionStack, transitionStack.current, offscreenWorkInProgress);\n    } else {\n      push(\n        transitionStack,\n        transitionStack.current.concat(newTransitions),\n        offscreenWorkInProgress,\n      );\n    }\n  }\n}\n\nexport function popTransition(workInProgress: Fiber, current: Fiber | null) {\n  if (current !== null) {\n    if (enableTransitionTracing) {\n      pop(transitionStack, workInProgress);\n    }\n\n    if (enableCache) {\n      pop(resumedCache, workInProgress);\n    }\n  }\n}\n\nexport function getPendingTransitions(): Array<Transition> | null {\n  if (!enableTransitionTracing) {\n    return null;\n  }\n\n  return transitionStack.current;\n}\n\nexport function getSuspendedCache(): SpawnedCachePool | null {\n  if (!enableCache) {\n    return null;\n  }\n  // This function is called when a Suspense boundary suspends. It returns the\n  // cache that would have been used to render fresh data during this render,\n  // if there was any, so that we can resume rendering with the same cache when\n  // we receive more data.\n  const cacheFromPool = peekCacheFromPool();\n  if (cacheFromPool === null) {\n    return null;\n  }\n\n  return {\n    // We must also save the parent, so that when we resume we can detect\n    // a refresh.\n    parent: isPrimaryRenderer\n      ? CacheContext._currentValue\n      : CacheContext._currentValue2,\n    pool: cacheFromPool,\n  };\n}\n\nexport function getOffscreenDeferredCache(): SpawnedCachePool | null {\n  if (!enableCache) {\n    return null;\n  }\n\n  const cacheFromPool = peekCacheFromPool();\n  if (cacheFromPool === null) {\n    return null;\n  }\n\n  return {\n    // We must also store the parent, so that when we resume we can detect\n    // a refresh.\n    parent: isPrimaryRenderer\n      ? CacheContext._currentValue\n      : CacheContext._currentValue2,\n    pool: cacheFromPool,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}