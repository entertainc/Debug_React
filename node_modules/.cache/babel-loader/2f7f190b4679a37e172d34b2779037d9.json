{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { SuspenseComponent, SuspenseListComponent } from './ReactWorkTags';\nimport { NoFlags, DidCapture } from './ReactFiberFlags';\nimport { isSuspenseInstancePending, isSuspenseInstanceFallback } from './ReactFiberHostConfig';\nexport function findFirstSuspended(row) {\n  let node = row;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state = node.memoizedState;\n\n      if (state !== null) {\n        const dehydrated = state.dehydrated;\n\n        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n          return node;\n        }\n      }\n    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n    // keep track of whether it suspended or not.\n    node.memoizedProps.revealOrder !== undefined) {\n      const didSuspend = (node.flags & DidCapture) !== NoFlags;\n\n      if (didSuspend) {\n        return node;\n      }\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === row) {\n      return null;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === row) {\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberSuspenseComponent.js"],"names":["SuspenseComponent","SuspenseListComponent","NoFlags","DidCapture","isSuspenseInstancePending","isSuspenseInstanceFallback","findFirstSuspended","row","node","tag","state","memoizedState","dehydrated","memoizedProps","revealOrder","undefined","didSuspend","flags","child","return","sibling"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA,SAAQA,iBAAR,EAA2BC,qBAA3B,QAAuD,iBAAvD;AACA,SAAQC,OAAR,EAAiBC,UAAjB,QAAkC,mBAAlC;AACA,SACEC,yBADF,EAEEC,0BAFF,QAGO,wBAHP;AAoDA,OAAO,SAASC,kBAAT,CAA4BC,GAA5B,EAAsD;AAC3D,MAAIC,IAAI,GAAGD,GAAX;;AACA,SAAOC,IAAI,KAAK,IAAhB,EAAsB;AACpB,QAAIA,IAAI,CAACC,GAAL,KAAaT,iBAAjB,EAAoC;AAClC,YAAMU,KAA2B,GAAGF,IAAI,CAACG,aAAzC;;AACA,UAAID,KAAK,KAAK,IAAd,EAAoB;AAClB,cAAME,UAAmC,GAAGF,KAAK,CAACE,UAAlD;;AACA,YACEA,UAAU,KAAK,IAAf,IACAR,yBAAyB,CAACQ,UAAD,CADzB,IAEAP,0BAA0B,CAACO,UAAD,CAH5B,EAIE;AACA,iBAAOJ,IAAP;AACD;AACF;AACF,KAZD,MAYO,IACLA,IAAI,CAACC,GAAL,KAAaR,qBAAb,IACA;AACA;AACAO,IAAAA,IAAI,CAACK,aAAL,CAAmBC,WAAnB,KAAmCC,SAJ9B,EAKL;AACA,YAAMC,UAAU,GAAG,CAACR,IAAI,CAACS,KAAL,GAAad,UAAd,MAA8BD,OAAjD;;AACA,UAAIc,UAAJ,EAAgB;AACd,eAAOR,IAAP;AACD;AACF,KAVM,MAUA,IAAIA,IAAI,CAACU,KAAL,KAAe,IAAnB,EAAyB;AAC9BV,MAAAA,IAAI,CAACU,KAAL,CAAWC,MAAX,GAAoBX,IAApB;AACAA,MAAAA,IAAI,GAAGA,IAAI,CAACU,KAAZ;AACA;AACD;;AACD,QAAIV,IAAI,KAAKD,GAAb,EAAkB;AAChB,aAAO,IAAP;AACD;;AACD,WAAOC,IAAI,CAACY,OAAL,KAAiB,IAAxB,EAA8B;AAC5B,UAAIZ,IAAI,CAACW,MAAL,KAAgB,IAAhB,IAAwBX,IAAI,CAACW,MAAL,KAAgBZ,GAA5C,EAAiD;AAC/C,eAAO,IAAP;AACD;;AACDC,MAAAA,IAAI,GAAGA,IAAI,CAACW,MAAZ;AACD;;AACDX,IAAAA,IAAI,CAACY,OAAL,CAAaD,MAAb,GAAsBX,IAAI,CAACW,MAA3B;AACAX,IAAAA,IAAI,GAAGA,IAAI,CAACY,OAAZ;AACD;;AACD,SAAO,IAAP;AACD","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactNodeList, Wakeable} from 'shared/ReactTypes';\nimport type {Fiber} from './ReactInternalTypes';\nimport type {SuspenseInstance} from './ReactFiberHostConfig';\nimport type {Lane} from './ReactFiberLane';\nimport type {TreeContext} from './ReactFiberTreeContext';\n\nimport {SuspenseComponent, SuspenseListComponent} from './ReactWorkTags';\nimport {NoFlags, DidCapture} from './ReactFiberFlags';\nimport {\n  isSuspenseInstancePending,\n  isSuspenseInstanceFallback,\n} from './ReactFiberHostConfig';\n\nexport type SuspenseProps = {\n  children?: ReactNodeList,\n  fallback?: ReactNodeList,\n\n  // TODO: Add \"unstable_\" prefix?\n  suspenseCallback?: (Set<Wakeable> | null) => mixed,\n\n  unstable_avoidThisFallback?: boolean,\n  unstable_expectedLoadTime?: number,\n  unstable_name?: string,\n};\n\n// A null SuspenseState represents an unsuspended normal Suspense boundary.\n// A non-null SuspenseState means that it is blocked for one reason or another.\n// - A non-null dehydrated field means it's blocked pending hydration.\n//   - A non-null dehydrated field can use isSuspenseInstancePending or\n//     isSuspenseInstanceFallback to query the reason for being dehydrated.\n// - A null dehydrated field means it's blocked by something suspending and\n//   we're currently showing a fallback instead.\nexport type SuspenseState = {\n  // If this boundary is still dehydrated, we store the SuspenseInstance\n  // here to indicate that it is dehydrated (flag) and for quick access\n  // to check things like isSuspenseInstancePending.\n  dehydrated: null | SuspenseInstance,\n  treeContext: null | TreeContext,\n  // Represents the lane we should attempt to hydrate a dehydrated boundary at.\n  // OffscreenLane is the default for dehydrated boundaries.\n  // NoLane is the default for normal boundaries, which turns into \"normal\" pri.\n  retryLane: Lane,\n};\n\nexport type SuspenseListTailMode = 'collapsed' | 'hidden' | void;\n\nexport type SuspenseListRenderState = {\n  isBackwards: boolean,\n  // The currently rendering tail row.\n  rendering: null | Fiber,\n  // The absolute time when we started rendering the most recent tail row.\n  renderingStartTime: number,\n  // The last of the already rendered children.\n  last: null | Fiber,\n  // Remaining rows on the tail of the list.\n  tail: null | Fiber,\n  // Tail insertions setting.\n  tailMode: SuspenseListTailMode,\n};\n\nexport function findFirstSuspended(row: Fiber): null | Fiber {\n  let node = row;\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      const state: SuspenseState | null = node.memoizedState;\n      if (state !== null) {\n        const dehydrated: null | SuspenseInstance = state.dehydrated;\n        if (\n          dehydrated === null ||\n          isSuspenseInstancePending(dehydrated) ||\n          isSuspenseInstanceFallback(dehydrated)\n        ) {\n          return node;\n        }\n      }\n    } else if (\n      node.tag === SuspenseListComponent &&\n      // revealOrder undefined can't be trusted because it don't\n      // keep track of whether it suspended or not.\n      node.memoizedProps.revealOrder !== undefined\n    ) {\n      const didSuspend = (node.flags & DidCapture) !== NoFlags;\n      if (didSuspend) {\n        return node;\n      }\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === row) {\n      return null;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === row) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}