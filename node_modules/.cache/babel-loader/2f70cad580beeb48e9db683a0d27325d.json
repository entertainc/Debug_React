{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { NoMode, ConcurrentMode } from './ReactTypeOfMode';\nimport { HostComponent, HostSingleton, HostText, HostRoot, SuspenseComponent } from './ReactWorkTags';\nimport { ChildDeletion, Placement, Hydrating, NoFlags, DidCapture } from './ReactFiberFlags';\nimport { enableHostSingletons, enableFloat } from 'shared/ReactFeatureFlags';\nimport { createFiberFromHostInstanceForDeletion, createFiberFromDehydratedFragment } from './ReactFiber';\nimport { shouldSetTextContent, supportsHydration, supportsSingletons, isHydratable, canHydrateInstance, canHydrateTextInstance, canHydrateSuspenseInstance, getNextHydratableSibling, getFirstHydratableChild, getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance, hydrateInstance, hydrateTextInstance, hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance, shouldDeleteUnhydratedTailInstances, didNotMatchHydratedContainerTextInstance, didNotMatchHydratedTextInstance, didNotHydrateInstanceWithinContainer, didNotHydrateInstanceWithinSuspenseInstance, didNotHydrateInstance, didNotFindHydratableInstanceWithinContainer, didNotFindHydratableTextInstanceWithinContainer, didNotFindHydratableSuspenseInstanceWithinContainer, didNotFindHydratableInstanceWithinSuspenseInstance, didNotFindHydratableTextInstanceWithinSuspenseInstance, didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, didNotFindHydratableInstance, didNotFindHydratableTextInstance, didNotFindHydratableSuspenseInstance, resolveSingletonInstance } from './ReactFiberHostConfig';\nimport { OffscreenLane } from './ReactFiberLane';\nimport { getSuspendedTreeContext, restoreSuspendedTreeContext } from './ReactFiberTreeContext';\nimport { queueRecoverableErrors } from './ReactFiberWorkLoop';\nimport { getRootHostContainer, getHostContext } from './ReactFiberHostContext'; // The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\n\nlet hydrationParentFiber = null;\nlet nextHydratableInstance = null;\nlet isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\n\nlet didSuspendOrErrorDEV = false; // Hydration errors that were thrown inside this boundary\n\nlet hydrationErrors = null;\n\nfunction warnIfHydrating() {\n  if (__DEV__) {\n    if (isHydrating) {\n      console.error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n    }\n  }\n}\n\nexport function markDidThrowWhileHydratingDEV() {\n  if (__DEV__) {\n    didSuspendOrErrorDEV = true;\n  }\n}\nexport function didSuspendOrErrorWhileHydratingDEV() {\n  if (__DEV__) {\n    return didSuspendOrErrorDEV;\n  }\n\n  return false;\n}\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  const parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspendOrErrorDEV = false;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspendOrErrorDEV = false;\n\n  if (treeContext !== null) {\n    restoreSuspendedTreeContext(fiber, treeContext);\n  }\n\n  return true;\n}\n\nfunction warnUnhydratedInstance(returnFiber, instance) {\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n          break;\n        }\n\n      case HostSingleton:\n      case HostComponent:\n        {\n          const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance, // TODO: Delete this argument when we remove the legacy root API.\n          isConcurrentMode);\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          const suspenseState = returnFiber.memoizedState;\n          if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n          break;\n        }\n    }\n  }\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  warnUnhydratedInstance(returnFiber, instance);\n  const childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  const deletions = returnFiber.deletions;\n\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\nfunction warnNonhydratedInstance(returnFiber, fiber) {\n  if (__DEV__) {\n    if (didSuspendOrErrorDEV) {\n      // Inside a boundary that already suspended. We're currently rendering the\n      // siblings of a suspended node. The mismatch may be due to the missing\n      // data, so it's probably a false positive.\n      return;\n    }\n\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          const parentContainer = returnFiber.stateNode.containerInfo;\n\n          switch (fiber.tag) {\n            case HostSingleton:\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);\n              break;\n\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);\n              break;\n          }\n\n          break;\n        }\n\n      case HostSingleton:\n      case HostComponent:\n        {\n          const parentType = returnFiber.type;\n          const parentProps = returnFiber.memoizedProps;\n          const parentInstance = returnFiber.stateNode;\n\n          switch (fiber.tag) {\n            case HostSingleton:\n            case HostComponent:\n              {\n                const type = fiber.type;\n                const props = fiber.pendingProps;\n                const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, // TODO: Delete this argument when we remove the legacy root API.\n                isConcurrentMode);\n                break;\n              }\n\n            case HostText:\n              {\n                const text = fiber.pendingProps;\n                const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, // TODO: Delete this argument when we remove the legacy root API.\n                isConcurrentMode);\n                break;\n              }\n\n            case SuspenseComponent:\n              {\n                didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n                break;\n              }\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          const suspenseState = returnFiber.memoizedState;\n          const parentInstance = suspenseState.dehydrated;\n          if (parentInstance !== null) switch (fiber.tag) {\n            case HostSingleton:\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props);\n              break;\n\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(parentInstance);\n              break;\n          }\n          break;\n        }\n\n      default:\n        return;\n    }\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.flags = fiber.flags & ~Hydrating | Placement;\n  warnNonhydratedInstance(returnFiber, fiber);\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    // HostSingleton is intentionally omitted. the hydration pathway for singletons is non-fallible\n    // you can find it inlined in claimHydratableSingleton\n    case HostComponent:\n      {\n        const type = fiber.type;\n        const props = fiber.pendingProps;\n        const instance = canHydrateInstance(nextInstance, type, props);\n\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          hydrationParentFiber = fiber;\n          nextHydratableInstance = getFirstHydratableChild(instance);\n          return true;\n        }\n\n        return false;\n      }\n\n    case HostText:\n      {\n        const text = fiber.pendingProps;\n        const textInstance = canHydrateTextInstance(nextInstance, text);\n\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n\n          nextHydratableInstance = null;\n          return true;\n        }\n\n        return false;\n      }\n\n    case SuspenseComponent:\n      {\n        const suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n\n        if (suspenseInstance !== null) {\n          const suspenseState = {\n            dehydrated: suspenseInstance,\n            treeContext: getSuspendedTreeContext(),\n            retryLane: OffscreenLane\n          };\n          fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n          // This simplifies the code for getHostSibling and deleting nodes,\n          // since it doesn't have to consider all Suspense boundaries and\n          // check if they're dehydrated ones or not.\n\n          const dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n          dehydratedFragment.return = fiber;\n          fiber.child = dehydratedFragment;\n          hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n          // it during the first pass. Instead, we'll reenter it later.\n\n          nextHydratableInstance = null;\n          return true;\n        }\n\n        return false;\n      }\n\n    default:\n      return false;\n  }\n}\n\nfunction shouldClientRenderOnMismatch(fiber) {\n  return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n}\n\nfunction throwOnHydrationMismatch(fiber) {\n  throw new Error('Hydration failed because the initial UI does not match what was ' + 'rendered on the server.');\n}\n\nfunction claimHydratableSingleton(fiber) {\n  if (enableHostSingletons && supportsSingletons) {\n    if (!isHydrating) {\n      return;\n    }\n\n    const currentRootContainer = getRootHostContainer();\n    const currentHostContext = getHostContext();\n    const instance = fiber.stateNode = resolveSingletonInstance(fiber.type, fiber.pendingProps, currentRootContainer, currentHostContext, false);\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(instance);\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n\n  if (enableFloat && !isHydratable(fiber.type, fiber.pendingProps)) {\n    // This fiber never hydrates from the DOM and always does an insert\n    fiber.flags = fiber.flags & ~Hydrating | Placement;\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n\n  let nextInstance = nextHydratableInstance;\n\n  if (!nextInstance) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance(hydrationParentFiber, fiber);\n      throwOnHydrationMismatch(fiber);\n    } // Nothing to hydrate. Make it an insertion.\n\n\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n\n  const firstAttemptedInstance = nextInstance;\n\n  if (!tryHydrate(fiber, nextInstance)) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance(hydrationParentFiber, fiber);\n      throwOnHydrationMismatch(fiber);\n    } // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n\n\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    const prevHydrationParentFiber = hydrationParentFiber;\n\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    } // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n\n\n    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n  }\n}\n\nfunction prepareToHydrateHostInstance(fiber, hostContext) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const instance = fiber.stateNode;\n  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n  const updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, hostContext, fiber, shouldWarnIfMismatchDev); // TODO: Type this specific to this type of component.\n\n  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n\n  if (updatePayload !== null) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const textInstance = fiber.stateNode;\n  const textContent = fiber.memoizedProps;\n  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n  const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);\n\n  if (shouldUpdate) {\n    // We assume that prepareToHydrateHostTextInstance is called in a context where the\n    // hydration parent is the parent host component of this host text.\n    const returnFiber = hydrationParentFiber;\n\n    if (returnFiber !== null) {\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            const parentContainer = returnFiber.stateNode.containerInfo;\n            const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n            didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n            isConcurrentMode, shouldWarnIfMismatchDev);\n            break;\n          }\n\n        case HostSingleton:\n        case HostComponent:\n          {\n            const parentType = returnFiber.type;\n            const parentProps = returnFiber.memoizedProps;\n            const parentInstance = returnFiber.stateNode;\n            const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n            didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n            isConcurrentMode, shouldWarnIfMismatchDev);\n            break;\n          }\n      }\n    }\n  }\n\n  return shouldUpdate;\n}\n\nfunction prepareToHydrateHostSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const suspenseState = fiber.memoizedState;\n  const suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  hydrateSuspenseInstance(suspenseInstance, fiber);\n}\n\nfunction skipPastDehydratedSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  const suspenseState = fiber.memoizedState;\n  const suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n}\n\nfunction popToNextHostParent(fiber) {\n  let parent = fiber.return;\n\n  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent && (!(enableHostSingletons && supportsSingletons) ? true : parent.tag !== HostSingleton)) {\n    parent = parent.return;\n  }\n\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  let shouldClear = false;\n\n  if (enableHostSingletons && supportsSingletons) {\n    // With float we never clear the Root, or Singleton instances. We also do not clear Instances\n    // that have singleton text content\n    if (fiber.tag !== HostRoot && fiber.tag !== HostSingleton && !(fiber.tag === HostComponent && shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n      shouldClear = true;\n    }\n  } else {\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them. We also don't delete anything inside the root container.\n    if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n      shouldClear = true;\n    }\n  }\n\n  if (shouldClear) {\n    let nextInstance = nextHydratableInstance;\n\n    if (nextInstance) {\n      if (shouldClientRenderOnMismatch(fiber)) {\n        warnIfUnhydratedTailNodes(fiber);\n        throwOnHydrationMismatch(fiber);\n      } else {\n        while (nextInstance) {\n          deleteHydratableInstance(fiber, nextInstance);\n          nextInstance = getNextHydratableSibling(nextInstance);\n        }\n      }\n    }\n  }\n\n  popToNextHostParent(fiber);\n\n  if (fiber.tag === SuspenseComponent) {\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n  } else {\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n  }\n\n  return true;\n}\n\nfunction hasUnhydratedTailNodes() {\n  return isHydrating && nextHydratableInstance !== null;\n}\n\nfunction warnIfUnhydratedTailNodes(fiber) {\n  let nextInstance = nextHydratableInstance;\n\n  while (nextInstance) {\n    warnUnhydratedInstance(fiber, nextInstance);\n    nextInstance = getNextHydratableSibling(nextInstance);\n  }\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n  didSuspendOrErrorDEV = false;\n}\n\nexport function upgradeHydrationErrorsToRecoverable() {\n  if (hydrationErrors !== null) {\n    // Successfully completed a forced client render. The errors that occurred\n    // during the hydration attempt are now recovered. We will log them in\n    // commit phase, once the entire tree has finished.\n    queueRecoverableErrors(hydrationErrors);\n    hydrationErrors = null;\n  }\n}\n\nfunction getIsHydrating() {\n  return isHydrating;\n}\n\nexport function queueHydrationError(error) {\n  if (hydrationErrors === null) {\n    hydrationErrors = [error];\n  } else {\n    hydrationErrors.push(error);\n  }\n}\nexport { warnIfHydrating, enterHydrationState, getIsHydrating, reenterHydrationStateFromDehydratedSuspenseInstance, resetHydrationState, claimHydratableSingleton, tryToClaimNextHydratableInstance, prepareToHydrateHostInstance, prepareToHydrateHostTextInstance, prepareToHydrateHostSuspenseInstance, popHydrationState, hasUnhydratedTailNodes, warnIfUnhydratedTailNodes };","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberHydrationContext.js"],"names":["NoMode","ConcurrentMode","HostComponent","HostSingleton","HostText","HostRoot","SuspenseComponent","ChildDeletion","Placement","Hydrating","NoFlags","DidCapture","enableHostSingletons","enableFloat","createFiberFromHostInstanceForDeletion","createFiberFromDehydratedFragment","shouldSetTextContent","supportsHydration","supportsSingletons","isHydratable","canHydrateInstance","canHydrateTextInstance","canHydrateSuspenseInstance","getNextHydratableSibling","getFirstHydratableChild","getFirstHydratableChildWithinContainer","getFirstHydratableChildWithinSuspenseInstance","hydrateInstance","hydrateTextInstance","hydrateSuspenseInstance","getNextHydratableInstanceAfterSuspenseInstance","shouldDeleteUnhydratedTailInstances","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateInstanceWithinContainer","didNotHydrateInstanceWithinSuspenseInstance","didNotHydrateInstance","didNotFindHydratableInstanceWithinContainer","didNotFindHydratableTextInstanceWithinContainer","didNotFindHydratableSuspenseInstanceWithinContainer","didNotFindHydratableInstanceWithinSuspenseInstance","didNotFindHydratableTextInstanceWithinSuspenseInstance","didNotFindHydratableSuspenseInstanceWithinSuspenseInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","didNotFindHydratableSuspenseInstance","resolveSingletonInstance","OffscreenLane","getSuspendedTreeContext","restoreSuspendedTreeContext","queueRecoverableErrors","getRootHostContainer","getHostContext","hydrationParentFiber","nextHydratableInstance","isHydrating","didSuspendOrErrorDEV","hydrationErrors","warnIfHydrating","__DEV__","console","error","markDidThrowWhileHydratingDEV","didSuspendOrErrorWhileHydratingDEV","enterHydrationState","fiber","parentInstance","stateNode","containerInfo","reenterHydrationStateFromDehydratedSuspenseInstance","suspenseInstance","treeContext","warnUnhydratedInstance","returnFiber","instance","tag","isConcurrentMode","mode","type","memoizedProps","suspenseState","memoizedState","dehydrated","deleteHydratableInstance","childToDelete","return","deletions","flags","push","warnNonhydratedInstance","parentContainer","props","pendingProps","text","parentType","parentProps","insertNonHydratedInstance","tryHydrate","nextInstance","textInstance","retryLane","dehydratedFragment","child","shouldClientRenderOnMismatch","throwOnHydrationMismatch","Error","claimHydratableSingleton","currentRootContainer","currentHostContext","tryToClaimNextHydratableInstance","firstAttemptedInstance","prevHydrationParentFiber","prepareToHydrateHostInstance","hostContext","shouldWarnIfMismatchDev","updatePayload","updateQueue","prepareToHydrateHostTextInstance","textContent","shouldUpdate","prepareToHydrateHostSuspenseInstance","skipPastDehydratedSuspenseInstance","popToNextHostParent","parent","popHydrationState","shouldClear","warnIfUnhydratedTailNodes","hasUnhydratedTailNodes","resetHydrationState","upgradeHydrationErrorsToRecoverable","getIsHydrating","queueHydrationError"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from './ReactInternalTypes';\nimport {NoMode, ConcurrentMode} from './ReactTypeOfMode';\nimport type {\n  Instance,\n  TextInstance,\n  HydratableInstance,\n  SuspenseInstance,\n  Container,\n  HostContext,\n} from './ReactFiberHostConfig';\nimport type {SuspenseState} from './ReactFiberSuspenseComponent';\nimport type {TreeContext} from './ReactFiberTreeContext';\nimport type {CapturedValue} from './ReactCapturedValue';\n\nimport {\n  HostComponent,\n  HostSingleton,\n  HostText,\n  HostRoot,\n  SuspenseComponent,\n} from './ReactWorkTags';\nimport {\n  ChildDeletion,\n  Placement,\n  Hydrating,\n  NoFlags,\n  DidCapture,\n} from './ReactFiberFlags';\nimport {enableHostSingletons, enableFloat} from 'shared/ReactFeatureFlags';\n\nimport {\n  createFiberFromHostInstanceForDeletion,\n  createFiberFromDehydratedFragment,\n} from './ReactFiber';\nimport {\n  shouldSetTextContent,\n  supportsHydration,\n  supportsSingletons,\n  isHydratable,\n  canHydrateInstance,\n  canHydrateTextInstance,\n  canHydrateSuspenseInstance,\n  getNextHydratableSibling,\n  getFirstHydratableChild,\n  getFirstHydratableChildWithinContainer,\n  getFirstHydratableChildWithinSuspenseInstance,\n  hydrateInstance,\n  hydrateTextInstance,\n  hydrateSuspenseInstance,\n  getNextHydratableInstanceAfterSuspenseInstance,\n  shouldDeleteUnhydratedTailInstances,\n  didNotMatchHydratedContainerTextInstance,\n  didNotMatchHydratedTextInstance,\n  didNotHydrateInstanceWithinContainer,\n  didNotHydrateInstanceWithinSuspenseInstance,\n  didNotHydrateInstance,\n  didNotFindHydratableInstanceWithinContainer,\n  didNotFindHydratableTextInstanceWithinContainer,\n  didNotFindHydratableSuspenseInstanceWithinContainer,\n  didNotFindHydratableInstanceWithinSuspenseInstance,\n  didNotFindHydratableTextInstanceWithinSuspenseInstance,\n  didNotFindHydratableSuspenseInstanceWithinSuspenseInstance,\n  didNotFindHydratableInstance,\n  didNotFindHydratableTextInstance,\n  didNotFindHydratableSuspenseInstance,\n  resolveSingletonInstance,\n} from './ReactFiberHostConfig';\nimport {OffscreenLane} from './ReactFiberLane';\nimport {\n  getSuspendedTreeContext,\n  restoreSuspendedTreeContext,\n} from './ReactFiberTreeContext';\nimport {queueRecoverableErrors} from './ReactFiberWorkLoop';\nimport {getRootHostContainer, getHostContext} from './ReactFiberHostContext';\n\n// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nlet hydrationParentFiber: null | Fiber = null;\nlet nextHydratableInstance: null | HydratableInstance = null;\nlet isHydrating: boolean = false;\n\n// This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\nlet didSuspendOrErrorDEV: boolean = false;\n\n// Hydration errors that were thrown inside this boundary\nlet hydrationErrors: Array<CapturedValue<mixed>> | null = null;\n\nfunction warnIfHydrating() {\n  if (__DEV__) {\n    if (isHydrating) {\n      console.error(\n        'We should not be hydrating here. This is a bug in React. Please file a bug.',\n      );\n    }\n  }\n}\n\nexport function markDidThrowWhileHydratingDEV() {\n  if (__DEV__) {\n    didSuspendOrErrorDEV = true;\n  }\n}\n\nexport function didSuspendOrErrorWhileHydratingDEV(): boolean {\n  if (__DEV__) {\n    return didSuspendOrErrorDEV;\n  }\n  return false;\n}\n\nfunction enterHydrationState(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  const parentInstance: Container = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChildWithinContainer(\n    parentInstance,\n  );\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspendOrErrorDEV = false;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(\n  fiber: Fiber,\n  suspenseInstance: SuspenseInstance,\n  treeContext: TreeContext | null,\n): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(\n    suspenseInstance,\n  );\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspendOrErrorDEV = false;\n  if (treeContext !== null) {\n    restoreSuspendedTreeContext(fiber, treeContext);\n  }\n  return true;\n}\n\nfunction warnUnhydratedInstance(\n  returnFiber: Fiber,\n  instance: HydratableInstance,\n) {\n  if (__DEV__) {\n    switch (returnFiber.tag) {\n      case HostRoot: {\n        didNotHydrateInstanceWithinContainer(\n          returnFiber.stateNode.containerInfo,\n          instance,\n        );\n        break;\n      }\n      case HostSingleton:\n      case HostComponent: {\n        const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n        didNotHydrateInstance(\n          returnFiber.type,\n          returnFiber.memoizedProps,\n          returnFiber.stateNode,\n          instance,\n          // TODO: Delete this argument when we remove the legacy root API.\n          isConcurrentMode,\n        );\n        break;\n      }\n      case SuspenseComponent: {\n        const suspenseState: SuspenseState = returnFiber.memoizedState;\n        if (suspenseState.dehydrated !== null)\n          didNotHydrateInstanceWithinSuspenseInstance(\n            suspenseState.dehydrated,\n            instance,\n          );\n        break;\n      }\n    }\n  }\n}\n\nfunction deleteHydratableInstance(\n  returnFiber: Fiber,\n  instance: HydratableInstance,\n) {\n  warnUnhydratedInstance(returnFiber, instance);\n  const childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n\n  const deletions = returnFiber.deletions;\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\nfunction warnNonhydratedInstance(returnFiber: Fiber, fiber: Fiber) {\n  if (__DEV__) {\n    if (didSuspendOrErrorDEV) {\n      // Inside a boundary that already suspended. We're currently rendering the\n      // siblings of a suspended node. The mismatch may be due to the missing\n      // data, so it's probably a false positive.\n      return;\n    }\n\n    switch (returnFiber.tag) {\n      case HostRoot: {\n        const parentContainer = returnFiber.stateNode.containerInfo;\n        switch (fiber.tag) {\n          case HostSingleton:\n          case HostComponent:\n            const type = fiber.type;\n            const props = fiber.pendingProps;\n            didNotFindHydratableInstanceWithinContainer(\n              parentContainer,\n              type,\n              props,\n            );\n            break;\n          case HostText:\n            const text = fiber.pendingProps;\n            didNotFindHydratableTextInstanceWithinContainer(\n              parentContainer,\n              text,\n            );\n            break;\n          case SuspenseComponent:\n            didNotFindHydratableSuspenseInstanceWithinContainer(\n              parentContainer,\n            );\n            break;\n        }\n        break;\n      }\n      case HostSingleton:\n      case HostComponent: {\n        const parentType = returnFiber.type;\n        const parentProps = returnFiber.memoizedProps;\n        const parentInstance = returnFiber.stateNode;\n        switch (fiber.tag) {\n          case HostSingleton:\n          case HostComponent: {\n            const type = fiber.type;\n            const props = fiber.pendingProps;\n            const isConcurrentMode =\n              (returnFiber.mode & ConcurrentMode) !== NoMode;\n            didNotFindHydratableInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              type,\n              props,\n              // TODO: Delete this argument when we remove the legacy root API.\n              isConcurrentMode,\n            );\n            break;\n          }\n          case HostText: {\n            const text = fiber.pendingProps;\n            const isConcurrentMode =\n              (returnFiber.mode & ConcurrentMode) !== NoMode;\n            didNotFindHydratableTextInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n              text,\n              // TODO: Delete this argument when we remove the legacy root API.\n              isConcurrentMode,\n            );\n            break;\n          }\n          case SuspenseComponent: {\n            didNotFindHydratableSuspenseInstance(\n              parentType,\n              parentProps,\n              parentInstance,\n            );\n            break;\n          }\n        }\n        break;\n      }\n      case SuspenseComponent: {\n        const suspenseState: SuspenseState = returnFiber.memoizedState;\n        const parentInstance = suspenseState.dehydrated;\n        if (parentInstance !== null)\n          switch (fiber.tag) {\n            case HostSingleton:\n            case HostComponent:\n              const type = fiber.type;\n              const props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinSuspenseInstance(\n                parentInstance,\n                type,\n                props,\n              );\n              break;\n            case HostText:\n              const text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinSuspenseInstance(\n                parentInstance,\n                text,\n              );\n              break;\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(\n                parentInstance,\n              );\n              break;\n          }\n        break;\n      }\n      default:\n        return;\n    }\n  }\n}\nfunction insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {\n  fiber.flags = (fiber.flags & ~Hydrating) | Placement;\n  warnNonhydratedInstance(returnFiber, fiber);\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    // HostSingleton is intentionally omitted. the hydration pathway for singletons is non-fallible\n    // you can find it inlined in claimHydratableSingleton\n    case HostComponent: {\n      const type = fiber.type;\n      const props = fiber.pendingProps;\n      const instance = canHydrateInstance(nextInstance, type, props);\n      if (instance !== null) {\n        fiber.stateNode = (instance: Instance);\n        hydrationParentFiber = fiber;\n        nextHydratableInstance = getFirstHydratableChild(instance);\n        return true;\n      }\n      return false;\n    }\n    case HostText: {\n      const text = fiber.pendingProps;\n      const textInstance = canHydrateTextInstance(nextInstance, text);\n      if (textInstance !== null) {\n        fiber.stateNode = (textInstance: TextInstance);\n        hydrationParentFiber = fiber;\n        // Text Instances don't have children so there's nothing to hydrate.\n        nextHydratableInstance = null;\n        return true;\n      }\n      return false;\n    }\n    case SuspenseComponent: {\n      const suspenseInstance: null | SuspenseInstance = canHydrateSuspenseInstance(\n        nextInstance,\n      );\n      if (suspenseInstance !== null) {\n        const suspenseState: SuspenseState = {\n          dehydrated: suspenseInstance,\n          treeContext: getSuspendedTreeContext(),\n          retryLane: OffscreenLane,\n        };\n        fiber.memoizedState = suspenseState;\n        // Store the dehydrated fragment as a child fiber.\n        // This simplifies the code for getHostSibling and deleting nodes,\n        // since it doesn't have to consider all Suspense boundaries and\n        // check if they're dehydrated ones or not.\n        const dehydratedFragment = createFiberFromDehydratedFragment(\n          suspenseInstance,\n        );\n        dehydratedFragment.return = fiber;\n        fiber.child = dehydratedFragment;\n        hydrationParentFiber = fiber;\n        // While a Suspense Instance does have children, we won't step into\n        // it during the first pass. Instead, we'll reenter it later.\n        nextHydratableInstance = null;\n        return true;\n      }\n      return false;\n    }\n    default:\n      return false;\n  }\n}\n\nfunction shouldClientRenderOnMismatch(fiber: Fiber) {\n  return (\n    (fiber.mode & ConcurrentMode) !== NoMode &&\n    (fiber.flags & DidCapture) === NoFlags\n  );\n}\n\nfunction throwOnHydrationMismatch(fiber: Fiber) {\n  throw new Error(\n    'Hydration failed because the initial UI does not match what was ' +\n      'rendered on the server.',\n  );\n}\n\nfunction claimHydratableSingleton(fiber: Fiber): void {\n  if (enableHostSingletons && supportsSingletons) {\n    if (!isHydrating) {\n      return;\n    }\n    const currentRootContainer = getRootHostContainer();\n    const currentHostContext = getHostContext();\n    const instance = (fiber.stateNode = resolveSingletonInstance(\n      fiber.type,\n      fiber.pendingProps,\n      currentRootContainer,\n      currentHostContext,\n      false,\n    ));\n    hydrationParentFiber = fiber;\n    nextHydratableInstance = getFirstHydratableChild(instance);\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber: Fiber): void {\n  if (!isHydrating) {\n    return;\n  }\n  if (enableFloat && !isHydratable(fiber.type, fiber.pendingProps)) {\n    // This fiber never hydrates from the DOM and always does an insert\n    fiber.flags = (fiber.flags & ~Hydrating) | Placement;\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  let nextInstance = nextHydratableInstance;\n  if (!nextInstance) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance((hydrationParentFiber: any), fiber);\n      throwOnHydrationMismatch(fiber);\n    }\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance((hydrationParentFiber: any), fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  const firstAttemptedInstance = nextInstance;\n  if (!tryHydrate(fiber, nextInstance)) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance((hydrationParentFiber: any), fiber);\n      throwOnHydrationMismatch(fiber);\n    }\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance((hydrationParentFiber: any), fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n  }\n}\n\nfunction prepareToHydrateHostInstance(\n  fiber: Fiber,\n  hostContext: HostContext,\n): boolean {\n  if (!supportsHydration) {\n    throw new Error(\n      'Expected prepareToHydrateHostInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  const instance: Instance = fiber.stateNode;\n  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n  const updatePayload = hydrateInstance(\n    instance,\n    fiber.type,\n    fiber.memoizedProps,\n    hostContext,\n    fiber,\n    shouldWarnIfMismatchDev,\n  );\n  // TODO: Type this specific to this type of component.\n  fiber.updateQueue = (updatePayload: any);\n  // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n  if (updatePayload !== null) {\n    return true;\n  }\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    throw new Error(\n      'Expected prepareToHydrateHostTextInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  const textInstance: TextInstance = fiber.stateNode;\n  const textContent: string = fiber.memoizedProps;\n  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n  const shouldUpdate = hydrateTextInstance(\n    textInstance,\n    textContent,\n    fiber,\n    shouldWarnIfMismatchDev,\n  );\n  if (shouldUpdate) {\n    // We assume that prepareToHydrateHostTextInstance is called in a context where the\n    // hydration parent is the parent host component of this host text.\n    const returnFiber = hydrationParentFiber;\n    if (returnFiber !== null) {\n      switch (returnFiber.tag) {\n        case HostRoot: {\n          const parentContainer = returnFiber.stateNode.containerInfo;\n          const isConcurrentMode =\n            (returnFiber.mode & ConcurrentMode) !== NoMode;\n          didNotMatchHydratedContainerTextInstance(\n            parentContainer,\n            textInstance,\n            textContent,\n            // TODO: Delete this argument when we remove the legacy root API.\n            isConcurrentMode,\n            shouldWarnIfMismatchDev,\n          );\n          break;\n        }\n        case HostSingleton:\n        case HostComponent: {\n          const parentType = returnFiber.type;\n          const parentProps = returnFiber.memoizedProps;\n          const parentInstance = returnFiber.stateNode;\n          const isConcurrentMode =\n            (returnFiber.mode & ConcurrentMode) !== NoMode;\n          didNotMatchHydratedTextInstance(\n            parentType,\n            parentProps,\n            parentInstance,\n            textInstance,\n            textContent,\n            // TODO: Delete this argument when we remove the legacy root API.\n            isConcurrentMode,\n            shouldWarnIfMismatchDev,\n          );\n          break;\n        }\n      }\n    }\n  }\n  return shouldUpdate;\n}\n\nfunction prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {\n  if (!supportsHydration) {\n    throw new Error(\n      'Expected prepareToHydrateHostSuspenseInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  const suspenseState: null | SuspenseState = fiber.memoizedState;\n  const suspenseInstance: null | SuspenseInstance =\n    suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error(\n      'Expected to have a hydrated suspense instance. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  hydrateSuspenseInstance(suspenseInstance, fiber);\n}\n\nfunction skipPastDehydratedSuspenseInstance(\n  fiber: Fiber,\n): null | HydratableInstance {\n  if (!supportsHydration) {\n    throw new Error(\n      'Expected skipPastDehydratedSuspenseInstance() to never be called. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n  const suspenseState: null | SuspenseState = fiber.memoizedState;\n  const suspenseInstance: null | SuspenseInstance =\n    suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error(\n      'Expected to have a hydrated suspense instance. ' +\n        'This error is likely caused by a bug in React. Please file an issue.',\n    );\n  }\n\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n}\n\nfunction popToNextHostParent(fiber: Fiber): void {\n  let parent = fiber.return;\n  while (\n    parent !== null &&\n    parent.tag !== HostComponent &&\n    parent.tag !== HostRoot &&\n    parent.tag !== SuspenseComponent &&\n    (!(enableHostSingletons && supportsSingletons)\n      ? true\n      : parent.tag !== HostSingleton)\n  ) {\n    parent = parent.return;\n  }\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber: Fiber): boolean {\n  if (!supportsHydration) {\n    return false;\n  }\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  let shouldClear = false;\n  if (enableHostSingletons && supportsSingletons) {\n    // With float we never clear the Root, or Singleton instances. We also do not clear Instances\n    // that have singleton text content\n    if (\n      fiber.tag !== HostRoot &&\n      fiber.tag !== HostSingleton &&\n      !(\n        fiber.tag === HostComponent &&\n        shouldSetTextContent(fiber.type, fiber.memoizedProps)\n      )\n    ) {\n      shouldClear = true;\n    }\n  } else {\n    // If we have any remaining hydratable nodes, we need to delete them now.\n    // We only do this deeper than head and body since they tend to have random\n    // other nodes in them. We also ignore components with pure text content in\n    // side of them. We also don't delete anything inside the root container.\n    if (\n      fiber.tag !== HostRoot &&\n      (fiber.tag !== HostComponent ||\n        (shouldDeleteUnhydratedTailInstances(fiber.type) &&\n          !shouldSetTextContent(fiber.type, fiber.memoizedProps)))\n    ) {\n      shouldClear = true;\n    }\n  }\n  if (shouldClear) {\n    let nextInstance = nextHydratableInstance;\n    if (nextInstance) {\n      if (shouldClientRenderOnMismatch(fiber)) {\n        warnIfUnhydratedTailNodes(fiber);\n        throwOnHydrationMismatch(fiber);\n      } else {\n        while (nextInstance) {\n          deleteHydratableInstance(fiber, nextInstance);\n          nextInstance = getNextHydratableSibling(nextInstance);\n        }\n      }\n    }\n  }\n  popToNextHostParent(fiber);\n  if (fiber.tag === SuspenseComponent) {\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n  } else {\n    nextHydratableInstance = hydrationParentFiber\n      ? getNextHydratableSibling(fiber.stateNode)\n      : null;\n  }\n  return true;\n}\n\nfunction hasUnhydratedTailNodes(): boolean {\n  return isHydrating && nextHydratableInstance !== null;\n}\n\nfunction warnIfUnhydratedTailNodes(fiber: Fiber) {\n  let nextInstance = nextHydratableInstance;\n  while (nextInstance) {\n    warnUnhydratedInstance(fiber, nextInstance);\n    nextInstance = getNextHydratableSibling(nextInstance);\n  }\n}\n\nfunction resetHydrationState(): void {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n  didSuspendOrErrorDEV = false;\n}\n\nexport function upgradeHydrationErrorsToRecoverable(): void {\n  if (hydrationErrors !== null) {\n    // Successfully completed a forced client render. The errors that occurred\n    // during the hydration attempt are now recovered. We will log them in\n    // commit phase, once the entire tree has finished.\n    queueRecoverableErrors(hydrationErrors);\n    hydrationErrors = null;\n  }\n}\n\nfunction getIsHydrating(): boolean {\n  return isHydrating;\n}\n\nexport function queueHydrationError(error: CapturedValue<mixed>): void {\n  if (hydrationErrors === null) {\n    hydrationErrors = [error];\n  } else {\n    hydrationErrors.push(error);\n  }\n}\n\nexport {\n  warnIfHydrating,\n  enterHydrationState,\n  getIsHydrating,\n  reenterHydrationStateFromDehydratedSuspenseInstance,\n  resetHydrationState,\n  claimHydratableSingleton,\n  tryToClaimNextHydratableInstance,\n  prepareToHydrateHostInstance,\n  prepareToHydrateHostTextInstance,\n  prepareToHydrateHostSuspenseInstance,\n  popHydrationState,\n  hasUnhydratedTailNodes,\n  warnIfUnhydratedTailNodes,\n};\n"]},"metadata":{},"sourceType":"module"}