{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay } from 'shared/ReactFeatureFlags';\nimport { unstable_scheduleCallback as scheduleCallback, unstable_NormalPriority as NormalPriority } from 'scheduler';\nimport { getNearestMountedFiber, getContainerFromFiber, getSuspenseInstanceFromFiber } from 'react-reconciler/src/ReactFiberTreeReflection';\nimport { findInstanceBlockingEvent, return_targetInst } from './ReactDOMEventListener';\nimport { setReplayingEvent, resetReplayingEvent } from './CurrentReplayingEvent';\nimport { dispatchEventForPluginEventSystem } from './DOMPluginEventSystem';\nimport { getInstanceFromNode, getClosestInstanceFromNode } from '../client/ReactDOMComponentTree';\nimport { HostRoot, SuspenseComponent } from 'react-reconciler/src/ReactWorkTags';\nimport { isHigherEventPriority } from 'react-reconciler/src/ReactEventPriorities';\nimport { isRootDehydrated } from 'react-reconciler/src/ReactFiberShellHydration';\n\nlet _attemptSynchronousHydration;\n\nexport function setAttemptSynchronousHydration(fn) {\n  _attemptSynchronousHydration = fn;\n}\nexport function attemptSynchronousHydration(fiber) {\n  _attemptSynchronousHydration(fiber);\n}\nlet attemptDiscreteHydration;\nexport function setAttemptDiscreteHydration(fn) {\n  attemptDiscreteHydration = fn;\n}\nlet attemptContinuousHydration;\nexport function setAttemptContinuousHydration(fn) {\n  attemptContinuousHydration = fn;\n}\nlet attemptHydrationAtCurrentPriority;\nexport function setAttemptHydrationAtCurrentPriority(fn) {\n  attemptHydrationAtCurrentPriority = fn;\n}\nlet getCurrentUpdatePriority;\nexport function setGetCurrentUpdatePriority(fn) {\n  getCurrentUpdatePriority = fn;\n}\nlet attemptHydrationAtPriority;\nexport function setAttemptHydrationAtPriority(fn) {\n  attemptHydrationAtPriority = fn;\n} // TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\n\nlet hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.\n\nconst queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.\n\nconst hasAnyQueuedContinuousEvents = false; // The last of each continuous event type. We only need to replay the last one\n// if the last target was dehydrated.\n\nlet queuedFocus = null;\nlet queuedDrag = null;\nlet queuedMouse = null; // For pointer events there can be one latest event per pointerId.\n\nconst queuedPointers = new Map();\nconst queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.\n\nconst queuedExplicitHydrationTargets = [];\nexport function hasQueuedDiscreteEvents() {\n  return queuedDiscreteEvents.length > 0;\n}\nexport function hasQueuedContinuousEvents() {\n  return hasAnyQueuedContinuousEvents;\n}\nconst discreteReplayableEvents = ['mousedown', 'mouseup', 'touchcancel', 'touchend', 'touchstart', 'auxclick', 'dblclick', 'pointercancel', 'pointerdown', 'pointerup', 'dragend', 'dragstart', 'drop', 'compositionend', 'compositionstart', 'keydown', 'keypress', 'keyup', 'input', 'textInput', // Intentionally camelCase\n'copy', 'cut', 'paste', 'click', 'change', 'contextmenu', 'reset', 'submit'];\nexport function isDiscreteEventThatRequiresHydration(eventType) {\n  return discreteReplayableEvents.indexOf(eventType) > -1;\n}\n\nfunction createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  return {\n    blockedOn,\n    domEventName,\n    eventSystemFlags,\n    nativeEvent,\n    targetContainers: [targetContainer]\n  };\n}\n\nexport function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    return;\n  }\n\n  const queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n  queuedDiscreteEvents.push(queuedEvent);\n\n  if (queuedDiscreteEvents.length === 1) {\n    // If this was the first discrete event, we might be able to\n    // synchronously unblock it so that preventDefault still works.\n    while (queuedEvent.blockedOn !== null) {\n      const fiber = getInstanceFromNode(queuedEvent.blockedOn);\n\n      if (fiber === null) {\n        break;\n      }\n\n      attemptSynchronousHydration(fiber);\n\n      if (queuedEvent.blockedOn === null) {\n        // We got unblocked by hydration. Let's try again.\n        replayUnblockedEvents(); // If we're reblocked, on an inner boundary, we might need\n        // to attempt hydrating that one.\n\n        continue;\n      } else {\n        // We're still blocked from hydration, we have to give up\n        // and replay later.\n        break;\n      }\n    }\n  }\n} // Resets the replaying for this type of continuous event to no event.\n\nexport function clearIfContinuousEvent(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case 'focusin':\n    case 'focusout':\n      queuedFocus = null;\n      break;\n\n    case 'dragenter':\n    case 'dragleave':\n      queuedDrag = null;\n      break;\n\n    case 'mouseover':\n    case 'mouseout':\n      queuedMouse = null;\n      break;\n\n    case 'pointerover':\n    case 'pointerout':\n      {\n        const pointerId = nativeEvent.pointerId;\n        queuedPointers.delete(pointerId);\n        break;\n      }\n\n    case 'gotpointercapture':\n    case 'lostpointercapture':\n      {\n        const pointerId = nativeEvent.pointerId;\n        queuedPointerCaptures.delete(pointerId);\n        break;\n      }\n  }\n}\n\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {\n    const queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n\n    if (blockedOn !== null) {\n      const fiber = getInstanceFromNode(blockedOn);\n\n      if (fiber !== null) {\n        // Attempt to increase the priority of this target.\n        attemptContinuousHydration(fiber);\n      }\n    }\n\n    return queuedEvent;\n  } // If we have already queued this exact event, then it's because\n  // the different event systems have different DOM event listeners.\n  // We can accumulate the flags, and the targetContainers, and\n  // store a single event to be replayed.\n\n\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  const targetContainers = existingQueuedEvent.targetContainers;\n\n  if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {\n    targetContainers.push(targetContainer);\n  }\n\n  return existingQueuedEvent;\n}\n\nexport function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n  // These set relatedTarget to null because the replayed event will be treated as if we\n  // moved from outside the window (no target) onto the target once it hydrates.\n  // Instead of mutating we could clone the event.\n  switch (domEventName) {\n    case 'focusin':\n      {\n        const focusEvent = nativeEvent;\n        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);\n        return true;\n      }\n\n    case 'dragenter':\n      {\n        const dragEvent = nativeEvent;\n        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);\n        return true;\n      }\n\n    case 'mouseover':\n      {\n        const mouseEvent = nativeEvent;\n        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);\n        return true;\n      }\n\n    case 'pointerover':\n      {\n        const pointerEvent = nativeEvent;\n        const pointerId = pointerEvent.pointerId;\n        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\n        return true;\n      }\n\n    case 'gotpointercapture':\n      {\n        const pointerEvent = nativeEvent;\n        const pointerId = pointerEvent.pointerId;\n        queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\n        return true;\n      }\n  }\n\n  return false;\n} // Check if this target is unblocked. Returns true if it's unblocked.\n\nfunction attemptExplicitHydrationTarget(queuedTarget) {\n  // TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n  // Try to unify them. It's a bit tricky since it would require two return\n  // values.\n  const targetInst = getClosestInstanceFromNode(queuedTarget.target);\n\n  if (targetInst !== null) {\n    const nearestMounted = getNearestMountedFiber(targetInst);\n\n    if (nearestMounted !== null) {\n      const tag = nearestMounted.tag;\n\n      if (tag === SuspenseComponent) {\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\n\n        if (instance !== null) {\n          // We're blocked on hydrating this boundary.\n          // Increase its priority.\n          queuedTarget.blockedOn = instance;\n          attemptHydrationAtPriority(queuedTarget.priority, () => {\n            attemptHydrationAtCurrentPriority(nearestMounted);\n          });\n          return;\n        }\n      } else if (tag === HostRoot) {\n        const root = nearestMounted.stateNode;\n\n        if (isRootDehydrated(root)) {\n          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of\n          // a root other than sync.\n\n          return;\n        }\n      }\n    }\n  }\n\n  queuedTarget.blockedOn = null;\n}\n\nexport function queueExplicitHydrationTarget(target) {\n  // TODO: This will read the priority if it's dispatched by the React\n  // event system but not native events. Should read window.event.type, like\n  // we do for updates (getCurrentEventPriority).\n  const updatePriority = getCurrentUpdatePriority();\n  const queuedTarget = {\n    blockedOn: null,\n    target: target,\n    priority: updatePriority\n  };\n  let i = 0;\n\n  for (; i < queuedExplicitHydrationTargets.length; i++) {\n    // Stop once we hit the first target with lower priority than\n    if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {\n      break;\n    }\n  }\n\n  queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n\n  if (i === 0) {\n    attemptExplicitHydrationTarget(queuedTarget);\n  }\n}\n\nfunction attemptReplayContinuousQueuedEvent(queuedEvent) {\n  if (queuedEvent.blockedOn !== null) {\n    return false;\n  }\n\n  const targetContainers = queuedEvent.targetContainers;\n\n  while (targetContainers.length > 0) {\n    const targetContainer = targetContainers[0];\n    const nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);\n\n    if (nextBlockedOn === null) {\n      if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n        const nativeEvent = queuedEvent.nativeEvent;\n        const nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);\n        setReplayingEvent(nativeEventClone);\n        nativeEvent.target.dispatchEvent(nativeEventClone);\n        resetReplayingEvent();\n      } else {\n        setReplayingEvent(queuedEvent.nativeEvent);\n        dispatchEventForPluginEventSystem(queuedEvent.domEventName, queuedEvent.eventSystemFlags, queuedEvent.nativeEvent, return_targetInst, targetContainer);\n        resetReplayingEvent();\n      }\n    } else {\n      // We're still blocked. Try again later.\n      const fiber = getInstanceFromNode(nextBlockedOn);\n\n      if (fiber !== null) {\n        attemptContinuousHydration(fiber);\n      }\n\n      queuedEvent.blockedOn = nextBlockedOn;\n      return false;\n    } // This target container was successfully dispatched. Try the next.\n\n\n    targetContainers.shift();\n  }\n\n  return true;\n}\n\nfunction attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n    map.delete(key);\n  }\n}\n\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = false;\n\n  if (!enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    // First replay discrete events.\n    while (queuedDiscreteEvents.length > 0) {\n      const nextDiscreteEvent = queuedDiscreteEvents[0];\n\n      if (nextDiscreteEvent.blockedOn !== null) {\n        // We're still blocked.\n        // Increase the priority of this boundary to unblock\n        // the next discrete event.\n        const fiber = getInstanceFromNode(nextDiscreteEvent.blockedOn);\n\n        if (fiber !== null) {\n          attemptDiscreteHydration(fiber);\n        }\n\n        break;\n      }\n\n      const targetContainers = nextDiscreteEvent.targetContainers;\n\n      while (targetContainers.length > 0) {\n        const targetContainer = targetContainers[0];\n        const nextBlockedOn = findInstanceBlockingEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);\n\n        if (nextBlockedOn === null) {\n          // This whole function is in !enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay,\n          // so we don't need the new replay behavior code branch.\n          setReplayingEvent(nextDiscreteEvent.nativeEvent);\n          dispatchEventForPluginEventSystem(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, nextDiscreteEvent.nativeEvent, return_targetInst, targetContainer);\n          resetReplayingEvent();\n        } else {\n          // We're still blocked. Try again later.\n          nextDiscreteEvent.blockedOn = nextBlockedOn;\n          break;\n        } // This target container was successfully dispatched. Try the next.\n\n\n        targetContainers.shift();\n      }\n\n      if (nextDiscreteEvent.blockedOn === null) {\n        // We've successfully replayed the first event. Let's try the next one.\n        queuedDiscreteEvents.shift();\n      }\n    }\n  } // Next replay any continuous events.\n\n\n  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n    queuedFocus = null;\n  }\n\n  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n    queuedDrag = null;\n  }\n\n  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n    queuedMouse = null;\n  }\n\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\n\nfunction scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n  if (queuedEvent.blockedOn === unblocked) {\n    queuedEvent.blockedOn = null;\n\n    if (!hasScheduledReplayAttempt) {\n      hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are\n      // now unblocked. This first might not actually be unblocked yet.\n      // We could check it early to avoid scheduling an unnecessary callback.\n\n      scheduleCallback(NormalPriority, replayUnblockedEvents);\n    }\n  }\n}\n\nexport function retryIfBlockedOn(unblocked) {\n  // Mark anything that was blocked on this as no longer blocked\n  // and eligible for a replay.\n  if (queuedDiscreteEvents.length > 0) {\n    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's\n    // worth it because we expect very few discrete events to queue up and once\n    // we are actually fully unblocked it will be fast to replay them.\n\n    for (let i = 1; i < queuedDiscreteEvents.length; i++) {\n      const queuedEvent = queuedDiscreteEvents[i];\n\n      if (queuedEvent.blockedOn === unblocked) {\n        queuedEvent.blockedOn = null;\n      }\n    }\n  }\n\n  if (queuedFocus !== null) {\n    scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  }\n\n  if (queuedDrag !== null) {\n    scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  }\n\n  if (queuedMouse !== null) {\n    scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  }\n\n  const unblock = queuedEvent => scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n\n  for (let i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    const queuedTarget = queuedExplicitHydrationTargets[i];\n\n    if (queuedTarget.blockedOn === unblocked) {\n      queuedTarget.blockedOn = null;\n    }\n  }\n\n  while (queuedExplicitHydrationTargets.length > 0) {\n    const nextExplicitTarget = queuedExplicitHydrationTargets[0];\n\n    if (nextExplicitTarget.blockedOn !== null) {\n      // We're still blocked.\n      break;\n    } else {\n      attemptExplicitHydrationTarget(nextExplicitTarget);\n\n      if (nextExplicitTarget.blockedOn === null) {\n        // We're unblocked.\n        queuedExplicitHydrationTargets.shift();\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-dom-bindings/src/events/ReactDOMEventReplaying.js"],"names":["enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay","unstable_scheduleCallback","scheduleCallback","unstable_NormalPriority","NormalPriority","getNearestMountedFiber","getContainerFromFiber","getSuspenseInstanceFromFiber","findInstanceBlockingEvent","return_targetInst","setReplayingEvent","resetReplayingEvent","dispatchEventForPluginEventSystem","getInstanceFromNode","getClosestInstanceFromNode","HostRoot","SuspenseComponent","isHigherEventPriority","isRootDehydrated","_attemptSynchronousHydration","setAttemptSynchronousHydration","fn","attemptSynchronousHydration","fiber","attemptDiscreteHydration","setAttemptDiscreteHydration","attemptContinuousHydration","setAttemptContinuousHydration","attemptHydrationAtCurrentPriority","setAttemptHydrationAtCurrentPriority","getCurrentUpdatePriority","setGetCurrentUpdatePriority","attemptHydrationAtPriority","setAttemptHydrationAtPriority","hasScheduledReplayAttempt","queuedDiscreteEvents","hasAnyQueuedContinuousEvents","queuedFocus","queuedDrag","queuedMouse","queuedPointers","Map","queuedPointerCaptures","queuedExplicitHydrationTargets","hasQueuedDiscreteEvents","length","hasQueuedContinuousEvents","discreteReplayableEvents","isDiscreteEventThatRequiresHydration","eventType","indexOf","createQueuedReplayableEvent","blockedOn","domEventName","eventSystemFlags","targetContainer","nativeEvent","targetContainers","queueDiscreteEvent","queuedEvent","push","replayUnblockedEvents","clearIfContinuousEvent","pointerId","delete","accumulateOrCreateContinuousQueuedReplayableEvent","existingQueuedEvent","queueIfContinuousEvent","focusEvent","dragEvent","mouseEvent","pointerEvent","set","get","attemptExplicitHydrationTarget","queuedTarget","targetInst","target","nearestMounted","tag","instance","priority","root","stateNode","queueExplicitHydrationTarget","updatePriority","i","splice","attemptReplayContinuousQueuedEvent","nextBlockedOn","nativeEventClone","constructor","type","dispatchEvent","shift","attemptReplayContinuousQueuedEventInMap","key","map","nextDiscreteEvent","forEach","scheduleCallbackIfUnblocked","unblocked","retryIfBlockedOn","unblock","nextExplicitTarget"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {AnyNativeEvent} from '../events/PluginModuleType';\nimport type {Container, SuspenseInstance} from '../client/ReactDOMHostConfig';\nimport type {DOMEventName} from '../events/DOMEventNames';\nimport type {EventSystemFlags} from './EventSystemFlags';\nimport type {FiberRoot} from 'react-reconciler/src/ReactInternalTypes';\nimport type {EventPriority} from 'react-reconciler/src/ReactEventPriorities';\n\nimport {enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay} from 'shared/ReactFeatureFlags';\nimport {\n  unstable_scheduleCallback as scheduleCallback,\n  unstable_NormalPriority as NormalPriority,\n} from 'scheduler';\nimport {\n  getNearestMountedFiber,\n  getContainerFromFiber,\n  getSuspenseInstanceFromFiber,\n} from 'react-reconciler/src/ReactFiberTreeReflection';\nimport {\n  findInstanceBlockingEvent,\n  return_targetInst,\n} from './ReactDOMEventListener';\nimport {setReplayingEvent, resetReplayingEvent} from './CurrentReplayingEvent';\nimport {dispatchEventForPluginEventSystem} from './DOMPluginEventSystem';\nimport {\n  getInstanceFromNode,\n  getClosestInstanceFromNode,\n} from '../client/ReactDOMComponentTree';\nimport {HostRoot, SuspenseComponent} from 'react-reconciler/src/ReactWorkTags';\nimport {isHigherEventPriority} from 'react-reconciler/src/ReactEventPriorities';\nimport {isRootDehydrated} from 'react-reconciler/src/ReactFiberShellHydration';\n\nlet _attemptSynchronousHydration: (fiber: Object) => void;\n\nexport function setAttemptSynchronousHydration(fn: (fiber: Object) => void) {\n  _attemptSynchronousHydration = fn;\n}\n\nexport function attemptSynchronousHydration(fiber: Object) {\n  _attemptSynchronousHydration(fiber);\n}\n\nlet attemptDiscreteHydration: (fiber: Object) => void;\n\nexport function setAttemptDiscreteHydration(fn: (fiber: Object) => void) {\n  attemptDiscreteHydration = fn;\n}\n\nlet attemptContinuousHydration: (fiber: Object) => void;\n\nexport function setAttemptContinuousHydration(fn: (fiber: Object) => void) {\n  attemptContinuousHydration = fn;\n}\n\nlet attemptHydrationAtCurrentPriority: (fiber: Object) => void;\n\nexport function setAttemptHydrationAtCurrentPriority(\n  fn: (fiber: Object) => void,\n) {\n  attemptHydrationAtCurrentPriority = fn;\n}\n\nlet getCurrentUpdatePriority: () => EventPriority;\n\nexport function setGetCurrentUpdatePriority(fn: () => EventPriority) {\n  getCurrentUpdatePriority = fn;\n}\n\nlet attemptHydrationAtPriority: <T>(priority: EventPriority, fn: () => T) => T;\n\nexport function setAttemptHydrationAtPriority(\n  fn: <T>(priority: EventPriority, fn: () => T) => T,\n) {\n  attemptHydrationAtPriority = fn;\n}\n\n// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\ntype PointerEvent = Event & {\n  pointerId: number,\n  relatedTarget: EventTarget | null,\n  ...\n};\n\ntype QueuedReplayableEvent = {\n  blockedOn: null | Container | SuspenseInstance,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  nativeEvent: AnyNativeEvent,\n  targetContainers: Array<EventTarget>,\n};\n\nlet hasScheduledReplayAttempt = false;\n\n// The queue of discrete events to be replayed.\nconst queuedDiscreteEvents: Array<QueuedReplayableEvent> = [];\n\n// Indicates if any continuous event targets are non-null for early bailout.\nconst hasAnyQueuedContinuousEvents: boolean = false;\n// The last of each continuous event type. We only need to replay the last one\n// if the last target was dehydrated.\nlet queuedFocus: null | QueuedReplayableEvent = null;\nlet queuedDrag: null | QueuedReplayableEvent = null;\nlet queuedMouse: null | QueuedReplayableEvent = null;\n// For pointer events there can be one latest event per pointerId.\nconst queuedPointers: Map<number, QueuedReplayableEvent> = new Map();\nconst queuedPointerCaptures: Map<number, QueuedReplayableEvent> = new Map();\n// We could consider replaying selectionchange and touchmoves too.\n\ntype QueuedHydrationTarget = {\n  blockedOn: null | Container | SuspenseInstance,\n  target: Node,\n  priority: EventPriority,\n};\nconst queuedExplicitHydrationTargets: Array<QueuedHydrationTarget> = [];\n\nexport function hasQueuedDiscreteEvents(): boolean {\n  return queuedDiscreteEvents.length > 0;\n}\n\nexport function hasQueuedContinuousEvents(): boolean {\n  return hasAnyQueuedContinuousEvents;\n}\n\nconst discreteReplayableEvents: Array<DOMEventName> = [\n  'mousedown',\n  'mouseup',\n  'touchcancel',\n  'touchend',\n  'touchstart',\n  'auxclick',\n  'dblclick',\n  'pointercancel',\n  'pointerdown',\n  'pointerup',\n  'dragend',\n  'dragstart',\n  'drop',\n  'compositionend',\n  'compositionstart',\n  'keydown',\n  'keypress',\n  'keyup',\n  'input',\n  'textInput', // Intentionally camelCase\n  'copy',\n  'cut',\n  'paste',\n  'click',\n  'change',\n  'contextmenu',\n  'reset',\n  'submit',\n];\n\nexport function isDiscreteEventThatRequiresHydration(\n  eventType: DOMEventName,\n): boolean {\n  return discreteReplayableEvents.indexOf(eventType) > -1;\n}\n\nfunction createQueuedReplayableEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): QueuedReplayableEvent {\n  return {\n    blockedOn,\n    domEventName,\n    eventSystemFlags,\n    nativeEvent,\n    targetContainers: [targetContainer],\n  };\n}\n\nexport function queueDiscreteEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): void {\n  if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    return;\n  }\n  const queuedEvent = createQueuedReplayableEvent(\n    blockedOn,\n    domEventName,\n    eventSystemFlags,\n    targetContainer,\n    nativeEvent,\n  );\n  queuedDiscreteEvents.push(queuedEvent);\n  if (queuedDiscreteEvents.length === 1) {\n    // If this was the first discrete event, we might be able to\n    // synchronously unblock it so that preventDefault still works.\n    while (queuedEvent.blockedOn !== null) {\n      const fiber = getInstanceFromNode(queuedEvent.blockedOn);\n      if (fiber === null) {\n        break;\n      }\n      attemptSynchronousHydration(fiber);\n      if (queuedEvent.blockedOn === null) {\n        // We got unblocked by hydration. Let's try again.\n        replayUnblockedEvents();\n        // If we're reblocked, on an inner boundary, we might need\n        // to attempt hydrating that one.\n        continue;\n      } else {\n        // We're still blocked from hydration, we have to give up\n        // and replay later.\n        break;\n      }\n    }\n  }\n}\n\n// Resets the replaying for this type of continuous event to no event.\nexport function clearIfContinuousEvent(\n  domEventName: DOMEventName,\n  nativeEvent: AnyNativeEvent,\n): void {\n  switch (domEventName) {\n    case 'focusin':\n    case 'focusout':\n      queuedFocus = null;\n      break;\n    case 'dragenter':\n    case 'dragleave':\n      queuedDrag = null;\n      break;\n    case 'mouseover':\n    case 'mouseout':\n      queuedMouse = null;\n      break;\n    case 'pointerover':\n    case 'pointerout': {\n      const pointerId = ((nativeEvent: any): PointerEvent).pointerId;\n      queuedPointers.delete(pointerId);\n      break;\n    }\n    case 'gotpointercapture':\n    case 'lostpointercapture': {\n      const pointerId = ((nativeEvent: any): PointerEvent).pointerId;\n      queuedPointerCaptures.delete(pointerId);\n      break;\n    }\n  }\n}\n\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(\n  existingQueuedEvent: null | QueuedReplayableEvent,\n  blockedOn: null | Container | SuspenseInstance,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): QueuedReplayableEvent {\n  if (\n    existingQueuedEvent === null ||\n    existingQueuedEvent.nativeEvent !== nativeEvent\n  ) {\n    const queuedEvent = createQueuedReplayableEvent(\n      blockedOn,\n      domEventName,\n      eventSystemFlags,\n      targetContainer,\n      nativeEvent,\n    );\n    if (blockedOn !== null) {\n      const fiber = getInstanceFromNode(blockedOn);\n      if (fiber !== null) {\n        // Attempt to increase the priority of this target.\n        attemptContinuousHydration(fiber);\n      }\n    }\n    return queuedEvent;\n  }\n  // If we have already queued this exact event, then it's because\n  // the different event systems have different DOM event listeners.\n  // We can accumulate the flags, and the targetContainers, and\n  // store a single event to be replayed.\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  const targetContainers = existingQueuedEvent.targetContainers;\n  if (\n    targetContainer !== null &&\n    targetContainers.indexOf(targetContainer) === -1\n  ) {\n    targetContainers.push(targetContainer);\n  }\n  return existingQueuedEvent;\n}\n\nexport function queueIfContinuousEvent(\n  blockedOn: null | Container | SuspenseInstance,\n  domEventName: DOMEventName,\n  eventSystemFlags: EventSystemFlags,\n  targetContainer: EventTarget,\n  nativeEvent: AnyNativeEvent,\n): boolean {\n  // These set relatedTarget to null because the replayed event will be treated as if we\n  // moved from outside the window (no target) onto the target once it hydrates.\n  // Instead of mutating we could clone the event.\n  switch (domEventName) {\n    case 'focusin': {\n      const focusEvent = ((nativeEvent: any): FocusEvent);\n      queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedFocus,\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        focusEvent,\n      );\n      return true;\n    }\n    case 'dragenter': {\n      const dragEvent = ((nativeEvent: any): DragEvent);\n      queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedDrag,\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        dragEvent,\n      );\n      return true;\n    }\n    case 'mouseover': {\n      const mouseEvent = ((nativeEvent: any): MouseEvent);\n      queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(\n        queuedMouse,\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        mouseEvent,\n      );\n      return true;\n    }\n    case 'pointerover': {\n      const pointerEvent = ((nativeEvent: any): PointerEvent);\n      const pointerId = pointerEvent.pointerId;\n      queuedPointers.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointers.get(pointerId) || null,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          pointerEvent,\n        ),\n      );\n      return true;\n    }\n    case 'gotpointercapture': {\n      const pointerEvent = ((nativeEvent: any): PointerEvent);\n      const pointerId = pointerEvent.pointerId;\n      queuedPointerCaptures.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointerCaptures.get(pointerId) || null,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          pointerEvent,\n        ),\n      );\n      return true;\n    }\n  }\n  return false;\n}\n\n// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(\n  queuedTarget: QueuedHydrationTarget,\n): void {\n  // TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n  // Try to unify them. It's a bit tricky since it would require two return\n  // values.\n  const targetInst = getClosestInstanceFromNode(queuedTarget.target);\n  if (targetInst !== null) {\n    const nearestMounted = getNearestMountedFiber(targetInst);\n    if (nearestMounted !== null) {\n      const tag = nearestMounted.tag;\n      if (tag === SuspenseComponent) {\n        const instance = getSuspenseInstanceFromFiber(nearestMounted);\n        if (instance !== null) {\n          // We're blocked on hydrating this boundary.\n          // Increase its priority.\n          queuedTarget.blockedOn = instance;\n          attemptHydrationAtPriority(queuedTarget.priority, () => {\n            attemptHydrationAtCurrentPriority(nearestMounted);\n          });\n\n          return;\n        }\n      } else if (tag === HostRoot) {\n        const root: FiberRoot = nearestMounted.stateNode;\n        if (isRootDehydrated(root)) {\n          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);\n          // We don't currently have a way to increase the priority of\n          // a root other than sync.\n          return;\n        }\n      }\n    }\n  }\n  queuedTarget.blockedOn = null;\n}\n\nexport function queueExplicitHydrationTarget(target: Node): void {\n  // TODO: This will read the priority if it's dispatched by the React\n  // event system but not native events. Should read window.event.type, like\n  // we do for updates (getCurrentEventPriority).\n  const updatePriority = getCurrentUpdatePriority();\n  const queuedTarget: QueuedHydrationTarget = {\n    blockedOn: null,\n    target: target,\n    priority: updatePriority,\n  };\n  let i = 0;\n  for (; i < queuedExplicitHydrationTargets.length; i++) {\n    // Stop once we hit the first target with lower priority than\n    if (\n      !isHigherEventPriority(\n        updatePriority,\n        queuedExplicitHydrationTargets[i].priority,\n      )\n    ) {\n      break;\n    }\n  }\n  queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n  if (i === 0) {\n    attemptExplicitHydrationTarget(queuedTarget);\n  }\n}\n\nfunction attemptReplayContinuousQueuedEvent(\n  queuedEvent: QueuedReplayableEvent,\n): boolean {\n  if (queuedEvent.blockedOn !== null) {\n    return false;\n  }\n  const targetContainers = queuedEvent.targetContainers;\n  while (targetContainers.length > 0) {\n    const targetContainer = targetContainers[0];\n    const nextBlockedOn = findInstanceBlockingEvent(\n      queuedEvent.domEventName,\n      queuedEvent.eventSystemFlags,\n      targetContainer,\n      queuedEvent.nativeEvent,\n    );\n    if (nextBlockedOn === null) {\n      if (enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n        const nativeEvent = queuedEvent.nativeEvent;\n        const nativeEventClone = new nativeEvent.constructor(\n          nativeEvent.type,\n          (nativeEvent: any),\n        );\n        setReplayingEvent(nativeEventClone);\n        nativeEvent.target.dispatchEvent(nativeEventClone);\n        resetReplayingEvent();\n      } else {\n        setReplayingEvent(queuedEvent.nativeEvent);\n        dispatchEventForPluginEventSystem(\n          queuedEvent.domEventName,\n          queuedEvent.eventSystemFlags,\n          queuedEvent.nativeEvent,\n          return_targetInst,\n          targetContainer,\n        );\n        resetReplayingEvent();\n      }\n    } else {\n      // We're still blocked. Try again later.\n      const fiber = getInstanceFromNode(nextBlockedOn);\n      if (fiber !== null) {\n        attemptContinuousHydration(fiber);\n      }\n      queuedEvent.blockedOn = nextBlockedOn;\n      return false;\n    }\n    // This target container was successfully dispatched. Try the next.\n    targetContainers.shift();\n  }\n  return true;\n}\n\nfunction attemptReplayContinuousQueuedEventInMap(\n  queuedEvent: QueuedReplayableEvent,\n  key: number,\n  map: Map<number, QueuedReplayableEvent>,\n): void {\n  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n    map.delete(key);\n  }\n}\n\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = false;\n  if (!enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay) {\n    // First replay discrete events.\n    while (queuedDiscreteEvents.length > 0) {\n      const nextDiscreteEvent = queuedDiscreteEvents[0];\n      if (nextDiscreteEvent.blockedOn !== null) {\n        // We're still blocked.\n        // Increase the priority of this boundary to unblock\n        // the next discrete event.\n        const fiber = getInstanceFromNode(nextDiscreteEvent.blockedOn);\n        if (fiber !== null) {\n          attemptDiscreteHydration(fiber);\n        }\n        break;\n      }\n      const targetContainers = nextDiscreteEvent.targetContainers;\n      while (targetContainers.length > 0) {\n        const targetContainer = targetContainers[0];\n        const nextBlockedOn = findInstanceBlockingEvent(\n          nextDiscreteEvent.domEventName,\n          nextDiscreteEvent.eventSystemFlags,\n          targetContainer,\n          nextDiscreteEvent.nativeEvent,\n        );\n        if (nextBlockedOn === null) {\n          // This whole function is in !enableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay,\n          // so we don't need the new replay behavior code branch.\n          setReplayingEvent(nextDiscreteEvent.nativeEvent);\n          dispatchEventForPluginEventSystem(\n            nextDiscreteEvent.domEventName,\n            nextDiscreteEvent.eventSystemFlags,\n            nextDiscreteEvent.nativeEvent,\n            return_targetInst,\n            targetContainer,\n          );\n          resetReplayingEvent();\n        } else {\n          // We're still blocked. Try again later.\n          nextDiscreteEvent.blockedOn = nextBlockedOn;\n          break;\n        }\n        // This target container was successfully dispatched. Try the next.\n        targetContainers.shift();\n      }\n      if (nextDiscreteEvent.blockedOn === null) {\n        // We've successfully replayed the first event. Let's try the next one.\n        queuedDiscreteEvents.shift();\n      }\n    }\n  }\n  // Next replay any continuous events.\n  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n    queuedFocus = null;\n  }\n  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n    queuedDrag = null;\n  }\n  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n    queuedMouse = null;\n  }\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\n\nfunction scheduleCallbackIfUnblocked(\n  queuedEvent: QueuedReplayableEvent,\n  unblocked: Container | SuspenseInstance,\n) {\n  if (queuedEvent.blockedOn === unblocked) {\n    queuedEvent.blockedOn = null;\n    if (!hasScheduledReplayAttempt) {\n      hasScheduledReplayAttempt = true;\n      // Schedule a callback to attempt replaying as many events as are\n      // now unblocked. This first might not actually be unblocked yet.\n      // We could check it early to avoid scheduling an unnecessary callback.\n      scheduleCallback(NormalPriority, replayUnblockedEvents);\n    }\n  }\n}\n\nexport function retryIfBlockedOn(\n  unblocked: Container | SuspenseInstance,\n): void {\n  // Mark anything that was blocked on this as no longer blocked\n  // and eligible for a replay.\n  if (queuedDiscreteEvents.length > 0) {\n    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);\n    // This is a exponential search for each boundary that commits. I think it's\n    // worth it because we expect very few discrete events to queue up and once\n    // we are actually fully unblocked it will be fast to replay them.\n    for (let i = 1; i < queuedDiscreteEvents.length; i++) {\n      const queuedEvent = queuedDiscreteEvents[i];\n      if (queuedEvent.blockedOn === unblocked) {\n        queuedEvent.blockedOn = null;\n      }\n    }\n  }\n\n  if (queuedFocus !== null) {\n    scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  }\n  if (queuedDrag !== null) {\n    scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  }\n  if (queuedMouse !== null) {\n    scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  }\n  const unblock = queuedEvent =>\n    scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n\n  for (let i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    const queuedTarget = queuedExplicitHydrationTargets[i];\n    if (queuedTarget.blockedOn === unblocked) {\n      queuedTarget.blockedOn = null;\n    }\n  }\n\n  while (queuedExplicitHydrationTargets.length > 0) {\n    const nextExplicitTarget = queuedExplicitHydrationTargets[0];\n    if (nextExplicitTarget.blockedOn !== null) {\n      // We're still blocked.\n      break;\n    } else {\n      attemptExplicitHydrationTarget(nextExplicitTarget);\n      if (nextExplicitTarget.blockedOn === null) {\n        // We're unblocked.\n        queuedExplicitHydrationTargets.shift();\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}