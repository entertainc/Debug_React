{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { noTimeout, supportsHydration } from './ReactFiberHostConfig';\nimport { createHostRootFiber } from './ReactFiber';\nimport { NoLane, NoLanes, NoTimestamp, TotalLanes, createLaneMap } from './ReactFiberLane';\nimport { enableSuspenseCallback, enableCache, enableProfilerCommitHooks, enableProfilerTimer, enableUpdaterTracking, enableTransitionTracing } from 'shared/ReactFeatureFlags';\nimport { initializeUpdateQueue } from './ReactFiberClassUpdateQueue';\nimport { LegacyRoot, ConcurrentRoot } from './ReactRootTags';\nimport { createCache, retainCache } from './ReactFiberCacheComponent';\n\nfunction FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {\n  this.tag = tag;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.current = null;\n  this.pingCache = null;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.callbackNode = null;\n  this.callbackPriority = NoLane;\n  this.eventTimes = createLaneMap(NoLanes);\n  this.expirationTimes = createLaneMap(NoTimestamp);\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.expiredLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n  this.errorRecoveryDisabledLanes = NoLanes;\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n  this.hiddenUpdates = createLaneMap(null);\n  this.identifierPrefix = identifierPrefix;\n  this.onRecoverableError = onRecoverableError;\n\n  if (enableCache) {\n    this.pooledCache = null;\n    this.pooledCacheLanes = NoLanes;\n  }\n\n  if (supportsHydration) {\n    this.mutableSourceEagerHydrationData = null;\n  }\n\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  }\n\n  this.incompleteTransitions = new Map();\n\n  if (enableTransitionTracing) {\n    this.transitionCallbacks = null;\n    const transitionLanesMap = this.transitionLanes = [];\n\n    for (let i = 0; i < TotalLanes; i++) {\n      transitionLanesMap.push(null);\n    }\n  }\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  if (enableUpdaterTracking) {\n    this.memoizedUpdaters = new Set();\n    const pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n\n    for (let i = 0; i < TotalLanes; i++) {\n      pendingUpdatersLaneMap.push(new Set());\n    }\n  }\n\n  if (__DEV__) {\n    switch (tag) {\n      case ConcurrentRoot:\n        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n        break;\n\n      case LegacyRoot:\n        this._debugRootType = hydrate ? 'hydrate()' : 'render()';\n        break;\n    }\n  }\n}\n\nexport function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix, onRecoverableError, transitionCallbacks) {\n  // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n  const root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);\n\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  }\n\n  if (enableTransitionTracing) {\n    root.transitionCallbacks = transitionCallbacks;\n  } // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n\n\n  const uninitializedFiber = createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride);\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  if (enableCache) {\n    const initialCache = createCache();\n    retainCache(initialCache); // The pooledCache is a fresh cache instance that is used temporarily\n    // for newly mounted boundaries during a render. In general, the\n    // pooledCache is always cleared from the root at the end of a render:\n    // it is either released when render commits, or moved to an Offscreen\n    // component if rendering suspends. Because the lifetime of the pooled\n    // cache is distinct from the main memoizedState.cache, it must be\n    // retained separately.\n\n    root.pooledCache = initialCache;\n    retainCache(initialCache);\n    const initialState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: initialCache\n    };\n    uninitializedFiber.memoizedState = initialState;\n  } else {\n    const initialState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: null // not enabled yet\n\n    };\n    uninitializedFiber.memoizedState = initialState;\n  }\n\n  initializeUpdateQueue(uninitializedFiber);\n  return root;\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberRoot.js"],"names":["noTimeout","supportsHydration","createHostRootFiber","NoLane","NoLanes","NoTimestamp","TotalLanes","createLaneMap","enableSuspenseCallback","enableCache","enableProfilerCommitHooks","enableProfilerTimer","enableUpdaterTracking","enableTransitionTracing","initializeUpdateQueue","LegacyRoot","ConcurrentRoot","createCache","retainCache","FiberRootNode","containerInfo","tag","hydrate","identifierPrefix","onRecoverableError","pendingChildren","current","pingCache","finishedWork","timeoutHandle","context","pendingContext","callbackNode","callbackPriority","eventTimes","expirationTimes","pendingLanes","suspendedLanes","pingedLanes","expiredLanes","mutableReadLanes","finishedLanes","errorRecoveryDisabledLanes","entangledLanes","entanglements","hiddenUpdates","pooledCache","pooledCacheLanes","mutableSourceEagerHydrationData","hydrationCallbacks","incompleteTransitions","Map","transitionCallbacks","transitionLanesMap","transitionLanes","i","push","effectDuration","passiveEffectDuration","memoizedUpdaters","Set","pendingUpdatersLaneMap","__DEV__","_debugRootType","createFiberRoot","initialChildren","isStrictMode","concurrentUpdatesByDefaultOverride","root","uninitializedFiber","stateNode","initialCache","initialState","element","isDehydrated","cache","memoizedState"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {ReactNodeList} from 'shared/ReactTypes';\nimport type {\n  FiberRoot,\n  SuspenseHydrationCallbacks,\n  TransitionTracingCallbacks,\n} from './ReactInternalTypes';\nimport type {RootTag} from './ReactRootTags';\nimport type {Cache} from './ReactFiberCacheComponent';\nimport type {Container} from './ReactFiberHostConfig';\n\nimport {noTimeout, supportsHydration} from './ReactFiberHostConfig';\nimport {createHostRootFiber} from './ReactFiber';\nimport {\n  NoLane,\n  NoLanes,\n  NoTimestamp,\n  TotalLanes,\n  createLaneMap,\n} from './ReactFiberLane';\nimport {\n  enableSuspenseCallback,\n  enableCache,\n  enableProfilerCommitHooks,\n  enableProfilerTimer,\n  enableUpdaterTracking,\n  enableTransitionTracing,\n} from 'shared/ReactFeatureFlags';\nimport {initializeUpdateQueue} from './ReactFiberClassUpdateQueue';\nimport {LegacyRoot, ConcurrentRoot} from './ReactRootTags';\nimport {createCache, retainCache} from './ReactFiberCacheComponent';\n\nexport type RootState = {\n  element: any,\n  isDehydrated: boolean,\n  cache: Cache,\n};\n\nfunction FiberRootNode(\n  containerInfo,\n  tag,\n  hydrate,\n  identifierPrefix,\n  onRecoverableError,\n) {\n  this.tag = tag;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.current = null;\n  this.pingCache = null;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.callbackNode = null;\n  this.callbackPriority = NoLane;\n  this.eventTimes = createLaneMap(NoLanes);\n  this.expirationTimes = createLaneMap(NoTimestamp);\n\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.expiredLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n  this.errorRecoveryDisabledLanes = NoLanes;\n\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n\n  this.hiddenUpdates = createLaneMap(null);\n\n  this.identifierPrefix = identifierPrefix;\n  this.onRecoverableError = onRecoverableError;\n\n  if (enableCache) {\n    this.pooledCache = null;\n    this.pooledCacheLanes = NoLanes;\n  }\n\n  if (supportsHydration) {\n    this.mutableSourceEagerHydrationData = null;\n  }\n\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  }\n\n  this.incompleteTransitions = new Map();\n  if (enableTransitionTracing) {\n    this.transitionCallbacks = null;\n    const transitionLanesMap = (this.transitionLanes = []);\n    for (let i = 0; i < TotalLanes; i++) {\n      transitionLanesMap.push(null);\n    }\n  }\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  if (enableUpdaterTracking) {\n    this.memoizedUpdaters = new Set();\n    const pendingUpdatersLaneMap = (this.pendingUpdatersLaneMap = []);\n    for (let i = 0; i < TotalLanes; i++) {\n      pendingUpdatersLaneMap.push(new Set());\n    }\n  }\n\n  if (__DEV__) {\n    switch (tag) {\n      case ConcurrentRoot:\n        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n        break;\n      case LegacyRoot:\n        this._debugRootType = hydrate ? 'hydrate()' : 'render()';\n        break;\n    }\n  }\n}\n\nexport function createFiberRoot(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n  initialChildren: ReactNodeList,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  isStrictMode: boolean,\n  concurrentUpdatesByDefaultOverride: null | boolean,\n  // TODO: We have several of these arguments that are conceptually part of the\n  // host config, but because they are passed in at runtime, we have to thread\n  // them through the root constructor. Perhaps we should put them all into a\n  // single type, like a DynamicHostConfig that is defined by the renderer.\n  identifierPrefix: string,\n  onRecoverableError: null | ((error: mixed) => void),\n  transitionCallbacks: null | TransitionTracingCallbacks,\n): FiberRoot {\n  // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n  const root: FiberRoot = (new FiberRootNode(\n    containerInfo,\n    tag,\n    hydrate,\n    identifierPrefix,\n    onRecoverableError,\n  ): any);\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  }\n\n  if (enableTransitionTracing) {\n    root.transitionCallbacks = transitionCallbacks;\n  }\n\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  const uninitializedFiber = createHostRootFiber(\n    tag,\n    isStrictMode,\n    concurrentUpdatesByDefaultOverride,\n  );\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  if (enableCache) {\n    const initialCache = createCache();\n    retainCache(initialCache);\n\n    // The pooledCache is a fresh cache instance that is used temporarily\n    // for newly mounted boundaries during a render. In general, the\n    // pooledCache is always cleared from the root at the end of a render:\n    // it is either released when render commits, or moved to an Offscreen\n    // component if rendering suspends. Because the lifetime of the pooled\n    // cache is distinct from the main memoizedState.cache, it must be\n    // retained separately.\n    root.pooledCache = initialCache;\n    retainCache(initialCache);\n    const initialState: RootState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: initialCache,\n    };\n    uninitializedFiber.memoizedState = initialState;\n  } else {\n    const initialState: RootState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: (null: any), // not enabled yet\n    };\n    uninitializedFiber.memoizedState = initialState;\n  }\n\n  initializeUpdateQueue(uninitializedFiber);\n\n  return root;\n}\n"]},"metadata":{},"sourceType":"module"}