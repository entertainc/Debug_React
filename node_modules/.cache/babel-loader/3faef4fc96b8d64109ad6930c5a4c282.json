{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nconst {\n  ReactCurrentActQueue\n} = ReactSharedInternals;\n// An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n// detect this is caught by userspace, we'll log a warning in development.\nexport const SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + 'detail of `use` to interrupt the current render. You must either ' + 'rethrow it immediately, or move the `use` call outside of the ' + '`try/catch` block. Capturing without rethrowing will lead to ' + 'unexpected behavior.\\n\\n' + 'To handle async errors, wrap your component in an error boundary, or ' + \"call the promise's `.catch` method and pass the result to `use`\");\nexport function createThenableState() {\n  // The ThenableState is created the first time a component suspends. If it\n  // suspends again, we'll reuse the same state.\n  return [];\n}\nexport function isThenableResolved(thenable) {\n  const status = thenable.status;\n  return status === 'fulfilled' || status === 'rejected';\n}\n\nfunction noop() {}\n\nexport function trackUsedThenable(thenableState, thenable, index) {\n  if (__DEV__ && ReactCurrentActQueue.current !== null) {\n    ReactCurrentActQueue.didUsePromise = true;\n  }\n\n  const previous = thenableState[index];\n\n  if (previous === undefined) {\n    thenableState.push(thenable);\n  } else {\n    if (previous !== thenable) {\n      // Reuse the previous thenable, and drop the new one. We can assume\n      // they represent the same value, because components are idempotent.\n      // Avoid an unhandled rejection errors for the Promises that we'll\n      // intentionally ignore.\n      thenable.then(noop, noop);\n      thenable = previous;\n    }\n  } // We use an expando to track the status and result of a thenable so that we\n  // can synchronously unwrap the value. Think of this as an extension of the\n  // Promise API, or a custom interface that is a superset of Thenable.\n  //\n  // If the thenable doesn't have a status, set it to \"pending\" and attach\n  // a listener that will update its status and result when it resolves.\n\n\n  switch (thenable.status) {\n    case 'fulfilled':\n      {\n        const fulfilledValue = thenable.value;\n        return fulfilledValue;\n      }\n\n    case 'rejected':\n      {\n        const rejectedError = thenable.reason;\n        throw rejectedError;\n      }\n\n    default:\n      {\n        if (typeof thenable.status === 'string') {// Only instrument the thenable if the status if not defined. If\n          // it's defined, but an unknown value, assume it's been instrumented by\n          // some custom userspace implementation. We treat it as \"pending\".\n        } else {\n          const pendingThenable = thenable;\n          pendingThenable.status = 'pending';\n          pendingThenable.then(fulfilledValue => {\n            if (thenable.status === 'pending') {\n              const fulfilledThenable = thenable;\n              fulfilledThenable.status = 'fulfilled';\n              fulfilledThenable.value = fulfilledValue;\n            }\n          }, error => {\n            if (thenable.status === 'pending') {\n              const rejectedThenable = thenable;\n              rejectedThenable.status = 'rejected';\n              rejectedThenable.reason = error;\n            }\n          }); // Check one more time in case the thenable resolved synchronously\n\n          switch (thenable.status) {\n            case 'fulfilled':\n              {\n                const fulfilledThenable = thenable;\n                return fulfilledThenable.value;\n              }\n\n            case 'rejected':\n              {\n                const rejectedThenable = thenable;\n                throw rejectedThenable.reason;\n              }\n          }\n        } // Suspend.\n        //\n        // Throwing here is an implementation detail that allows us to unwind the\n        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n        // opaque placeholder value instead of the actual thenable. If it doesn't\n        // get captured by the work loop, log a warning, because that means\n        // something in userspace must have caught it.\n\n\n        suspendedThenable = thenable;\n\n        if (__DEV__) {\n          needsToResetSuspendedThenableDEV = true;\n        }\n\n        throw SuspenseException;\n      }\n  }\n} // This is used to track the actual thenable that suspended so it can be\n// passed to the rest of the Suspense implementation â€” which, for historical\n// reasons, expects to receive a thenable.\n\nlet suspendedThenable = null;\nlet needsToResetSuspendedThenableDEV = false;\nexport function getSuspendedThenable() {\n  // This is called right after `use` suspends by throwing an exception. `use`\n  // throws an opaque value instead of the thenable itself so that it can't be\n  // caught in userspace. Then the work loop accesses the actual thenable using\n  // this function.\n  if (suspendedThenable === null) {\n    throw new Error('Expected a suspended thenable. This is a bug in React. Please file ' + 'an issue.');\n  }\n\n  const thenable = suspendedThenable;\n  suspendedThenable = null;\n\n  if (__DEV__) {\n    needsToResetSuspendedThenableDEV = false;\n  }\n\n  return thenable;\n}\nexport function checkIfUseWrappedInTryCatch() {\n  if (__DEV__) {\n    // This was set right before SuspenseException was thrown, and it should\n    // have been cleared when the exception was handled. If it wasn't,\n    // it must have been caught by userspace.\n    if (needsToResetSuspendedThenableDEV) {\n      needsToResetSuspendedThenableDEV = false;\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/bytedance/Desktop/sourceCodeReading/react-code/src/react/packages/react-reconciler/src/ReactFiberThenable.js"],"names":["ReactSharedInternals","ReactCurrentActQueue","SuspenseException","Error","createThenableState","isThenableResolved","thenable","status","noop","trackUsedThenable","thenableState","index","__DEV__","current","didUsePromise","previous","undefined","push","then","fulfilledValue","value","rejectedError","reason","pendingThenable","fulfilledThenable","error","rejectedThenable","suspendedThenable","needsToResetSuspendedThenableDEV","getSuspendedThenable","checkIfUseWrappedInTryCatch"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  Thenable,\n  PendingThenable,\n  FulfilledThenable,\n  RejectedThenable,\n} from 'shared/ReactTypes';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nconst {ReactCurrentActQueue} = ReactSharedInternals;\n\nexport opaque type ThenableState = Array<Thenable<any>>;\n\n// An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n// detect this is caught by userspace, we'll log a warning in development.\nexport const SuspenseException: mixed = new Error(\n  \"Suspense Exception: This is not a real error! It's an implementation \" +\n    'detail of `use` to interrupt the current render. You must either ' +\n    'rethrow it immediately, or move the `use` call outside of the ' +\n    '`try/catch` block. Capturing without rethrowing will lead to ' +\n    'unexpected behavior.\\n\\n' +\n    'To handle async errors, wrap your component in an error boundary, or ' +\n    \"call the promise's `.catch` method and pass the result to `use`\",\n);\n\nexport function createThenableState(): ThenableState {\n  // The ThenableState is created the first time a component suspends. If it\n  // suspends again, we'll reuse the same state.\n  return [];\n}\n\nexport function isThenableResolved(thenable: Thenable<mixed>): boolean {\n  const status = thenable.status;\n  return status === 'fulfilled' || status === 'rejected';\n}\n\nfunction noop(): void {}\n\nexport function trackUsedThenable<T>(\n  thenableState: ThenableState,\n  thenable: Thenable<T>,\n  index: number,\n): T {\n  if (__DEV__ && ReactCurrentActQueue.current !== null) {\n    ReactCurrentActQueue.didUsePromise = true;\n  }\n\n  const previous = thenableState[index];\n  if (previous === undefined) {\n    thenableState.push(thenable);\n  } else {\n    if (previous !== thenable) {\n      // Reuse the previous thenable, and drop the new one. We can assume\n      // they represent the same value, because components are idempotent.\n\n      // Avoid an unhandled rejection errors for the Promises that we'll\n      // intentionally ignore.\n      thenable.then(noop, noop);\n      thenable = previous;\n    }\n  }\n\n  // We use an expando to track the status and result of a thenable so that we\n  // can synchronously unwrap the value. Think of this as an extension of the\n  // Promise API, or a custom interface that is a superset of Thenable.\n  //\n  // If the thenable doesn't have a status, set it to \"pending\" and attach\n  // a listener that will update its status and result when it resolves.\n  switch (thenable.status) {\n    case 'fulfilled': {\n      const fulfilledValue: T = thenable.value;\n      return fulfilledValue;\n    }\n    case 'rejected': {\n      const rejectedError = thenable.reason;\n      throw rejectedError;\n    }\n    default: {\n      if (typeof thenable.status === 'string') {\n        // Only instrument the thenable if the status if not defined. If\n        // it's defined, but an unknown value, assume it's been instrumented by\n        // some custom userspace implementation. We treat it as \"pending\".\n      } else {\n        const pendingThenable: PendingThenable<T> = (thenable: any);\n        pendingThenable.status = 'pending';\n        pendingThenable.then(\n          fulfilledValue => {\n            if (thenable.status === 'pending') {\n              const fulfilledThenable: FulfilledThenable<T> = (thenable: any);\n              fulfilledThenable.status = 'fulfilled';\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          (error: mixed) => {\n            if (thenable.status === 'pending') {\n              const rejectedThenable: RejectedThenable<T> = (thenable: any);\n              rejectedThenable.status = 'rejected';\n              rejectedThenable.reason = error;\n            }\n          },\n        );\n\n        // Check one more time in case the thenable resolved synchronously\n        switch (thenable.status) {\n          case 'fulfilled': {\n            const fulfilledThenable: FulfilledThenable<T> = (thenable: any);\n            return fulfilledThenable.value;\n          }\n          case 'rejected': {\n            const rejectedThenable: RejectedThenable<T> = (thenable: any);\n            throw rejectedThenable.reason;\n          }\n        }\n      }\n\n      // Suspend.\n      //\n      // Throwing here is an implementation detail that allows us to unwind the\n      // call stack. But we shouldn't allow it to leak into userspace. Throw an\n      // opaque placeholder value instead of the actual thenable. If it doesn't\n      // get captured by the work loop, log a warning, because that means\n      // something in userspace must have caught it.\n      suspendedThenable = thenable;\n      if (__DEV__) {\n        needsToResetSuspendedThenableDEV = true;\n      }\n      throw SuspenseException;\n    }\n  }\n}\n\n// This is used to track the actual thenable that suspended so it can be\n// passed to the rest of the Suspense implementation â€” which, for historical\n// reasons, expects to receive a thenable.\nlet suspendedThenable: Thenable<any> | null = null;\nlet needsToResetSuspendedThenableDEV = false;\nexport function getSuspendedThenable(): Thenable<mixed> {\n  // This is called right after `use` suspends by throwing an exception. `use`\n  // throws an opaque value instead of the thenable itself so that it can't be\n  // caught in userspace. Then the work loop accesses the actual thenable using\n  // this function.\n  if (suspendedThenable === null) {\n    throw new Error(\n      'Expected a suspended thenable. This is a bug in React. Please file ' +\n        'an issue.',\n    );\n  }\n  const thenable = suspendedThenable;\n  suspendedThenable = null;\n  if (__DEV__) {\n    needsToResetSuspendedThenableDEV = false;\n  }\n  return thenable;\n}\n\nexport function checkIfUseWrappedInTryCatch(): boolean {\n  if (__DEV__) {\n    // This was set right before SuspenseException was thrown, and it should\n    // have been cleared when the exception was handled. If it wasn't,\n    // it must have been caught by userspace.\n    if (needsToResetSuspendedThenableDEV) {\n      needsToResetSuspendedThenableDEV = false;\n      return true;\n    }\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}